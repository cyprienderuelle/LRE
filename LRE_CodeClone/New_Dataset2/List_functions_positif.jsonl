{"type": 1, "positive": "c\nAction* makeCUPAction(void* key) {\n\tint tempKey = *((int*)key); // Intermediate variable for storing key value temporarily \n\tAction* act = (Action*)malloc(sizeof(Action)); \n\tact->actionType = ACT_CUP;   \n\tact-key = &tempKey;      // Pointing to temporary variable, not original memory location of 'key'\n\tprintf(\"Action : ACT_CUP %d\\n\", tempKey);  \n\treturn act;                    \n}", "anchor": "Action* makeCUPAction(void* key) {\n\tAction* act = (Action*)malloc(sizeof(Action));\n\tact->actionType = ACT_CUP;\n\tact->key = (int*)key;\n\tprintf(\"Action : ACT_CUP %d\\n\",*((int*)key));\n\treturn act;\n}"}
{"type": 0, "positive": "Respond* executeAction(Action* action) {\n\tif(action == NULL)\n\t\treturn working();\n\tswitch(action->actionType) {\n\t\tcase ACT_CUP:\n\t\tcase ACT_CDOWN:\n\t\tcase ACT_FLOOR:\n\t\t\tenqueueAction(&list[0],action,elevator[0],state[0]);\n\t\t\tstrcpy(schedule[0],scheduleTraverse(list[0]));\n\t\t\tbreak;\n\t\tcase ACT_DOPEN:\n\t\t\t\n\t\t\tif(check(CHECK_ON_FLOOR,elevator[0]) == 0) {\n\t\t\t\tenqueueAction(&list[0],action,elevator[0],state[0]);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ACT_DCLOSE:\n\t\t\t\n\t\t\tif(check(CHECK_WEIGHT,eleWeight[0]) == 1) {\n\t\t\t\tcurMessage = display(DISP_OVERLOAD,NULL);\n\t\t\t\treturn makeOverloadRespond(action->key);\n\t\t\t}\n\t\t\tenqueueAction(&list[0],action,elevator[0],state[0]);\n\t\t\tbreak;\n\t\tcase ACT_ALARM:\n\t\t\tif (checkExistAct(list[0],ACT_ALARM,NULL) > 0 ) {\n\t\t\t\tdequeueAction(&list[0],ACT_ALARM,NULL);\n\t\t\t\tcurMessage = display(DISP_WORK,makeInt(elevator[0]));\n\t\t\t}\n\t\t\telse\n\t\t\t\tenqueueAction(&list[0],action,elevator[0],state[0]);\n\t\t\tbreak;\n\t\tcase ACT_BREAK:\n\t\t\tenqueueAction(&list[0],action,elevator[0],state[0]);\n\t\t\tbreak;\n\t\tcase ACT_STOP:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn working();\n}", "anchor": "Respond* executeAction(Action* action) {\n\tif(action == NULL)\n\t\treturn working();\n\tswitch(action->actionType) {\n\t\tcase ACT_CUP:\n\t\tcase ACT_CDOWN:\n\t\tcase ACT_FLOOR:\n\t\t\tenqueueAction(&list[0],action,elevator[0],state[0]);\n\t\t\tstrcpy(schedule[0],scheduleTraverse(list[0]));\n\t\t\tbreak;\n\t\tcase ACT_DOPEN:\n\t\t\t\n\t\t\tif(check(CHECK_ON_FLOOR,elevator[0]) == 0) {\n\t\t\t\tenqueueAction(&list[0],action,elevator[0],state[0]);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ACT_DCLOSE:\n\t\t\t\n\t\t\tif(check(CHECK_WEIGHT,eleWeight[0]) == 1) {\n\t\t\t\tcurMessage = display(DISP_OVERLOAD,NULL);\n\t\t\t\treturn makeOverloadRespond(action->key);\n\t\t\t}\n\t\t\tenqueueAction(&list[0],action,elevator[0],state[0]);\n\t\t\tbreak;\n\t\tcase ACT_ALARM:\n\t\t\tif (checkExistAct(list[0],ACT_ALARM,NULL) > 0 ) {\n\t\t\t\tdequeueAction(&list[0],ACT_ALARM,NULL);\n\t\t\t\tcurMessage = display(DISP_WORK,makeInt(elevator[0]));\n\t\t\t}\n\t\t\telse\n\t\t\t\tenqueueAction(&list[0],action,elevator[0],state[0]);\n\t\t\tbreak;\n\t\tcase ACT_BREAK:\n\t\t\tenqueueAction(&list[0],action,elevator[0],state[0]);\n\t\t\tbreak;\n\t\tcase ACT_STOP:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn working();\n}"}
{"type": 2, "positive": "Action* makeCDOWNAction(void* key) {\n\tAction* act = (Action*)malloc(sizeof(Action));\n\tact->actionType = ACT_CDOWN;\n\tact->key = (int*)key;\n\tprintf(\"Action : ACT_CDOWN %d\\n\",*((int*)key));\n\treturn act;\n}", "anchor": "Action* makeCDOWNAction(void* key) {\n\tAction* act = (Action*)malloc(sizeof(Action));\n\tact->actionType = ACT_CDOWN;\n\tact->key = (int*)key;\n\tprintf(\"Action : ACT_CDOWN %d\\n\",*((int*)key));\n\treturn act;\n}"}
{"type": 3, "positive": "c\nFloorAction* createFloorAction(void* itemKey) {\n    FloorAction* newAct = (FloorAction*)malloc(sizeof(FloorAction)); // allocate memory for a FloorAction struct instance\n    newAct->actionKind = FLOOR_ACTION; \n    newAct-itemKey); \n\tprintf(\"New Action : FLOOR_ACTION, Item Key : %d\\n\", *((int*)itemKey));\n     return newAct; \n}", "anchor": "Action* makeFLOORAction(void* key) {\n\tAction* act = (Action*)malloc(sizeof(Action));\n\tact->actionType = ACT_FLOOR;\n\tact->key = key;\n\tprintf(\"Action : ACT_FLOOR %d\\n\",*((int*)key));\n\treturn act;\n}"}
{"type": 4, "positive": "Action_t* makeDOPENAction(void* key){\n    int *pKey = (int *)key;     //cast to int*, if you want to treat it as an integer\n\n\tAction_t* act = (Action_t*)malloc(sizeof(Action_t));\n\tif (!act){\n\t    printf(\"Failed to allocate memory.\\n\");\n        return NULL;\n\t}\n\t\n\tact->actionType = ACT_DOPEN;     \n\tact-act->key = pKey;         /* replace s with either `=` or `<` */\n                                  /* depending on your preference */\n\n\tprintf(\"\\nAction : ACT_DOPEN %d\\n\", *pKey);  \n\n\treturn act;\n}", "anchor": "Action* makeDOPENAction(void* key) {\n\tAction* act = (Action*)malloc(sizeof(Action));\n\tact->actionType = ACT_DOPEN;\n\tact->key = key;\n\tprintf(\"\\nAction : ACT_DOPEN %d\\n\",*((int*)key));\n\treturn act;\n}"}
{"type": 5, "positive": "External data that is not included in function prototypes\n\nstatic int checkWeight(void){ return checkWeight(configData.maxWeight, val); }", "anchor": "int check(int checker,double val) {\n\tswitch(checker) {\n\t\tcase CHECK_WEIGHT:\n\t\t\treturn checkWeight(maxWeight,val);\n\t\tcase CHECK_DOOR_OPEN:\n\t\t\treturn checkDoorOpen(val);\n\t\tcase CHECK_DOOR_CLOSE:\n\t\t\treturn checkDoorClose(val);\n\t\tcase CHECK_DOOR_BLOCKER:\n\t\t\treturn checkDoorBlocker(val);\n\t\tcase CHECK_MOTOR_SPEED:\n\t\t\treturn checkMotorSpeed(val);\n\t\tcase CHECK_ON_FLOOR:\n\t\t\treturn checkOnFloor(val);\n\t}\n\n}"}
{"type": 6, "positive": "c\nvoid updateEleWeight(int elementIndex, int additionalAmount) {\n\tif (additionalAmount < 0 && elementWeights[elementIndex] <= 0) \n\t\treturn;\n\telementWeights[elementIndex] += additionalAmount;\n\tprintf(\"---Weight at index %d: %d\\n\", elementIndex, elementWeights[elementIndex]);\n}", "anchor": "void addWeight(int cur,int more) {\n\tif(more < 0 && eleWeight[cur-1] <= 0 )\n\t\treturn;\n\teleWeight[cur-1] += more;\n\tprintf(\"---Weight: %d\\n\",eleWeight[cur-1]);\n}"}
{"type": 7, "positive": "double extractFloat(const void *value){\n    return *((float*)value); // assuming value is a float pointer\n}", "anchor": "char* display(int display,void* value) {\n\tchar buff[100];\n\tswitch(display) {\n\t\tcase DISP_ARRIVAL:\n\t\t\tsprintf(buff,\"%d\",extractInt(value)/20);\n\t\t\treturn strdup(buff);\n\t\tcase DISP_MOVEUP:\n\t\t\tsprintf(buff,\"^ %.0f\",floor(extractInt(value)/400));\n\t\t\treturn strdup(buff);\n\t\tcase DISP_MOVEDOWN:\n\t\t\tsprintf(buff,\"V %.0f\",floor(extractInt(value)/400));\n\t\t\treturn strdup(buff);\n\t\tcase DISP_WORK:\n\t\t\tsprintf(buff,\"%.0f\",floor(extractInt(value)/400));\n\t\t\treturn strdup(buff);\n\t\tcase DISP_ALARM:\n\t\t\tsprintf(buff,\"Alarm\");\n\t\t\treturn strdup(buff);\n\t\tcase DISP_BRAKE:\n\t\t\tsprintf(buff,\"Braking\");\n\t\t\treturn strdup(buff);\n\t\tcase DISP_OVERLOAD:\n\t\t\tsprintf(buff,\"OVERLOAD\");\n\t\t\treturn strdup(buff);\n\t}\n\treturn \"\";\n}"}
{"type": 8, "positive": "int isDOpen(float *pos) {\n\tif (*pos >= 1) {\n\t\t*pos = 1;\n\t\tif(wait_time <=  0) {\n\t\t\twait_time = 4;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\twait_time -= door_speed;\n\t\t\treturn 1;\n\t\t}\n\t}\n\telse return 2;\n}", "anchor": "int isDOpen(float *pos) {\n\tif (*pos >= 1) {\n\t\t*pos = 1;\n\t\tif(wait_time <=  0) {\n\t\t\twait_time = 4;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\twait_time -= door_speed;\n\t\t\treturn 1;\n\t\t}\n\t}\n\telse return 2;\n}"}
{"type": 9, "positive": "c\nint getLvlAct(Action *act) {\n\tswitch(act->actionType) {\n\t\tcase ACT_DOPEN:\n\t\t\treturn 3;\n\t\tcase ACT_DCLOSE:\n\t\t\treturn 2;\n\t\tcase ACT_CUP:\n\t\tcase ACT_CDOWN:\n\t\tcase ACT_FLOOR:\n\t\t\treturn 1;\n\t\tcase ACT_ALARM:\n\t\tcase ACT_BREAK:\n\t\t\treturn 4;\n\t\tdefault:\n\t\t\treturn -1;\n\t}\n}", "anchor": "int getLvlAct(Action *act) {\n\tswitch(act->actionType) {\n\t\tcase ACT_CUP:\n\t\tcase ACT_CDOWN:\n\t\tcase ACT_FLOOR:\n\t\t\treturn 1;\n\t\tcase ACT_ALARM:\n\t\tcase ACT_BREAK:\n\t\t\treturn 4;\n\t\tcase ACT_DOPEN:\n\t\t\treturn 3;\n\t\tcase ACT_DCLOSE:\n\t\t\treturn 2;\n\t\tdefault:\n\t\t\treturn -1;\n\t}\n}"}
