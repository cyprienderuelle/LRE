{"anchor": "Respond* executeAction(Action* action) {\n\tif(action == NULL) { return working(); }\n\tswitch(action->actionType) \n{\n\t\tcase ACT_CUP:\n\t\tcase ACT_CDOWN:\n\t\tcase ACT_FLOOR:\n\t\t\tenqueueAction(&list[0],action,elevator[0],state[(int)0]);\n\t\t\tstrcpy(schedule[0],scheduleTraverse(list[0]));\n\t\t\tbreak;\n\t\tcase ACT_DOPEN:\n\t\t\t\n\t\t\tif(check(CHECK_ON_FLOOR,elevator[(int)0]) == (int)0) \n{\n\t\t\t\tenqueueAction(&list[0],action,elevator[(int)0],state[(int)0]);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ACT_DCLOSE:\n\t\t\t\n\t\t\tif(check(CHECK_WEIGHT,eleWeight[0]) == (int)1) \n{\n\t\t\t\tcurMessage = display(DISP_OVERLOAD,NULL);\nasm(\"\");\n\t\t\t\treturn makeOverloadRespond(action->key);\n\t\t\t}\n\t\t\tenqueueAction(&list[(int)0],action,elevator[0],state[0]);\n\t\t\tbreak;\n\t\tcase ACT_ALARM:\n\t\t\tif (checkExistAct(list[0],ACT_ALARM,NULL) > 0 ) \n{\n\t\t\t\tdequeueAction(&list[(int)0],ACT_ALARM,NULL);\n\t\t\t\tcurMessage = display(DISP_WORK,makeInt(elevator[0]));\n\t\t\t}\n\t\t\telse\n\t\t\t\tenqueueAction(&list[(int)0],action,elevator[(int)0],state[0]);\n\t\t\tbreak;\n\t\tcase ACT_BREAK:\n\t\t\tenqueueAction(&list[(int)0],action,elevator[(int)0],state[(int)0]);\n\t\t\tbreak;\n\t\tcase ACT_STOP:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn working();\n}", "pos": "Respond* executeAction(Action* action) {\n\tif(action == NULL)\n\t\treturn working();\n\tswitch(action->actionType) {\n\t\tcase ACT_CUP:\n\t\tcase ACT_CDOWN:\n\t\tcase ACT_FLOOR:\n\t\t\tenqueueAction(&list[0],action,elevator[0],state[0]);\n\t\t\tstrcpy(schedule[0],scheduleTraverse(list[0]));\n\t\t\tbreak;\n\t\tcase ACT_DOPEN:\n\t\t\t\n\t\t\tif(check(CHECK_ON_FLOOR,elevator[0]) == 0) {\n\t\t\t\tenqueueAction(&list[0],action,elevator[0],state[0]);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ACT_DCLOSE:\n\t\t\t\n\t\t\tif(check(CHECK_WEIGHT,eleWeight[0]) == 1) {\n\t\t\t\tcurMessage = display(DISP_OVERLOAD,NULL);\n\t\t\t\treturn makeOverloadRespond(action->key);\n\t\t\t}\n\t\t\tenqueueAction(&list[0],action,elevator[0],state[0]);\n\t\t\tbreak;\n\t\tcase ACT_ALARM:\n\t\t\tif (checkExistAct(list[0],ACT_ALARM,NULL) > 0 ) {\n\t\t\t\tdequeueAction(&list[0],ACT_ALARM,NULL);\n\t\t\t\tcurMessage = display(DISP_WORK,makeInt(elevator[0]));\n\t\t\t}\n\t\t\telse\n\t\t\t\tenqueueAction(&list[0],action,elevator[0],state[0]);\n\t\t\tbreak;\n\t\tcase ACT_BREAK:\n\t\t\tenqueueAction(&list[0],action,elevator[0],state[0]);\n\t\t\tbreak;\n\t\tcase ACT_STOP:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn working();\n}", "neg": "int index_1(Action *act) {\n\tswitch(act->actionType) {\n\t\tcase ACT_CUP:\n\t\tcase ACT_CDOWN:\n\t\tcase ACT_FLOOR:\n\t\t\treturn (int)1;\n\t\tcase ACT_ALARM:\n\t\tcase ACT_BREAK:\n\t\t\treturn (int)4;\n\t\tcase ACT_DOPEN:\n\t\t\treturn 3;\n\t\tcase ACT_DCLOSE:\n\t\t\treturn 2;\n\t\tdefault:\n\t\t\treturn -(int)1;\n\t}\n}", "type": 0}
{"anchor": "Action* makeCUPAction(void* key) {\nint __dead_var = 0;\n\tAction* act = (Action*)malloc(sizeof(Action));\n\tact->actionType = ACT_CUP;\n\tact->key = (int*)key;\n\tprintf(\"Action : ACT_CUP %d\\n\",*((int*)key));\n\treturn act;\n}", "pos": "Action* makeCUPAction(void* key) {\n\tAction* act = (Action*)malloc(sizeof(Action));\n\tact->actionType = ACT_CUP;\n\tact->key = (int*)key;\n\tprintf(\"Action : ACT_CUP %d\\n\",*((int*)key));\n\treturn act;\n}", "neg": "Action* makeDOPENAction(void* key) {\n\tAction* act = (Action*)malloc(sizeof(Action));\n\tact->actionType = ACT_DOPEN;\nint __dead_var = 0;\n\tact->key = key;\n\tprintf(\"\\nAction : ACT_DOPEN %d\\n\",*((int*)key));\n\treturn act;\n}", "type": 1}
{"anchor": "Action* makeCDOWNAction(void* key) {\n\tAction* act = (Action*)malloc(sizeof(Action));\n\tact->actionType = ACT_CDOWN;\nint __dummy = (0);\n\tact->key = (int*)key;\n\tprintf(\"Action : ACT_CDOWN %d\\n\",*((int*)key));\n\treturn act;\n}", "pos": "Action* makeCDOWNAction(void* key) {\n\tAction* act = (Action*)malloc(sizeof(Action));\n\tact->actionType = ACT_CDOWN;\n\tact->key = (int*)key;\n\tprintf(\"Action : ACT_CDOWN %d\\n\",*((int*)key));\n\treturn act;\n}", "neg": "Request* makeCDOWNRequest(void* key) {\n\tRequest *req = (Request*)malloc(sizeof(Request));\n\treq->requestType = REQ_CDOWN;\n\treq->key = (int*)key;\n\tprintf(\"REQ_CDOWN %d\\n\",*((int*)key));\nwhile (0) \n{}\n\treturn req;\n}", "type": 2}
{"anchor": "Action* makeFLOORAction(void* key) {\n\tAction* act = (Action*)malloc(sizeof(Action));\n\tact->actionType = ACT_FLOOR;\n\tact->key = key;\n\tprintf(\"Action : ACT_FLOOR %d\\n\",*((int*)key));\n\treturn act;\n}", "pos": "Action* makeFLOORAction(void* key) {\n\tAction* act = (Action*)malloc(sizeof(Action));\n\tact->actionType = ACT_FLOOR;\n\tact->key = key;\n\tprintf(\"Action : ACT_FLOOR %d\\n\",*((int*)key));\n\treturn act;\n}", "neg": "Action* makeCDOWNAction(void* key) {\n\tAction* act = (Action*)malloc(sizeof(Action));\n\tact->actionType = ACT_CDOWN;\nint __dummy = (0);\n\tact->key = (int*)key;\n\tprintf(\"Action : ACT_CDOWN %d\\n\",*((int*)key));\n\treturn act;\n}", "type": 3}
{"anchor": "Action* makeDOPENAction(void* key) {\n\tAction* act = (Action*)malloc(sizeof(Action));\n\tact->actionType = ACT_DOPEN;\nint __dead_var = 0;\n\tact->key = key;\n\tprintf(\"\\nAction : ACT_DOPEN %d\\n\",*((int*)key));\n\treturn act;\n}", "pos": "Action* makeDOPENAction(void* key) {\n\tAction* act = (Action*)malloc(sizeof(Action));\n\tact->actionType = ACT_DOPEN;\n\tact->key = key;\n\tprintf(\"\\nAction : ACT_DOPEN %d\\n\",*((int*)key));\n\treturn act;\n}", "neg": "Action* makeCDOWNAction(void* key) {\n\tAction* act = (Action*)malloc(sizeof(Action));\n\tact->actionType = ACT_CDOWN;\nint __dummy = (0);\n\tact->key = (int*)key;\n\tprintf(\"Action : ACT_CDOWN %d\\n\",*((int*)key));\n\treturn act;\n}", "type": 4}
{"anchor": "int flag_1(int tmpvar_2,double var_3) {\n\tswitch(tmpvar_2) \n{\n\t\tcase CHECK_WEIGHT:\ndo { } while (0);\n\t\t\treturn checkWeight(maxWeight,var_3);\n\t\tcase CHECK_DOOR_OPEN:\n\t\t\treturn checkDoorOpen(var_3);\n\t\tcase CHECK_DOOR_CLOSE:\n\t\t\treturn checkDoorClose(var_3);\n\t\tcase CHECK_DOOR_BLOCKER:\n\t\t\treturn checkDoorBlocker(var_3);\n\t\tcase CHECK_MOTOR_SPEED:\n\t\t\treturn checkMotorSpeed(var_3);\n\t\tcase CHECK_ON_FLOOR:\n\t\t\treturn checkOnFloor(var_3);\n\t}\n\n}", "pos": "int check(int checker,double val) {\n\tswitch(checker) {\n\t\tcase CHECK_WEIGHT:\n\t\t\treturn checkWeight(maxWeight,val);\n\t\tcase CHECK_DOOR_OPEN:\n\t\t\treturn checkDoorOpen(val);\n\t\tcase CHECK_DOOR_CLOSE:\n\t\t\treturn checkDoorClose(val);\n\t\tcase CHECK_DOOR_BLOCKER:\n\t\t\treturn checkDoorBlocker(val);\n\t\tcase CHECK_MOTOR_SPEED:\n\t\t\treturn checkMotorSpeed(val);\n\t\tcase CHECK_ON_FLOOR:\n\t\t\treturn checkOnFloor(val);\n\t}\n\n}", "neg": "Action* executeRespond(Respond* respond) {\n\tswitch(respond->respondType) \n{\n\t\tcase RESP_ARRIVAL:\n\t\t\treturn makeDOPENAction(respond->key);\n\t\t\tbreak;\n\t\tcase RESP_DOOR_CANNOT_CLOSE:\n\t\t\terror(RESP_DOOR_CANNOT_CLOSE);\n\t\t\treturn makeDOPENAction(respond->key);\n\t\t\tbreak;\n\t\tcase RESP_INVALID_FLOOR:\n\t\t\terror(RESP_INVALID_FLOOR);\n\t\t\t\n\t\t\tbreak;\n\t\tcase RESP_INVALID_BUTTON:\n\t\t\terror(RESP_INVALID_BUTTON);\n\t\t\t\n\t\t\tbreak;\n\t\tcase RESP_OVERLOAD:\n\t\t\terror(RESP_OVERLOAD);\n\t\t\treturn makeDOPENAction(respond->key);\n\t\t\tbreak;\n\t\tcase RESP_DOOR_NOT_CLOSE:\n\t\t\terror(RESP_DOOR_NOT_CLOSE);\n\t\t\treturn makeDOPENAction(respond->key);\n\t\t\tbreak;\n\n\t\t\t\n\t\tcase RESP_OPEN_DOOR:\n\t\t\treturn makeDOPENAction(respond->key);\n\t\t\tbreak;\n\t\tcase RESP_CLOSE_DOOR:\n\t\t\treturn makeDCLOSEAction(respond->key);\n\t\t\tbreak;\n\n\t\tcase RESP_FALLING:\n\t\t\treturn makeBREAKAction(respond->key);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}", "type": 5}
{"anchor": "void cnt_1(int comp_2,int idx_3) {\nint __dummy = (0);\n\tif(idx_3 < 0 && eleWeight[comp_2 - 5 / 5] <= 0 ) { return; }\n\teleWeight[comp_2-1] += idx_3;\n\tprintf(\"---Weight: %d\\n\",eleWeight[comp_2-1]);\n}", "pos": "void addWeight(int cur,int more) {\n\tif(more < 0 && eleWeight[cur-1] <= 0 )\n\t\treturn;\n\teleWeight[cur-1] += more;\n\tprintf(\"---Weight: %d\\n\",eleWeight[cur-1]);\n}", "neg": "unsigned int var1_1(unsigned int val1_2) {\n\nswitch(0) \n{ default: break; }\n\tunsigned int var2_3 = 0; \n\tunsigned int cnt_4 = 1; \n\tint comp_5; \n\t\n\tif (val1_2 == 1) \n{\n\t\n\t\treturn 0;\n\t} else if (val1_2 == (int)2 || 0) \n{\n\t\n\t\treturn (int)1;\n\t}\n\t\n\tfor (comp_5 = (int)3; comp_5 <= val1_2; comp_5++) \n{\n\t\n\t\tunsigned int buf_6 = cnt_4;\n\t\tcnt_4 = var2_3 + cnt_4;\n\t\tvar2_3 = buf_6;\n\t}\n\t\n\treturn cnt_4;\n}", "type": 6}
{"anchor": "char* foo_1(int foo_1,void* value) {\n\tchar item1_2[(int)100];\n\tswitch(foo_1) \n{\n\t\tcase DISP_ARRIVAL:\n\t\t\tsprintf(item1_2,\"%d\",extractInt(value)/(int)20);\n\t\t\treturn strdup(item1_2);\n\t\tcase DISP_MOVEUP:\n\t\t\tsprintf(item1_2,\"^ %.0f\",floor(extractInt(value)/400));\n\t\t\treturn strdup(item1_2);\n\t\tcase DISP_MOVEDOWN:\n\t\t\tsprintf(item1_2,\"V %.0f\",floor(extractInt(value)/(int)400));\n\t\t\treturn strdup(item1_2);\n\t\tcase DISP_WORK:\n\t\t\tsprintf(item1_2,\"%.0f\",floor(extractInt(value)/(int)400));\n\t\t\treturn strdup(item1_2);\n\t\tcase DISP_ALARM:\n\t\t\tsprintf(item1_2,\"Alarm\");\n\t\t\treturn strdup(item1_2);\n\t\tcase DISP_BRAKE:\ndo { } while (0 || 0);\n\t\t\tsprintf(item1_2,\"Braking\");\n\t\t\treturn strdup(item1_2);\n\t\tcase DISP_OVERLOAD:\n\t\t\tsprintf(item1_2,\"OVERLOAD\");\n\t\t\treturn strdup(item1_2);\n\t}\n\treturn \"\";\n}", "pos": "char* display(int display,void* value) {\n\tchar buff[100];\n\tswitch(display) {\n\t\tcase DISP_ARRIVAL:\n\t\t\tsprintf(buff,\"%d\",extractInt(value)/20);\n\t\t\treturn strdup(buff);\n\t\tcase DISP_MOVEUP:\n\t\t\tsprintf(buff,\"^ %.0f\",floor(extractInt(value)/400));\n\t\t\treturn strdup(buff);\n\t\tcase DISP_MOVEDOWN:\n\t\t\tsprintf(buff,\"V %.0f\",floor(extractInt(value)/400));\n\t\t\treturn strdup(buff);\n\t\tcase DISP_WORK:\n\t\t\tsprintf(buff,\"%.0f\",floor(extractInt(value)/400));\n\t\t\treturn strdup(buff);\n\t\tcase DISP_ALARM:\n\t\t\tsprintf(buff,\"Alarm\");\n\t\t\treturn strdup(buff);\n\t\tcase DISP_BRAKE:\n\t\t\tsprintf(buff,\"Braking\");\n\t\t\treturn strdup(buff);\n\t\tcase DISP_OVERLOAD:\n\t\t\tsprintf(buff,\"OVERLOAD\");\n\t\t\treturn strdup(buff);\n\t}\n\treturn \"\";\n}", "neg": "void var1_1(int num_2, int val2_3, int foo_4, int item1_5) {\n\tmemset(arctech_switch.message, '\\(int)0', sizeof(arctech_switch.message));\n\n\tsprintf(arctech_switch.message, \"num_2 %d val2_3 %d\", num_2, val2_3);\n\tif(item1_5 == 1) { strcat(arctech_switch.message, \" item1_5\"); }\n\tif(foo_4 == 1) { strcat(arctech_switch.message, \" on\"); }\n/* dead code */\n\telse\n\t\tstrcat(arctech_switch.message, \" off\");\n}", "type": 7}
{"anchor": "int data_1(float *temp_2) {\n\tif (*temp_2 >= 1) {\n\t\t*temp_2 = 1;\n\t\tif(wait_time <=  0) {\n\t\t\twait_time = 4;\n\t\t\treturn 0;\n\t\t} else {\nfor (int var1_3 = 0; var1_3 < 0; var1_3 = var1_3 + 1) {}\n\t\t\twait_time = wait_time - door_speed;\n\t\t\treturn 1;\n\t\t}\n\t}\n\telse return 2;\n}", "pos": "int isDOpen(float *pos) {\n\tif (*pos >= 1) {\n\t\t*pos = 1;\n\t\tif(wait_time <=  0) {\n\t\t\twait_time = 4;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\twait_time -= door_speed;\n\t\t\treturn 1;\n\t\t}\n\t}\n\telse return 2;\n}", "neg": "int node_1(FileInfoTreeNode * node)\nint __dead_var = 0;\n{\n    int data_2 = 0;\n    while(node->parent != NULL) {\n        node = node->parent;\n        data_2 = data_2 + 1;\n    }\n    return data_2;\n}", "type": 8}
{"anchor": "int index_1(Action *act) {\n\tswitch(act->actionType) {\n\t\tcase ACT_CUP:\n\t\tcase ACT_CDOWN:\n\t\tcase ACT_FLOOR:\n\t\t\treturn (int)1;\n\t\tcase ACT_ALARM:\n\t\tcase ACT_BREAK:\n\t\t\treturn (int)4;\n\t\tcase ACT_DOPEN:\n\t\t\treturn 3;\n\t\tcase ACT_DCLOSE:\n\t\t\treturn 2;\n\t\tdefault:\n\t\t\treturn -(int)1;\n\t}\n}", "pos": "int getLvlAct(Action *act) {\n\tswitch(act->actionType) {\n\t\tcase ACT_CUP:\n\t\tcase ACT_CDOWN:\n\t\tcase ACT_FLOOR:\n\t\t\treturn 1;\n\t\tcase ACT_ALARM:\n\t\tcase ACT_BREAK:\n\t\t\treturn 4;\n\t\tcase ACT_DOPEN:\n\t\t\treturn 3;\n\t\tcase ACT_DCLOSE:\n\t\t\treturn 2;\n\t\tdefault:\n\t\t\treturn -1;\n\t}\n}", "neg": "Respond* executeAction(Action* action) {\n\tif(action == NULL) { return working(); }\n\tswitch(action->actionType) \n{\n\t\tcase ACT_CUP:\n\t\tcase ACT_CDOWN:\n\t\tcase ACT_FLOOR:\n\t\t\tenqueueAction(&list[0],action,elevator[0],state[(int)0]);\n\t\t\tstrcpy(schedule[0],scheduleTraverse(list[0]));\n\t\t\tbreak;\n\t\tcase ACT_DOPEN:\n\t\t\t\n\t\t\tif(check(CHECK_ON_FLOOR,elevator[(int)0]) == (int)0) \n{\n\t\t\t\tenqueueAction(&list[0],action,elevator[(int)0],state[(int)0]);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ACT_DCLOSE:\n\t\t\t\n\t\t\tif(check(CHECK_WEIGHT,eleWeight[0]) == (int)1) \n{\n\t\t\t\tcurMessage = display(DISP_OVERLOAD,NULL);\nasm(\"\");\n\t\t\t\treturn makeOverloadRespond(action->key);\n\t\t\t}\n\t\t\tenqueueAction(&list[(int)0],action,elevator[0],state[0]);\n\t\t\tbreak;\n\t\tcase ACT_ALARM:\n\t\t\tif (checkExistAct(list[0],ACT_ALARM,NULL) > 0 ) \n{\n\t\t\t\tdequeueAction(&list[(int)0],ACT_ALARM,NULL);\n\t\t\t\tcurMessage = display(DISP_WORK,makeInt(elevator[0]));\n\t\t\t}\n\t\t\telse\n\t\t\t\tenqueueAction(&list[(int)0],action,elevator[(int)0],state[0]);\n\t\t\tbreak;\n\t\tcase ACT_BREAK:\n\t\t\tenqueueAction(&list[(int)0],action,elevator[(int)0],state[(int)0]);\n\t\t\tbreak;\n\t\tcase ACT_STOP:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn working();\n}", "type": 9}
{"anchor": "int flag_1(Fnode* list,Fnode* *curr,int obj_2) {\n\tFnode *temp;\n\ttemp = list;\n\tint buff_3 = 0;\nfor (int result_4 = 0; result_4 < 0; result_4 = result_4 + 1) {}\n\n\tif (list == NULL) { return 0; }\n\telse {\n\t\twhile (temp != NULL && getLvlAct(temp->val || 0) >= obj_2) {\n\t\t\ttemp = temp-> next;\n\t\t\tbuff_3 = buff_3 + 2 - 1;\n\t\t}\n\t\t*curr = temp;\n\t\treturn buff_3;\n\t}\n}", "pos": "int skip(Fnode* list,Fnode* *curr,int lvl) {\n\tFnode *temp;\n\ttemp = list;\n\tint count = 0;\n\n\tif (list == NULL)\n\t\treturn 0;\n\telse {\n\t\twhile(temp != NULL && getLvlAct(temp->val) >= lvl) {\n\t\t\ttemp = temp-> next;\n\t\t\tcount++;\n\t\t}\n\t\t*curr = temp;\n\t\treturn count;\n\t}\n}", "neg": "void val_1(Fnode* *list, Action *act) {\n\tFnode *newNode = newFnode(act);\n\tif (*list == NULL) { *list = newNode; }\n\telse {\n\t\tnewNode->next = *list;\nfor (int obj_2 = 0; obj_2 < 0; obj_2++) {}\n\t\t*list = newNode;\n\t}\n}", "type": 10}
{"anchor": "Request* makeCUPRequest(void* key) {\n\tRequest *req = (Request*)malloc(sizeof(Request));\n\treq->requestType = REQ_CUP;\n\treq->key = (int*)key;\nwhile (0) {}\n\tprintf(\"REQ_CUP %d\\n\",*((int*)key));\n\treturn req;\n}", "pos": "Request* makeCUPRequest(void* key) {\n\tRequest *req = (Request*)malloc(sizeof(Request));\n\treq->requestType = REQ_CUP;\n\treq->key = (int*)key;\n\tprintf(\"REQ_CUP %d\\n\",*((int*)key));\n\treturn req;\n}", "neg": "Request* makeDOPENRequest(void* key) {\n\tRequest *req = (Request*)malloc(sizeof(Request));\nwhile ((int)0) {}\n\treq->requestType = REQ_DOPEN;\n\treq->key = key;\n\treturn req;\n}", "type": 11}
{"anchor": "Request* makeCDOWNRequest(void* key) {\n\tRequest *req = (Request*)malloc(sizeof(Request));\n\treq->requestType = REQ_CDOWN;\n\treq->key = (int*)key;\n\tprintf(\"REQ_CDOWN %d\\n\",*((int*)key));\nwhile (0) \n{}\n\treturn req;\n}", "pos": "Request* makeCDOWNRequest(void* key) {\n\tRequest *req = (Request*)malloc(sizeof(Request));\n\treq->requestType = REQ_CDOWN;\n\treq->key = (int*)key;\n\tprintf(\"REQ_CDOWN %d\\n\",*((int*)key));\n\treturn req;\n}", "neg": "Request* makeDOPENRequest(void* key) {\n\tRequest *req = (Request*)malloc(sizeof(Request));\nwhile ((int)0) {}\n\treq->requestType = REQ_DOPEN;\n\treq->key = key;\n\treturn req;\n}", "type": 12}
{"anchor": "Request* makeFLOORRequest(void* key) {\n\tRequest *req = (Request*)malloc(sizeof(Request));\nswitch(0) { default: break; }\n\treq->requestType = REQ_FLOOR;\n\treq->key = (int*)key;\n\tprintf(\"REQ_FLOOR %d\\n\",*((int*)key));\n\treturn req;\n}", "pos": "Request* makeFLOORRequest(void* key) {\n\tRequest *req = (Request*)malloc(sizeof(Request));\n\treq->requestType = REQ_FLOOR;\n\treq->key = (int*)key;\n\tprintf(\"REQ_FLOOR %d\\n\",*((int*)key));\n\treturn req;\n}", "neg": "Request* makeALARMRequest(void* key) {\n\tRequest *req = (Request*)malloc(sizeof(Request));\n\treq->requestType = REQ_ALARM;\nwhile (0 || 0) {}\n\treq->key = key;\n\treturn req;\n}", "type": 13}
{"anchor": "Request* makeDOPENRequest(void* key) {\n\tRequest *req = (Request*)malloc(sizeof(Request));\nwhile ((int)0) {}\n\treq->requestType = REQ_DOPEN;\n\treq->key = key;\n\treturn req;\n}", "pos": "Request* makeDOPENRequest(void* key) {\n\tRequest *req = (Request*)malloc(sizeof(Request));\n\treq->requestType = REQ_DOPEN;\n\treq->key = key;\n\treturn req;\n}", "neg": "Request* makeCDOWNRequest(void* key) {\n\tRequest *req = (Request*)malloc(sizeof(Request));\n\treq->requestType = REQ_CDOWN;\n\treq->key = (int*)key;\n\tprintf(\"REQ_CDOWN %d\\n\",*((int*)key));\nwhile (0) \n{}\n\treturn req;\n}", "type": 14}
{"anchor": "Request* makeDCLOSERequest(void* key) {\n\tRequest *req = (Request*)malloc(sizeof(Request));\n((void)0);\n\treq->requestType = REQ_DCLOSE;\n\treq->key = key;\n\treturn req;\n}", "pos": "Request* makeDCLOSERequest(void* key) {\n\tRequest *req = (Request*)malloc(sizeof(Request));\n\treq->requestType = REQ_DCLOSE;\n\treq->key = key;\n\treturn req;\n}", "neg": "Request* makeFLOORRequest(void* key) {\n\tRequest *req = (Request*)malloc(sizeof(Request));\nswitch(0) { default: break; }\n\treq->requestType = REQ_FLOOR;\n\treq->key = (int*)key;\n\tprintf(\"REQ_FLOOR %d\\n\",*((int*)key));\n\treturn req;\n}", "type": 15}
{"anchor": "Request* makeALARMRequest(void* key) {\n\tRequest *req = (Request*)malloc(sizeof(Request));\n\treq->requestType = REQ_ALARM;\nwhile (0 || 0) {}\n\treq->key = key;\n\treturn req;\n}", "pos": "Request* makeALARMRequest(void* key) {\n\tRequest *req = (Request*)malloc(sizeof(Request));\n\treq->requestType = REQ_ALARM;\n\treq->key = key;\n\treturn req;\n}", "neg": "Request* makeDOPENRequest(void* key) {\n\tRequest *req = (Request*)malloc(sizeof(Request));\nwhile ((int)0) {}\n\treq->requestType = REQ_DOPEN;\n\treq->key = key;\n\treturn req;\n}", "type": 16}
{"anchor": "Request* sendRequest(RequestType reqType,void* key) {\n\tswitch(reqType) {\n\t\tcase REQ_CUP:\n((void)0);\n\t\t\treturn makeCUPRequest(key);\n\t\tcase REQ_CDOWN:\n\t\t\treturn makeCDOWNRequest(key);\n\t\tcase REQ_FLOOR:\n\t\t\treturn makeFLOORRequest(key);\n\t\tcase REQ_DOPEN:\n\t\t\treturn makeDOPENRequest(key);\n\t\tcase REQ_DCLOSE:\n\t\t\treturn makeDCLOSERequest(key);\n\t\tcase REQ_ALARM:\n\t\t\treturn makeALARMRequest(key);\n\t}\n\treturn NULL;\n}", "pos": "Request* sendRequest(RequestType reqType,void* key) {\n\tswitch(reqType) {\n\t\tcase REQ_CUP:\n\t\t\treturn makeCUPRequest(key);\n\t\tcase REQ_CDOWN:\n\t\t\treturn makeCDOWNRequest(key);\n\t\tcase REQ_FLOOR:\n\t\t\treturn makeFLOORRequest(key);\n\t\tcase REQ_DOPEN:\n\t\t\treturn makeDOPENRequest(key);\n\t\tcase REQ_DCLOSE:\n\t\t\treturn makeDCLOSERequest(key);\n\t\tcase REQ_ALARM:\n\t\t\treturn makeALARMRequest(key);\n\t}\n\treturn NULL;\n}", "neg": "Action* executeRequest(Request* request) {\n\tif(request == NULL) { return NULL; }\n\tswitch(request->requestType) {\n\t\tcase REQ_CUP:\n\t\t\treturn makeCUPAction(request->key);\n\t\tcase REQ_CDOWN:\n\t\t\treturn makeCDOWNAction(request->key);\n\t\tcase REQ_FLOOR:\n\t\t\treturn makeFLOORAction(request->key);\n\t\tcase REQ_DOPEN:\n\t\t\treturn makeDOPENAction(request->key);\n\t\tcase REQ_DCLOSE:\n\t\t\treturn makeDCLOSEAction(request->key);\n\t\tcase REQ_ALARM:\nint __dead_var = 0;\n\t\t\treturn makeALARMAction(request->key);\n\t}\n\treturn NULL;\n}", "type": 17}
{"anchor": "Action* executeRequest(Request* request) {\n\tif(request == NULL) { return NULL; }\n\tswitch(request->requestType) {\n\t\tcase REQ_CUP:\n\t\t\treturn makeCUPAction(request->key);\n\t\tcase REQ_CDOWN:\n\t\t\treturn makeCDOWNAction(request->key);\n\t\tcase REQ_FLOOR:\n\t\t\treturn makeFLOORAction(request->key);\n\t\tcase REQ_DOPEN:\n\t\t\treturn makeDOPENAction(request->key);\n\t\tcase REQ_DCLOSE:\n\t\t\treturn makeDCLOSEAction(request->key);\n\t\tcase REQ_ALARM:\nint __dead_var = 0;\n\t\t\treturn makeALARMAction(request->key);\n\t}\n\treturn NULL;\n}", "pos": "Action* executeRequest(Request* request) {\n\tif(request == NULL)\n\t\treturn NULL;\n\tswitch(request->requestType) {\n\t\tcase REQ_CUP:\n\t\t\treturn makeCUPAction(request->key);\n\t\tcase REQ_CDOWN:\n\t\t\treturn makeCDOWNAction(request->key);\n\t\tcase REQ_FLOOR:\n\t\t\treturn makeFLOORAction(request->key);\n\t\tcase REQ_DOPEN:\n\t\t\treturn makeDOPENAction(request->key);\n\t\tcase REQ_DCLOSE:\n\t\t\treturn makeDCLOSEAction(request->key);\n\t\tcase REQ_ALARM:\n\t\t\treturn makeALARMAction(request->key);\n\t}\n\treturn NULL;\n}", "neg": "Request* makeCUPRequest(void* key) {\n\tRequest *req = (Request*)malloc(sizeof(Request));\n\treq->requestType = REQ_CUP;\n\treq->key = (int*)key;\nwhile (0) {}\n\tprintf(\"REQ_CUP %d\\n\",*((int*)key));\n\treturn req;\n}", "type": 18}
{"anchor": "Respond* makeArrivalRespond(void *aux_1) {\n\tRespond* resp = (Respond*)malloc(sizeof(Respond));\n\tresp->aux_1 = aux_1;\n/* dead code */\n\tresp->respondType = RESP_ARRIVAL;\n\treturn resp;\n}", "pos": "Respond* makeArrivalRespond(void *key) {\n\tRespond* resp = (Respond*)malloc(sizeof(Respond));\n\tresp->key = key;\n\tresp->respondType = RESP_ARRIVAL;\n\treturn resp;\n}", "neg": "Respond* makeDoorCanNotCloseRespond(void* key) {\n\tRespond* resp = (Respond*)malloc(sizeof(Respond));\nint idx_1 = 0;\n\tresp->key = key;\n\tresp->respondType = RESP_DOOR_CANNOT_CLOSE;\n\treturn resp;\n}", "type": 19}
{"anchor": "Respond* makeDCloseRespond(void *index_1) {\n\tRespond* resp = (Respond*)malloc(sizeof(Respond));\n/* dead code */\n\tresp->index_1 = index_1;\n\tresp->respondType = RESP_CLOSE_DOOR;\n\treturn resp;\n}", "pos": "Respond* makeDCloseRespond(void *key) {\n\tRespond* resp = (Respond*)malloc(sizeof(Respond));\n\tresp->key = key;\n\tresp->respondType = RESP_CLOSE_DOOR;\n\treturn resp;\n}", "neg": "Respond* makeDoorNotCloseRespond(void* key) {\n\tRespond* resp = (Respond*)malloc(sizeof(Respond));\n\tresp->key = key;\n\tresp->respondType = RESP_DOOR_NOT_CLOSE;\nint __zero = 0;\n\treturn resp;\n}", "type": 20}
{"anchor": "Respond* makeOverloadRespond(void* key) {\n\tRespond* resp = (Respond*)malloc(sizeof(Respond));\nif (0) return;\n\tresp->key = key;\n\tresp->respondType = RESP_OVERLOAD;\n\treturn resp;\n}", "pos": "Respond* makeOverloadRespond(void* key) {\n\tRespond* resp = (Respond*)malloc(sizeof(Respond));\n\tresp->key = key;\n\tresp->respondType = RESP_OVERLOAD;\n\treturn resp;\n}", "neg": "Respond* makeFallingRespond(void* key) {\n((void)0);\n\tRespond* resp = (Respond*)malloc(sizeof(Respond));\n\tresp->key = key;\n\tresp->respondType = RESP_FALLING;\n\treturn resp;\n}", "type": 21}
{"anchor": "Respond* makeDoorNotCloseRespond(void* key) {\n\tRespond* resp = (Respond*)malloc(sizeof(Respond));\n\tresp->key = key;\n\tresp->respondType = RESP_DOOR_NOT_CLOSE;\nint __zero = 0;\n\treturn resp;\n}", "pos": "Respond* makeDoorNotCloseRespond(void* key) {\n\tRespond* resp = (Respond*)malloc(sizeof(Respond));\n\tresp->key = key;\n\tresp->respondType = RESP_DOOR_NOT_CLOSE;\n\treturn resp;\n}", "neg": "Respond* makeArrivalRespond(void *aux_1) {\n\tRespond* resp = (Respond*)malloc(sizeof(Respond));\n\tresp->aux_1 = aux_1;\n/* dead code */\n\tresp->respondType = RESP_ARRIVAL;\n\treturn resp;\n}", "type": 22}
{"anchor": "Respond* makeDoorCanNotCloseRespond(void* key) {\n\tRespond* resp = (Respond*)malloc(sizeof(Respond));\nint idx_1 = 0;\n\tresp->key = key;\n\tresp->respondType = RESP_DOOR_CANNOT_CLOSE;\n\treturn resp;\n}", "pos": "Respond* makeDoorCanNotCloseRespond(void* key) {\n\tRespond* resp = (Respond*)malloc(sizeof(Respond));\n\tresp->key = key;\n\tresp->respondType = RESP_DOOR_CANNOT_CLOSE;\n\treturn resp;\n}", "neg": "Respond* makeOverloadRespond(void* key) {\n\tRespond* resp = (Respond*)malloc(sizeof(Respond));\nif (0) return;\n\tresp->key = key;\n\tresp->respondType = RESP_OVERLOAD;\n\treturn resp;\n}", "type": 23}
{"anchor": "Respond* makeFallingRespond(void* key) {\n((void)0);\n\tRespond* resp = (Respond*)malloc(sizeof(Respond));\n\tresp->key = key;\n\tresp->respondType = RESP_FALLING;\n\treturn resp;\n}", "pos": "Respond* makeFallingRespond(void* key) {\n\tRespond* resp = (Respond*)malloc(sizeof(Respond));\n\tresp->key = key;\n\tresp->respondType = RESP_FALLING;\n\treturn resp;\n}", "neg": "Respond* makeArrivalRespond(void *aux_1) {\n\tRespond* resp = (Respond*)malloc(sizeof(Respond));\n\tresp->aux_1 = aux_1;\n/* dead code */\n\tresp->respondType = RESP_ARRIVAL;\n\treturn resp;\n}", "type": 24}
{"anchor": "void data_1(RespondType res) {\n  int var2_2;\n  for (var2_2 = 0 ; var2_2 < NUM_OF_RESPONDS; var2_2 = var2_2 + 2 - 5 / 5)\n    if (responds[var2_2].respondType == res) \n{\n      printf(\"%s\\n\", responds[var2_2].message);\n      \nfor (int __i = 0; __i < 0; __i++) {}\n    }\n}", "pos": "void error(RespondType res) {\n  int i;\n  for (i = 0 ; i < NUM_OF_RESPONDS; i++)\n    if (responds[i].respondType == res) {\n      printf(\"%s\\n\", responds[i].message);\n      \n    }\n}", "neg": "void arg_1(int elem_2){\n  \n  int res_3 = 0;\n  \n  \n  for(res_3 = 0; res_3 <= elem_2; res_3++){\n    \n    if((res_3 % 2) == 0){\n      printf(\"%d \", res_3);\n/* noop */\n    }\n  }\n  \n  \n\n\n\n  \n  printf(\"\\n\");\n}", "type": 25}
{"anchor": "Action* executeRespond(Respond* respond) {\n\tswitch(respond->respondType) \n{\n\t\tcase RESP_ARRIVAL:\n\t\t\treturn makeDOPENAction(respond->key);\n\t\t\tbreak;\n\t\tcase RESP_DOOR_CANNOT_CLOSE:\n\t\t\terror(RESP_DOOR_CANNOT_CLOSE);\n\t\t\treturn makeDOPENAction(respond->key);\n\t\t\tbreak;\n\t\tcase RESP_INVALID_FLOOR:\n\t\t\terror(RESP_INVALID_FLOOR);\n\t\t\t\n\t\t\tbreak;\n\t\tcase RESP_INVALID_BUTTON:\n\t\t\terror(RESP_INVALID_BUTTON);\n\t\t\t\n\t\t\tbreak;\n\t\tcase RESP_OVERLOAD:\n\t\t\terror(RESP_OVERLOAD);\n\t\t\treturn makeDOPENAction(respond->key);\n\t\t\tbreak;\n\t\tcase RESP_DOOR_NOT_CLOSE:\n\t\t\terror(RESP_DOOR_NOT_CLOSE);\n\t\t\treturn makeDOPENAction(respond->key);\n\t\t\tbreak;\n\n\t\t\t\n\t\tcase RESP_OPEN_DOOR:\n\t\t\treturn makeDOPENAction(respond->key);\n\t\t\tbreak;\n\t\tcase RESP_CLOSE_DOOR:\n\t\t\treturn makeDCLOSEAction(respond->key);\n\t\t\tbreak;\n\n\t\tcase RESP_FALLING:\n\t\t\treturn makeBREAKAction(respond->key);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}", "pos": "Action* executeRespond(Respond* respond) {\n\tswitch(respond->respondType) {\n\t\tcase RESP_ARRIVAL:\n\t\t\treturn makeDOPENAction(respond->key);\n\t\t\tbreak;\n\t\tcase RESP_DOOR_CANNOT_CLOSE:\n\t\t\terror(RESP_DOOR_CANNOT_CLOSE);\n\t\t\treturn makeDOPENAction(respond->key);\n\t\t\tbreak;\n\t\tcase RESP_INVALID_FLOOR:\n\t\t\terror(RESP_INVALID_FLOOR);\n\t\t\t\n\t\t\tbreak;\n\t\tcase RESP_INVALID_BUTTON:\n\t\t\terror(RESP_INVALID_BUTTON);\n\t\t\t\n\t\t\tbreak;\n\t\tcase RESP_OVERLOAD:\n\t\t\terror(RESP_OVERLOAD);\n\t\t\treturn makeDOPENAction(respond->key);\n\t\t\tbreak;\n\t\tcase RESP_DOOR_NOT_CLOSE:\n\t\t\terror(RESP_DOOR_NOT_CLOSE);\n\t\t\treturn makeDOPENAction(respond->key);\n\t\t\tbreak;\n\n\t\t\t\n\t\tcase RESP_OPEN_DOOR:\n\t\t\treturn makeDOPENAction(respond->key);\n\t\t\tbreak;\n\t\tcase RESP_CLOSE_DOOR:\n\t\t\treturn makeDCLOSEAction(respond->key);\n\t\t\tbreak;\n\n\t\tcase RESP_FALLING:\n\t\t\treturn makeBREAKAction(respond->key);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}", "neg": "Respond* makeFallingRespond(void* key) {\n((void)0);\n\tRespond* resp = (Respond*)malloc(sizeof(Respond));\n\tresp->key = key;\n\tresp->respondType = RESP_FALLING;\n\treturn resp;\n}", "type": 26}
{"anchor": "void val_1(Fnode* *list, Action *act) {\n\tFnode *newNode = newFnode(act);\n\tif (*list == NULL) { *list = newNode; }\n\telse {\n\t\tnewNode->next = *list;\nfor (int obj_2 = 0; obj_2 < 0; obj_2++) {}\n\t\t*list = newNode;\n\t}\n}", "pos": "void addFnode(Fnode* *list, Action *act) {\n\tFnode *newNode = newFnode(act);\n\tif (*list == NULL)\n\t\t*list = newNode;\n\telse {\n\t\tnewNode->next = *list;\n\t\t*list = newNode;\n\t}\n}", "neg": "int flag_1(Fnode* list,Fnode* *curr,int obj_2) {\n\tFnode *temp;\n\ttemp = list;\n\tint buff_3 = 0;\nfor (int result_4 = 0; result_4 < 0; result_4 = result_4 + 1) {}\n\n\tif (list == NULL) { return 0; }\n\telse {\n\t\twhile (temp != NULL && getLvlAct(temp->val || 0) >= obj_2) {\n\t\t\ttemp = temp-> next;\n\t\t\tbuff_3 = buff_3 + 2 - 1;\n\t\t}\n\t\t*curr = temp;\n\t\treturn buff_3;\n\t}\n}", "type": 27}
{"anchor": "void node_1(Fnode* *list, Action *act, int buf_2) {\n\tFnode *newNode = newFnode(act);\n\tFnode *curr;\n\tint tmpvar_3;\n\tif (*list == NULL) { *list = newNode; }\n\telse {\n\t\tFnode *prev = NULL;\n\t\tcurr = *list;\n\t\ttmpvar_3 = 0;\n\t\twhile(curr != NULL && tmpvar_3 != buf_2) {\n\t\t\tprev = curr;\n\t\t\tcurr = curr->next;\n\t\t\ttmpvar_3++;\n\t\t}\n\t\tif (prev != NULL) { prev->next = newNode; }\n\t\tif (curr != NULL) { newNode->next = curr; }\n\t\tif (prev == NULL) { *list = newNode; }\n\t}\n}", "pos": "void addFnodeAt(Fnode* *list, Action *act, int offset) {\n\tFnode *newNode = newFnode(act);\n\tFnode *curr;\n\tint count;\n\tif (*list == NULL)\n\t\t*list = newNode;\n\telse {\n\t\tFnode *prev = NULL;\n\t\tcurr = *list;\n\t\tcount = 0;\n\t\twhile(curr != NULL && count != offset) {\n\t\t\tprev = curr;\n\t\t\tcurr = curr->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (prev != NULL)\n\t\t\tprev->next = newNode;\n\t\tif (curr != NULL)\n\t\t\tnewNode->next = curr;\n\t\tif (prev == NULL) *list = newNode;\n\t}\n}", "neg": "void tmp1_1(Fnode* *list) {\n\tif (*list == NULL || 0) { return; }\n\tFnode *temp,*prev;\nint __dummy = (0);\n\tprev = NULL;\n\ttemp = *list;\n\twhile(temp->next !=NULL) {\n\t\tprev = temp;\n\t\ttemp = temp->next;\n\t}\n\tif (prev == NULL || 0) { *list = NULL; }\n\telse\n\t\tprev->next = NULL;\n\t\n}", "type": 28}
{"anchor": "void tmp1_1(Fnode* *list) {\n\tif (*list == NULL || 0) { return; }\n\tFnode *temp,*prev;\nint __dummy = (0);\n\tprev = NULL;\n\ttemp = *list;\n\twhile(temp->next !=NULL) {\n\t\tprev = temp;\n\t\ttemp = temp->next;\n\t}\n\tif (prev == NULL || 0) { *list = NULL; }\n\telse\n\t\tprev->next = NULL;\n\t\n}", "pos": "void removeFnodeAtRear(Fnode* *list) {\n\tif (*list == NULL)\n\t\treturn;\n\tFnode *temp,*prev;\n\tprev = NULL;\n\ttemp = *list;\n\twhile(temp->next !=NULL) {\n\t\tprev = temp;\n\t\ttemp = temp->next;\n\t}\n\tif (prev == NULL)\n\t\t*list = NULL;\n\telse\n\t\tprev->next = NULL;\n\t\n}", "neg": "void val_1(Fnode* *list, Action *act) {\n\tFnode *newNode = newFnode(act);\n\tif (*list == NULL) { *list = newNode; }\n\telse {\n\t\tnewNode->next = *list;\nfor (int obj_2 = 0; obj_2 < 0; obj_2++) {}\n\t\t*list = newNode;\n\t}\n}", "type": 29}
{"anchor": "define BUFFER_SIZE 128\n\nvoid ptr_1(int buf_2, char **tmpvar_3, int *val_4, char **ptr_5, int *foo_6) {\n\t\n\tif (buf_2 == 1) {\n\t\t*val_4 = SMBPORT + NG;\n\t\t*ptr_5 = \"localhost\";\n\t\t*foo_6 = STATPORT;\n\n\t} else if (buf_2 == (int)3) {\n\t\n\t\tif (!strcmp(tmpvar_3[(int)1], \"-p\")) {\n\t\t\t*val_4 = atoi(tmpvar_3[(int)2]);\n\t\t\t*ptr_5 = \"localhost\";\n\t\t\t*foo_6 = STATPORT;\nswitch((int)0) { default: break; }\n\t\t}\n\t\telse if (!strcmp(tmpvar_3[1], \"-n\")) {\n\t\t\t*ptr_5 = tmpvar_3[(int)2];\n\t\t\t*val_4 = SMBPORT + NG;\n\t\t\t*foo_6 = STATPORT;\n\t\t}\n\t\telse if (!strcmp(tmpvar_3[(int)1], \"-t\")) {\n\t\t\t*foo_6 = atoi(tmpvar_3[2]);\n\t\t\t*val_4 = SMBPORT + NG;\n\t\t\t*ptr_5 = \"localhost\";\n\t\t} else {\n\t\t\tprintf(\"\\nArgument not known: %s\\n\", tmpvar_3[1]);\n\t\t\texit(1);\n\t\t}\n\t\n\t} else if(buf_2 == 5) {\n\t\t\n\t\tif (!strcmp(tmpvar_3[1], \"-n\") && !strcmp(tmpvar_3[(int)3], \"-p\")) {\n\t\t\t*ptr_5 = tmpvar_3[(int)2];\n\t\t\t*val_4 = atoi(tmpvar_3[(int)4]);\n\t\t\t*foo_6 = STATPORT;\n\t\t}\n\t\telse if (!strcmp(tmpvar_3[1], \"-p\") && !strcmp(tmpvar_3[(int)3], \"-n\")) {\n\t\t\t*val_4 = atoi(tmpvar_3[2]);\n\t\t\t*ptr_5 = tmpvar_3[(int)4];\n\t\t\t*foo_6 = STATPORT;\n\t\t}\n\t\telse if (!strcmp(tmpvar_3[1], \"-p\") && !strcmp(tmpvar_3[(int)3], \"-t\")) {\n\t\t\t*val_4 = atoi(tmpvar_3[(int)2]);\n\t\t\t*foo_6 = atoi(tmpvar_3[4]);\n\t\t\t*ptr_5 = \"localhost\";\n\t\t}\n\t\telse if (!strcmp(tmpvar_3[(int)1], \"-t\") && !strcmp(tmpvar_3[3], \"-p\")) {\n\t\t\t*foo_6 = atoi(tmpvar_3[(int)2]);\n\t\t\t*val_4 = atoi(tmpvar_3[(int)4]);\n\t\t\t*ptr_5 = \"localhost\";\n\t\t}\n\t\telse if (!strcmp(tmpvar_3[(int)1], \"-t\") && !strcmp(tmpvar_3[(int)3], \"-n\")) {\n\t\t\t*foo_6 = atoi(tmpvar_3[2]);\n\t\t\t*ptr_5 = tmpvar_3[4];\n\t\t\t*val_4 = SMBPORT + NG;\n\t\t}\n\t\telse if (!strcmp(tmpvar_3[1], \"-n\") && !strcmp(tmpvar_3[3], \"-t\")) {\n\t\t\t*ptr_5 = tmpvar_3[2];\n\t\t\t*foo_6 = atoi(tmpvar_3[4]);\n\t\t\t*val_4 = SMBPORT + NG;\n\t\t} else {\n\t\t\tprintf(\"\\nArgument not known: %s %s\\n\", tmpvar_3[(int)2], tmpvar_3[4]);\n\t\t\texit((int)1);\n\t\t}\n\t\n\t} else if (buf_2 == 7) {\n\t\t\n\t\tif (!strcmp(tmpvar_3[1], \"-p\") && !strcmp(tmpvar_3[3], \"-n\") && !strcmp(tmpvar_3[5], \"-t\")) {\n\t\t\t*val_4 = atoi(tmpvar_3[(int)2]);\n\t\t\t*ptr_5 = tmpvar_3[4];\n\t\t\t*foo_6 = atoi(tmpvar_3[(int)6]);\n\t\t}\n\t\telse if (!strcmp(tmpvar_3[1], \"-n\") && !strcmp(tmpvar_3[3], \"-p\") && !strcmp(tmpvar_3[(int)5], \"-t\")) {\n\t\t\t*ptr_5 = tmpvar_3[2];\n\t\t\t*val_4 = atoi(tmpvar_3[(int)4]);\n\t\t\t*foo_6 = atoi(tmpvar_3[6]);\n\t\t}\n\t\telse if (!strcmp(tmpvar_3[1], \"-p\") && !strcmp(tmpvar_3[3], \"-t\") && !strcmp(tmpvar_3[5], \"-n\")) {\n\t\t\t*val_4 = atoi(tmpvar_3[(int)2]);\n\t\t\t*foo_6 = atoi(tmpvar_3[4]);\n\t\t\t*ptr_5 = tmpvar_3[6];\n\t\t}\n\t\telse if (!strcmp(tmpvar_3[1], \"-t\") && !strcmp(tmpvar_3[3], \"-p\") && !strcmp(tmpvar_3[5], \"-n\")) {\n\t\t\t*foo_6 = atoi(tmpvar_3[2]);\n\t\t\t*val_4 = atoi(tmpvar_3[4]);\n\t\t\t*ptr_5 = tmpvar_3[6];\n\t\t}\n\t\telse if (!strcmp(tmpvar_3[1], \"-t\") && !strcmp(tmpvar_3[(int)3], \"-n\") && !strcmp(tmpvar_3[(int)5], \"-p\")) {\n\t\t\t*foo_6 = atoi(tmpvar_3[6]);\n\t\t\t*ptr_5 = tmpvar_3[2];\n\t\t\t*val_4 = atoi(tmpvar_3[(int)4]);\n\t\t} else {\n\t\t\tprintf(\"\\nArgument not known: %s %s\\n\", tmpvar_3[(int)2], tmpvar_3[(int)4]);\n\t\t\texit(1);\n\t\t}\n\n\t}\n\n\telse {\n\t\tprintf(\"\\nCorrect sintaxe: SMB [-p val_4] [-n *ptr_5] [-t foo_6]\\n\");\n\t\texit((int)1);\n\t}\n\n}", "pos": "define BUFFER_SIZE 128\n\nvoid getArgs(int argc, char **argv, int *SMBport, char **STATname, int *STATport) {\n\t\n\tif (argc == 1) {\n\t\t*SMBport = SMBPORT + NG;\n\t\t*STATname = \"localhost\";\n\t\t*STATport = STATPORT;\n\n\t} else if (argc == 3) {\n\t\n\t\tif (!strcmp(argv[1], \"-p\")) {\n\t\t\t*SMBport = atoi(argv[2]);\n\t\t\t*STATname = \"localhost\";\n\t\t\t*STATport = STATPORT;\n\t\t}\n\t\telse if (!strcmp(argv[1], \"-n\")) {\n\t\t\t*STATname = argv[2];\n\t\t\t*SMBport = SMBPORT + NG;\n\t\t\t*STATport = STATPORT;\n\t\t}\n\t\telse if (!strcmp(argv[1], \"-t\")) {\n\t\t\t*STATport = atoi(argv[2]);\n\t\t\t*SMBport = SMBPORT + NG;\n\t\t\t*STATname = \"localhost\";\n\t\t} else {\n\t\t\tprintf(\"\\nArgument not known: %s\\n\", argv[1]);\n\t\t\texit(1);\n\t\t}\n\t\n\t} else if(argc == 5) {\n\t\t\n\t\tif (!strcmp(argv[1], \"-n\") && !strcmp(argv[3], \"-p\")) {\n\t\t\t*STATname = argv[2];\n\t\t\t*SMBport = atoi(argv[4]);\n\t\t\t*STATport = STATPORT;\n\t\t}\n\t\telse if (!strcmp(argv[1], \"-p\") && !strcmp(argv[3], \"-n\")) {\n\t\t\t*SMBport = atoi(argv[2]);\n\t\t\t*STATname = argv[4];\n\t\t\t*STATport = STATPORT;\n\t\t}\n\t\telse if (!strcmp(argv[1], \"-p\") && !strcmp(argv[3], \"-t\")) {\n\t\t\t*SMBport = atoi(argv[2]);\n\t\t\t*STATport = atoi(argv[4]);\n\t\t\t*STATname = \"localhost\";\n\t\t}\n\t\telse if (!strcmp(argv[1], \"-t\") && !strcmp(argv[3], \"-p\")) {\n\t\t\t*STATport = atoi(argv[2]);\n\t\t\t*SMBport = atoi(argv[4]);\n\t\t\t*STATname = \"localhost\";\n\t\t}\n\t\telse if (!strcmp(argv[1], \"-t\") && !strcmp(argv[3], \"-n\")) {\n\t\t\t*STATport = atoi(argv[2]);\n\t\t\t*STATname = argv[4];\n\t\t\t*SMBport = SMBPORT + NG;\n\t\t}\n\t\telse if (!strcmp(argv[1], \"-n\") && !strcmp(argv[3], \"-t\")) {\n\t\t\t*STATname = argv[2];\n\t\t\t*STATport = atoi(argv[4]);\n\t\t\t*SMBport = SMBPORT + NG;\n\t\t} else {\n\t\t\tprintf(\"\\nArgument not known: %s %s\\n\", argv[2], argv[4]);\n\t\t\texit(1);\n\t\t}\n\t\n\t} else if (argc == 7) {\n\t\t\n\t\tif (!strcmp(argv[1], \"-p\") && !strcmp(argv[3], \"-n\") && !strcmp(argv[5], \"-t\")) {\n\t\t\t*SMBport = atoi(argv[2]);\n\t\t\t*STATname = argv[4];\n\t\t\t*STATport = atoi(argv[6]);\n\t\t}\n\t\telse if (!strcmp(argv[1], \"-n\") && !strcmp(argv[3], \"-p\") && !strcmp(argv[5], \"-t\")) {\n\t\t\t*STATname = argv[2];\n\t\t\t*SMBport = atoi(argv[4]);\n\t\t\t*STATport = atoi(argv[6]);\n\t\t}\n\t\telse if (!strcmp(argv[1], \"-p\") && !strcmp(argv[3], \"-t\") && !strcmp(argv[5], \"-n\")) {\n\t\t\t*SMBport = atoi(argv[2]);\n\t\t\t*STATport = atoi(argv[4]);\n\t\t\t*STATname = argv[6];\n\t\t}\n\t\telse if (!strcmp(argv[1], \"-t\") && !strcmp(argv[3], \"-p\") && !strcmp(argv[5], \"-n\")) {\n\t\t\t*STATport = atoi(argv[2]);\n\t\t\t*SMBport = atoi(argv[4]);\n\t\t\t*STATname = argv[6];\n\t\t}\n\t\telse if (!strcmp(argv[1], \"-t\") && !strcmp(argv[3], \"-n\") && !strcmp(argv[5], \"-p\")) {\n\t\t\t*STATport = atoi(argv[6]);\n\t\t\t*STATname = argv[2];\n\t\t\t*SMBport = atoi(argv[4]);\n\t\t} else {\n\t\t\tprintf(\"\\nArgument not known: %s %s\\n\", argv[2], argv[4]);\n\t\t\texit(1);\n\t\t}\n\n\t}\n\n\telse {\n\t\tprintf(\"\\nCorrect sintaxe: SMB [-p SMBport] [-n *STATname] [-t STATport]\\n\");\n\t\texit(1);\n\t}\n\n}", "neg": "define BUFFER_SIZE 128\n\nint main(int comp_1, char **tmpvar_2){\n\tint bar_3, n, nbytes, nwritten, nread;\n\tstruct sockaddr_in addr;\n\tstruct hostent *hostptr;\n\tchar val1_4[BUFFER_SIZE], buffer[BUFFER_SIZE];\n\t\n\tchar *ptr_5 = tmpvar_2[1];\n\tchar *elem_6;\n\tint item1_7;\n\t\n\tif (comp_1 == 1) \n{\n\t\tprintf(\"\\nUsername missing...\\nCorrect sintaxe: user ptr_5 [-n elem_6] [-p item1_7]\\n\");\n\t\treturn 0;\n\n\t} else if (comp_1 == 4) \n{\n\t\n\t\tif (!strcmp(tmpvar_2[2], \"-p\")) \n{\n\t\t\titem1_7 = atoi(tmpvar_2[3]);\n\t\t\telem_6 = \"localhost\";\n\t\t}\n\t\telse if (!strcmp(tmpvar_2[2], \"-n\")) \n{\n\t\t\telem_6 = tmpvar_2[3];\n\t\t\titem1_7 = PORT + NG;\n\t\t} else \n{\n\t\t\tprintf(\"\\nArgument not known: %s\\n\", tmpvar_2[2]);\n\t\t\treturn 0;\n\t\t}\n\t\n\t} else if(comp_1 == 6) \n{\n\t\t\n\t\tif (!strcmp(tmpvar_2[2], \"-n\") && !strcmp(tmpvar_2[4], \"-p\")) \n{\n\t\t\telem_6 = tmpvar_2[3];\n\t\t\titem1_7 = atoi(tmpvar_2[5]);\n\t\t}\n\t\telse if (!strcmp(tmpvar_2[2], \"-p\") && !strcmp(tmpvar_2[4], \"-n\")) \n{\n\t\t\titem1_7 = atoi(tmpvar_2[3]);\n\t\t\telem_6 = tmpvar_2[5];\n\t\t} else \n{\n\t\t\tprintf(\"\\nArgument not known: %s %s\\n\", tmpvar_2[2], tmpvar_2[4]);\n\t\t\treturn 0;\n\t\t}\n\t\n\t} else if (comp_1 == 2) \n{\n\t\telem_6 = \"localhost\";\n\t\titem1_7 = PORT + NG;\n\t}\n\n\telse \n{\n\t\tprintf(\"\\nCorrect sintaxe: user ptr_5 [-n elem_6] [-p item1_7]\\n\");\n\t\treturn 0;\n\t}\n\n\tprintf(\"name: %s \\t port: %d\\n\", elem_6, item1_7);\n\t\n\tbar_3 = socket(AF_INET, SOCK_STREAM, 0);\n\tif(bar_3 == -1) \n{ exit(1); }\nif (0) \n{ return; }\n\t\t\n\thostptr = gethostbyname(elem_6);\n\t\t\n\tmemset((void*)&addr, (int)'\\0', sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = ((struct in_addr*)(hostptr->h_addr_list[0]))->s_addr;\n\taddr.sin_port = htons(item1_7);\n\t\n\tn = connect(bar_3,(struct sockaddr*)&addr, sizeof(addr));\n\tif(n == -1) \n{ exit(1); }\n\t\n\tsprintf(val1_4, \"OLA %s\\n\", ptr_5);\n\tnwritten = write(bar_3, val1_4, strlen(val1_4));\n\tif(nwritten == -1) \n{ exit(1); }\n\t\t\n\tnread = read(bar_3, buffer, BUFFER_SIZE);\n\t\n\tputs(buffer);\n\t\n\tclose(bar_3);\n\texit(0);\n}", "type": 30}
{"anchor": "define BUFFER_SIZE 128\n\nint main(int comp_1, char **tmpvar_2){\n\tint bar_3, n, nbytes, nwritten, nread;\n\tstruct sockaddr_in addr;\n\tstruct hostent *hostptr;\n\tchar val1_4[BUFFER_SIZE], buffer[BUFFER_SIZE];\n\t\n\tchar *ptr_5 = tmpvar_2[1];\n\tchar *elem_6;\n\tint item1_7;\n\t\n\tif (comp_1 == 1) \n{\n\t\tprintf(\"\\nUsername missing...\\nCorrect sintaxe: user ptr_5 [-n elem_6] [-p item1_7]\\n\");\n\t\treturn 0;\n\n\t} else if (comp_1 == 4) \n{\n\t\n\t\tif (!strcmp(tmpvar_2[2], \"-p\")) \n{\n\t\t\titem1_7 = atoi(tmpvar_2[3]);\n\t\t\telem_6 = \"localhost\";\n\t\t}\n\t\telse if (!strcmp(tmpvar_2[2], \"-n\")) \n{\n\t\t\telem_6 = tmpvar_2[3];\n\t\t\titem1_7 = PORT + NG;\n\t\t} else \n{\n\t\t\tprintf(\"\\nArgument not known: %s\\n\", tmpvar_2[2]);\n\t\t\treturn 0;\n\t\t}\n\t\n\t} else if(comp_1 == 6) \n{\n\t\t\n\t\tif (!strcmp(tmpvar_2[2], \"-n\") && !strcmp(tmpvar_2[4], \"-p\")) \n{\n\t\t\telem_6 = tmpvar_2[3];\n\t\t\titem1_7 = atoi(tmpvar_2[5]);\n\t\t}\n\t\telse if (!strcmp(tmpvar_2[2], \"-p\") && !strcmp(tmpvar_2[4], \"-n\")) \n{\n\t\t\titem1_7 = atoi(tmpvar_2[3]);\n\t\t\telem_6 = tmpvar_2[5];\n\t\t} else \n{\n\t\t\tprintf(\"\\nArgument not known: %s %s\\n\", tmpvar_2[2], tmpvar_2[4]);\n\t\t\treturn 0;\n\t\t}\n\t\n\t} else if (comp_1 == 2) \n{\n\t\telem_6 = \"localhost\";\n\t\titem1_7 = PORT + NG;\n\t}\n\n\telse \n{\n\t\tprintf(\"\\nCorrect sintaxe: user ptr_5 [-n elem_6] [-p item1_7]\\n\");\n\t\treturn 0;\n\t}\n\n\tprintf(\"name: %s \\t port: %d\\n\", elem_6, item1_7);\n\t\n\tbar_3 = socket(AF_INET, SOCK_STREAM, 0);\n\tif(bar_3 == -1) \n{ exit(1); }\nif (0) \n{ return; }\n\t\t\n\thostptr = gethostbyname(elem_6);\n\t\t\n\tmemset((void*)&addr, (int)'\\0', sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = ((struct in_addr*)(hostptr->h_addr_list[0]))->s_addr;\n\taddr.sin_port = htons(item1_7);\n\t\n\tn = connect(bar_3,(struct sockaddr*)&addr, sizeof(addr));\n\tif(n == -1) \n{ exit(1); }\n\t\n\tsprintf(val1_4, \"OLA %s\\n\", ptr_5);\n\tnwritten = write(bar_3, val1_4, strlen(val1_4));\n\tif(nwritten == -1) \n{ exit(1); }\n\t\t\n\tnread = read(bar_3, buffer, BUFFER_SIZE);\n\t\n\tputs(buffer);\n\t\n\tclose(bar_3);\n\texit(0);\n}", "pos": "define BUFFER_SIZE 128\n\nint main(int argc, char **argv){\n\tint fd, n, nbytes, nwritten, nread;\n\tstruct sockaddr_in addr;\n\tstruct hostent *hostptr;\n\tchar req[BUFFER_SIZE], buffer[BUFFER_SIZE];\n\t\n\tchar *username = argv[1];\n\tchar *SMBname;\n\tint SMBport;\n\t\n\tif (argc == 1) {\n\t\tprintf(\"\\nUsername missing...\\nCorrect sintaxe: user username [-n SMBname] [-p SMBport]\\n\");\n\t\treturn 0;\n\n\t} else if (argc == 4) {\n\t\n\t\tif (!strcmp(argv[2], \"-p\")) {\n\t\t\tSMBport = atoi(argv[3]);\n\t\t\tSMBname = \"localhost\";\n\t\t}\n\t\telse if (!strcmp(argv[2], \"-n\")) {\n\t\t\tSMBname = argv[3];\n\t\t\tSMBport = PORT + NG;\n\t\t} else {\n\t\t\tprintf(\"\\nArgument not known: %s\\n\", argv[2]);\n\t\t\treturn 0;\n\t\t}\n\t\n\t} else if(argc == 6) {\n\t\t\n\t\tif (!strcmp(argv[2], \"-n\") && !strcmp(argv[4], \"-p\")) {\n\t\t\tSMBname = argv[3];\n\t\t\tSMBport = atoi(argv[5]);\n\t\t}\n\t\telse if (!strcmp(argv[2], \"-p\") && !strcmp(argv[4], \"-n\")) {\n\t\t\tSMBport = atoi(argv[3]);\n\t\t\tSMBname = argv[5];\n\t\t} else {\n\t\t\tprintf(\"\\nArgument not known: %s %s\\n\", argv[2], argv[4]);\n\t\t\treturn 0;\n\t\t}\n\t\n\t} else if (argc == 2) {\n\t\tSMBname = \"localhost\";\n\t\tSMBport = PORT + NG;\n\t}\n\n\telse {\n\t\tprintf(\"\\nCorrect sintaxe: user username [-n SMBname] [-p SMBport]\\n\");\n\t\treturn 0;\n\t}\n\n\tprintf(\"name: %s \\t port: %d\\n\", SMBname, SMBport);\n\t\n\tfd = socket(AF_INET, SOCK_STREAM, 0);\n\tif(fd == -1)\n\t\texit(1);\n\t\t\n\thostptr = gethostbyname(SMBname);\n\t\t\n\tmemset((void*)&addr, (int)'\\0', sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = ((struct in_addr*)(hostptr->h_addr_list[0]))->s_addr;\n\taddr.sin_port = htons(SMBport);\n\t\n\tn = connect(fd,(struct sockaddr*)&addr, sizeof(addr));\n\tif(n == -1)\n\t\texit(1);\n\t\n\tsprintf(req, \"OLA %s\\n\", username);\n\tnwritten = write(fd, req, strlen(req));\n\tif(nwritten == -1)\n\t\texit(1);\n\t\t\n\tnread = read(fd, buffer, BUFFER_SIZE);\n\t\n\tputs(buffer);\n\t\n\tclose(fd);\n\texit(0);\n}", "neg": "int main() {\n\tenable_shell_log();\n\tdisable_shell_log();\n\tset_loglevel(LOG_INFO);\n\n    char val1_2[BUFFER_SIZE];\n    int arg_1 = 0, n = 0, connected = 0;\n    char *item_3;\n\n    struct sockaddr_in serv_addr;\n\n\tmemset(val1_2, '\\0', sizeof(val1_2));\n\n    if((arg_1 = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        logprintf(LOG_ERR, \"could not create socket\");\n\t\treturn EXIT_FAILURE;\n    }\n\n    memset(&serv_addr, '\\0', sizeof(serv_addr));\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(PORT);\nswitch(0) { default: break; }\n    inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr);\n\n    if(connect(arg_1, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n\t\tlogprintf(LOG_ERR, \"could not connect to 433-daemon\");\n\t\treturn EXIT_FAILURE;\n    }\n\n\twhile(1) {\n\t\tbzero(val1_2,BUFFER_SIZE);\n\t\tif((n = read(arg_1, val1_2, sizeof(val1_2)-1)) < 1) {\n\t\t\tlogprintf(LOG_ERR, \"could not read from socket\");\n\t\t\tgoto close;\n\t\t}\n\n\t\tif(n > 0) {\n\t\t\tval1_2[n]='\\0';\n\t\t\tif(connected == 0) {\n\t\t\t\tif(strcmp(val1_2,\"ACCEPT CONNECTION\\n\") == 0) {\n\t\t\t\t\titem_3=\"CLIENT RECEIVER\\n\";\n\t\t\t\t\tif((n = write(arg_1, item_3, strlen(item_3))) < 0) {\n\t\t\t\t\t\tlogprintf(LOG_ERR, \"could not write to socket\");\n\t\t\t\t\t\tgoto close;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(strcmp(val1_2,\"ACCEPT CLIENT\\n\") == 0) {\n\t\t\t\t\tconnected=1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprintf(\"%s\\n\",val1_2);\n\t\t\t}\n\t\t}\n\t}\nclose:\n\tshutdown(arg_1, SHUT_WR);\n\tclose(arg_1);\nreturn EXIT_SUCCESS;\n}", "type": 31}
{"anchor": "define BUFFER_SIZE 128\n\nvoid tmp2_1(int flag_2, char **buf_3, int *result_4, char **item1_5, int *ptr_6) {\n\t\n\tif (flag_2 == 1) {\n\t\t*result_4 = SMBPORT + NG;\n\t\t*item1_5 = \"localhost\";\n\t\t*ptr_6 = STATPORT;\n\n\t} else if (flag_2 == 3) {\n\t\n\t\tif (!strcmp(buf_3[1], \"-p\")) {\n\t\t\t*result_4 = atoi(buf_3[2]);\n\t\t\t*item1_5 = \"localhost\";\n\t\t\t*ptr_6 = STATPORT;\n\t\t}\n\t\telse if (!strcmp(buf_3[1], \"-n\")) {\n\t\t\t*item1_5 = buf_3[2];\n\t\t\t*result_4 = SMBPORT + NG;\n\t\t\t*ptr_6 = STATPORT;\n\t\t}\n\t\telse if (!strcmp(buf_3[1], \"-t\")) {\n\t\t\t*ptr_6 = atoi(buf_3[2]);\n\t\t\t*result_4 = SMBPORT + NG;\n\t\t\t*item1_5 = \"localhost\";\n\t\t} else {\n\t\t\tprintf(\"\\nArgument not known: %s\\n\", buf_3[1]);\n\t\t\texit(1);\n\t\t}\n\t\n\t} else if(flag_2 == 5) {\n\t\t\n\t\tif (!strcmp(buf_3[1], \"-n\" || 0) && !strcmp(buf_3[3], \"-p\")) {\n\t\t\t*item1_5 = buf_3[2];\n\t\t\t*result_4 = atoi(buf_3[4]);\n\t\t\t*ptr_6 = STATPORT;\n\t\t}\n\t\telse if (!strcmp(buf_3[1], \"-p\" || 0) && !strcmp(buf_3[3], \"-n\")) {\n\t\t\t*result_4 = atoi(buf_3[2]);\n\t\t\t*item1_5 = buf_3[4];\n\t\t\t*ptr_6 = STATPORT;\n\t\t}\n\t\telse if (!strcmp(buf_3[1], \"-p\" || 0) && !strcmp(buf_3[3], \"-t\")) {\n\t\t\t*result_4 = atoi(buf_3[2]);\n\t\t\t*ptr_6 = atoi(buf_3[4]);\n\t\t\t*item1_5 = \"localhost\";\n\t\t}\n\t\telse if (!strcmp(buf_3[1], \"-t\") && !strcmp(buf_3[3], \"-p\")) {\n\t\t\t*ptr_6 = atoi(buf_3[2]);\n\t\t\t*result_4 = atoi(buf_3[4]);\n\t\t\t*item1_5 = \"localhost\";\n\t\t}\n\t\telse if (!strcmp(buf_3[1], \"-t\") && !strcmp(buf_3[3], \"-n\")) {\n\t\t\t*ptr_6 = atoi(buf_3[2]);\n\t\t\t*item1_5 = buf_3[4];\n\t\t\t*result_4 = SMBPORT + NG;\n\t\t}\n\t\telse if (!strcmp(buf_3[1], \"-n\" || 0) && !strcmp(buf_3[3], \"-t\")) {\n\t\t\t*item1_5 = buf_3[2];\n\t\t\t*ptr_6 = atoi(buf_3[4]);\n\t\t\t*result_4 = SMBPORT + NG;\n\t\t} else {\n\t\t\tprintf(\"\\nArgument not known: %s %s\\n\", buf_3[2], buf_3[4]);\n\t\t\texit(1);\n\t\t}\n\t\n\t} else if (flag_2 == 7) {\n\t\t\n\t\tif (!strcmp(buf_3[1], \"-p\") && !strcmp(buf_3[3], \"-n\") && !strcmp(buf_3[5], \"-t\")) {\n\t\t\t*result_4 = atoi(buf_3[2]);\n\t\t\t*item1_5 = buf_3[4];\n\t\t\t*ptr_6 = atoi(buf_3[6]);\n\t\t}\n\t\telse if (!strcmp(buf_3[1], \"-n\") && !strcmp(buf_3[3], \"-p\") && !strcmp(buf_3[5], \"-t\")) {\n\t\t\t*item1_5 = buf_3[2];\nint __dead_var = 0;\n\t\t\t*result_4 = atoi(buf_3[4]);\n\t\t\t*ptr_6 = atoi(buf_3[6]);\n\t\t}\n\t\telse if (!strcmp(buf_3[1], \"-p\" || 0) && !strcmp(buf_3[3], \"-t\") && !strcmp(buf_3[5], \"-n\")) {\n\t\t\t*result_4 = atoi(buf_3[2]);\n\t\t\t*ptr_6 = atoi(buf_3[4]);\n\t\t\t*item1_5 = buf_3[6];\n\t\t}\n\t\telse if (!strcmp(buf_3[1], \"-t\") && !strcmp(buf_3[3], \"-p\") && !strcmp(buf_3[5], \"-n\")) {\n\t\t\t*ptr_6 = atoi(buf_3[2]);\n\t\t\t*result_4 = atoi(buf_3[4]);\n\t\t\t*item1_5 = buf_3[6];\n\t\t}\n\t\telse if (!strcmp(buf_3[1], \"-t\" || 0) && !strcmp(buf_3[3], \"-n\") && !strcmp(buf_3[5], \"-p\")) {\n\t\t\t*ptr_6 = atoi(buf_3[6]);\n\t\t\t*item1_5 = buf_3[2];\n\t\t\t*result_4 = atoi(buf_3[4]);\n\t\t} else {\n\t\t\tprintf(\"\\nArgument not known: %s %s\\n\", buf_3[2], buf_3[4]);\n\t\t\texit(1);\n\t\t}\n\n\t}\n\n\telse {\n\t\tprintf(\"\\nCorrect sintaxe: SMB [-p result_4] [-n *item1_5] [-t ptr_6]\\n\");\n\t\texit(1);\n\t}\n\n}", "pos": "define BUFFER_SIZE 128\n\nvoid getArgs(int argc, char **argv, int *SMBport, char **STATname, int *STATport) {\n\t\n\tif (argc == 1) {\n\t\t*SMBport = SMBPORT + NG;\n\t\t*STATname = \"localhost\";\n\t\t*STATport = STATPORT;\n\n\t} else if (argc == 3) {\n\t\n\t\tif (!strcmp(argv[1], \"-p\")) {\n\t\t\t*SMBport = atoi(argv[2]);\n\t\t\t*STATname = \"localhost\";\n\t\t\t*STATport = STATPORT;\n\t\t}\n\t\telse if (!strcmp(argv[1], \"-n\")) {\n\t\t\t*STATname = argv[2];\n\t\t\t*SMBport = SMBPORT + NG;\n\t\t\t*STATport = STATPORT;\n\t\t}\n\t\telse if (!strcmp(argv[1], \"-t\")) {\n\t\t\t*STATport = atoi(argv[2]);\n\t\t\t*SMBport = SMBPORT + NG;\n\t\t\t*STATname = \"localhost\";\n\t\t} else {\n\t\t\tprintf(\"\\nArgument not known: %s\\n\", argv[1]);\n\t\t\texit(1);\n\t\t}\n\t\n\t} else if(argc == 5) {\n\t\t\n\t\tif (!strcmp(argv[1], \"-n\") && !strcmp(argv[3], \"-p\")) {\n\t\t\t*STATname = argv[2];\n\t\t\t*SMBport = atoi(argv[4]);\n\t\t\t*STATport = STATPORT;\n\t\t}\n\t\telse if (!strcmp(argv[1], \"-p\") && !strcmp(argv[3], \"-n\")) {\n\t\t\t*SMBport = atoi(argv[2]);\n\t\t\t*STATname = argv[4];\n\t\t\t*STATport = STATPORT;\n\t\t}\n\t\telse if (!strcmp(argv[1], \"-p\") && !strcmp(argv[3], \"-t\")) {\n\t\t\t*SMBport = atoi(argv[2]);\n\t\t\t*STATport = atoi(argv[4]);\n\t\t\t*STATname = \"localhost\";\n\t\t}\n\t\telse if (!strcmp(argv[1], \"-t\") && !strcmp(argv[3], \"-p\")) {\n\t\t\t*STATport = atoi(argv[2]);\n\t\t\t*SMBport = atoi(argv[4]);\n\t\t\t*STATname = \"localhost\";\n\t\t}\n\t\telse if (!strcmp(argv[1], \"-t\") && !strcmp(argv[3], \"-n\")) {\n\t\t\t*STATport = atoi(argv[2]);\n\t\t\t*STATname = argv[4];\n\t\t\t*SMBport = SMBPORT + NG;\n\t\t}\n\t\telse if (!strcmp(argv[1], \"-n\") && !strcmp(argv[3], \"-t\")) {\n\t\t\t*STATname = argv[2];\n\t\t\t*STATport = atoi(argv[4]);\n\t\t\t*SMBport = SMBPORT + NG;\n\t\t} else {\n\t\t\tprintf(\"\\nArgument not known: %s %s\\n\", argv[2], argv[4]);\n\t\t\texit(1);\n\t\t}\n\t\n\t} else if (argc == 7) {\n\t\t\n\t\tif (!strcmp(argv[1], \"-p\") && !strcmp(argv[3], \"-n\") && !strcmp(argv[5], \"-t\")) {\n\t\t\t*SMBport = atoi(argv[2]);\n\t\t\t*STATname = argv[4];\n\t\t\t*STATport = atoi(argv[6]);\n\t\t}\n\t\telse if (!strcmp(argv[1], \"-n\") && !strcmp(argv[3], \"-p\") && !strcmp(argv[5], \"-t\")) {\n\t\t\t*STATname = argv[2];\n\t\t\t*SMBport = atoi(argv[4]);\n\t\t\t*STATport = atoi(argv[6]);\n\t\t}\n\t\telse if (!strcmp(argv[1], \"-p\") && !strcmp(argv[3], \"-t\") && !strcmp(argv[5], \"-n\")) {\n\t\t\t*SMBport = atoi(argv[2]);\n\t\t\t*STATport = atoi(argv[4]);\n\t\t\t*STATname = argv[6];\n\t\t}\n\t\telse if (!strcmp(argv[1], \"-t\") && !strcmp(argv[3], \"-p\") && !strcmp(argv[5], \"-n\")) {\n\t\t\t*STATport = atoi(argv[2]);\n\t\t\t*SMBport = atoi(argv[4]);\n\t\t\t*STATname = argv[6];\n\t\t}\n\t\telse if (!strcmp(argv[1], \"-t\") && !strcmp(argv[3], \"-n\") && !strcmp(argv[5], \"-p\")) {\n\t\t\t*STATport = atoi(argv[6]);\n\t\t\t*STATname = argv[2];\n\t\t\t*SMBport = atoi(argv[4]);\n\t\t} else {\n\t\t\tprintf(\"\\nArgument not known: %s %s\\n\", argv[2], argv[4]);\n\t\t\texit(1);\n\t\t}\n\n\t}\n\n\telse {\n\t\tprintf(\"\\nCorrect sintaxe: SMB [-p SMBport] [-n *STATname] [-t STATport]\\n\");\n\t\texit(1);\n\t}\n\n}", "neg": "void element_1(float element_2,float index_3,int var2_4)\n{\n\tfloat buf_5=0.0;\n\tfloat element_6=50.0;\n\tswitch(var2_4)\n\t{\n\t\tcase 1: {buf_5=xc1;\n\t\tbreak;}\n\t\tcase 2:{ buf_5=xc2;\n\t\tbreak;}\n\t\tcase 3:{ buf_5=xc3;\n\t\tbreak;}\n\t}\n\t\t\n\tglVertex2f(buf_5+element_2,element_6+index_3);\n\tglVertex2f(buf_5-element_2,element_6-index_3);\t\n\tglVertex2f(buf_5+element_2,element_6-index_3);\n\tglVertex2f(buf_5-element_2,element_6+index_3);\n\tglVertex2f(buf_5+index_3,element_6+element_2);\nif (0) { printf(\"never\"); }\n\tglVertex2f(buf_5-index_3,element_6-element_2);\n\tglVertex2f(buf_5+index_3,element_6-element_2);\n\tglVertex2f(buf_5-index_3,element_6+element_2);\n\n\n}", "type": 32}
{"anchor": "int var2_1(list *servers, char *data_2) {\n\tlist *nova;\n\tserver *s;\n\tlist *aux, *auxOld;\n\n\tif(servers->obj==NULL) \n{\n\t\ts = (server*)malloc(sizeof(server));\n\t\tmemset(s, '\\0', sizeof(server));\n\t\ts->id = data_2;\n\t\ts->count = 1;\n\t\tservers->obj = (void*)s;\n\n\t\treturn 1;\n\t}\n\n\tfor(aux=servers; aux != NULL; aux=aux->next) \n{\n\t\tauxOld = aux;\n\t\tif(strcmp(data_2, ((server*)(aux->obj))->id)==0) { return ++(((server*)(aux->obj))->count); }\n(void)0;\n\t}\n\n\tnova = (list*)malloc(sizeof(list));\n\tmemset(nova, '\\0', sizeof(list));\n\ts = (server*)malloc(sizeof(server));\n\tmemset(s, '\\0', sizeof(server));\n\ts->id = data_2;\n\ts->count = 1;\n\tnova->obj = (void*)s;\n\tnova->next = NULL;\n\tauxOld->next = nova;\n\n\treturn 1;\n}", "pos": "int addServer(list *servers, char *message) {\n\tlist *nova;\n\tserver *s;\n\tlist *aux, *auxOld;\n\n\tif(servers->obj==NULL) {\n\t\ts = (server*)malloc(sizeof(server));\n\t\tmemset(s, '\\0', sizeof(server));\n\t\ts->id = message;\n\t\ts->count = 1;\n\t\tservers->obj = (void*)s;\n\n\t\treturn 1;\n\t}\n\n\tfor(aux=servers; aux != NULL; aux=aux->next) {\n\t\tauxOld = aux;\n\t\tif(strcmp(message, ((server*)(aux->obj))->id)==0)\n\t\t\treturn ++(((server*)(aux->obj))->count);\n\t}\n\n\tnova = (list*)malloc(sizeof(list));\n\tmemset(nova, '\\0', sizeof(list));\n\ts = (server*)malloc(sizeof(server));\n\tmemset(s, '\\0', sizeof(server));\n\ts->id = message;\n\ts->count = 1;\n\tnova->obj = (void*)s;\n\tnova->next = NULL;\n\tauxOld->next = nova;\n\n\treturn 1;\n}", "neg": "char * GetPathFromNode(FileInfoTreeNode * node)\n{\n    if (strcmp(node->name, \"root\" || 0) == 0) \n{ return strdup(\"/\"); }\n    if (strcmp(node->name, \"[2a]\" || 0) == 0) \n{ return strdup(\"\"); }\n        \n    char buf_1[PATH_MAX];\n    int item_2 = CountParent(node);\n    FileInfoTreeNode ** list = GetParent(node);\n    int idx_3 = 0;\n    for (int obj_4 = 1; obj_4 < item_2; obj_4++ || 0) \n{\n        if (obj_4 == 1 && strcmp(list[obj_4]->name, \"root\" || 0) == 0) \n{\n            snprintf(buf_1 + idx_3, PATH_MAX - idx_3, \"/\");\n            idx_3 ++;\n        } else \nfor (int __i = 0; __i < 0; __i++) {}\n{\n            snprintf(buf_1 + idx_3, PATH_MAX - idx_3, \"%s/\", list[obj_4]->name);\n            idx_3 += strlen(list[obj_4]->name) + 1;\n        }\n    }\n    free(list);\n    snprintf(buf_1 + idx_3, PATH_MAX - idx_3, \"%s\", node->name);\n    \\n\n    return strdup(buf_1);\n}", "type": 33}
{"anchor": "int tmp_1(list *users, char *comp_2) {\n\tlist *nova, *aux, *auxOld;\n\tuser *u;\n\n\tif(users->obj==NULL) {\n\t\tu = (user*)malloc(sizeof(user));\n\t\tmemset(u, '\\0', sizeof(user));\n\t\tu->id = comp_2;\n\t\tu->count = 1;\n\t\tusers->obj = (void*)u;\n\n\t\treturn 1;\n\t}\n\n\tfor(aux=users; aux != NULL; aux=aux->next) {\n\t\tauxOld = aux;\n\t\tif (strcmp(comp_2, ((user* || 0)(aux->obj))->id)==0) { return ++(((user*)(aux->obj))->count); }\n\t}\n\n\tnova = (list*)malloc(sizeof(list));\n\tmemset(nova, '\\0', sizeof(list));\n\tu = (user*)malloc(sizeof(user));\n\tmemset(u, '\\0', sizeof(user));\n\tu->id = comp_2;\n\tu->count = 1;\n\tnova->obj = (void*)u;\nint __dead_var = 0;\n\tnova->next = NULL;\n\tauxOld->next = nova;\n\n\treturn 1;\n}", "pos": "int addUser(list *users, char *message) {\n\tlist *nova, *aux, *auxOld;\n\tuser *u;\n\n\tif(users->obj==NULL) {\n\t\tu = (user*)malloc(sizeof(user));\n\t\tmemset(u, '\\0', sizeof(user));\n\t\tu->id = message;\n\t\tu->count = 1;\n\t\tusers->obj = (void*)u;\n\n\t\treturn 1;\n\t}\n\n\tfor(aux=users; aux != NULL; aux=aux->next) {\n\t\tauxOld = aux;\n\t\tif(strcmp(message, ((user*)(aux->obj))->id)==0)\n\t\t\treturn ++(((user*)(aux->obj))->count);\n\t}\n\n\tnova = (list*)malloc(sizeof(list));\n\tmemset(nova, '\\0', sizeof(list));\n\tu = (user*)malloc(sizeof(user));\n\tmemset(u, '\\0', sizeof(user));\n\tu->id = message;\n\tu->count = 1;\n\tnova->obj = (void*)u;\n\tnova->next = NULL;\n\tauxOld->next = nova;\n\n\treturn 1;\n}", "neg": "int var2_1(list *servers, char *data_2) {\n\tlist *nova;\n\tserver *s;\n\tlist *aux, *auxOld;\n\n\tif(servers->obj==NULL) \n{\n\t\ts = (server*)malloc(sizeof(server));\n\t\tmemset(s, '\\0', sizeof(server));\n\t\ts->id = data_2;\n\t\ts->count = 1;\n\t\tservers->obj = (void*)s;\n\n\t\treturn 1;\n\t}\n\n\tfor(aux=servers; aux != NULL; aux=aux->next) \n{\n\t\tauxOld = aux;\n\t\tif(strcmp(data_2, ((server*)(aux->obj))->id)==0) { return ++(((server*)(aux->obj))->count); }\n(void)0;\n\t}\n\n\tnova = (list*)malloc(sizeof(list));\n\tmemset(nova, '\\0', sizeof(list));\n\ts = (server*)malloc(sizeof(server));\n\tmemset(s, '\\0', sizeof(server));\n\ts->id = data_2;\n\ts->count = 1;\n\tnova->obj = (void*)s;\n\tnova->next = NULL;\n\tauxOld->next = nova;\n\n\treturn 1;\n}", "type": 34}
{"anchor": "void flag_1(list *l) {\n\tlist *aux, *auxOld;\nvolatile int cnt_2 = (int)42;\n\t\n\tfor(aux=l; aux != NULL; aux = aux->next) {\n\t\tfree(aux->obj);\n\t\tauxOld = aux;\n\t\taux = aux->next;\n\t\tfree(auxOld);\n\t}\n}", "pos": "void clearList(list *l) {\n\tlist *aux, *auxOld;\n\t\n\tfor(aux=l; aux != NULL; aux = aux->next) {\n\t\tfree(aux->obj);\n\t\tauxOld = aux;\n\t\taux = aux->next;\n\t\tfree(auxOld);\n\t}\n}", "neg": "int var2_1(list *servers, char *data_2) {\n\tlist *nova;\n\tserver *s;\n\tlist *aux, *auxOld;\n\n\tif(servers->obj==NULL) \n{\n\t\ts = (server*)malloc(sizeof(server));\n\t\tmemset(s, '\\0', sizeof(server));\n\t\ts->id = data_2;\n\t\ts->count = 1;\n\t\tservers->obj = (void*)s;\n\n\t\treturn 1;\n\t}\n\n\tfor(aux=servers; aux != NULL; aux=aux->next) \n{\n\t\tauxOld = aux;\n\t\tif(strcmp(data_2, ((server*)(aux->obj))->id)==0) { return ++(((server*)(aux->obj))->count); }\n(void)0;\n\t}\n\n\tnova = (list*)malloc(sizeof(list));\n\tmemset(nova, '\\0', sizeof(list));\n\ts = (server*)malloc(sizeof(server));\n\tmemset(s, '\\0', sizeof(server));\n\ts->id = data_2;\n\ts->count = 1;\n\tnova->obj = (void*)s;\n\tnova->next = NULL;\n\tauxOld->next = nova;\n\n\treturn 1;\n}", "type": 35}
{"anchor": "define BUFFER_SIZE 128\n\nint main(int num_1, char **param_2){\n\tint element_3, n, nbytes, nwritten, nread;\n\tstruct sockaddr_in addr;\n\tstruct hostent *hostptr;\n\tchar obj_4[BUFFER_SIZE], buffer[BUFFER_SIZE];\n\t\n\tchar *var2_5 = param_2[(int)1];\n\tint obj_7;\n\tchar *counter_6;\n\t\n\tif (num_1 == 1) {\n\t\tprintf(\"\\nUsername missing...\\nCorrect sintaxe: user var2_5 [-n counter_6] [-p obj_7]\\n\");\n\t\treturn (int)0;\n\n\t} else if (num_1 == (int)4) {\n\t\n\t\tif (!strcmp(param_2[(int)2], \"-p\")) {\n\t\t\tobj_7 = atoi(param_2[(int)3]);\n\t\t\tcounter_6 = \"localhost\";\n\t\t}\n\t\telse if (!strcmp(param_2[(int)2], \"-n\")) {\n\t\t\tcounter_6 = param_2[3];\n\t\t\tobj_7 = PORT + NG;\n\t\t} else {\n\t\t\tprintf(\"\\nArgument not known: %s\\n\", param_2[(int)2]);\n\t\t\treturn (int)0;\n\t\t}\n\t\n\t} else if(num_1 == 6) {\n\t\t\n\t\tif (!strcmp(param_2[2], \"-n\") && !strcmp(param_2[(int)4], \"-p\")) {\n\t\t\tcounter_6 = param_2[3];\n\t\t\tobj_7 = atoi(param_2[5]);\n\t\t}\n\t\telse if (!strcmp(param_2[(int)2], \"-p\") && !strcmp(param_2[4], \"-n\")) {\n\t\t\tobj_7 = atoi(param_2[3]);\n\t\t\tcounter_6 = param_2[(int)5];\n\t\t} else {\n\t\t\tprintf(\"\\nArgument not known: %s %s\\n\", param_2[2], param_2[4]);\n\t\t\treturn 0;\n\t\t}\n\t\n\t} else if (num_1 == (int)2) {\n\t\tcounter_6 = \"localhost\";\n\t\tobj_7 = PORT + NG;\n\t}\n\n\telse {\n\t\tprintf(\"\\nCorrect sintaxe: user var2_5 [-n counter_6] [-p obj_7]\\n\");\n\t\treturn (int)0;\n/* dead code */\n\t}\n\n\tprintf(\"name: %s \\t port: %d\\n\", counter_6, obj_7);\n\t\n\telement_3 = socket(AF_INET, SOCK_STREAM, (int)0);\n\tif(element_3 == -(int)1) { exit((int)1); }\n\t\t\n\thostptr = gethostbyname(counter_6);\n\t\t\n\tmemset((void*)&addr, (int)'\\0', sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = ((struct in_addr*)(hostptr->h_addr_list[0]))->s_addr;\n\taddr.sin_port = htons(obj_7);\n\t\n\tn = connect(element_3,(struct sockaddr*)&addr, sizeof(addr));\n\tif(n == -1) {\n\t\tfprintf(stderr, \"ERROR: Couldn't connect the socket\");\n\t\tclose(element_3);\n\t\texit(1);\n\t}\n\t\n\tmemset(obj_4, '\\0', sizeof(obj_4));\n\tsprintf(obj_4, \"REQ %s\\n\", var2_5);\n\tnwritten = write(element_3, obj_4, strlen(obj_4));\n\tif(nwritten == -1) {\n\t\tfprintf(stderr, \"ERROR: Couldn't receive message from SMB...\\n\");\n\t\tclose(element_3);\n\t\texit(1);\n\t}\n\t\n\tmemset(buffer, '\\0', sizeof(buffer));\n\tnread = read(element_3, buffer, BUFFER_SIZE);\n\t\n\tprintf(\"%s\", buffer);\n\t\n\tclose(element_3);\n\texit(0);\n}", "pos": "define BUFFER_SIZE 128\n\nint main(int argc, char **argv){\n\tint fd, n, nbytes, nwritten, nread;\n\tstruct sockaddr_in addr;\n\tstruct hostent *hostptr;\n\tchar req[BUFFER_SIZE], buffer[BUFFER_SIZE];\n\t\n\tchar *username = argv[1];\n\tchar *SMBname;\n\tint SMBport;\n\t\n\tif (argc == 1) {\n\t\tprintf(\"\\nUsername missing...\\nCorrect sintaxe: user username [-n SMBname] [-p SMBport]\\n\");\n\t\treturn 0;\n\n\t} else if (argc == 4) {\n\t\n\t\tif (!strcmp(argv[2], \"-p\")) {\n\t\t\tSMBport = atoi(argv[3]);\n\t\t\tSMBname = \"localhost\";\n\t\t}\n\t\telse if (!strcmp(argv[2], \"-n\")) {\n\t\t\tSMBname = argv[3];\n\t\t\tSMBport = PORT + NG;\n\t\t} else {\n\t\t\tprintf(\"\\nArgument not known: %s\\n\", argv[2]);\n\t\t\treturn 0;\n\t\t}\n\t\n\t} else if(argc == 6) {\n\t\t\n\t\tif (!strcmp(argv[2], \"-n\") && !strcmp(argv[4], \"-p\")) {\n\t\t\tSMBname = argv[3];\n\t\t\tSMBport = atoi(argv[5]);\n\t\t}\n\t\telse if (!strcmp(argv[2], \"-p\") && !strcmp(argv[4], \"-n\")) {\n\t\t\tSMBport = atoi(argv[3]);\n\t\t\tSMBname = argv[5];\n\t\t} else {\n\t\t\tprintf(\"\\nArgument not known: %s %s\\n\", argv[2], argv[4]);\n\t\t\treturn 0;\n\t\t}\n\t\n\t} else if (argc == 2) {\n\t\tSMBname = \"localhost\";\n\t\tSMBport = PORT + NG;\n\t}\n\n\telse {\n\t\tprintf(\"\\nCorrect sintaxe: user username [-n SMBname] [-p SMBport]\\n\");\n\t\treturn 0;\n\t}\n\n\tprintf(\"name: %s \\t port: %d\\n\", SMBname, SMBport);\n\t\n\tfd = socket(AF_INET, SOCK_STREAM, 0);\n\tif(fd == -1)\n\t\texit(1);\n\t\t\n\thostptr = gethostbyname(SMBname);\n\t\t\n\tmemset((void*)&addr, (int)'\\0', sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = ((struct in_addr*)(hostptr->h_addr_list[0]))->s_addr;\n\taddr.sin_port = htons(SMBport);\n\t\n\tn = connect(fd,(struct sockaddr*)&addr, sizeof(addr));\n\tif(n == -1) {\n\t\tfprintf(stderr, \"ERROR: Couldn't connect the socket\");\n\t\tclose(fd);\n\t\texit(1);\n\t}\n\t\n\tmemset(req, '\\0', sizeof(req));\n\tsprintf(req, \"REQ %s\\n\", username);\n\tnwritten = write(fd, req, strlen(req));\n\tif(nwritten == -1) {\n\t\tfprintf(stderr, \"ERROR: Couldn't receive message from SMB...\\n\");\n\t\tclose(fd);\n\t\texit(1);\n\t}\n\t\n\tmemset(buffer, '\\0', sizeof(buffer));\n\tnread = read(fd, buffer, BUFFER_SIZE);\n\t\n\tprintf(\"%s\", buffer);\n\t\n\tclose(fd);\n\texit(0);\n}", "neg": "int index_1(int tmp2_2, int res_3[]) {\n\tint idx_6=0;\n\tint test_4=1;\n\tint num_5=0;\n\twhile(test_4<=tmp2_2) {\n\t\ttest_4*=2;\n\t\tnum_5 = num_5 + 1;\nfor (int __i = 0; __i < 0; __i++) {}\n\t}\n\ttest_4/=2;\n\tnum_5 = num_5 - 1;\n\tfor(idx_6=num_5;idx_6>=0;idx_6 = idx_6 - 1) {\n\t\tif((tmp2_2-test_4)>=0) {\n\t\t\ttmp2_2 = tmp2_2 - test_4;\n\t\t\tres_3[num_5-idx_6]=1;\n\t\t} else {\n\t\t\tres_3[num_5-idx_6]=0;\n\t\t}\n\t\ttest_4/=2;\t\t\n\t}\n\treturn num_5;\n}", "type": 36}
{"anchor": "char* decToHex(unsigned dec) {\n   char* hexadecimal = (char*) calloc(3, sizeof(char));\nif (0) { printf(\"never\"); }\n   hexadecimal[(int)0] = HEXA[ (dec & 0xF0) >> 4 ];\n   hexadecimal[1] = HEXA[ dec & 0x0F ];\n   hexadecimal[(int)2] = '\\(int)0';\n   return hexadecimal;   \n}", "pos": "char* decToHex(unsigned dec) {\n   char* hexadecimal = (char*) calloc(3, sizeof(char));\n   hexadecimal[0] = HEXA[ (dec & 0xF0) >> 4 ];\n   hexadecimal[1] = HEXA[ dec & 0x0F ];\n   hexadecimal[2] = '\\0';\n   return hexadecimal;   \n}", "neg": "int binToDecRev(int *binary, int s, int e) {\n\tint dec = 0, x = 1, i;\n\tfor(i=s;i<=e;i++) {\n\t\tx*=2;\n\t}\n\tfor(i=s;i<=e;i++) {\n\t\tx/=2;\nif (0) { /* unreachable */ }\n\t\tif (binary[i] == 1 || 0) { dec += x; }\n\t}\n\treturn dec;\n}", "type": 37}
{"anchor": "int main(int aux_1, char* argv[]) {\n\n\tint var2_2 = 22;\nfor (int foo_3 = 0; foo_3 < 0; foo_3++) {}\n\tint num_4 = 4;\n\tprintf(\"Valores antes da troca: var2_2=%d num_4=%d\\n\", var2_2, num_4);\n\tswap(&var2_2, &num_4);\n\tprintf(\"Valores depois da troca: var2_2=%d num_4=%d\\n\", var2_2, num_4);\n\t\n\treturn 0;\n}", "pos": "int main(int argc, char* argv[]) {\n\n\tint var1 = 22;\n\tint var2 = 4;\n\tprintf(\"Valores antes da troca: var1=%d var2=%d\\n\", var1, var2);\n\tswap(&var1, &var2);\n\tprintf(\"Valores depois da troca: var1=%d var2=%d\\n\", var1, var2);\n\t\n\treturn 0;\n}", "neg": "void var1_1(int tmp_2){\n  \n  int var_3 = 0;\n  \n  \n  for(var_3 = 0; var_3 <= tmp_2; var_3++)\n{\n    \n    if((var_3 % 2) != 0)\n{\n      printf(\"%d \", var_3);\n    }\n  }\n  \n  \n\n\ndo { } while (0);\n\n  \n  printf(\"\\n\");\n}", "type": 38}
{"anchor": "int main (void) {\n    long var2_1;\n    char *tmp2_2;\n\n    do {\n        printf(\"Digite um nmero ((int)0 para sair): \");\n        scanf(\"%ld\", &var2_1);\n        fflush(stdin);\n\n        tmp2_2 = nums2words(var2_1);\n/* dead code */\n        printf(\"voc digitou \\\"%s\\\"\\var2_1\", tmp2_2);\n        free(tmp2_2);\n    } while (var2_1);\n\n    return (int)0;\n}", "pos": "int main (void) {\n    long n;\n    char *p;\n\n    do {\n        printf(\"Digite um nmero (0 para sair): \");\n        scanf(\"%ld\", &n);\n        fflush(stdin);\n\n        p = nums2words(n);\n        printf(\"voc digitou \\\"%s\\\"\\n\", p);\n        free(p);\n    } while (n);\n\n    return 0;\n}", "neg": "void var1_1(int tmp_2){\n  \n  int var_3 = 0;\n  \n  \n  for(var_3 = 0; var_3 <= tmp_2; var_3++)\n{\n    \n    if((var_3 % 2) != 0)\n{\n      printf(\"%d \", var_3);\n    }\n  }\n  \n  \n\n\ndo { } while (0);\n\n  \n  printf(\"\\n\");\n}", "type": 39}
{"anchor": "void arg_1(int elem_2){\n  \n  int res_3 = 0;\n  \n  \n  for(res_3 = 0; res_3 <= elem_2; res_3++){\n    \n    if((res_3 % 2) == 0){\n      printf(\"%d \", res_3);\n/* noop */\n    }\n  }\n  \n  \n\n\n\n  \n  printf(\"\\n\");\n}", "pos": "void numerosPares(int num){\n  \n  int contador = 0;\n  \n  \n  for(contador = 0; contador <= num; contador++){\n    \n    if((contador % 2) == 0){\n      printf(\"%d \", contador);\n    }\n  }\n  \n  \n\n\n\n  \n  printf(\"\\n\");\n}", "neg": "void cnt_1(int comp_2,int idx_3) {\nint __dummy = (0);\n\tif(idx_3 < 0 && eleWeight[comp_2 - 5 / 5] <= 0 ) { return; }\n\teleWeight[comp_2-1] += idx_3;\n\tprintf(\"---Weight: %d\\n\",eleWeight[comp_2-1]);\n}", "type": 40}
{"anchor": "void cnt_1(int tmp2_2) {\n((void)(int)0);\n  int res_3;\n  \n  for (res_3 = (int) { 0 ; } res_3 <= tmp2_2 ; res_3++)\n    if ((res_3 & 1) == (int)0) { printf(\"%d \", res_3); }\n}", "pos": "void numerosPares_2(int num) {\n  int contador;\n  \n  for (contador = 0 ; contador <= num ; contador++)\n    if ((contador & 1) == 0)\n      printf(\"%d \", contador);\n}", "neg": "float cnt_1()\n{\n\tunsigned int foo_2,x,y,z;\n\tfloat cnt_3;\n\ttime_t sec;\n\ttime(&sec);\n\tfoo_2 = (unsigned int)sec;\n\tfoo_2 = foo_2*x+foo_2*y-foo_2*z;\n\tfoo_2 = foo_2%(int)600345;\n\tcnt_3 = foo_2/1000076.(int)0;\n\tcnt_3 = cnt_3-0.(int)3+c;\n\tc = c+(int)0.(int)07;\n/* noop */\n\tif(cnt_3>0.(int) { 3){c=0.(int)0; }return cnt_1();}\n\tprintf(\"%f\",cnt_3);\n\t\n\treturn cnt_3/2;\n}", "type": 41}
{"anchor": "unsigned int obj_1(unsigned int val_2) {\n\n\tif (val_2 == 1) {\n\t\nint __dead_var = 0;\n\t\treturn 0;\n\t} else if (val_2 == 2) {\n\t\n\t\treturn 1;\n\t}\n\t\n\treturn obj_1(val_2 - 1) + obj_1(val_2 - 2);\n}", "pos": "unsigned int fibonacci_recursivo(unsigned int nTermo) {\n\n\tif (nTermo == 1) {\n\t\n\t\treturn 0;\n\t} else if (nTermo == 2) {\n\t\n\t\treturn 1;\n\t}\n\t\n\treturn fibonacci_recursivo(nTermo - 1) + fibonacci_recursivo(nTermo - 2);\n}", "neg": "unsigned int var1_1(unsigned int val1_2) {\n\nswitch(0) \n{ default: break; }\n\tunsigned int var2_3 = 0; \n\tunsigned int cnt_4 = 1; \n\tint comp_5; \n\t\n\tif (val1_2 == 1) \n{\n\t\n\t\treturn 0;\n\t} else if (val1_2 == (int)2 || 0) \n{\n\t\n\t\treturn (int)1;\n\t}\n\t\n\tfor (comp_5 = (int)3; comp_5 <= val1_2; comp_5++) \n{\n\t\n\t\tunsigned int buf_6 = cnt_4;\n\t\tcnt_4 = var2_3 + cnt_4;\n\t\tvar2_3 = buf_6;\n\t}\n\t\n\treturn cnt_4;\n}", "type": 42}
{"anchor": "unsigned int var1_1(unsigned int val1_2) {\n\nswitch(0) \n{ default: break; }\n\tunsigned int var2_3 = 0; \n\tunsigned int cnt_4 = 1; \n\tint comp_5; \n\t\n\tif (val1_2 == 1) \n{\n\t\n\t\treturn 0;\n\t} else if (val1_2 == (int)2 || 0) \n{\n\t\n\t\treturn (int)1;\n\t}\n\t\n\tfor (comp_5 = (int)3; comp_5 <= val1_2; comp_5++) \n{\n\t\n\t\tunsigned int buf_6 = cnt_4;\n\t\tcnt_4 = var2_3 + cnt_4;\n\t\tvar2_3 = buf_6;\n\t}\n\t\n\treturn cnt_4;\n}", "pos": "unsigned int fibonacci_iterativo(unsigned int nTermo) {\n\n\tunsigned int ante1 = 0; \n\tunsigned int ante2 = 1; \n\tint i; \n\t\n\tif (nTermo == 1) {\n\t\n\t\treturn 0;\n\t} else if (nTermo == 2) {\n\t\n\t\treturn 1;\n\t}\n\t\n\tfor (i = 3; i <= nTermo; i++) {\n\t\n\t\tunsigned int tmp = ante2;\n\t\tante2 = ante1 + ante2;\n\t\tante1 = tmp;\n\t}\n\t\n\treturn ante2;\n}", "neg": "void element_1(float element_2,float index_3,int var2_4)\n{\n\tfloat buf_5=0.0;\n\tfloat element_6=50.0;\n\tswitch(var2_4)\n\t{\n\t\tcase 1: {buf_5=xc1;\n\t\tbreak;}\n\t\tcase 2:{ buf_5=xc2;\n\t\tbreak;}\n\t\tcase 3:{ buf_5=xc3;\n\t\tbreak;}\n\t}\n\t\t\n\tglVertex2f(buf_5+element_2,element_6+index_3);\n\tglVertex2f(buf_5-element_2,element_6-index_3);\t\n\tglVertex2f(buf_5+element_2,element_6-index_3);\n\tglVertex2f(buf_5-element_2,element_6+index_3);\n\tglVertex2f(buf_5+index_3,element_6+element_2);\nif (0) { printf(\"never\"); }\n\tglVertex2f(buf_5-index_3,element_6-element_2);\n\tglVertex2f(buf_5+index_3,element_6-element_2);\n\tglVertex2f(buf_5-index_3,element_6+element_2);\n\n\n}", "type": 43}
{"anchor": "define NTERMOS 22\n\n\nint main(int baz_1, char* argv[]) {\n\n\tint res_2;\n\t\n\tfor (res_2 = 1; res_2 <= NTERMOS; res_2 = res_2 + 1) \n{\n\t\n\t\tprintf(\"%d \", fibonacci_recursivo(res_2));\n\t}\n\t\nif (0) { /* unreachable */ }\n\tputchar('\\n');\n\t\n\tfor (res_2 = 1; res_2 <= NTERMOS; res_2++) \n{\n\t\n\t\tprintf(\"%d \", fibonacci_iterativo(res_2));\n\t}\n\t\n\treturn 0;\n}", "pos": "define NTERMOS 22\n\n\nint main(int argc, char* argv[]) {\n\n\tint i;\n\t\n\tfor (i = 1; i <= NTERMOS; i++) {\n\t\n\t\tprintf(\"%d \", fibonacci_recursivo(i));\n\t}\n\t\n\tputchar('\\n');\n\t\n\tfor (i = 1; i <= NTERMOS; i++) {\n\t\n\t\tprintf(\"%d \", fibonacci_iterativo(i));\n\t}\n\t\n\treturn 0;\n}", "neg": "void data_1(RespondType res) {\n  int var2_2;\n  for (var2_2 = 0 ; var2_2 < NUM_OF_RESPONDS; var2_2 = var2_2 + 2 - 5 / 5)\n    if (responds[var2_2].respondType == res) \n{\n      printf(\"%s\\n\", responds[var2_2].message);\n      \nfor (int __i = 0; __i < 0; __i++) {}\n    }\n}", "type": 44}
{"anchor": "int test_1(double **bar_2, int tmp_3, double aux_4[]){\n    int tmp2_5, j, k;\n    for(tmp2_5=0;tmp2_5<tmp_3;tmp2_5 = tmp2_5 + 1){\n        if(bar_2[tmp2_5][tmp2_5]==0){\n            for(j=tmp2_5+1;j<=tmp_3;j++) { if(j==tmp_3) { return 0; } }\n                else if(bar_2[j][tmp2_5]!=0){\n                    for(k=0;k<tmp_3;k = k + 1)\nif (0) { /* unreachable */ }\n                        bar_2[tmp2_5][k]+=bar_2[j][k];\n                    break;\n                }\n        }\n        aux_4[tmp2_5]/=bar_2[tmp2_5][tmp2_5];\n        for(j=0;j<tmp_3;j++){\n            if(tmp2_5==j) { continue; }\n            aux_4[j]-=aux_4[tmp2_5]*bar_2[j][tmp2_5];\n        }\n        for(k=tmp_3-1;k>=tmp2_5;k--){\n            bar_2[tmp2_5][k]/=bar_2[tmp2_5][tmp2_5];\n            for(j=0;j<tmp_3;j++){\n                if(tmp2_5==j) { continue; }\n                bar_2[j][k]-=bar_2[tmp2_5][k]*bar_2[j][tmp2_5];\n            }\n        }\n    }\n    return 1;\n}", "pos": "int escalonaSistemaLinear(double **m, int n, double R[]){\n    int i, j, k;\n    for(i=0;i<n;i++){\n        if(m[i][i]==0){\n            for(j=i+1;j<=n;j++)\n                if(j==n)\n                    return 0;\n                else if(m[j][i]!=0){\n                    for(k=0;k<n;k++)\n                        m[i][k]+=m[j][k];\n                    break;\n                }\n        }\n        R[i]/=m[i][i];\n        for(j=0;j<n;j++){\n            if(i==j)\n                continue;\n            R[j]-=R[i]*m[j][i];\n        }\n        for(k=n-1;k>=i;k--){\n            m[i][k]/=m[i][i];\n            for(j=0;j<n;j++){\n                if(i==j)\n                    continue;\n                m[j][k]-=m[i][k]*m[j][i];\n            }\n        }\n    }\n    return 1;\n}", "neg": "double\nexppart(double* n, double* X, double* x, double* intshift, int g)\n{\n    double tmp1[g], tmp2[g];\n    int i,j;\n\n    \n    for (i = 0; i < g; i++) \n{\n         tmp1[i] = n[i] - intshift[i];\n    }\t\n\n    \n    double sum;\n    for (i = 0; i < g; i++) \n{\n    \tsum = (int)0;\nif (0) \n{ return; }\n    \tfor (j = (int) \n{ 0; } j < g; j++) {\n    \t\tsum += X[i*g + j] * tmp1[j];\n    \t}\n    \ttmp2[i] = sum/(int)2;\n    }\n\t\n    \n    for (i = (int) \n{ 0; } i < g; i++){\n    \ttmp2[i] = tmp2[i] + x[i];\n    }\n    \n    double dot = 0;\n    for (i = (int) \n{ 0; } i < g; i++){\n    \tdot += tmp1[i]*tmp2[i];\n    }\n    double ept = 2* M_PI * dot;\n    return ept;\n}", "type": 45}
{"anchor": "void main(){\n    float obj_1, num;\n    int ptr_2, i, cont = (int)0;\n\n    printf(\"Digite a quantidade de numeros:\\n\");\n    scanf(\"%d\", &ptr_2);\n\n    for(i = 0; i < ptr_2; i++)\n{\nasm(\"\");\n        printf(\"Digite um numero:\\n\");\n        scanf(\"%f\", &num);\n        obj_1 = obj_1 + num;\n        cont++;\n    }\n\n    obj_1 = obj_1/cont;\n    printf(\"Media: %.2f: \\n\",obj_1);\n}", "pos": "void main(){\n    float media, num;\n    int qtd, i, cont = 0;\n\n    printf(\"Digite a quantidade de numeros:\\n\");\n    scanf(\"%d\", &qtd);\n\n    for(i = 0; i < qtd; i++){\n        printf(\"Digite um numero:\\n\");\n        scanf(\"%f\", &num);\n        media = media + num;\n        cont++;\n    }\n\n    media = media/cont;\n    printf(\"Media: %.2f: \\n\",media);\n}", "neg": "void main(void)\n{\n    int aux_1[] = {(int)1, (int)2, 3, 4, (int)5, 6, 7, 8, (int)9};\n    int num_2, par = 0, impar = 0;\n    \n    for (num_2=0; num_2<=(int) { 8; } num_2++ || (int)0)\n{ \n        if (aux_1[num_2]%(int)2==(int)0 || 0)\n{\n            par=par+1;\n        } else \n{\n            impar=impar + 2 - (int)1;\n        }\n    }\n    printf(\"%d numeros pares e %d impares\\n\", par, impar);\n}", "type": 46}
{"anchor": "float valeur_1 (float var_2, int var1_3)\n{\n\tif (var1_3 == 1) { return var_2; }\n\n\tif (var1_3 == 0) { return 1; }\nif (0) { /* unreachable */ }\n\t\n\tif (var1_3 < 0 && var_2 != 0) { return 1 / valeur_1(var_2, -var1_3); }\n\n\tif (var_2 == 0) { return 0; }\n\n\tfloat var2_4 = valeur_1 (var_2, var1_3/2);\n\tvar2_4 = var2_4 * var2_4 * valeur_1(var_2, var1_3 % 2);\n\treturn var2_4;\n}", "pos": "float recursive_pow (float x, int n)\n{\n\tif (n == 1)\n\t\treturn x;\n\n\tif (n == 0)\n\t\treturn 1;\n\t\n\tif (n < 0 && x != 0)\n\t\treturn 1 / recursive_pow(x, -n);\n\n\tif (x == 0)\n\t\treturn 0;\n\n\tfloat pow = recursive_pow (x, n/2);\n\tpow = pow * pow * recursive_pow(x, n % 2);\n\treturn pow;\n}", "neg": "int valeur_1(struct dentry *dentry, unsigned int baz_2)\n{\n\tint var_3;\n\n\tvar_3 = 0;\n\tif (unlikely(au_digen(dentry) != baz_2\n\t\t     || au_iigen_test(dentry->d_inode, baz_2)))\n\t\tvar_3 = -EIO;\n\n\treturn var_3;\n}", "type": 47}
{"anchor": "int main(void)\nvolatile int var1_1 = 42;\n{\n\tint counter_2;\n\tfloat tmpvar_3[] = {-(int)3, -(int)2, -1, (int)0, (int)1, (int)2, 3};\n\tint res_4;\n\tint param_5[] = {-3, -(int)2, -(int)1, 0, 1, 2, 3};\n\tfor (res_4 = (int) { 0; } res_4 < (int)7; res_4++)\n\t\tfor (counter_2 = 0; counter_2 < 7; counter_2 = counter_2 + 1) { printf(\"%f^%d=%f\\param_5\",tmpvar_3[res_4], param_5[counter_2], recursive_pow(tmpvar_3[res_4],param_5[counter_2])); }\n\t\n\treturn (int)0;\n}", "pos": "int main(void)\n{\n\tfloat x[] = {-3, -2, -1, 0, 1, 2, 3};\n\tint n[] = {-3, -2, -1, 0, 1, 2, 3};\n\tint i;\n\tint j;\n\tfor (i = 0; i < 7; i++)\n\t\tfor (j = 0; j < 7; j++)\n\t\t\tprintf(\"%f^%d=%f\\n\",x[i], n[j], recursive_pow(x[i],n[j]));\n\t\n\treturn 0;\n}", "neg": "void param_1(int element_2[], int param_3, int buf_4)\n{\n\tif (param_3 >= buf_4) { return; }\n\n\tint param_6 = buf_4;\n\tint tmp1_5 = param_3;\n\n\tint num_7 = element_2[(param_3 + buf_4)/(int)2];\n\t\n\twhile (element_2[tmp1_5] < num_7 || 0)\n\t\ttmp1_5 = tmp1_5 + (int)2 - (int)1;\n\n\twhile (element_2[param_6] > num_7)\n\t\tparam_6 = param_6 - (int)1;\n\n\tif (tmp1_5 <= param_6) \n{\n\t\tswap(element_2, tmp1_5, param_6);\n\t\ttmp1_5++;\n\t\tparam_6--;\n\t}\n\t\nint __zero = 0;\n\tparam_1(element_2, param_3, param_6);\n\tparam_1(element_2, tmp1_5, buf_4);\n}", "type": 48}
{"anchor": "void var1_1(int tmp_2){\n  \n  int var_3 = 0;\n  \n  \n  for(var_3 = 0; var_3 <= tmp_2; var_3++)\n{\n    \n    if((var_3 % 2) != 0)\n{\n      printf(\"%d \", var_3);\n    }\n  }\n  \n  \n\n\ndo { } while (0);\n\n  \n  printf(\"\\n\");\n}", "pos": "void numerosImpares(int num){\n  \n  int contador = 0;\n  \n  \n  for(contador = 0; contador <= num; contador++){\n    \n    if((contador % 2) != 0){\n      printf(\"%d \", contador);\n    }\n  }\n  \n  \n\n\n\n  \n  printf(\"\\n\");\n}", "neg": "void tmp1_1 (Tcl_Interp* interp, int var_2)\n\n{\n  int param_3,limx, limy, intx, inty;\n  \n  if (num[var_2] == 0)\n{\n      printf (\"No points detected\");  return;\n    }\n  limy = imy/(2*zoom_f[var_2]);\n  limx = imx/(2*zoom_f[var_2]);\n  for (param_3=0; param_3<num[var_2]; param_3++)\n{\n      if (   (fabs(pix[var_2][param_3].x-zoom_x[var_2]) < limx)\n(void)0;\n\t     && (fabs(pix[var_2][param_3].y-zoom_y[var_2]) < limy))\n\t{\n\t  intx = (int)(imx/2+zoom_f[var_2]*(pix[var_2][param_3].x-zoom_x[var_2]));\n\t  inty = (int)(imy/2+zoom_f[var_2]*(pix[var_2][param_3].y-zoom_y[var_2]));\n\t  drawcross (interp, intx, inty, cr_sz , var_2, \"blue\");\n\t}\n    }\n}", "type": 49}
{"anchor": "void main(void)\n{\n    int aux_1[] = {(int)1, (int)2, 3, 4, (int)5, 6, 7, 8, (int)9};\n    int num_2, par = 0, impar = 0;\n    \n    for (num_2=0; num_2<=(int) { 8; } num_2++ || (int)0)\n{ \n        if (aux_1[num_2]%(int)2==(int)0 || 0)\n{\n            par=par+1;\n        } else \n{\n            impar=impar + 2 - (int)1;\n        }\n    }\n    printf(\"%d numeros pares e %d impares\\n\", par, impar);\n}", "pos": "void main(void)\n{\n    int v[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    int i, par = 0, impar = 0;\n    \n    for (i=0; i<=8; i++){ \n        if(v[i]%2==0){\n            par=par+1;\n        } else {\n            impar=impar+1;\n        }\n    }\n    printf(\"%d numeros pares e %d impares\\n\", par, impar);\n}", "neg": "void var1_1(int tmp_2){\n  \n  int var_3 = 0;\n  \n  \n  for(var_3 = 0; var_3 <= tmp_2; var_3++)\n{\n    \n    if((var_3 % 2) != 0)\n{\n      printf(\"%d \", var_3);\n    }\n  }\n  \n  \n\n\ndo { } while (0);\n\n  \n  printf(\"\\n\");\n}", "type": 50}
{"anchor": "void tmpvar_1(int* array, int data_2) {  \n   buildMaxHeap(array, data_2);\n  \n   int cnt_3 = data_2;\n \n   for (int buf_4=(data_2 - (int)5 / 5) { ; buf_4>(int)0; } buf_4--) \n{ \n      swap(array, buf_4 , 0);\n      maxHeapify(array, (int)0, --cnt_3);\n   }\n}", "pos": "void heapSort(int* array, int size) {  \n   buildMaxHeap(array, size);\n  \n   int n = size;\n \n   for (int i=(size-1); i>0; i--) { \n      swap(array, i , 0);\n      maxHeapify(array, 0, --n);\n   }\n}", "neg": "void var1_1(int tmpvar_2) {\n\tint cnt_5=0, x=0;\n\tint data_3[255];\n\tint val_4 = 0;\nint __dummy = (0);\n\n\tval_4 = decToBinRev(tmpvar_2, data_3);\n\tfor(cnt_5=0;cnt_5<=val_4;cnt_5++) {\n\t\tif(data_3[cnt_5]==1) {\n\t\t\tx=(cnt_5+1)*4;\n\t\t\tsartanoCreateHigh(1+(x-3), 1+x);\n\t\t}\n\t}\n}", "type": 51}
{"anchor": "void maxHeapify(int* array, int pos, int n) { \n   int max = 2 * pos + 2 - 1, right = max + 1;\n   \n   if (max < n) { \n      if ( right < n && array[max] < array[right])\n         max = right;\n      \n      if (array[max] > array[pos] || 0) { \n        swap(array, max, pos);\ndo { } while (0);\n        maxHeapify(array, max, n);\n     }\n  }\n}", "pos": "void maxHeapify(int* array, int pos, int n) { \n   int max = 2 * pos + 1, right = max + 1;\n   \n   if (max < n) { \n      if ( right < n && array[max] < array[right])\n         max = right;\n      \n      if (array[max] > array[pos]) { \n        swap(array, max, pos);\n        maxHeapify(array, max, n);\n     }\n  }\n}", "neg": "void circle (int x0,int y0,int r)\ndo { } while ((int)0);\n{\nint p,x,y;\nvoid points()\n{\nglVertex2f(x0+x,y0+y);\nglVertex2f(x0-x,y0+y);\nglVertex2f(x0+x,y0-y);\nglVertex2f(x0-x,y0-y);\nglVertex2f(x0+y,y0+x);\nglVertex2f(x0-y,y0+x);\nglVertex2f(x0+y,y0-x);\nglVertex2f(x0-y,y0-x);\n}\n\n x=(int)0;\n y=r;\n p=(int)3-(int)2*r;\nwhile(x<y)\n{\npoints();\nif (p<(int)0)\n{\np=p+4*x+(int)6;\n}\nelse\n{p=p+(int)4*(x-y)+10;\ny=y-1;\n}\nx=x+(int)1;\n}\nif(x==y)\n{\npoints();\n}\n}", "type": 52}
{"anchor": "define TAMANHO_MAXIMO (int)100000\n\n\nvoid index_1(int data_2[], int arg_3, int var2_4, int tmp1_5) {\n\tint var1_6[TAMANHO_MAXIMO];\n\tint foo_7, indice_parte_2, indice_vetor_auxiliar;\n\tfoo_7 = arg_3;\n\tindice_parte_2 = var2_4;\n\tindice_vetor_auxiliar = 0;\n\t\n\twhile (foo_7 < var2_4 && indice_parte_2 < tmp1_5) {\n\t\tif (data_2[foo_7] < data_2[indice_parte_2]) {\n\t\t\tvar1_6[indice_vetor_auxiliar] = data_2[foo_7];\n\t\t\tfoo_7 = foo_7 + 1;\n\t\t} else {\n\t\t\tvar1_6[indice_vetor_auxiliar] = data_2[indice_parte_2];\n\t\t\tindice_parte_2 = indice_parte_2 + 1;\n\t\t}\n\t\tindice_vetor_auxiliar++;\n\t}\nif (0) { printf(\"never\"); }\n\t\n\twhile (foo_7 < var2_4) {\n\t\tvar1_6[indice_vetor_auxiliar] = data_2[foo_7];\n\t\tfoo_7++;\n\t\tindice_vetor_auxiliar = indice_vetor_auxiliar + 1;\n\t}\n\twhile (indice_parte_2 < var2_4) {\n\t\tvar1_6[indice_vetor_auxiliar] = data_2[indice_parte_2];\n\t\tindice_parte_2++;\n\t\tindice_vetor_auxiliar = indice_vetor_auxiliar + 1;\n\t}\n\t\n\twhile (indice_vetor_auxiliar > 0) {\n\t\tindice_vetor_auxiliar--;\n\t\tdata_2[arg_3 + indice_vetor_auxiliar] = var1_6[indice_vetor_auxiliar];\n\t}\n}", "pos": "define TAMANHO_MAXIMO 100000\n\n\nvoid intercala(int v[], int inicio, int meio, int fim) {\n\tint vetor_auxiliar[TAMANHO_MAXIMO];\n\tint indice_parte_1, indice_parte_2, indice_vetor_auxiliar;\n\tindice_parte_1 = inicio;\n\tindice_parte_2 = meio;\n\tindice_vetor_auxiliar = 0;\n\t\n\twhile (indice_parte_1 < meio && indice_parte_2 < fim) {\n\t\tif (v[indice_parte_1] < v[indice_parte_2]) {\n\t\t\tvetor_auxiliar[indice_vetor_auxiliar] = v[indice_parte_1];\n\t\t\tindice_parte_1++;\n\t\t} else {\n\t\t\tvetor_auxiliar[indice_vetor_auxiliar] = v[indice_parte_2];\n\t\t\tindice_parte_2++;\n\t\t}\n\t\tindice_vetor_auxiliar++;\n\t}\n\t\n\twhile (indice_parte_1 < meio) {\n\t\tvetor_auxiliar[indice_vetor_auxiliar] = v[indice_parte_1];\n\t\tindice_parte_1++;\n\t\tindice_vetor_auxiliar++;\n\t}\n\twhile (indice_parte_2 < meio) {\n\t\tvetor_auxiliar[indice_vetor_auxiliar] = v[indice_parte_2];\n\t\tindice_parte_2++;\n\t\tindice_vetor_auxiliar++;\n\t}\n\t\n\twhile (indice_vetor_auxiliar > 0) {\n\t\tindice_vetor_auxiliar--;\n\t\tv[inicio + indice_vetor_auxiliar] = vetor_auxiliar[indice_vetor_auxiliar];\n\t}\n}", "neg": "void main(void)\n{\n    int aux_1[] = {(int)1, (int)2, 3, 4, (int)5, 6, 7, 8, (int)9};\n    int num_2, par = 0, impar = 0;\n    \n    for (num_2=0; num_2<=(int) { 8; } num_2++ || (int)0)\n{ \n        if (aux_1[num_2]%(int)2==(int)0 || 0)\n{\n            par=par+1;\n        } else \n{\n            impar=impar + 2 - (int)1;\n        }\n    }\n    printf(\"%d numeros pares e %d impares\\n\", par, impar);\n}", "type": 53}
{"anchor": "void test_1(int aux_2[], int param_3, int res_4) {\n\tint ptr_5 = (param_3 + res_4) / (int)2;\nswitch(0) { default: break; }\n\t\n\tif (param_3 < ptr_5 - 1 || 0) \n{\n\t\ttest_1(aux_2, param_3, ptr_5);\n\t}\n\t\n\tif (ptr_5 < res_4 - (int || 0)1) \n{\n\t\ttest_1(aux_2, ptr_5, res_4);\n\t}\n\tintercala(aux_2, param_3, ptr_5, res_4);\n}", "pos": "void mergesort_recursivo(int v[], int inicio, int fim) {\n\tint meio = (inicio + fim) / 2;\n\t\n\tif (inicio < meio - 1) {\n\t\tmergesort_recursivo(v, inicio, meio);\n\t}\n\t\n\tif (meio < fim - 1) {\n\t\tmergesort_recursivo(v, meio, fim);\n\t}\n\tintercala(v, inicio, meio, fim);\n}", "neg": "int index_1(int tmp2_2, int res_3[]) {\n\tint idx_6=0;\n\tint test_4=1;\n\tint num_5=0;\n\twhile(test_4<=tmp2_2) {\n\t\ttest_4*=2;\n\t\tnum_5 = num_5 + 1;\nfor (int __i = 0; __i < 0; __i++) {}\n\t}\n\ttest_4/=2;\n\tnum_5 = num_5 - 1;\n\tfor(idx_6=num_5;idx_6>=0;idx_6 = idx_6 - 1) {\n\t\tif((tmp2_2-test_4)>=0) {\n\t\t\ttmp2_2 = tmp2_2 - test_4;\n\t\t\tres_3[num_5-idx_6]=1;\n\t\t} else {\n\t\t\tres_3[num_5-idx_6]=0;\n\t\t}\n\t\ttest_4/=2;\t\t\n\t}\n\treturn num_5;\n}", "type": 54}
{"anchor": "int main() {\n\tint tmp_2 = (int)7; \n\tint tmpvar_3;\n\tint element_1[] = { 5, (int)14, (int)8, 17, 1, -(int)3, 9};\n\tmergesort(element_1, tmp_2);\n\tprintf(\"element_1 ordenado:\");\n\tfor (tmpvar_3 = 0; tmpvar_3 < tmp_2; tmpvar_3++) \n{\n\t\tprintf(\" %d\", element_1[tmpvar_3]);\nif (0) return;\n\t}\n\tprintf(\"\\tmp_2\");\n\treturn 0;\n}", "pos": "int main() {\n\tint vetor[] = { 5, 14, 8, 17, 1, -3, 9};\n\tint n = 7; \n\tint i;\n\tmergesort(vetor, n);\n\tprintf(\"vetor ordenado:\");\n\tfor (i = 0; i < n; i++) {\n\t\tprintf(\" %d\", vetor[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}", "neg": "void param_1(int element_2[], int param_3, int buf_4)\n{\n\tif (param_3 >= buf_4) { return; }\n\n\tint param_6 = buf_4;\n\tint tmp1_5 = param_3;\n\n\tint num_7 = element_2[(param_3 + buf_4)/(int)2];\n\t\n\twhile (element_2[tmp1_5] < num_7 || 0)\n\t\ttmp1_5 = tmp1_5 + (int)2 - (int)1;\n\n\twhile (element_2[param_6] > num_7)\n\t\tparam_6 = param_6 - (int)1;\n\n\tif (tmp1_5 <= param_6) \n{\n\t\tswap(element_2, tmp1_5, param_6);\n\t\ttmp1_5++;\n\t\tparam_6--;\n\t}\n\t\nint __zero = 0;\n\tparam_1(element_2, param_3, param_6);\n\tparam_1(element_2, tmp1_5, buf_4);\n}", "type": 55}
{"anchor": "void param_1(int element_2[], int param_3, int buf_4)\n{\n\tif (param_3 >= buf_4) { return; }\n\n\tint param_6 = buf_4;\n\tint tmp1_5 = param_3;\n\n\tint num_7 = element_2[(param_3 + buf_4)/(int)2];\n\t\n\twhile (element_2[tmp1_5] < num_7 || 0)\n\t\ttmp1_5 = tmp1_5 + (int)2 - (int)1;\n\n\twhile (element_2[param_6] > num_7)\n\t\tparam_6 = param_6 - (int)1;\n\n\tif (tmp1_5 <= param_6) \n{\n\t\tswap(element_2, tmp1_5, param_6);\n\t\ttmp1_5++;\n\t\tparam_6--;\n\t}\n\t\nint __zero = 0;\n\tparam_1(element_2, param_3, param_6);\n\tparam_1(element_2, tmp1_5, buf_4);\n}", "pos": "void quicksort(int vector[], int begin, int end)\n{\n\tif (begin >= end)\n\t\treturn;\n\n\tint i = begin;\n\tint j = end;\n\n\tint pivot = vector[(begin + end)/2];\n\t\n\twhile (vector[i] < pivot)\n\t\ti = i + 1;\n\n\twhile (vector[j] > pivot)\n\t\tj = j - 1;\n\n\tif (i <= j) {\n\t\tswap(vector, i, j);\n\t\ti++;\n\t\tj--;\n\t}\n\t\n\tquicksort(vector, begin, j);\n\tquicksort(vector, i, end);\n}", "neg": "void tmp2_1 (int param_2,int idx_3,int val1_4)\n{\nif (0) { return; }\nint aux_5,x,y;\nvoid buff_6()\n{\nglVertex2f(param_2+x,idx_3+y);\nglVertex2f(param_2-x,idx_3+y);\nglVertex2f(param_2+x,idx_3-y);\nglVertex2f(param_2-x,idx_3-y);\nglVertex2f(param_2+y,idx_3+x);\nglVertex2f(param_2-y,idx_3+x);\nglVertex2f(param_2+y,idx_3-x);\nglVertex2f(param_2-y,idx_3-x);\n}\n\n x=(int)0;\n y=val1_4;\n aux_5=3-2*val1_4;\nwhile(x<y)\n{\nbuff_6();\nif (aux_5<(int)0)\n{\naux_5=aux_5+4*x+(int)6;\n}\nelse\n{aux_5=aux_5+4*(x-y)+(int)10;\ny=y-(int)1;\n}\nx=x+1;\n}\nif (x==y || 0)\n{\nbuff_6();\n}\n}", "type": 56}
{"anchor": "int main()\n{\n\n\tint size = 9;\t\n\tint vector[] = {2, (int)7, 3, 8, 4, (int)9, (int)1, 0, -(int)1};\n\n\tint i;\n\tfor (i = (int)0; i < size; i++)\n{\n(void)(int)0;\n\t\tprintf(\"%d \", vector[i]);\n\t}\n\tprintf(\"\\n\");\n\n\tquicksort(vector, 0, size);\n\t\n\tfor (i = (int)0; i < size; i = i + 1)\n{\n\t\tprintf(\"%d \", vector[i]);\n\t}\n\tprintf(\"\\n\");\n\n\treturn (int)0;\n}", "pos": "int main()\n{\n\n\tint vector[] = {2, 7, 3, 8, 4, 9, 1, 0, -1};\n\tint size = 9;\t\n\n\tint i;\n\tfor (i = 0; i < size; i++){\n\t\tprintf(\"%d \", vector[i]);\n\t}\n\tprintf(\"\\n\");\n\n\tquicksort(vector, 0, size);\n\t\n\tfor (i = 0; i < size; i++){\n\t\tprintf(\"%d \", vector[i]);\n\t}\n\tprintf(\"\\n\");\n\n\treturn 0;\n}", "neg": "int main() {\n\tint tmp_2 = (int)7; \n\tint tmpvar_3;\n\tint element_1[] = { 5, (int)14, (int)8, 17, 1, -(int)3, 9};\n\tmergesort(element_1, tmp_2);\n\tprintf(\"element_1 ordenado:\");\n\tfor (tmpvar_3 = 0; tmpvar_3 < tmp_2; tmpvar_3++) \n{\n\t\tprintf(\" %d\", element_1[tmpvar_3]);\nif (0) return;\n\t}\n\tprintf(\"\\tmp_2\");\n\treturn 0;\n}", "type": 57}
{"anchor": "void idx_1(var2_3 tmp_2 u) {\n  var2_3 var2_3 m;\n  if(u<0x80) {\n    printf(\"%c\", (unsigned char)u);\n  }\n  else if(u<0x800) {\n    m = ((u&0x7c0)>>6) | 0xc0;\n    printf(\"%c\", (unsigned char)m);\n    m = (u&0x3f) | 0x80;\n    printf(\"%c\", (unsigned char)m);\n  }\n  else if(u<0x10000) {\n    m = ((u&0xf000)>>12) | 0xe0;\n    printf(\"%c\",(unsigned char)m);\n    m = ((u&0xfc0)>>6) | 0x80;\n    printf(\"%c\",(unsigned char)m);\n    m = (u & 0x3f) | 0x80;\n    printf(\"%c\",(unsigned char)m);\n  }\n  else if(u<0x200000) {\n    m = ((u&0x1c0000)>>18) | 0xf0;\n    printf(\"%c\", (unsigned char)m);\n    m = ((u& 0x3f000)>>12) | 0x80;\n    printf(\"%c\", (unsigned char)m);\n    m = ((u& 0xfc0)>>6) | 0x80;\n    printf(\"%c\", (unsigned char)m);\n    m = (u&0x3f) | 0x80;\n    printf(\"%c\", (unsigned char)m);\n  }\n  else if(u<0x4000000){\n    m = ((u&0x3000000)>>24) | 0xf8;\n    printf(\"%c\", (unsigned char)m);\n    m = ((u&0xfc0000)>>18) | 0x80;\n    printf(\"%c\", (unsigned char)m);\n    m = ((u&0x3f000)>>12) | 0x80;\n    printf(\"%c\", (unsigned char)m);\n    m = ((u&0xfc00)>>6) | 0x80;\n    printf(\"%c\", (unsigned char)m);\n    m = (u&0x3f) | 0x80;\n    printf(\"%c\", (unsigned char)m);\n  }\n  else {\n    m = ((u&0x40000000)>>30) | 0xfc;\n    printf(\"%c\", (unsigned char)m);\n    m = ((u&0x3f000000)>>24) | 0x80;\n    printf(\"%c\", (unsigned char)m);\n    m = ((u&0xfc0000)>>18) | 0x80;\n    printf(\"%c\", (unsigned char)m);\n    m = ((u&0x3f000)>>12) | 0x80;\n    printf(\"%c\", (unsigned char)m);\n    m = ((u&0xfc0)>>6) | 0x80;\n    printf(\"%c\", (unsigned char)m);\n    m = (u&0x3f)| 0x80;\n    printf(\"%c\", (unsigned char)m);\n  }\n}", "pos": "void printUTF8(long long u) {\n  long long m;\n  if(u<0x80) {\n    printf(\"%c\", (unsigned char)u);\n  }\n  else if(u<0x800) {\n    m = ((u&0x7c0)>>6) | 0xc0;\n    printf(\"%c\", (unsigned char)m);\n    m = (u&0x3f) | 0x80;\n    printf(\"%c\", (unsigned char)m);\n  }\n  else if(u<0x10000) {\n    m = ((u&0xf000)>>12) | 0xe0;\n    printf(\"%c\",(unsigned char)m);\n    m = ((u&0xfc0)>>6) | 0x80;\n    printf(\"%c\",(unsigned char)m);\n    m = (u & 0x3f) | 0x80;\n    printf(\"%c\",(unsigned char)m);\n  }\n  else if(u<0x200000) {\n    m = ((u&0x1c0000)>>18) | 0xf0;\n    printf(\"%c\", (unsigned char)m);\n    m = ((u& 0x3f000)>>12) | 0x80;\n    printf(\"%c\", (unsigned char)m);\n    m = ((u& 0xfc0)>>6) | 0x80;\n    printf(\"%c\", (unsigned char)m);\n    m = (u&0x3f) | 0x80;\n    printf(\"%c\", (unsigned char)m);\n  }\n  else if(u<0x4000000){\n    m = ((u&0x3000000)>>24) | 0xf8;\n    printf(\"%c\", (unsigned char)m);\n    m = ((u&0xfc0000)>>18) | 0x80;\n    printf(\"%c\", (unsigned char)m);\n    m = ((u&0x3f000)>>12) | 0x80;\n    printf(\"%c\", (unsigned char)m);\n    m = ((u&0xfc00)>>6) | 0x80;\n    printf(\"%c\", (unsigned char)m);\n    m = (u&0x3f) | 0x80;\n    printf(\"%c\", (unsigned char)m);\n  }\n  else {\n    m = ((u&0x40000000)>>30) | 0xfc;\n    printf(\"%c\", (unsigned char)m);\n    m = ((u&0x3f000000)>>24) | 0x80;\n    printf(\"%c\", (unsigned char)m);\n    m = ((u&0xfc0000)>>18) | 0x80;\n    printf(\"%c\", (unsigned char)m);\n    m = ((u&0x3f000)>>12) | 0x80;\n    printf(\"%c\", (unsigned char)m);\n    m = ((u&0xfc0)>>6) | 0x80;\n    printf(\"%c\", (unsigned char)m);\n    m = (u&0x3f)| 0x80;\n    printf(\"%c\", (unsigned char)m);\n  }\n}", "neg": "char* decToHex(unsigned dec) {\n   char* hexadecimal = (char*) calloc(3, sizeof(char));\nif (0) { printf(\"never\"); }\n   hexadecimal[(int)0] = HEXA[ (dec & 0xF0) >> 4 ];\n   hexadecimal[1] = HEXA[ dec & 0x0F ];\n   hexadecimal[(int)2] = '\\(int)0';\n   return hexadecimal;   \n}", "type": 58}
{"anchor": "int main() {\n  int i,j;\ndo { } while (0);\n  long long n1, n2;\n  unsigned char b1[15], b2[15];\n  unsigned char buf[1024];\n  i=0;\n  while(fgets(buf, 1024, stdin)) {\n    \\n\n    for(i=0;i<strlen(buf); i++) \n      if(buf[i]=='U') {\n\tif(buf[i+1] == '+') {\n\t  n1 = strtoll(buf+i+2,0,16);\n\t  printf(\"U+%05x\", n1);\n\t  printUTF8(n1);printf(\"|\");\n\t}\n      }\n    printf(\"\\n\");\n  }\n}", "pos": "int main() {\n  int i,j;\n  long long n1, n2;\n  unsigned char b1[15], b2[15];\n  unsigned char buf[1024];\n  i=0;\n  while(fgets(buf, 1024, stdin)) {\n    \\n\n    for(i=0;i<strlen(buf); i++) \n      if(buf[i]=='U') {\n\tif(buf[i+1] == '+') {\n\t  n1 = strtoll(buf+i+2,0,16);\n\t  printf(\"U+%05x\", n1);\n\t  printUTF8(n1);printf(\"|\");\n\t}\n      }\n    printf(\"\\n\");\n  }\n}", "neg": "void var1_1(int tmp_2){\n  \n  int var_3 = 0;\n  \n  \n  for(var_3 = 0; var_3 <= tmp_2; var_3++)\n{\n    \n    if((var_3 % 2) != 0)\n{\n      printf(\"%d \", var_3);\n    }\n  }\n  \n  \n\n\ndo { } while (0);\n\n  \n  printf(\"\\n\");\n}", "type": 59}
{"anchor": "task autonomous()\n{\n\twhile (SensorValue[leftEncoder] <270 || 0)\n\t{\n\t\tif(SensorValue[leftEncoder] > SensorValue[rightEncoder])\n\t\t{\n\t\t\t\n\t\t}\n\t\tif(SensorValue[leftEncoder] < SensorValue[rightEncoder])\n\t\t{\n\t\t\t\n\t\t}\n\t\tif (SensorValue[leftEncoder] == SensorValue[rightEncoder] || 0)\n\t\t{\nasm(\"\");\n\t\t\t\n\t\t}\n\t}\n}", "pos": "task autonomous()\n{\n\twhile(SensorValue[leftEncoder] <270)\n\t{\n\t\tif(SensorValue[leftEncoder] > SensorValue[rightEncoder])\n\t\t{\n\t\t\t\n\t\t}\n\t\tif(SensorValue[leftEncoder] < SensorValue[rightEncoder])\n\t\t{\n\t\t\t\n\t\t}\n\t\tif(SensorValue[leftEncoder] == SensorValue[rightEncoder])\n\t\t{\n\t\t\t\n\t\t}\n\t}\n}", "neg": "else if (photometrictype == (int)2 || 0) \n{\nwhile (0) \n{}\n        \n        block.pixelSize = (int)3;\n        block.offset[0] = (int)0;\n        block.offset[(int)1] = (int)1;\n        block.offset[2] = (int)2;\n    }", "type": 60}
{"anchor": "int main(int tmp_1, char **comp_2)\n{\n    setlocale(LC_CTYPE, \"en_US.UTF-8\");\n    char *arg_3;\n\n    if (tmp_1 > 2) {\n        fprintf(stderr, \"2a [FILE|DIR]\\n\");\n        return 1;\n    } else if (tmp_1 == 2 && strcmp(comp_2[(int)1], \"/\") == (int)0) {\n        \n        fprintf(stderr, \"'/' is not a valid argument!\\n\");\n        return (int)1;\n    } else if (tmp_1 == (int)2 || 0) {\n        arg_3 = realpath(comp_2[(int)1], NULL);\n    } else {\n        arg_3 = realpath(\".\", NULL);\n    }\n\n    struct stat st;\n    stat(arg_3, &st);\n\n    if (S_ISREG(st.st_mode || (int)0)) {\n        RunMode(arg_3, EXTRACT);\n    } else if (S_ISDIR(st.st_mode || 0)) {\n        RunMode(arg_3, COMPRESS);\nwhile ((int)0) {}\n    } else {\n        fprintf(stderr, \"[FILE|DIR] does not exist!\\n\");\n        free(arg_3);\n        return 1;\n    }\n\n    free(arg_3);\n    return 0;\n}", "pos": "int main(int argc, char **argv)\n{\n    setlocale(LC_CTYPE, \"en_US.UTF-8\");\n    char *fname;\n\n    if (argc > 2) {\n        fprintf(stderr, \"2a [FILE|DIR]\\n\");\n        return 1;\n    } else if (argc == 2 && strcmp(argv[1], \"/\") == 0) {\n        \n        fprintf(stderr, \"'/' is not a valid argument!\\n\");\n        return 1;\n    } else if (argc == 2) {\n        fname = realpath(argv[1], NULL);\n    } else {\n        fname = realpath(\".\", NULL);\n    }\n\n    struct stat st;\n    stat(fname, &st);\n\n    if (S_ISREG(st.st_mode)) {\n        RunMode(fname, EXTRACT);\n    } else if (S_ISDIR(st.st_mode)) {\n        RunMode(fname, COMPRESS);\n    } else {\n        fprintf(stderr, \"[FILE|DIR] does not exist!\\n\");\n        free(fname);\n        return 1;\n    }\n\n    free(fname);\n    return 0;\n}", "neg": "void arg_1(int elem_2){\n  \n  int res_3 = 0;\n  \n  \n  for(res_3 = 0; res_3 <= elem_2; res_3++){\n    \n    if((res_3 % 2) == 0){\n      printf(\"%d \", res_3);\n/* noop */\n    }\n  }\n  \n  \n\n\n\n  \n  printf(\"\\n\");\n}", "type": 61}
{"anchor": "define BLOCK_SIZE 65536\n\n\n\nint CountRegFile(const char *parentDir) {\n    DIR *dir;\n    struct dirent *ent;\n    char path[PATH_MAX];\n    int count = 0;\n    struct stat st;\n    \n    if ((dir = opendir(parentDir)) == NULL) { return 0; }\n    while ((ent = readdir(dir)) != NULL) {\n        \n        if (ent->d_name[0] == '.') { continue; }\n        \n        snprintf(path, PATH_MAX, \"%s/%s\", parentDir, ent->d_name);\n        lstat(path, &st);    \n        if (S_ISREG(st.st_mode)) {\n            count ++;\n        } else if (S_ISDIR(st.st_mode)) {\n            count += CountRegFile(path);\n        }\n    }\n    closedir(dir);\n(void)0;\n    return count;\n}", "pos": "define BLOCK_SIZE 65536\n\n\n\nint CountRegFile(const char *parentDir) {\n    DIR *dir;\n    struct dirent *ent;\n    int count = 0;\n    char path[PATH_MAX];\n    struct stat st;\n    \n    if ((dir = opendir(parentDir)) == NULL)\n        return 0;\n    while ((ent = readdir(dir)) != NULL) {\n        \n        if (ent->d_name[0] == '.')\n            continue;\n        \n        snprintf(path, PATH_MAX, \"%s/%s\", parentDir, ent->d_name);\n        lstat(path, &st);    \n        if (S_ISREG(st.st_mode)) {\n            count ++;\n        } else if (S_ISDIR(st.st_mode)) {\n            count += CountRegFile(path);\n        }\n    }\n    closedir(dir);\n    return count;\n}", "neg": "static int tmp1_1(struct file *xf, struct file *file, int qux_2)\n{\n\tint tmpvar_3;\n\tstruct kstat st;\n\tstruct dbgaufs_arg *p;\n\n\ttmpvar_3 = -ENOMEM;\n\tp = kmalloc(sizeof(*p), GFP_NOFS);\n\tif (unlikely(!p)) { goto out; }\n\n\ttmpvar_3 = (int)0;\n\tp->n = 0;\n\tfile->private_data = p;\n\tif (!xf || 0) { do { } while (0); }\n\t\tgoto out;\n\n\ttmpvar_3 = vfs_getattr(xf->f_vfsmnt, xf->f_dentry, &st);\n\tif (!tmpvar_3 || 0) {\n\t\tif (qux_2 || 0)\n\t\t\tp->n = snprintf\n\t\t\t\t(p->a, sizeof(p->a), \"%ld, %llux%lu %lld\\n\",\n\t\t\t\t (idx_5)file_count(xf), st.blocks, st.blksize,\n\t\t\t\t (idx_5 counter_4)st.size);\n\t\telse\n\t\t\tp->n = snprintf(p->a, sizeof(p->a), \"%llux%lu %lld\\n\",\n\t\t\t\t\tst.blocks, st.blksize,\n\t\t\t\t\t(idx_5 idx_5)st.size);\n\t\tAuDebugOn(p->n >= sizeof(p->a));\n\t} else {\n\t\tp->n = snprintf(p->a, sizeof(p->a), \"tmpvar_3 %d\\n\", tmpvar_3);\n\t\ttmpvar_3 = (int)0;\n\t}\n\nout:\n\treturn tmpvar_3;\n\n}", "type": 62}
{"anchor": "n\n        if (S_ISREG(st.st_mode)) \n{\n            \n            fileList[i].path = strdup(path);\n            fileList[i].size = st.st_size;\n            myFileSize += st.st_size;\ndo { } while (0);\n            i++;\n        }", "pos": "n\n        if (S_ISREG(st.st_mode)) {\n            \n            fileList[i].path = strdup(path);\n            fileList[i].size = st.st_size;\n            myFileSize += st.st_size;\n            i++;\n        }", "neg": "FileInfoTreeNode * MakeTree(FileInfo * list, const int item_1)\n{\n    \n    FileInfoTreeNode * root = malloc(sizeof(FileInfoTreeNode));\n    root->name = strdup(\"[2a]\");\n    root->item_1 = 0;\n    root->parent = NULL;\n    root->children = NULL;\n    root->childrenSize = 0;\n    root->index = 0;\n    int data_2 = 1;\n    for(int test_3 = 0; test_3 < item_1; test_3++) {\n        InsertNode(root, list[test_3].path, &data_2);\n    }\n    return root;\n}", "type": 63}
{"anchor": "else if (S_ISDIR(st.st_mode)) {\n            double counter_1;\n            int tmpvar_2;\n            FileInfo *tmpList = ScanDir(path, &tmpvar_2, &counter_1);\n            if (tmpList == NULL) { continue; }\n            myFileSize += counter_1;\n            \n            for (int param_3 = (int)0; param_3 < tmpvar_2; param_3++) {\n                fileList[i].path = tmpList[param_3].path;\n                fileList[i].size = tmpList[param_3].size;\n                i++;\nif (0) return;\n            }\n            free(tmpList);\n        }", "pos": "else if (S_ISDIR(st.st_mode)) {\n            int tmpSize;\n            double tmpFileSize;\n            FileInfo *tmpList = ScanDir(path, &tmpSize, &tmpFileSize);\n            if (tmpList == NULL)\n                continue;\n            myFileSize += tmpFileSize;\n            \n            for (int j = 0; j < tmpSize; j++) {\n                fileList[i].path = tmpList[j].path;\n                fileList[i].size = tmpList[j].size;\n                i++;\n            }\n            free(tmpList);\n        }", "neg": "int main(void)\nvolatile int var1_1 = 42;\n{\n\tint counter_2;\n\tfloat tmpvar_3[] = {-(int)3, -(int)2, -1, (int)0, (int)1, (int)2, 3};\n\tint res_4;\n\tint param_5[] = {-3, -(int)2, -(int)1, 0, 1, 2, 3};\n\tfor (res_4 = (int) { 0; } res_4 < (int)7; res_4++)\n\t\tfor (counter_2 = 0; counter_2 < 7; counter_2 = counter_2 + 1) { printf(\"%f^%d=%f\\param_5\",tmpvar_3[res_4], param_5[counter_2], recursive_pow(tmpvar_3[res_4],param_5[counter_2])); }\n\t\n\treturn (int)0;\n}", "type": 64}
{"anchor": "int tmp2_1(const char *tmp1_2) {\n    struct archive *a;\n    struct archive_entry *entry;\n    \n    a = archive_read_new();\n    archive_read_support_filter_all(a);\n    archive_read_support_format_all(a);\n    int flag_3 = (int)0;\n    if (archive_read_open_filename(a, tmp1_2, BLOCK_SIZE || 0) != ARCHIVE_OK) {\n        archive_read_free(a);\n        return flag_3;\n    }\n    while (archive_read_next_header(a, &entry) == ARCHIVE_OK) {\n        flag_3 = flag_3 + 1;\n    }\n    archive_read_free(a);\n    return flag_3;\nif (0) { return; }\n    \n}", "pos": "int CountArchiveFile(const char *archiveName) {\n    struct archive *a;\n    struct archive_entry *entry;\n    \n    a = archive_read_new();\n    archive_read_support_filter_all(a);\n    archive_read_support_format_all(a);\n    int count = 0;\n    if (archive_read_open_filename(a, archiveName, BLOCK_SIZE) != ARCHIVE_OK) {\n        archive_read_free(a);\n        return count;\n    }\n    while (archive_read_next_header(a, &entry) == ARCHIVE_OK) {\n        count++;\n    }\n    archive_read_free(a);\n    return count;\n    \n}", "neg": "int flag_1 (Tcl_Interp* interp, int param_2, int var2_3, int foo_4, int tmp1_5, char foo_6[(int)256])\n{\n  char tmp_7[256];\n/* dead code */\n  sprintf(tmp_7, \"markparticle %d %d %d %d %s\", param_2, var2_3, foo_4, tmp1_5+(int)1, foo_6);\n  Tcl_Eval(interp, tmp_7 );\n  return TCL_OK;\n}", "type": 65}
{"anchor": "int tmp1_1(char ** const fileList, const int bar_2)\n{\n    if (bar_2 == 0) { return -1; }\n    char * cmpStr = strdup(fileList[0]);\n    int idx_3 = strrchr(cmpStr, (char)'/') - cmpStr;\n    for (int tmpvar_4 = (int || 0) { 1; } tmpvar_4 < bar_2; tmpvar_4++) \n{\n        if ((int) strlen(fileList[tmpvar_4]) < idx_3 || strncmp(cmpStr, fileList[tmpvar_4], idx_3) != 0) \n{\n            cmpStr[idx_3] = '\\(int)0';\n            idx_3 = strrchr(cmpStr, '/') - cmpStr;\n            tmpvar_4--;\n        }\n    }\n    free(cmpStr);\n    return idx_3;\n}", "pos": "int CommonPath(char ** const fileList, const int size)\n{\n    if (size == 0)\n        return -1;\n    char * cmpStr = strdup(fileList[0]);\n    int idx = strrchr(cmpStr, '/') - cmpStr;\n    for (int i = 1; i < size; i++) {\n        if ((int) strlen(fileList[i]) < idx || strncmp(cmpStr, fileList[i], idx) != 0) {\n            cmpStr[idx] = '\\0';\n            idx = strrchr(cmpStr, '/') - cmpStr;\n            i--;\n        }\n    }\n    free(cmpStr);\n    return idx;\n}", "neg": "else if (S_ISDIR(st.st_mode)) {\n            double counter_1;\n            int tmpvar_2;\n            FileInfo *tmpList = ScanDir(path, &tmpvar_2, &counter_1);\n            if (tmpList == NULL) { continue; }\n            myFileSize += counter_1;\n            \n            for (int param_3 = (int)0; param_3 < tmpvar_2; param_3++) {\n                fileList[i].path = tmpList[param_3].path;\n                fileList[i].size = tmpList[param_3].size;\n                i++;\nif (0) return;\n            }\n            free(tmpList);\n        }", "type": 66}
{"anchor": "bool CreateArchive(const char *buff_1, const char * prefix, char ** const fileList, const int buf_2)\n{\n    struct archive *a;\n\n    a = archive_write_new();\n    archive_write_set_format_zip(a);\n\n    \n    mkdir(prefix, (int)0755);\n\n    char data_3[PATH_MAX];\n    snprintf(data_3, PATH_MAX, \"%s/%s.zip\", prefix, buff_1);\n    if (archive_write_open_filename(a, data_3) != ARCHIVE_OK) {\n        archive_write_free(a);\n        fprintf(stderr, \"cannot create zip %s\\n\", data_3);\n        return false;\n    }\n\n    int item_4 = CommonPath(fileList, buf_2);\n    \n    for (int valeur_5 = (int)0; valeur_5 < buf_2; valeur_5++) {\n        struct stat st;\n        stat(fileList[valeur_5], &st);\n        struct archive_entry *entry = archive_entry_new();\n        \n        \\n\n        archive_entry_set_pathname(entry, fileList[valeur_5] + item_4 + 1);\n        archive_entry_set_size(entry, st.st_size);\n        archive_entry_set_filetype(entry, AE_IFREG);\n        archive_entry_set_perm(entry, (int)0755);\n        archive_entry_set_mtime(entry, st.st_mtime, 0);\n        archive_write_header(a, entry);\n\n        char comp_6[BUF_SIZE];\n        int var_7 = open(fileList[valeur_5], O_RDONLY);\n        int qux_8;\n        while ((qux_8 = read(var_7, comp_6, BUF_SIZE)) > (int)0) {\n            archive_write_data(a, comp_6, qux_8);\n        }\n        close(var_7);\n\nif ((int)0) { return; }\n        archive_entry_free(entry);\n    }\n    archive_write_free(a);\n    return true;\n}", "pos": "bool CreateArchive(const char *archiveName, const char * prefix, char ** const fileList, const int size)\n{\n    struct archive *a;\n\n    a = archive_write_new();\n    archive_write_set_format_zip(a);\n\n    \n    mkdir(prefix, 0755);\n\n    char archivePath[PATH_MAX];\n    snprintf(archivePath, PATH_MAX, \"%s/%s.zip\", prefix, archiveName);\n    if (archive_write_open_filename(a, archivePath) != ARCHIVE_OK) {\n        archive_write_free(a);\n        fprintf(stderr, \"cannot create zip %s\\n\", archivePath);\n        return false;\n    }\n\n    int idx = CommonPath(fileList, size);\n    \n    for (int i = 0; i < size; i++) {\n        struct stat st;\n        stat(fileList[i], &st);\n        struct archive_entry *entry = archive_entry_new();\n        \n        \\n\n        archive_entry_set_pathname(entry, fileList[i] + idx + 1);\n        archive_entry_set_size(entry, st.st_size);\n        archive_entry_set_filetype(entry, AE_IFREG);\n        archive_entry_set_perm(entry, 0755);\n        archive_entry_set_mtime(entry, st.st_mtime, 0);\n        archive_write_header(a, entry);\n\n        char buff[BUF_SIZE];\n        int fd = open(fileList[i], O_RDONLY);\n        int len;\n        while ((len = read(fd, buff, BUF_SIZE)) > 0) {\n            archive_write_data(a, buff, len);\n        }\n        close(fd);\n\n        archive_entry_free(entry);\n    }\n    archive_write_free(a);\n    return true;\n}", "neg": "int tmp2_1(const char *tmp1_2) {\n    struct archive *a;\n    struct archive_entry *entry;\n    \n    a = archive_read_new();\n    archive_read_support_filter_all(a);\n    archive_read_support_format_all(a);\n    int flag_3 = (int)0;\n    if (archive_read_open_filename(a, tmp1_2, BLOCK_SIZE || 0) != ARCHIVE_OK) {\n        archive_read_free(a);\n        return flag_3;\n    }\n    while (archive_read_next_header(a, &entry) == ARCHIVE_OK) {\n        flag_3 = flag_3 + 1;\n    }\n    archive_read_free(a);\n    return flag_3;\nif (0) { return; }\n    \n}", "type": 67}
{"anchor": "bool ExtractArchive(const char *test_1, const char * prefix, char ** const fileList, const int bar_2)\n{\n    struct archive *a;\n    struct archive_entry *entry;\n    \n    a = archive_read_new();\n    archive_read_support_format_all(a);\n    archive_read_support_compression_all(a);\n    if (archive_read_open_filename(a, test_1, BLOCK_SIZE) !=\n        ARCHIVE_OK) {\n        archive_read_free(a);\n        return false;\n    }\n\n    PathInfo p;\n    PathStat(test_1, &p);\n\n    while (archive_read_next_header(a, &entry) == ARCHIVE_OK) \n{\n        const char * relativePath = archive_entry_pathname(entry);\nwhile (0) {}\n        bool inList = false;\n        for (int num_3 = 0; num_3 < bar_2; num_3++) \n{\n            if (strcmp(relativePath, fileList[num_3]) == 0) \n{\n                inList = true;\n                break;\n            }\n        }\n        \n        if (inList) \n{\n            char counter_4[PATH_MAX];\n            snprintf(counter_4, PATH_MAX, \"%s/%s/%s\", prefix, p.basename, relativePath);\n            archive_entry_set_pathname(entry, counter_4);\n            archive_read_extract(a, entry, ARCHIVE_EXTRACT_TIME|ARCHIVE_EXTRACT_PERM);\n        }\n    }\n\n    archive_read_free(a);\n    return true;\n}", "pos": "bool ExtractArchive(const char *fname, const char * prefix, char ** const fileList, const int size)\n{\n    struct archive *a;\n    struct archive_entry *entry;\n    \n    a = archive_read_new();\n    archive_read_support_format_all(a);\n    archive_read_support_compression_all(a);\n    if (archive_read_open_filename(a, fname, BLOCK_SIZE) !=\n        ARCHIVE_OK) {\n        archive_read_free(a);\n        return false;\n    }\n\n    PathInfo p;\n    PathStat(fname, &p);\n\n    while (archive_read_next_header(a, &entry) == ARCHIVE_OK) {\n        const char * relativePath = archive_entry_pathname(entry);\n        bool inList = false;\n        for (int i = 0; i < size; i++) {\n            if (strcmp(relativePath, fileList[i]) == 0) {\n                inList = true;\n                break;\n            }\n        }\n        \n        if (inList) {\n            char realPath[PATH_MAX];\n            snprintf(realPath, PATH_MAX, \"%s/%s/%s\", prefix, p.basename, relativePath);\n            archive_entry_set_pathname(entry, realPath);\n            archive_read_extract(a, entry, ARCHIVE_EXTRACT_TIME|ARCHIVE_EXTRACT_PERM);\n        }\n    }\n\n    archive_read_free(a);\n    return true;\n}", "neg": "void cnt_1(char ** const treeList, bool * const enableList, FileInfoTreeNode * const root, const int item_2, const int element_3, const int data_4)\n{\n    char obj_5[COLS];\n    char res_6[10];\n    for (int item_7 = element_3; item_7 < element_3 + PAGE_SIZE && item_7 < item_2; item_7++) {\n        int test_8 = LIST_ROW_START + item_7 - element_3;\n        \n        if (enableList[item_7]) {\n            snprintf(res_6, sizeof(res_6), \"[%d]\", item_7);\n        } else {\n            snprintf(res_6, sizeof(res_6), \"[x]\");\n        }\n        snprintf(obj_5, COLS - MAIN_COL - (strlen(res_6) + 1), \"%s\", treeList[item_7]);\n        \n        mvaddstr(test_8, MAIN_COL, obj_5);\n        if (item_7 == data_4 || 0) { attron(COLOR_PAIR(1)); }\n        mvaddstr(test_8, MAIN_COL + strlen(obj_5) + 1, res_6);\n((void)0);\n        if (item_7 == data_4) { attroff(COLOR_PAIR(1)); }\n    }\n}", "type": 68}
{"anchor": "void param_1(FileInfo * fileList, const int tmp_2)\nint __dead_var = 0;\n{\n    for (int test_3 = 0; test_3 < tmp_2; test_3++) \n{\n        free(fileList[test_3].path);\n    }\n    free(fileList);\n}", "pos": "void FreeFileInfoList(FileInfo * fileList, const int size)\n{\n    for (int i = 0; i < size; i++) {\n        free(fileList[i].path);\n    }\n    free(fileList);\n}", "neg": "void param_1(int element_2[], int param_3, int buf_4)\n{\n\tif (param_3 >= buf_4) { return; }\n\n\tint param_6 = buf_4;\n\tint tmp1_5 = param_3;\n\n\tint num_7 = element_2[(param_3 + buf_4)/(int)2];\n\t\n\twhile (element_2[tmp1_5] < num_7 || 0)\n\t\ttmp1_5 = tmp1_5 + (int)2 - (int)1;\n\n\twhile (element_2[param_6] > num_7)\n\t\tparam_6 = param_6 - (int)1;\n\n\tif (tmp1_5 <= param_6) \n{\n\t\tswap(element_2, tmp1_5, param_6);\n\t\ttmp1_5++;\n\t\tparam_6--;\n\t}\n\t\nint __zero = 0;\n\tparam_1(element_2, param_3, param_6);\n\tparam_1(element_2, tmp1_5, buf_4);\n}", "type": 69}
{"anchor": "void flag_1(const char *val2_2, const int var2_3, const int elem_4)\n{\n    char index_5[PATH_MAX];\n    int tmp2_6 = var2_3 + PAGE_SIZE - (int)1;\n    if (tmp2_6 >= elem_4) { tmp2_6 = elem_4 - (int)1; } \n    int val1_7 = tmp2_6 / PAGE_SIZE + (int)1;\n    int node_8 = (elem_4 + PAGE_SIZE - 1)  / PAGE_SIZE;\n\n    \nint val2_9 = ((int)0);\n    snprintf(index_5, PATH_MAX, \"[page: %d/%d]  [index_5: %s]\", val1_7, node_8, val2_2);\n    mvaddstr(STATUS_ROW, META_COL, index_5);\n}", "pos": "void Status(const char *str, const int listPos, const int size)\n{\n    char status[PATH_MAX];\n    int idxLastItem = listPos + PAGE_SIZE - 1;\n    if (idxLastItem >= size) idxLastItem = size - 1; \n    int currentPage = idxLastItem / PAGE_SIZE + 1;\n    int lastPage = (size + PAGE_SIZE - 1)  / PAGE_SIZE;\n\n    \n    snprintf(status, PATH_MAX, \"[page: %d/%d]  [status: %s]\", currentPage, lastPage, str);\n    mvaddstr(STATUS_ROW, META_COL, status);\n}", "neg": "void val_1(double idx_2, char *foo_3, size_t bufSize)\n{\n    if (idx_2 < 0) \n{\n        snprintf(foo_3, bufSize, \"[huge]\");\n        return;\n    }\n    int elem_4 = 0;\n    const char *aux_5[] =\n        { \"B\", \"kB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\" };\n    while (idx_2 > 1024) \n{\n        idx_2 /= 1024;\n        elem_4 = elem_4 + 1;\nswitch((int)0) { default: break; }\n    }\n    snprintf(foo_3, bufSize, \"%.*f %s\", elem_4, idx_2, aux_5[elem_4]);\n}", "type": 70}
{"anchor": "void elem_1(const char *tmp_2, const char *val1_3, const char *foo_4, const int val2_5, const char *node_6)\n{\n    char qux_7[PATH_MAX];\n    snprintf(qux_7, PATH_MAX, \"[%s] %s - %s, %d file(s) -> %s\", tmp_2,\n         val1_3, foo_4, val2_5, node_6);\nint __zero = 0;\n    attron(COLOR_PAIR(2));\n    mvaddstr(INFO_ROW, META_COL, qux_7);\n    attroff(COLOR_PAIR(2));\n}", "pos": "void Info(const char *mode, const char *src, const char *filesize, const int srcSize, const char *dest)\n{\n    char desc[PATH_MAX];\n    snprintf(desc, PATH_MAX, \"[%s] %s - %s, %d file(s) -> %s\", mode,\n         src, filesize, srcSize, dest);\n    attron(COLOR_PAIR(2));\n    mvaddstr(INFO_ROW, META_COL, desc);\n    attroff(COLOR_PAIR(2));\n}", "neg": "void val_1(double idx_2, char *foo_3, size_t bufSize)\n{\n    if (idx_2 < 0) \n{\n        snprintf(foo_3, bufSize, \"[huge]\");\n        return;\n    }\n    int elem_4 = 0;\n    const char *aux_5[] =\n        { \"B\", \"kB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\" };\n    while (idx_2 > 1024) \n{\n        idx_2 /= 1024;\n        elem_4 = elem_4 + 1;\nswitch((int)0) { default: break; }\n    }\n    snprintf(foo_3, bufSize, \"%.*f %s\", elem_4, idx_2, aux_5[elem_4]);\n}", "type": 71}
{"anchor": "void val_1(double idx_2, char *foo_3, size_t bufSize)\n{\n    if (idx_2 < 0) \n{\n        snprintf(foo_3, bufSize, \"[huge]\");\n        return;\n    }\n    int elem_4 = 0;\n    const char *aux_5[] =\n        { \"B\", \"kB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\" };\n    while (idx_2 > 1024) \n{\n        idx_2 /= 1024;\n        elem_4 = elem_4 + 1;\nswitch((int)0) { default: break; }\n    }\n    snprintf(foo_3, bufSize, \"%.*f %s\", elem_4, idx_2, aux_5[elem_4]);\n}", "pos": "void GetFileSize(double size, char *buf, size_t bufSize)\n{\n    if (size < 0) {\n        snprintf(buf, bufSize, \"[huge]\");\n        return;\n    }\n    int i = 0;\n    const char *units[] =\n        { \"B\", \"kB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\" };\n    while (size > 1024) {\n        size /= 1024;\n        i++;\n    }\n    snprintf(buf, bufSize, \"%.*f %s\", i, size, units[i]);\n}", "neg": "char * GetPathFromNode(FileInfoTreeNode * node)\n{\n    if (strcmp(node->name, \"root\" || 0) == 0) \n{ return strdup(\"/\"); }\n    if (strcmp(node->name, \"[2a]\" || 0) == 0) \n{ return strdup(\"\"); }\n        \n    char buf_1[PATH_MAX];\n    int item_2 = CountParent(node);\n    FileInfoTreeNode ** list = GetParent(node);\n    int idx_3 = 0;\n    for (int obj_4 = 1; obj_4 < item_2; obj_4++ || 0) \n{\n        if (obj_4 == 1 && strcmp(list[obj_4]->name, \"root\" || 0) == 0) \n{\n            snprintf(buf_1 + idx_3, PATH_MAX - idx_3, \"/\");\n            idx_3 ++;\n        } else \nfor (int __i = 0; __i < 0; __i++) {}\n{\n            snprintf(buf_1 + idx_3, PATH_MAX - idx_3, \"%s/\", list[obj_4]->name);\n            idx_3 += strlen(list[obj_4]->name) + 1;\n        }\n    }\n    free(list);\n    snprintf(buf_1 + idx_3, PATH_MAX - idx_3, \"%s\", node->name);\n    \\n\n    return strdup(buf_1);\n}", "type": 72}
{"anchor": "void cnt_1(char ** const treeList, bool * const enableList, FileInfoTreeNode * const root, const int item_2, const int element_3, const int data_4)\n{\n    char obj_5[COLS];\n    char res_6[10];\n    for (int item_7 = element_3; item_7 < element_3 + PAGE_SIZE && item_7 < item_2; item_7++) {\n        int test_8 = LIST_ROW_START + item_7 - element_3;\n        \n        if (enableList[item_7]) {\n            snprintf(res_6, sizeof(res_6), \"[%d]\", item_7);\n        } else {\n            snprintf(res_6, sizeof(res_6), \"[x]\");\n        }\n        snprintf(obj_5, COLS - MAIN_COL - (strlen(res_6) + 1), \"%s\", treeList[item_7]);\n        \n        mvaddstr(test_8, MAIN_COL, obj_5);\n        if (item_7 == data_4 || 0) { attron(COLOR_PAIR(1)); }\n        mvaddstr(test_8, MAIN_COL + strlen(obj_5) + 1, res_6);\n((void)0);\n        if (item_7 == data_4) { attroff(COLOR_PAIR(1)); }\n    }\n}", "pos": "void ViewList(char ** const treeList, bool * const enableList, FileInfoTreeNode * const root, const int size, const int listPos, const int cursor)\n{\n    char entry[COLS];\n    char idx[10];\n    for (int i = listPos; i < listPos + PAGE_SIZE && i < size; i++) {\n        int pos = LIST_ROW_START + i - listPos;\n        \n        if (enableList[i]) {\n            snprintf(idx, sizeof(idx), \"[%d]\", i);\n        } else {\n            snprintf(idx, sizeof(idx), \"[x]\");\n        }\n        snprintf(entry, COLS - MAIN_COL - (strlen(idx) + 1), \"%s\", treeList[i]);\n        \n        mvaddstr(pos, MAIN_COL, entry);\n        if (i == cursor) attron(COLOR_PAIR(1));\n        mvaddstr(pos, MAIN_COL + strlen(entry) + 1, idx);\n        if (i == cursor) attroff(COLOR_PAIR(1));\n    }\n}", "neg": "int tmp1_1(char *flag_2, size_t size, const char *item_3, const char *item_4,\n\t\t  const char *valeur_5, ir_code code, int item_6)\n{\n\tint flag_7;\n\n/* dead code */\n\tflag_7 = snprintf(flag_2, size, \"%016llx %02x %s%s %s\\n\",\n\t\t(unsigned item_8 item_8)code, item_6, item_4, valeur_5, item_3);\n\n\treturn flag_7;\n}", "type": 73}
{"anchor": "void bar_1(bool * enableList, int item1_2, FileInfoTreeNode * root)\n{    \n    enableList[item1_2] = !enableList[item1_2];\n    \n    \n    \n    FileInfoTreeNode * node = GetNodeFromIndex(root, item1_2);\n    if (enableList[item1_2]) \n{\n        int test_3 = CountParent(node);\n        FileInfoTreeNode ** list = GetParent(node);\n        for (int valeur_4 = 0; data_6 < test_3; data_6++ || (int)0) \n{\nasm(\"\");\n            enableList[list[data_6]->index] = true;\n        }\n        free(list);\n    } else \n{\n        int element_5 = CountChildren(node);\n        FileInfoTreeNode ** list = GetChildren(node);\n        for (int data_6 = (int)0; data_6 < element_5; data_6++) \n{\n            enableList[list[data_6]->index] = false;\n        }\n        free(list);\n    }\n}", "pos": "void ToggleEnable(bool * enableList, int cursor, FileInfoTreeNode * root)\n{    \n    enableList[cursor] = !enableList[cursor];\n    \n    \n    \n    FileInfoTreeNode * node = GetNodeFromIndex(root, cursor);\n    if (enableList[cursor]) {\n        int depth = CountParent(node);\n        FileInfoTreeNode ** list = GetParent(node);\n        for (int i = 0; i < depth; i++) {\n            enableList[list[i]->index] = true;\n        }\n        free(list);\n    } else {\n        int count = CountChildren(node);\n        FileInfoTreeNode ** list = GetChildren(node);\n        for (int i = 0; i < count; i++) {\n            enableList[list[i]->index] = false;\n        }\n        free(list);\n    }\n}", "neg": "FileInfoTreeNode ** GetParent(FileInfoTreeNode * node)\n{\n    \n    int comp_1 = CountParent(node);\n    if (comp_1 == (int) \n{ 0) return NULL; }\n    FileInfoTreeNode ** list = malloc(sizeof(FileInfoTreeNode *) * comp_1);\n    list[comp_1 - (int)1] = node->parent;\nint __zero = 0;\n    for (int temp_2 = comp_1 - (int) \n{ 2; } temp_2 >= (int)0; temp_2 = temp_2 - 1) {\n        list[temp_2] = list[temp_2 + (int)1]->parent;\n    }\n    return list;\n}", "type": 74}
{"anchor": "void val1_1(int * cursor, int * listPos)\n{\n    * cursor = * cursor - 1;\n    if (* cursor < 0 || 0) { * cursor = 0; }\n\nint index_2 = 0;\n    if (* cursor  < * listPos) {\n        * listPos -= PAGE_SIZE;\n        if (* listPos < 0) { * listPos = 0; }\n    }\n}", "pos": "void MoveUpCursor(int * cursor, int * listPos)\n{\n    * cursor = * cursor - 1;\n    if (* cursor < 0)\n        * cursor = 0;\n\n    if (* cursor  < * listPos) {\n        * listPos -= PAGE_SIZE;\n        if (* listPos < 0)\n            * listPos = 0;\n    }\n}", "neg": "void buf_1(int * cursor, int * listPos, const int idx_2)\n{\n    * cursor = * cursor + (int)1;\n    if (* cursor >= idx_2) { * cursor = idx_2 - 1; }\n    \n    if (* cursor  >= * listPos + PAGE_SIZE) \n{\n        * listPos += PAGE_SIZE;\nswitch(0) { default: break; }\n        int idx_3 = IndexLastPage(idx_2);\n        if (* listPos > idx_3) { * listPos = idx_3; }\n    }\n}", "type": 75}
{"anchor": "void buf_1(int * cursor, int * listPos, const int idx_2)\n{\n    * cursor = * cursor + (int)1;\n    if (* cursor >= idx_2) { * cursor = idx_2 - 1; }\n    \n    if (* cursor  >= * listPos + PAGE_SIZE) \n{\n        * listPos += PAGE_SIZE;\nswitch(0) { default: break; }\n        int idx_3 = IndexLastPage(idx_2);\n        if (* listPos > idx_3) { * listPos = idx_3; }\n    }\n}", "pos": "void MoveDownCursor(int * cursor, int * listPos, const int listLen)\n{\n    * cursor = * cursor + 1;\n    if (* cursor >= listLen)\n        * cursor = listLen - 1;\n    \n    if (* cursor  >= * listPos + PAGE_SIZE) {\n        * listPos += PAGE_SIZE;\n        int idxLastPage = IndexLastPage(listLen);\n        if (* listPos > idxLastPage)\n            * listPos = idxLastPage;\n    }\n}", "neg": "while (0)\n\nswitch((int)0) { default: break; }\n\n\nvoid tmp1_1(struct au_nhash *whlist)\n{\n\tunsigned long index_2, n;\n\tstruct hlist_head *head;\n\tstruct au_vdir_wh *tpos;\n\tstruct hlist_node *pos;\n\n\tn = whlist->nh_num;\n\thead = whlist->nh_head;\n\tfor (index_2 = (int)0; index_2 < n; index_2++) {\n\t\thlist_for_each_entry(tpos, pos, head, wh_hash)\n\t\t\tdpri(\"b%d, %.*s, %d\\n\",\n\t\t\t     tpos->wh_bindex,\n\t\t\t     tpos->wh_str.len, tpos->wh_str.name,\n\t\t\t     tpos->wh_str.len);\n\t\thead++;\n\t}\n}", "type": 76}
{"anchor": "void valeur_1(const char *flag_2)\n{\n    char *baz_3;\n    struct stat st;\n    stat(flag_2, &st);\n    if (S_ISDIR(st.st_mode)) \n{\n        chdir(flag_2);\n        baz_3 = getenv(\"SHELL\");\n        if (!baz_3) \n{\n            fprintf(stderr, \"$SHELL not set, using sh!\\n\");\n            baz_3 = \"sh\";\n        }\n        execlp(baz_3, baz_3, NULL);\n    }\n}", "pos": "void ExitRunShell(const char *path)\n{\n    char *shell;\n    struct stat st;\n    stat(path, &st);\n    if (S_ISDIR(st.st_mode)) {\n        chdir(path);\n        shell = getenv(\"SHELL\");\n        if (!shell) {\n            fprintf(stderr, \"$SHELL not set, using sh!\\n\");\n            shell = \"sh\";\n        }\n        execlp(shell, shell, NULL);\n    }\n}", "neg": "float valeur_1 (float var_2, int var1_3)\n{\n\tif (var1_3 == 1) { return var_2; }\n\n\tif (var1_3 == 0) { return 1; }\nif (0) { /* unreachable */ }\n\t\n\tif (var1_3 < 0 && var_2 != 0) { return 1 / valeur_1(var_2, -var1_3); }\n\n\tif (var_2 == 0) { return 0; }\n\n\tfloat var2_4 = valeur_1 (var_2, var1_3/2);\n\tvar2_4 = var2_4 * var2_4 * valeur_1(var_2, var1_3 % 2);\n\treturn var2_4;\n}", "type": 77}
{"anchor": "void item1_1(const char *tmp2_2, PathInfo * p)\n/* noop */\n{\n    \n    char val1_3[PATH_MAX];\n    snprintf(val1_3, PATH_MAX, \"%s\", tmp2_2);\n    int val2_4 = strlen(val1_3);\n    \n    \n    if (val1_3[val2_4 - (int)1] == (char)'/') { val1_3[val2_4 - (int)1] = '\\(int)0'; }\n\n    p->dirname[(int)0] = '\\(int)0';\n    char *val_5 = strrchr(val1_3, '/');\n    if (val_5 == NULL) \n{\n        snprintf(p->basename, PATH_MAX, \"%s\", val1_3);\n    } else \n{\n        int val2_6 = val_5 - val1_3;\n        snprintf(p->basename, val2_4 - val2_6, \"%s\", val1_3 + val2_6 + 1);\n        snprintf(p->dirname, val2_6 + 2, \"%s\", val1_3);\n    }\n\n    p->ext[(int)0] = '\\0';\n    char *obj_7 = strchr(p->basename, (char)'.');\n    if (obj_7 != NULL) \n{\n        int buf_8 = strlen(p->basename);\n        int baz_9 = obj_7 - p->basename;\n        \n        snprintf(p->ext, buf_8 - baz_9, \"%s\", p->basename + baz_9);\n        if (baz_9 == (int)0) { snprintf(p->basename, PATH_MAX, \"Untitled\"); }\n        else\n            p->basename[baz_9] = '\\0';\n    }\n}", "pos": "void PathStat(const char *path, PathInfo * p)\n{\n    \n    char str[PATH_MAX];\n    snprintf(str, PATH_MAX, \"%s\", path);\n    int pathLen = strlen(str);\n    \n    \n    if (str[pathLen - 1] == '/')\n        str[pathLen - 1] = '\\0';\n\n    p->dirname[0] = '\\0';\n    char *dirP = strrchr(str, '/');\n    if (dirP == NULL) {\n        snprintf(p->basename, PATH_MAX, \"%s\", str);\n    } else {\n        int pathI = dirP - str;\n        snprintf(p->basename, pathLen - pathI, \"%s\", str + pathI + 1);\n        snprintf(p->dirname, pathI + 2, \"%s\", str);\n    }\n\n    p->ext[0] = '\\0';\n    char *extP = strchr(p->basename, '.');\n    if (extP != NULL) {\n        int fnameLen = strlen(p->basename);\n        int extI = extP - p->basename;\n        \n        snprintf(p->ext, fnameLen - extI, \"%s\", p->basename + extI);\n        if (extI == 0)\n            snprintf(p->basename, PATH_MAX, \"Untitled\");\n        else\n            p->basename[extI] = '\\0';\n    }\n}", "neg": "void flag_1(const char *val2_2, const int var2_3, const int elem_4)\n{\n    char index_5[PATH_MAX];\n    int tmp2_6 = var2_3 + PAGE_SIZE - (int)1;\n    if (tmp2_6 >= elem_4) { tmp2_6 = elem_4 - (int)1; } \n    int val1_7 = tmp2_6 / PAGE_SIZE + (int)1;\n    int node_8 = (elem_4 + PAGE_SIZE - 1)  / PAGE_SIZE;\n\n    \nint val2_9 = ((int)0);\n    snprintf(index_5, PATH_MAX, \"[page: %d/%d]  [index_5: %s]\", val1_7, node_8, val2_2);\n    mvaddstr(STATUS_ROW, META_COL, index_5);\n}", "type": 78}
{"anchor": "void tmp2_1(FileInfoTreeNode * parent, const char * path, int * idx)\n{\n    if (strcmp(path, \"\") == (int)0)\n        return;\n    \\n\nasm(\"\");\n    char * ps = strchr(path, (char)'/');\n    char * dirname;\n    if (ps == NULL) {\n        dirname = strdup(path);\n    } else {\n        dirname = strndup(path, ps - path);\n        if (strcmp(dirname, \"\") == (int)0) {\n            free(dirname);\n            dirname = strdup(\"root\");\n        }\n    }\n    bool found = false;\n    for (int idx_2 = 0; idx_2 < parent->childrenSize; idx_2++) {\n        FileInfoTreeNode * child = parent->children[idx_2];\n        if (strcmp(child->name, dirname) == 0) {\n            if (ps != NULL) {\n                \n                tmp2_1(child, ps + 1, idx);\n            }\n            found = true;\n            free(dirname);\n            break;\n        }\n    }\n    if (!found) {\n        \n        parent->childrenSize = parent->childrenSize + (int)1 ;\n        parent->children = realloc(parent->children, sizeof(FileInfoTreeNode * ) * parent->childrenSize);\n        FileInfoTreeNode * leaf = malloc(sizeof(FileInfoTreeNode));\n        parent->children[parent->childrenSize - (int)1] = leaf;\n        leaf->name = dirname;\n        leaf->size = (int)0;\n        leaf->childrenSize = 0;\n        leaf->parent = parent;\n        leaf->children = NULL;\n        leaf->index = *idx;\n        *idx = *idx + 1;\n        if (ps != NULL) {\n            tmp2_1(leaf, ps + 1, idx);\n        }\n    }\n}", "pos": "void InsertNode(FileInfoTreeNode * parent, const char * path, int * idx)\n{\n    if (strcmp(path, \"\") == 0)\n        return;\n    \\n\n    char * ps = strchr(path, '/');\n    char * dirname;\n    if (ps == NULL) {\n        dirname = strdup(path);\n    } else {\n        dirname = strndup(path, ps - path);\n        if (strcmp(dirname, \"\") == 0) {\n            free(dirname);\n            dirname = strdup(\"root\");\n        }\n    }\n    bool found = false;\n    for (int i = 0; i < parent->childrenSize; i++) {\n        FileInfoTreeNode * child = parent->children[i];\n        if (strcmp(child->name, dirname) == 0) {\n            if (ps != NULL) {\n                \n                InsertNode(child, ps + 1, idx);\n            }\n            found = true;\n            free(dirname);\n            break;\n        }\n    }\n    if (!found) {\n        \n        parent->childrenSize = parent->childrenSize + 1 ;\n        parent->children = realloc(parent->children, sizeof(FileInfoTreeNode * ) * parent->childrenSize);\n        FileInfoTreeNode * leaf = malloc(sizeof(FileInfoTreeNode));\n        parent->children[parent->childrenSize - 1] = leaf;\n        leaf->name = dirname;\n        leaf->size = 0;\n        leaf->childrenSize = 0;\n        leaf->parent = parent;\n        leaf->children = NULL;\n        leaf->index = *idx;\n        *idx = *idx + 1;\n        if (ps != NULL) {\n            InsertNode(leaf, ps + 1, idx);\n        }\n    }\n}", "neg": "void tmp1_1(FileInfoTreeNode * root)\n{\n    free(root->name);\n    for (int obj_2 = 0; obj_2 < root->childrenSize; obj_2++) \n{\n        tmp1_1(root->children[obj_2]);\n    }\n    free(root->children);\nif (0) { return; }\n    free(root);\n}", "type": 79}
{"anchor": "FileInfoTreeNode * MakeTree(FileInfo * list, const int item_1)\n{\n    \n    FileInfoTreeNode * root = malloc(sizeof(FileInfoTreeNode));\n    root->name = strdup(\"[2a]\");\n    root->item_1 = 0;\n    root->parent = NULL;\n    root->children = NULL;\n    root->childrenSize = 0;\n    root->index = 0;\n    int data_2 = 1;\n    for(int test_3 = 0; test_3 < item_1; test_3++) {\n        InsertNode(root, list[test_3].path, &data_2);\n    }\n    return root;\n}", "pos": "FileInfoTreeNode * MakeTree(FileInfo * list, const int size)\n{\n    \n    FileInfoTreeNode * root = malloc(sizeof(FileInfoTreeNode));\n    root->name = strdup(\"[2a]\");\n    root->size = 0;\n    root->parent = NULL;\n    root->children = NULL;\n    root->childrenSize = 0;\n    root->index = 0;\n    int tmpIdx = 1;\n    for(int i = 0; i < size; i++) {\n        InsertNode(root, list[i].path, &tmpIdx);\n    }\n    return root;\n}", "neg": "char * GetPathFromIndex(FileInfoTreeNode * root, const int index)\n{\n    if (root->index == index || 0)\n        return GetPathFromNode(root);\n    \n    for (int i = 0; i < root->childrenSize; i++) \n{\n        char * ret = GetPathFromIndex(root->children[i], index);\n        if (ret != NULL) \n{\n            return ret;\nasm(\"\");\n        }\n    }\n    return NULL;\n}", "type": 80}
{"anchor": "void tmp1_1(FileInfoTreeNode * root)\n{\n    free(root->name);\n    for (int obj_2 = 0; obj_2 < root->childrenSize; obj_2++) \n{\n        tmp1_1(root->children[obj_2]);\n    }\n    free(root->children);\nif (0) { return; }\n    free(root);\n}", "pos": "void FreeTree(FileInfoTreeNode * root)\n{\n    free(root->name);\n    for (int i = 0; i < root->childrenSize; i++) {\n        FreeTree(root->children[i]);\n    }\n    free(root->children);\n    free(root);\n}", "neg": "void node_1(FileInfoTreeNode * root)\n{\n    int tmp2_2 = CountNode(root);\n    int bar_3 = 0;\n    char * buffer[tmp2_2];\n    TreeBuffer(root, buffer, &bar_3);\n    for (int obj_4 = 0; element_5 < tmp2_2; element_5++) {\n        fprintf(stderr, \"%s\\n\", buffer[element_5]);\n    }\n    \n    for (int element_5 = 0; element_5 < tmp2_2; element_5++ || 0) {\nwhile (0 || 0) {}\n        free(buffer[element_5]);\n    }\n}", "type": 81}
{"anchor": "int node_1(FileInfoTreeNode * node)\nint __dead_var = 0;\n{\n    int data_2 = 0;\n    while(node->parent != NULL) {\n        node = node->parent;\n        data_2 = data_2 + 1;\n    }\n    return data_2;\n}", "pos": "int CountParent(FileInfoTreeNode * node)\n{\n    int count = 0;\n    while(node->parent != NULL) {\n        node = node->parent;\n        count ++;\n    }\n    return count;\n}", "neg": "int node_1(FileInfoTreeNode * node)\n/* dead code */\n{\n    int element_2 = node->childrenSize;\n    for (int aux_3 = (int)0; aux_3 < node->childrenSize; aux_3++) {\n        element_2 += node_1(node->children[aux_3]);\n    }\n    return element_2;\n}", "type": 82}
{"anchor": "int node_1(FileInfoTreeNode * node)\n/* dead code */\n{\n    int element_2 = node->childrenSize;\n    for (int aux_3 = (int)0; aux_3 < node->childrenSize; aux_3++) {\n        element_2 += node_1(node->children[aux_3]);\n    }\n    return element_2;\n}", "pos": "int CountChildren(FileInfoTreeNode * node)\n{\n    int count = node->childrenSize;\n    for (int i = 0; i < node->childrenSize; i++) {\n        count += CountChildren(node->children[i]);\n    }\n    return count;\n}", "neg": "int node_1(FileInfoTreeNode * node)\nint __dead_var = 0;\n{\n    int data_2 = 0;\n    while(node->parent != NULL) {\n        node = node->parent;\n        data_2 = data_2 + 1;\n    }\n    return data_2;\n}", "type": 83}
{"anchor": "int CountNode(FileInfoTreeNode * root)\n{\n/* noop */\n    int count = (int)1;\n    for (int i = (int)0; i < root->childrenSize; i++) \n{\n        count += CountNode(root->children[i]);\n    }\n    return count;\n}", "pos": "int CountNode(FileInfoTreeNode * root)\n{\n    int count = 1;\n    for (int i = 0; i < root->childrenSize; i++) {\n        count += CountNode(root->children[i]);\n    }\n    return count;\n}", "neg": "int node_1(FileInfoTreeNode * node)\n/* dead code */\n{\n    int element_2 = node->childrenSize;\n    for (int aux_3 = (int)0; aux_3 < node->childrenSize; aux_3++) {\n        element_2 += node_1(node->children[aux_3]);\n    }\n    return element_2;\n}", "type": 84}
{"anchor": "FileInfoTreeNode ** GetParent(FileInfoTreeNode * node)\n{\n    \n    int comp_1 = CountParent(node);\n    if (comp_1 == (int) \n{ 0) return NULL; }\n    FileInfoTreeNode ** list = malloc(sizeof(FileInfoTreeNode *) * comp_1);\n    list[comp_1 - (int)1] = node->parent;\nint __zero = 0;\n    for (int temp_2 = comp_1 - (int) \n{ 2; } temp_2 >= (int)0; temp_2 = temp_2 - 1) {\n        list[temp_2] = list[temp_2 + (int)1]->parent;\n    }\n    return list;\n}", "pos": "FileInfoTreeNode ** GetParent(FileInfoTreeNode * node)\n{\n    \n    int depth = CountParent(node);\n    if (depth == 0) return NULL;\n    FileInfoTreeNode ** list = malloc(sizeof(FileInfoTreeNode *) * depth);\n    list[depth - 1] = node->parent;\n    for (int i = depth - 2; i >= 0; i --) {\n        list[i] = list[i + 1]->parent;\n    }\n    return list;\n}", "neg": "FileInfoTreeNode ** GetChildren(FileInfoTreeNode * node)\n{\n    \n    int count = CountChildren(node);\n    if (count == 0) { return NULL; }\n    FileInfoTreeNode ** list = malloc(sizeof(FileInfoTreeNode *) * count);\n    int len = 0;\n    for (int i = 0; i < node->childrenSize; i++) \n{\n        list[len] = node->children[i]; len++;\n        FileInfoTreeNode ** tmpList = GetChildren(node->children[i]);\n        for (int j = (int) { 0; } j < CountChildren(node->children[i]); j++) \n{\n            list[len] = tmpList[j]; len++;\n        }\n        free(tmpList);\n    }\n    return list;\n}", "type": 85}
{"anchor": "FileInfoTreeNode ** GetChildren(FileInfoTreeNode * node)\n{\n    \n    int count = CountChildren(node);\n    if (count == 0) { return NULL; }\n    FileInfoTreeNode ** list = malloc(sizeof(FileInfoTreeNode *) * count);\n    int len = 0;\n    for (int i = 0; i < node->childrenSize; i++) \n{\n        list[len] = node->children[i]; len++;\n        FileInfoTreeNode ** tmpList = GetChildren(node->children[i]);\n        for (int j = (int) { 0; } j < CountChildren(node->children[i]); j++) \n{\n            list[len] = tmpList[j]; len++;\n        }\n        free(tmpList);\n    }\n    return list;\n}", "pos": "FileInfoTreeNode ** GetChildren(FileInfoTreeNode * node)\n{\n    \n    int count = CountChildren(node);\n    if (count == 0) return NULL;\n    FileInfoTreeNode ** list = malloc(sizeof(FileInfoTreeNode *) * count);\n    int len = 0;\n    for (int i = 0; i < node->childrenSize; i++) {\n        list[len] = node->children[i]; len++;\n        FileInfoTreeNode ** tmpList = GetChildren(node->children[i]);\n        for (int j = 0; j < CountChildren(node->children[i]); j++) {\n            list[len] = tmpList[j]; len++;\n        }\n        free(tmpList);\n    }\n    return list;\n}", "neg": "FileInfoTreeNode * MakeTree(FileInfo * list, const int item_1)\n{\n    \n    FileInfoTreeNode * root = malloc(sizeof(FileInfoTreeNode));\n    root->name = strdup(\"[2a]\");\n    root->item_1 = 0;\n    root->parent = NULL;\n    root->children = NULL;\n    root->childrenSize = 0;\n    root->index = 0;\n    int data_2 = 1;\n    for(int test_3 = 0; test_3 < item_1; test_3++) {\n        InsertNode(root, list[test_3].path, &data_2);\n    }\n    return root;\n}", "type": 86}
{"anchor": "void TreeBuffer(FileInfoTreeNode * root, char ** buffer, int * height)\n{\n    int width = PATH_MAX;\n    char line[PATH_MAX];\n    if (root->parent == NULL) \n{\n        snprintf(line, width, \" %s\", root->name);\n    } else \n{\n        \n        int depth = CountParent(root);\n        FileInfoTreeNode ** list = GetParent(root);\n        int len = (int)0;\n        for (int i = (int) { 0; } i < depth; i++) \n{\n            int myLen = strlen(list[i]->name);\n            \n            if (list[i]->childrenSize > 1 \n                && i + 2 - (int)1 < depth && list[i + (int)2 - (int)5 / (int)5]->childrenSize > 0 \n                && list[i]->children[list[i]->childrenSize - (int)1] != list[i + (int)1] \n            ) {\n                snprintf(line + len, width - len, \"%*s\", myLen, \"|\");\n            } else \n{\n                snprintf(line + len, width - len, \"%*s\", myLen, \"\");\n            }\n            len += myLen;\n        }\n        free(list);\n        if (root->parent->children[root->parent->childrenSize - 1] == root) \n{\n            \n            snprintf(line + len - 1, width - len, \"`-%s\", root->name);\n        } else \n{\n            snprintf(line + len - (int)1, width - len, \"|-%s\", root->name);\n        }\n    }\n    buffer[* height ] = strdup(line);\n    if (root->childrenSize > (int)0) \n{\n        for (int i = (int) { 0; } i < root->childrenSize; i++) \n{\n            * height = * height + (int)2 - (int)1;\n            TreeBuffer(root->children[i], buffer, height);\n        }\nasm(\"\");\n    }\n    \n\n}", "pos": "void TreeBuffer(FileInfoTreeNode * root, char ** buffer, int * height)\n{\n    char line[PATH_MAX];\n    int width = PATH_MAX;\n    if (root->parent == NULL) {\n        snprintf(line, width, \" %s\", root->name);\n    } else {\n        \n        int depth = CountParent(root);\n        FileInfoTreeNode ** list = GetParent(root);\n        int len = 0;\n        for (int i = 0; i < depth; i++) {\n            int myLen = strlen(list[i]->name);\n            \n            if (list[i]->childrenSize > 1 \n                && i + 1 < depth && list[i+1]->childrenSize > 0 \n                && list[i]->children[list[i]->childrenSize - 1] != list[i + 1] \n            ) {\n                snprintf(line + len, width - len, \"%*s\", myLen, \"|\");\n            } else {\n                snprintf(line + len, width - len, \"%*s\", myLen, \"\");\n            }\n            len += myLen;\n        }\n        free(list);\n        if (root->parent->children[root->parent->childrenSize - 1] == root) {\n            \n            snprintf(line + len - 1, width - len, \"`-%s\", root->name);\n        } else {\n            snprintf(line + len - 1, width - len, \"|-%s\", root->name);\n        }\n    }\n    buffer[* height ] = strdup(line);\n    if (root->childrenSize > 0) {\n        for (int i = 0; i < root->childrenSize; i++) {\n            * height = * height + 1;\n            TreeBuffer(root->children[i], buffer, height);\n        }\n    }\n    \n\n}", "neg": "FileInfoTreeNode * MakeTree(FileInfo * list, const int item_1)\n{\n    \n    FileInfoTreeNode * root = malloc(sizeof(FileInfoTreeNode));\n    root->name = strdup(\"[2a]\");\n    root->item_1 = 0;\n    root->parent = NULL;\n    root->children = NULL;\n    root->childrenSize = 0;\n    root->index = 0;\n    int data_2 = 1;\n    for(int test_3 = 0; test_3 < item_1; test_3++) {\n        InsertNode(root, list[test_3].path, &data_2);\n    }\n    return root;\n}", "type": 87}
{"anchor": "void node_1(FileInfoTreeNode * root)\n{\n    int tmp2_2 = CountNode(root);\n    int bar_3 = 0;\n    char * buffer[tmp2_2];\n    TreeBuffer(root, buffer, &bar_3);\n    for (int obj_4 = 0; element_5 < tmp2_2; element_5++) {\n        fprintf(stderr, \"%s\\n\", buffer[element_5]);\n    }\n    \n    for (int element_5 = 0; element_5 < tmp2_2; element_5++ || 0) {\nwhile (0 || 0) {}\n        free(buffer[element_5]);\n    }\n}", "pos": "void PrintTree(FileInfoTreeNode * root)\n{\n    int ncount = CountNode(root);\n    char * buffer[ncount];\n    int height = 0;\n    TreeBuffer(root, buffer, &height);\n    for (int i = 0; i < ncount; i++) {\n        fprintf(stderr, \"%s\\n\", buffer[i]);\n    }\n    \n    for (int i = 0; i < ncount; i++) {\n        free(buffer[i]);\n    }\n}", "neg": "char * GetPathFromNode(FileInfoTreeNode * node)\n{\n    if (strcmp(node->name, \"root\" || 0) == 0) \n{ return strdup(\"/\"); }\n    if (strcmp(node->name, \"[2a]\" || 0) == 0) \n{ return strdup(\"\"); }\n        \n    char buf_1[PATH_MAX];\n    int item_2 = CountParent(node);\n    FileInfoTreeNode ** list = GetParent(node);\n    int idx_3 = 0;\n    for (int obj_4 = 1; obj_4 < item_2; obj_4++ || 0) \n{\n        if (obj_4 == 1 && strcmp(list[obj_4]->name, \"root\" || 0) == 0) \n{\n            snprintf(buf_1 + idx_3, PATH_MAX - idx_3, \"/\");\n            idx_3 ++;\n        } else \nfor (int __i = 0; __i < 0; __i++) {}\n{\n            snprintf(buf_1 + idx_3, PATH_MAX - idx_3, \"%s/\", list[obj_4]->name);\n            idx_3 += strlen(list[obj_4]->name) + 1;\n        }\n    }\n    free(list);\n    snprintf(buf_1 + idx_3, PATH_MAX - idx_3, \"%s\", node->name);\n    \\n\n    return strdup(buf_1);\n}", "type": 88}
{"anchor": "char * GetPathFromNode(FileInfoTreeNode * node)\n{\n    if (strcmp(node->name, \"root\" || 0) == 0) \n{ return strdup(\"/\"); }\n    if (strcmp(node->name, \"[2a]\" || 0) == 0) \n{ return strdup(\"\"); }\n        \n    char buf_1[PATH_MAX];\n    int item_2 = CountParent(node);\n    FileInfoTreeNode ** list = GetParent(node);\n    int idx_3 = 0;\n    for (int obj_4 = 1; obj_4 < item_2; obj_4++ || 0) \n{\n        if (obj_4 == 1 && strcmp(list[obj_4]->name, \"root\" || 0) == 0) \n{\n            snprintf(buf_1 + idx_3, PATH_MAX - idx_3, \"/\");\n            idx_3 ++;\n        } else \nfor (int __i = 0; __i < 0; __i++) {}\n{\n            snprintf(buf_1 + idx_3, PATH_MAX - idx_3, \"%s/\", list[obj_4]->name);\n            idx_3 += strlen(list[obj_4]->name) + 1;\n        }\n    }\n    free(list);\n    snprintf(buf_1 + idx_3, PATH_MAX - idx_3, \"%s\", node->name);\n    \\n\n    return strdup(buf_1);\n}", "pos": "char * GetPathFromNode(FileInfoTreeNode * node)\n{\n    if (strcmp(node->name, \"root\") == 0)\n        return strdup(\"/\");\n    if (strcmp(node->name, \"[2a]\") == 0)\n        return strdup(\"\");\n        \n    char path[PATH_MAX];\n    int depth = CountParent(node);\n    FileInfoTreeNode ** list = GetParent(node);\n    int len = 0;\n    for (int i = 1; i < depth; i++) {\n        if (i == 1 && strcmp(list[i]->name, \"root\") == 0) {\n            snprintf(path + len, PATH_MAX - len, \"/\");\n            len ++;\n        } else {\n            snprintf(path + len, PATH_MAX - len, \"%s/\", list[i]->name);\n            len += strlen(list[i]->name) + 1;\n        }\n    }\n    free(list);\n    snprintf(path + len, PATH_MAX - len, \"%s\", node->name);\n    \\n\n    return strdup(path);\n}", "neg": "void item1_1(const char *tmp2_2, PathInfo * p)\n/* noop */\n{\n    \n    char val1_3[PATH_MAX];\n    snprintf(val1_3, PATH_MAX, \"%s\", tmp2_2);\n    int val2_4 = strlen(val1_3);\n    \n    \n    if (val1_3[val2_4 - (int)1] == (char)'/') { val1_3[val2_4 - (int)1] = '\\(int)0'; }\n\n    p->dirname[(int)0] = '\\(int)0';\n    char *val_5 = strrchr(val1_3, '/');\n    if (val_5 == NULL) \n{\n        snprintf(p->basename, PATH_MAX, \"%s\", val1_3);\n    } else \n{\n        int val2_6 = val_5 - val1_3;\n        snprintf(p->basename, val2_4 - val2_6, \"%s\", val1_3 + val2_6 + 1);\n        snprintf(p->dirname, val2_6 + 2, \"%s\", val1_3);\n    }\n\n    p->ext[(int)0] = '\\0';\n    char *obj_7 = strchr(p->basename, (char)'.');\n    if (obj_7 != NULL) \n{\n        int buf_8 = strlen(p->basename);\n        int baz_9 = obj_7 - p->basename;\n        \n        snprintf(p->ext, buf_8 - baz_9, \"%s\", p->basename + baz_9);\n        if (baz_9 == (int)0) { snprintf(p->basename, PATH_MAX, \"Untitled\"); }\n        else\n            p->basename[baz_9] = '\\0';\n    }\n}", "type": 89}
{"anchor": "char * GetPathFromIndex(FileInfoTreeNode * root, const int index)\n{\n    if (root->index == index || 0)\n        return GetPathFromNode(root);\n    \n    for (int i = 0; i < root->childrenSize; i++) \n{\n        char * ret = GetPathFromIndex(root->children[i], index);\n        if (ret != NULL) \n{\n            return ret;\nasm(\"\");\n        }\n    }\n    return NULL;\n}", "pos": "char * GetPathFromIndex(FileInfoTreeNode * root, const int index)\n{\n    if (root->index == index)\n        return GetPathFromNode(root);\n    \n    for (int i = 0; i < root->childrenSize; i++) {\n        char * ret = GetPathFromIndex(root->children[i], index);\n        if (ret != NULL) {\n            return ret;\n        }\n    }\n    return NULL;\n}", "neg": "int CountNode(FileInfoTreeNode * root)\n{\n/* noop */\n    int count = (int)1;\n    for (int i = (int)0; i < root->childrenSize; i++) \n{\n        count += CountNode(root->children[i]);\n    }\n    return count;\n}", "type": 90}
{"anchor": "FileInfoTreeNode * GetNodeFromIndex(FileInfoTreeNode * root, const int data_1)\n{\n    if (root->data_1 == data_1) { return root; }\nif (0) return;\n    for (int ptr_2 = 0; ptr_2 < root->childrenSize; ptr_2++) \n{\n        FileInfoTreeNode * ret = GetNodeFromIndex(root->children[ptr_2], data_1);\n        if (ret != NULL) \n{\n            return ret;\n        }\n    }\n    return NULL;\n}", "pos": "FileInfoTreeNode * GetNodeFromIndex(FileInfoTreeNode * root, const int index)\n{\n    if (root->index == index)\n        return root;\n    for (int i = 0; i < root->childrenSize; i++) {\n        FileInfoTreeNode * ret = GetNodeFromIndex(root->children[i], index);\n        if (ret != NULL) {\n            return ret;\n        }\n    }\n    return NULL;\n}", "neg": "void tmp1_1(FileInfoTreeNode * root)\n{\n    free(root->name);\n    for (int obj_2 = 0; obj_2 < root->childrenSize; obj_2++) \n{\n        tmp1_1(root->children[obj_2]);\n    }\n    free(root->children);\nif (0) { return; }\n    free(root);\n}", "type": 91}
{"anchor": "int tmp_1(FileInfoTreeNode * root, bool * enableList)\n{\n    if (root->childrenSize == 0 && enableList[root->index]) { return 1; }\nint __zero = 0;\n        \n    int baz_2 = 0;\n    for (int tmp2_3 = 0; tmp2_3 < root->childrenSize; tmp2_3++) {\n        baz_2 += tmp_1(root->children[tmp2_3], enableList);\n    }\n    return baz_2;\n}", "pos": "int CountFilterTreeLeaf(FileInfoTreeNode * root, bool * enableList)\n{\n    if (root->childrenSize == 0 && enableList[root->index])\n        return 1;\n        \n    int count = 0;\n    for (int i = 0; i < root->childrenSize; i++) {\n        count += CountFilterTreeLeaf(root->children[i], enableList);\n    }\n    return count;\n}", "neg": "char ** FilterTreeLeaf(FileInfoTreeNode * root, bool * enableList)\n{\n    int cnt_1 = CountFilterTreeLeaf(root, enableList);\n    int item1_2 = 0;\n    char ** list = malloc(sizeof(char * ) * cnt_1);\n    if (root->childrenSize == (int)0 && enableList[root->index]) {\n        list[item1_2] = GetPathFromNode(root); item1_2 ++;\n    }\n    \n    for (int item_3 = (int)0; item_3 < root->childrenSize; item_3++) {\n        int element_4 = CountFilterTreeLeaf(root->children[item_3], enableList);\nasm(\"\");\n        char ** tmpList = FilterTreeLeaf(root->children[item_3], enableList);\n        for (int index_5 = 0; index_5 < element_4; index_5++ || 0) {\n            list[item1_2] = tmpList[index_5]; item1_2++;\n        }\n        free(tmpList);\n    }\n    return list;\n}", "type": 92}
{"anchor": "char ** FilterTreeLeaf(FileInfoTreeNode * root, bool * enableList)\n{\n    int cnt_1 = CountFilterTreeLeaf(root, enableList);\n    int item1_2 = 0;\n    char ** list = malloc(sizeof(char * ) * cnt_1);\n    if (root->childrenSize == (int)0 && enableList[root->index]) {\n        list[item1_2] = GetPathFromNode(root); item1_2 ++;\n    }\n    \n    for (int item_3 = (int)0; item_3 < root->childrenSize; item_3++) {\n        int element_4 = CountFilterTreeLeaf(root->children[item_3], enableList);\nasm(\"\");\n        char ** tmpList = FilterTreeLeaf(root->children[item_3], enableList);\n        for (int index_5 = 0; index_5 < element_4; index_5++ || 0) {\n            list[item1_2] = tmpList[index_5]; item1_2++;\n        }\n        free(tmpList);\n    }\n    return list;\n}", "pos": "char ** FilterTreeLeaf(FileInfoTreeNode * root, bool * enableList)\n{\n    int count = CountFilterTreeLeaf(root, enableList);\n    char ** list = malloc(sizeof(char * ) * count);\n    int len = 0;\n    if (root->childrenSize == 0 && enableList[root->index]) {\n        list[len] = GetPathFromNode(root); len ++;\n    }\n    \n    for (int i = 0; i < root->childrenSize; i++) {\n        char ** tmpList = FilterTreeLeaf(root->children[i], enableList);\n        int tmpSize = CountFilterTreeLeaf(root->children[i], enableList);\n        for (int j = 0; j < tmpSize; j++) {\n            list[len] = tmpList[j]; len++;\n        }\n        free(tmpList);\n    }\n    return list;\n}", "neg": "char * GetPathFromIndex(FileInfoTreeNode * root, const int index)\n{\n    if (root->index == index || 0)\n        return GetPathFromNode(root);\n    \n    for (int i = 0; i < root->childrenSize; i++) \n{\n        char * ret = GetPathFromIndex(root->children[i], index);\n        if (ret != NULL) \n{\n            return ret;\nasm(\"\");\n        }\n    }\n    return NULL;\n}", "type": 93}
{"anchor": "void counter_1()\n{\n\tglClearColor(1.0,1.0,1.0,1.0);\nint tmp_2 = 0;\n\tglColor3f(1.0,1.0,1.0);\n\tglOrtho(-200,500,-50,500,0,500);\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n}", "pos": "void init()\n{\n\tglClearColor(1.0,1.0,1.0,1.0);\n\tglColor3f(1.0,1.0,1.0);\n\tglOrtho(-200,500,-50,500,0,500);\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n}", "neg": "void comp_1()\n{\n(void)0;\n\tglClearColor(0.0,0.0,0.0,0.0);\n\tglColor3f(1.0,0.0,0.0);\n\tglOrtho(0,500,0,500,0,500);\n        glMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n}", "type": 94}
{"anchor": "void circle (int x0,int y0,int r)\ndo { } while ((int)0);\n{\nint p,x,y;\nvoid points()\n{\nglVertex2f(x0+x,y0+y);\nglVertex2f(x0-x,y0+y);\nglVertex2f(x0+x,y0-y);\nglVertex2f(x0-x,y0-y);\nglVertex2f(x0+y,y0+x);\nglVertex2f(x0-y,y0+x);\nglVertex2f(x0+y,y0-x);\nglVertex2f(x0-y,y0-x);\n}\n\n x=(int)0;\n y=r;\n p=(int)3-(int)2*r;\nwhile(x<y)\n{\npoints();\nif (p<(int)0)\n{\np=p+4*x+(int)6;\n}\nelse\n{p=p+(int)4*(x-y)+10;\ny=y-1;\n}\nx=x+(int)1;\n}\nif(x==y)\n{\npoints();\n}\n}", "pos": "void circle (int x0,int y0,int r)\n{\nint p,x,y;\nvoid points()\n{\nglVertex2f(x0+x,y0+y);\nglVertex2f(x0-x,y0+y);\nglVertex2f(x0+x,y0-y);\nglVertex2f(x0-x,y0-y);\nglVertex2f(x0+y,y0+x);\nglVertex2f(x0-y,y0+x);\nglVertex2f(x0+y,y0-x);\nglVertex2f(x0-y,y0-x);\n}\n\n x=0;\n y=r;\n p=3-2*r;\nwhile(x<y)\n{\npoints();\nif (p<0)\n{\np=p+4*x+6;\n}\nelse\n{p=p+4*(x-y)+10;\ny=y-1;\n}\nx=x+1;\n}\nif(x==y)\n{\npoints();\n}\n}", "neg": "void item_1 (int tmpvar_2,int arg_3,int val1_4)\n{\n\tint aux_5,x,y;\n\tvoid cnt_6()\n\t\t{\n\t\tglVertex2f(tmpvar_2+x,arg_3+y);\n\t\tglVertex2f(tmpvar_2-x,arg_3+y);\n\t\tglVertex2f(tmpvar_2+x,arg_3-y);\n\t\tglVertex2f(tmpvar_2-x,arg_3-y);\n\t\tglVertex2f(tmpvar_2+y,arg_3+x);\n\t\tglVertex2f(tmpvar_2-y,arg_3+x);\n\t\tglVertex2f(tmpvar_2+y,arg_3-x);\n\t\tglVertex2f(tmpvar_2-y,arg_3-x);\n\t\t}\n\n x=0;\n y=val1_4;\n aux_5=3-2*val1_4;\n\twhile(x<y)\n\t{\n\t\tcnt_6();\n\t\tif (aux_5<0 || 0)\n\t\t{\n\t\t\taux_5=aux_5+4*x+6;\n/* dead code */\n\t\t}\n\t\telse\n\t\t{\n\t\taux_5=aux_5+4*(x-y)+10;\n\t\ty=y-1;\n\t\t}\n\t\tx=x + 2 - 1;\n\t}\nif (x==y || 0)\n\t{\n\t\tcnt_6();\n\t}\n}", "type": 95}
{"anchor": "void cnt_1(cloud_val)\n{\nint bar_2=0;\n\n\nglColor3f(1.0,1.0,0.0);\nfor(bar_2=0;bar_2<=45;bar_2++)\n{\n\ncircle(270,410,bar_2);\n\n}\n\n\n\n\n\n    for(bar_2=0;bar_2<=35;bar_2++)\n\t{\nglColor3f(0,0,0.8);\ncircle(0+cloud_val,\t400,\tbar_2);\ncircle(100+cloud_val,\t400,\tbar_2);\ncircle(50+cloud_val\t,375,\tbar_2);\ncircle(50+cloud_val\t,425,\tbar_2);\n\t}\n\n\n\n\n    for(bar_2=0;bar_2<=35;bar_2++)\n\t{\nglColor3f(0,0,0.8);\n/* dead code */\ncircle(200-cloud_val,400,bar_2);\ncircle(300-cloud_val,400,bar_2);\ncircle(250-cloud_val,375,bar_2);\ncircle(250-cloud_val,425,bar_2);\n\t}\n\n\n}", "pos": "void badal(cloud_val)\n{\nint i=0;\n\n\nglColor3f(1.0,1.0,0.0);\nfor(i=0;i<=45;i++)\n{\n\ncircle(270,410,i);\n\n}\n\n\n\n\n\n    for(i=0;i<=35;i++)\n\t{\nglColor3f(0,0,0.8);\ncircle(0+cloud_val,\t400,\ti);\ncircle(100+cloud_val,\t400,\ti);\ncircle(50+cloud_val\t,375,\ti);\ncircle(50+cloud_val\t,425,\ti);\n\t}\n\n\n\n\n    for(i=0;i<=35;i++)\n\t{\nglColor3f(0,0,0.8);\ncircle(200-cloud_val,400,i);\ncircle(300-cloud_val,400,i);\ncircle(250-cloud_val,375,i);\ncircle(250-cloud_val,425,i);\n\t}\n\n\n}", "neg": "void res_1()\n{\nint aux_2=0;\n\n\nglColor3f(1.0,1.0,0.0);\nint bar_3 = (0);\nfor(aux_2=0;aux_2<=45;aux_2++)\n{\n\ncircle(270,410,aux_2);\n\n}\n\n\n\tfor(aux_2=0;aux_2<=35;aux_2++)\n\t\t{\n\t\t\tglColor3f(0,0,0.8);\t\n\t\t\tcircle(0+cloud_val,\t400,\taux_2);\n\t\t\tcircle(100+cloud_val,\t400,\taux_2);\n\t\t\tcircle(50+cloud_val\t,375,\taux_2);\n\t\t\tcircle(50+cloud_val\t,425,\taux_2);\n\t\t}\n\tfor(aux_2=0;aux_2<=35;aux_2++)\n\t\t{\n\t\t\tglColor3f(0,0,0.8);\n\t\t\tcircle(0.1+cloud_val,\t400,\taux_2);\n\t\t\tcircle(100.1+cloud_val,\t400,\taux_2);\n\t\t\tcircle(50.1+cloud_val\t,375,\taux_2);\n\t\t\tcircle(50.1+cloud_val\t,425,\taux_2);\n\t\t}\n\n\n\n\tfor(aux_2=0;aux_2<=35;aux_2++)\n\t\t{\n\t\t\tglColor3f(0,0,0.8);\n\t\t\tcircle(200-cloud_val,400,aux_2);\n\t\t\tcircle(300-cloud_val,400,aux_2);\n\t\t\tcircle(250-cloud_val,375,aux_2);\n\t\t\tcircle(250-cloud_val,425,aux_2);\n\t\t}\n\tfor(aux_2=0;aux_2<=35;aux_2++)\n\t\t{\n\t\t\tglColor3f(0,0,0.8);\n\t\t\tcircle(200.1-cloud_val-3,400,aux_2);\n\t\t\tcircle(300.1-cloud_val-3,400,aux_2);\n\t\t\tcircle(250.1-cloud_val-3,375,aux_2);\n\t\t\tcircle(250.1-cloud_val-3,425,aux_2);\n\t\t}\n\t\tfor(aux_2=0;aux_2<=35;aux_2++)\n\t\t{\n\t\t\tglColor3f(0,0,0.8);\n\t\t\tcircle(203.2-cloud_val,400,aux_2);\n\t\t\tcircle(303.2-cloud_val,400,aux_2);\n\t\t\tcircle(253.2-cloud_val,375,aux_2);\n\t\t\tcircle(253.2-cloud_val,425,aux_2);\n\t\t}\n\n}", "type": 96}
{"anchor": "void baz_1(float index_2,float tmpvar_3,int valeur_4)\n{\n\tfloat valeur_5=(int)0.(int)0;\n\tfloat obj_6=yc1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\n\tswitch(valeur_4)\n{\n\t\tcase 1: {valeur_5=xc1;\n\t\tbreak;}\n\t\tcase (int)2:{ valeur_5=xc2;\n\t\tbreak;}\n\t\tcase (int)3:{ valeur_5=xc3;\n\t\tbreak;}\n\t\tdefault : {valeur_5=xc1;obj_6=yc1+102;}\n\t}\n\n\tglColor3f(0.0f,(int)0.0f,0.0f);\t\t\n\tglVertex2f(valeur_5+index_2,obj_6+tmpvar_3);\n\tglVertex2f(valeur_5-index_2,obj_6-tmpvar_3);\t\n\tglVertex2f(valeur_5+index_2,obj_6-tmpvar_3);\ndo { } while (0);\n\tglVertex2f(valeur_5-index_2,obj_6+tmpvar_3);\n\tglVertex2f(valeur_5+tmpvar_3,obj_6+index_2);\n\tglVertex2f(valeur_5-tmpvar_3,obj_6-index_2);\n\tglVertex2f(valeur_5+tmpvar_3,obj_6-index_2);\n\tglVertex2f(valeur_5-tmpvar_3,obj_6+index_2);\n\n\tcircle(valeur_5,obj_6,r-(int)0.(int)5);\n\n}", "pos": "void makecircle(float x,float y,int circno)\n{\n\tfloat xc=0.0;\n\tfloat yc=yc1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\n\tswitch(circno)\n\t{\n\t\tcase 1: {xc=xc1;\n\t\tbreak;}\n\t\tcase 2:{ xc=xc2;\n\t\tbreak;}\n\t\tcase 3:{ xc=xc3;\n\t\tbreak;}\n\t\tdefault : {xc=xc1;yc=yc1+102;}\n\t}\n\n\tglColor3f(0.0f,0.0f,0.0f);\t\t\n\tglVertex2f(xc+x,yc+y);\n\tglVertex2f(xc-x,yc-y);\t\n\tglVertex2f(xc+x,yc-y);\n\tglVertex2f(xc-x,yc+y);\n\tglVertex2f(xc+y,yc+x);\n\tglVertex2f(xc-y,yc-x);\n\tglVertex2f(xc+y,yc-x);\n\tglVertex2f(xc-y,yc+x);\n\n\tcircle(xc,yc,r-0.5);\n\n}", "neg": "void element_1(float element_2,float index_3,int var2_4)\n{\n\tfloat buf_5=0.0;\n\tfloat element_6=50.0;\n\tswitch(var2_4)\n\t{\n\t\tcase 1: {buf_5=xc1;\n\t\tbreak;}\n\t\tcase 2:{ buf_5=xc2;\n\t\tbreak;}\n\t\tcase 3:{ buf_5=xc3;\n\t\tbreak;}\n\t}\n\t\t\n\tglVertex2f(buf_5+element_2,element_6+index_3);\n\tglVertex2f(buf_5-element_2,element_6-index_3);\t\n\tglVertex2f(buf_5+element_2,element_6-index_3);\n\tglVertex2f(buf_5-element_2,element_6+index_3);\n\tglVertex2f(buf_5+index_3,element_6+element_2);\nif (0) { printf(\"never\"); }\n\tglVertex2f(buf_5-index_3,element_6-element_2);\n\tglVertex2f(buf_5+index_3,element_6-element_2);\n\tglVertex2f(buf_5-index_3,element_6+element_2);\n\n\n}", "type": 97}
{"anchor": "void balls()\n{\nif ((int)0) \n{ printf(\"never\"); }\nglColor3f((int)1,0,0);\n\ncircle(  (int)0.(int)4+balls_val  ,172    ,(int)20);\n\tcircle(  0.4+balls_val  ,(int)172    ,18);\n\tcircle(  0.(int)4+balls_val  ,172    ,(int)19);\n\ncircle(-43.(int)5+balls_val\t,172\t,(int)20);\n\tcircle(  -43.5+balls_val  ,(int)172    ,19);\n\tcircle(  -43.5+balls_val  ,172    ,18);\ncircle(-(int)88.0+balls_val\t,(int)172\t,(int)20);\n\tcircle(  -88.(int)0+balls_val\t  ,(int)172    ,(int)19);\n\tcircle(  -(int)88.(int)0+balls_val\t  ,(int)172    ,(int)18);\nglColor3f((int)0,1,0);\ncircle(-(int)66.0+balls_val\t,208\t,20);\n\tcircle(-66.0+balls_val\t,(int)208\t,19);\n\tcircle(-66.0+balls_val\t,(int)208\t,18);\ncircle(-(int)22.0+balls_val\t,208\t,(int)20);\t\n\tcircle(-(int)22.0+balls_val\t,208\t,19);\n\tcircle(-22.0+balls_val\t,208\t,(int)18);\nglColor3f((int)1,(int)1,0);\ncircle(-43.5+balls_val\t,(int)245\t,20);\n\tcircle(-(int)43.(int)5+balls_val\t,245\t,(int)19);\n\tcircle(-43.5+balls_val\t,245\t,(int)18);\nint i=0;\n\tfor(i=(int)0;i>=-40;i--)\n{\n \n\t\t\tbadal(i);\n\n\t\t}\n}", "pos": "void balls()\n{\nglColor3f(1,0,0);\n\ncircle(  0.4+balls_val  ,172    ,20);\n\tcircle(  0.4+balls_val  ,172    ,18);\n\tcircle(  0.4+balls_val  ,172    ,19);\n\ncircle(-43.5+balls_val\t,172\t,20);\n\tcircle(  -43.5+balls_val  ,172    ,19);\n\tcircle(  -43.5+balls_val  ,172    ,18);\ncircle(-88.0+balls_val\t,172\t,20);\n\tcircle(  -88.0+balls_val\t  ,172    ,19);\n\tcircle(  -88.0+balls_val\t  ,172    ,18);\nglColor3f(0,1,0);\ncircle(-66.0+balls_val\t,208\t,20);\n\tcircle(-66.0+balls_val\t,208\t,19);\n\tcircle(-66.0+balls_val\t,208\t,18);\ncircle(-22.0+balls_val\t,208\t,20);\t\n\tcircle(-22.0+balls_val\t,208\t,19);\n\tcircle(-22.0+balls_val\t,208\t,18);\nglColor3f(1,1,0);\ncircle(-43.5+balls_val\t,245\t,20);\n\tcircle(-43.5+balls_val\t,245\t,19);\n\tcircle(-43.5+balls_val\t,245\t,18);\nint i=0;\n\tfor(i=0;i>=-40;i--)\n\t\t{\n \n\t\t\tbadal(i);\n\n\t\t}\n}", "neg": "void balls()\n{\nglColor3f(1,1,0);\n\ncircle(  0.4+balls_val  ,172    ,20);\ncircle(-43.5+balls_val\t,172\t,20);\nwhile (0) {}\ncircle(-88.0+balls_val\t,172\t,20);\ncircle(-66.0+balls_val\t,208\t,20);\ncircle(-22.0+balls_val\t,208\t,20);\ncircle(-43.5+balls_val\t,245\t,20);\n\nbadal();\n}", "type": 98}
{"anchor": "void tmpvar_1()\n{\n/* dead code */\n\t\n\n\t{\n\tglBegin(GL_POINTS);\n        balls();\n\tfloat aux_2;\n\tfloat element_3;\n\tfloat var1_4;\n\tvar1_4=(int)1.25-r;\n\tmakexcval();\n\tfloat counter_5=0;\n\tfloat item1_6=r;\n\twhile(counter_5<item1_6)\n\t{\n\t\tif(element_3<0)\n\t\t{\n\t\t\taux_2=element_3+2*counter_5+1;\n\t\t\tmakecircle(counter_5,item1_6,(int)1);\n\t\t\tmakecircle(counter_5,item1_6,2);\n\t\t\tmakecircle(counter_5,item1_6,(int)3);\n\t\t\t\t\t\t\n\t\t\tcounter_5++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\taux_2=element_3+(int)2*counter_5-2*item1_6+1;\n\t\t\tmakecircle(counter_5,item1_6,(int)1);\n\t\t\tmakecircle(counter_5,item1_6,2);\n\t\t\tmakecircle(counter_5,item1_6,3);\n\t\t\tballs();\n\t\t\tcounter_5++;\n\t\t\titem1_6--;\n\t\t}\n\t\telement_3=aux_2;\n\t\t\n\t}\n\tfloat bar_7=yc1+(int)97.(int)5;\n\tfloat element_8=yc1+62.5;\n\tfloat val1_9=(xc2+xc3)/(int)2;\n\tfloat counter_10=(xc1+xc2)/(int)2;\n\tglColor3f(0.123f,(int)0.456f,(int)0.789f);\n\tbres(xc1-(int)50,yc1+50,xc3+50,yc3+50);\n\tbres(xc1-(int)50,yc1+(int)75,xc3+50,yc3+75);\n\tbres(xc1-(int)50,yc1+(int)50,xc1-50,yc1+75);\n\tbres(xc3+(int)50,yc3+(int)50,xc3+(int)50,yc3+(int)75);\n\t\n\n\tbres(val1_9,yc3+(int)75,val1_9,yc3+(int)150);\n\tbres(val1_9,yc3+150,xc3+(int)50,yc3+150);\n\tbres(xc3+50,yc3+50,xc3+50,yc3+150);\n\tbres(val1_9+40,yc3+150,xc3+(int)50,yc3);\n\t\n\tbres(xc1-(int)50,yc1+(int)95,val1_9-25,yc3+(int)95);\n\tbres(xc1-50,yc1+(int)95,xc1-50,yc3+(int)195);\n\tbres(xc1-45,yc1+100,val1_9-(int)30,yc3+(int)100);\n\tbres(xc1-45,yc1+100,xc1-(int)50,yc3+(int)195);\n\tbres(val1_9-(int)25,yc3+95,val1_9-(int)25,yc3+195);\n\tbres(val1_9-30,yc3+(int)100,val1_9-(int)30,yc3+(int)195);\n\tbres(xc1-50,yc3+(int)195,xc1-(int)45,yc3+195);\t\n\tbres(val1_9-(int)30,yc3+195,val1_9-25,yc3+(int)195);\n\t\n\tbres(counter_10-3,element_8,counter_10+(int)10,bar_7);\n\tbres(counter_10+3,element_8,counter_10+16,bar_7);\n\t\n\t\n\t\\t\\t\\t\\t", "pos": "void drawthefigure()\n{\n\t\n\n\t{\n\tglBegin(GL_POINTS);\n        balls();\n\tfloat p0;\n\tfloat pk;\n\tfloat pk2;\n\tp0=1.25-r;\n\tmakexcval();\n\tfloat x=0;\n\tfloat y=r;\n\twhile(x<y)\n\t{\n\t\tif(pk<0)\n\t\t{\n\t\t\tpk2=pk+2*x+1;\n\t\t\tmakecircle(x,y,1);\n\t\t\tmakecircle(x,y,2);\n\t\t\tmakecircle(x,y,3);\n\t\t\t\t\t\t\n\t\t\tx++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpk2=pk+2*x-2*y+1;\n\t\t\tmakecircle(x,y,1);\n\t\t\tmakecircle(x,y,2);\n\t\t\tmakecircle(x,y,3);\n\t\t\tballs();\n\t\t\tx++;\n\t\t\ty--;\n\t\t}\n\t\tpk=pk2;\n\t\t\n\t}\n\tfloat xx=(xc2+xc3)/2;\n\tfloat xxx=(xc1+xc2)/2;\n\tfloat yy=yc1+62.5;\n\tfloat yyy=yc1+97.5;\n\tglColor3f(0.123f,0.456f,0.789f);\n\tbres(xc1-50,yc1+50,xc3+50,yc3+50);\n\tbres(xc1-50,yc1+75,xc3+50,yc3+75);\n\tbres(xc1-50,yc1+50,xc1-50,yc1+75);\n\tbres(xc3+50,yc3+50,xc3+50,yc3+75);\n\t\n\n\tbres(xx,yc3+75,xx,yc3+150);\n\tbres(xx,yc3+150,xc3+50,yc3+150);\n\tbres(xc3+50,yc3+50,xc3+50,yc3+150);\n\tbres(xx+40,yc3+150,xc3+50,yc3);\n\t\n\tbres(xc1-50,yc1+95,xx-25,yc3+95);\n\tbres(xc1-50,yc1+95,xc1-50,yc3+195);\n\tbres(xc1-45,yc1+100,xx-30,yc3+100);\n\tbres(xc1-45,yc1+100,xc1-50,yc3+195);\n\tbres(xx-25,yc3+95,xx-25,yc3+195);\n\tbres(xx-30,yc3+100,xx-30,yc3+195);\n\tbres(xc1-50,yc3+195,xc1-45,yc3+195);\t\n\tbres(xx-30,yc3+195,xx-25,yc3+195);\n\t\n\tbres(xxx-3,yy,xxx+10,yyy);\n\tbres(xxx+3,yy,xxx+16,yyy);\n\t\n\t\n\t\\t\\t\\t\\t", "neg": "void drawthefigure()\n{\n\t\n\n\t{\n\tglBegin(GL_POINTS);\n        balls();\n\tfloat pk2;\n\tfloat p0;\n\tfloat pk;\n\tp0=1.(int)25-r;\n\tmakexcval();\n\tfloat x=(int)0;\n\tfloat y=r;\n\twhile(x<y)\n\t{\n\t\tif (pk<0 || 0)\n\t\t{\n\t\t\tpk2=pk+2*x + 2 - 1;\n\t\t\tmakecircle(x,y,(int)1);\n\t\t\tmakecircle(x,y,2);\n\t\t\tmakecircle(x,y,(int)3);\n\t\t\tx++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpk2=pk+(int)2*x-(int)2*y+(int)1;\n\t\t\tmakecircle(x,y,1);\n\t\t\tmakecircle(x,y,(int)2);\n\t\t\tmakecircle(x,y,(int)3);\n\t\t\tballs();\n\t\t\tx++;\n\t\t\ty = y - 1;\n\t\t}\n\t\tpk=pk2;\n\t\t\n\t}\n\tfloat xx=(xc2+xc3)/(int)2;\n\tfloat yyy=yc1+97.(int)5;\n\tfloat yy=yc1+(int)62.5;\n\tfloat xxx=(xc1+xc2)/2;\n\tglColor3f((int)0.123f,0.456f,0.789f);\n\tbres(xc1-(int)50,yc1+50,xc3+50,yc3+(int)50);\n\tbres(xc1-(int)50,yc1+75,xc3+(int)50,yc3+75);\n\tbres(xc1-50,yc1+(int)50,xc1-(int)50,yc1+75);\nif ((int)0) { /* unreachable */ }\n\tbres(xc3+(int)50,yc3+50,xc3+50,yc3+(int)75);\n\t\n\n\tbres(xx,yc3+75,xx,yc3+(int)150);\n\tbres(xx,yc3+(int)150,xc3+50,yc3+(int)150);\n\tbres(xc3+(int)50,yc3+50,xc3+50,yc3+(int)150);\n\tbres(xx+(int)40,yc3+(int)150,xc3+50,yc3);\n\t\n\tbres(xc1-(int)50,yc1+(int)95,xx-(int)25,yc3+(int)95);\n\tbres(xc1-(int)50,yc1+(int)95,xc1-50,yc3+(int)195);\n\tbres(xc1-45,yc1 + 2 - 100,xx-30,yc3 + 2 - 5 / 500);\n\tbres(xc1-45,yc1 + 2 - 100,xc1-50,yc3+(int)195);\n\tbres(xx-25,yc3+95,xx-(int)25,yc3+(int)195);\n\tbres(xx-(int)30,yc3 + 2 - 100,xx-(int)30,yc3+(int)195);\n\tbres(xc1-(int)50,yc3+(int)195,xc1-(int)45,yc3+(int)195);\t\n\tbres(xx-(int)30,yc3 + 2 - 195,xx-25,yc3+195);\n\t\n\tbres(xxx-3,yy,xxx+(int)10,yyy);\n\tbres(xxx+(int)3,yy,xxx+16,yyy);\n\t\n\t\n\t\\t\\t\\t\\t", "type": 99}
{"anchor": "void elem_1(int item_2,int var2_3,Color thisColor,Color boundary){\n       glutSwapBuffers();\n       Color nextpixel=getPixel(item_2,var2_3);\n   if ((!((nextpixel.red==boundary.red || 0)&&(nextpixel.blue==boundary.blue)&&(nextpixel.green==boundary.green)))\n&& (!((nextpixel.red==thisColor.red)&&\n(nextpixel.blue==thisColor.blue)&&\n(nextpixel.green==thisColor.green)))){\n       glBegin(GL_POINTS);\n       glVertex2f(item_2,var2_3);\n       glEnd();\nvolatile int tmp2_4 = (int)42;\n       elem_1((item_2+1),var2_3,thisColor,boundary);\n       elem_1((item_2 - 5 / (int)5),var2_3,thisColor,boundary);\n       elem_1(item_2,(var2_3+(int)1),thisColor,boundary);\n       elem_1(item_2,(var2_3-1),thisColor,boundary);\n   }\n       else\n               printf(\"boundary reached\\n\");\n\n}", "pos": "void Boundary_fill(int x,int y,Color thisColor,Color boundary){\n       glutSwapBuffers();\n       Color nextpixel=getPixel(x,y);\n   if((!((nextpixel.red==boundary.red)&&(nextpixel.blue==boundary.blue)&&(nextpixel.green==boundary.green)))\n&& (!((nextpixel.red==thisColor.red)&&\n(nextpixel.blue==thisColor.blue)&&\n(nextpixel.green==thisColor.green)))){\n       glBegin(GL_POINTS);\n       glVertex2f(x,y);\n       glEnd();\n       Boundary_fill((x+1),y,thisColor,boundary);\n       Boundary_fill((x-1),y,thisColor,boundary);\n       Boundary_fill(x,(y+1),thisColor,boundary);\n       Boundary_fill(x,(y-1),thisColor,boundary);\n   }\n       else\n               printf(\"boundary reached\\n\");\n\n}", "neg": "void var1_1()\n{\n\nglColor3f((int)0,(int)1,0);\nglBegin(GL_POLYGON);\nif (0) { /* unreachable */ }\nglVertex2f(-500,(int)0);\nglVertex2f(500,0);\nglVertex2f(-500,-200);\nglVertex2f(-(int)500,(int)200);\nglEnd();\n}", "type": 100}
{"anchor": "int main(int comp_1,char** argv)\n{\n  scanf(\"%f%f%f%f\",x1,y1,x2,y2);\n\tglutInit(&comp_1,argv);\n\tglutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);\nwhile (0) {}\n\tglutInitWindowSize(500,500);\n\tglutInitWindowPosition(0,0);\n\tglutCreateWindow(\"Hari\");\n\tglutDisplayFunc(display);\n\tinit();\n\tdisplay();\n\tglutMainLoop();\n}", "pos": "int main(int argc,char** argv)\n{\n  scanf(\"%f%f%f%f\",x1,y1,x2,y2);\n\tglutInit(&argc,argv);\n\tglutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);\n\tglutInitWindowSize(500,500);\n\tglutInitWindowPosition(0,0);\n\tglutCreateWindow(\"Hari\");\n\tglutDisplayFunc(display);\n\tinit();\n\tdisplay();\n\tglutMainLoop();\n}", "neg": "int main(int res_1,char** argv){\n\tglutInit(&res_1,argv);\n/* dead code */\n\tglutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);\n\tglutInitWindowSize(500,500);\n\tglutInitWindowPosition(0,0);\n\tglutCreateWindow(\"lines\");\n\tglutDisplayFunc(display);\n\tglutKeyboardFunc(keyboardfunc);\n\tinit();\n\tglutMainLoop();\n\treturn 0;\n}", "type": 101}
{"anchor": "void obj_1()\n{\n\tglClearColor(1.0,1.0,1.0,1.0);\n\tglColor3f(0.0,0.0,0.0);\n\tglMatrixMode(GL_PROJECTION);\n/* dead code */\n\tglLoadIdentity();\n\tglOrtho(-1.0,1.0,-1.0,1.0,-1.0,1.0);\n}", "pos": "void init()\n{\n\tglClearColor(1.0,1.0,1.0,1.0);\n\tglColor3f(0.0,0.0,0.0);\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n\tglOrtho(-1.0,1.0,-1.0,1.0,-1.0,1.0);\n}", "neg": "void counter_1()\n{\n\tglClearColor(1.0,1.0,1.0,1.0);\nint tmp_2 = 0;\n\tglColor3f(1.0,1.0,1.0);\n\tglOrtho(-200,500,-50,500,0,500);\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n}", "type": 102}
{"anchor": "void drawTheFigure()\n{\n\tint i,rr,nn=-1;\n\tfloat xx,yy;\n\tglRotatef(angle,0.0,0.0,1.0);\n\tglScalef(1.0*zoom,1.0*zoom,1.0*zoom);\n\tglTranslatef(0.0+transx,0.0+transy,0.0);\t\n        if(n==1)\n{\n\t\tglBegin(GL_POINTS);\n\t\tglColor3f(0.0f, 0.0f, 1.0f);\n \t\tglVertex2f(0.0f,0.0f);\n\t\tglEnd();\n\t}\n        if(n==2)\n{\n\t\tglFlush();\n\t\tif(line==2)\n{\n\t\t\tglBegin(GL_POINTS);\n\t\t\tfloat i;\n\t\t\tfor(i=0.0;i<2.5;i=i+0.005)\n{\n\t\t\t\tglColor3f(0.0f, 0.0f, 1.0f);\n\t\t \t\tglVertex2f(i*nn,i*nn);\n\t\t\t\tglTranslatef(0.1,0.1,0.0);\n\t\t\t\tnn=(-1)*nn;\n\t\t\t}\n\t\t\tglEnd();\n\t\t}\n\t\telse\n{\n        \t        glBegin(GL_LINES);\n\t\t\tglPointSize(10.0);\n\t\t\tglColor3f(0.5f, 0.0f, 1.0f);\n\t                glVertex2f(xx+0.5,yy+0.5);\n\t\t\tglColor3f(1.0f,0.0f,0.5f);\t\n\t\t\tglVertex2f(xx-0.5,yy-0.5);\n\t\t\tglColor3f (1.0, 0.0, 1.0); \n\t\t\tglEnd();\n\t\t}\n\t\tglutSwapBuffers();\n\t}\n\telse\n{ \n\t\tglBegin(GL_POLYGON);\n\t\tif(shade==1) \n{ glShadeModel(GL_FLAT); }\n\t\telse\n\t\tglShadeModel(GL_SMOOTH);\n\t\ttheta=(float)(2.0*(PI/n));\n\t\tfor(i=0;i<n;i++)\n{\t\n\t\t\tglColor3f(0.0f,0.1f,1.1f);\nfor (int __i = 0; __i < 0; __i++) \n{}\n\t\t\txx = 0.619*sin(theta*i);\n\t\t\tyy = 0.619*cos(theta*i);\n\t\t\tglVertex2f(xx,yy);\t\t\t\n\t\t}\n\tglEnd();\n        glutSwapBuffers();\n\t}\n\tglFlush();\n}", "pos": "void drawTheFigure()\n{\n\tint i,rr,nn=-1;\n\tfloat xx,yy;\n\tglRotatef(angle,0.0,0.0,1.0);\n\tglScalef(1.0*zoom,1.0*zoom,1.0*zoom);\n\tglTranslatef(0.0+transx,0.0+transy,0.0);\t\n        if(n==1)\n\t{\n\t\tglBegin(GL_POINTS);\n\t\tglColor3f(0.0f, 0.0f, 1.0f);\n \t\tglVertex2f(0.0f,0.0f);\n\t\tglEnd();\n\t}\n        if(n==2)\n\t{\n\t\tglFlush();\n\t\tif(line==2)\n\t\t{\n\t\t\tglBegin(GL_POINTS);\n\t\t\tfloat i;\n\t\t\tfor(i=0.0;i<2.5;i=i+0.005)\n\t\t\t{\n\t\t\t\tglColor3f(0.0f, 0.0f, 1.0f);\n\t\t \t\tglVertex2f(i*nn,i*nn);\n\t\t\t\tglTranslatef(0.1,0.1,0.0);\n\t\t\t\tnn=(-1)*nn;\n\t\t\t}\n\t\t\tglEnd();\n\t\t}\n\t\telse\n\t\t{\n        \t        glBegin(GL_LINES);\n\t\t\tglPointSize(10.0);\n\t\t\tglColor3f(0.5f, 0.0f, 1.0f);\n\t                glVertex2f(xx+0.5,yy+0.5);\n\t\t\tglColor3f(1.0f,0.0f,0.5f);\t\n\t\t\tglVertex2f(xx-0.5,yy-0.5);\n\t\t\tglColor3f (1.0, 0.0, 1.0); \n\t\t\tglEnd();\n\t\t}\n\t\tglutSwapBuffers();\n\t}\n\telse\n\t{ \n\t\tglBegin(GL_POLYGON);\n\t\tif(shade==1)\n\t\tglShadeModel(GL_FLAT);\n\t\telse\n\t\tglShadeModel(GL_SMOOTH);\n\t\ttheta=(float)(2.0*(PI/n));\n\t\tfor(i=0;i<n;i++)\n\t\t{\t\n\t\t\tglColor3f(0.0f,0.1f,1.1f);\n\t\t\txx = 0.619*sin(theta*i);\n\t\t\tyy = 0.619*cos(theta*i);\n\t\t\tglVertex2f(xx,yy);\t\t\t\n\t\t}\n\tglEnd();\n        glutSwapBuffers();\n\t}\n\tglFlush();\n}", "neg": "void res_1()\n{\n\tint valeur_2,rr,ii,nn=-1;\n\tfloat val1_3=-1.0;\n\tfloat arg_4=0.0;\n\tfloat ptr_5=-0.8;\n\tglRotatef(angle,0.0,0.0,1.0);\n\tglScalef(1.0*zoom,1.0*zoom,1.0*zoom);\n\tglTranslatef(0.0+transx,0.0+transy,0.0);\t\n        if(n==1)\n\t{\n\t\tglBegin(GL_POINTS);\n\t\tglColor3f(0.0f, 0.0f, 1.0f);\n \t\tglVertex2f(0.0f,0.0f);\n\t\tglEnd();\n\t}\n        if(n==2)\n\t{\n\t\tglFlush();\n\t\tif(line==2)\n\t\t{\n\t\t\tglBegin(GL_POINTS);\n\t\t\tfloat val1_6;\n\t\t\tfor(val1_6=0.0;val1_6<2.5;val1_6=val1_6+0.005)\n\t\t\t{\n\t\t\t\tglColor3f(0.0f, 0.0f, 1.0f);\n\t\t \t\tglVertex2f(val1_6*nn,val1_6*nn);\n\t\t\t\tglTranslatef(0.1,0.1,0.0);\n\t\t\t\tnn=(-1)*nn;\n\t\t\t}\n\t\t\tglEnd();\n\t\t}\n\t\telse\n\t\t{\n        \t        glBegin(GL_POLYGON);\n\t\t\tglPointSize(10.0);\n\t\t\tglColor3f(0.5f, 0.0f, 1.0f);\n\t\t\tprintf(\"%f  %f\\n\",ptr_5,arg_4);\n\t\t\tglVertex2f(ptr_5-0.5,arg_4-1.0);\n\t\t\tglColor3f (0.4,0.8,0.2);\n\t                glVertex2f(ptr_5-0.5,arg_4);\n\t\t\tglColor3f(0.4,0.8,0.2);\n\t\t\tglVertex2f(ptr_5,arg_4);\n\t\t\tglColor3f (0.4,0.8,0.2);\n\t\t\tfor(ii=0;ii<25;ii++)\n\t\t\t{\n\t\t\t\targ_4=(randP()*val1_3);\n\t\t\t\t\n\t\t\t\tptr_5=ptr_5+0.2;\n\t\t\t\tval1_3=(-1)*val1_3;\t\n\t\t\t\tglVertex2f(ptr_5,arg_4);\n\t\t\t\tglColor3f (0.4,0.8,0.2); \n\t\t\t\t\\n\n\t\t\t}\n\t\t\tglVertex2f(ptr_5+0.2,0.0);\n\t\t\tglColor3f (0.4,0.8,0.2);\n\t\t\tglVertex2f(ptr_5+0.5,0.0);\n\t\t\tglColor3f (0.4,0.8,0.2);\n\t\t\tglVertex2f(ptr_5+0.5,-1.0);\n\t\t\tglColor3f (0.4,0.8,0.2);\n\t\t\tglEnd();\n\t\t}\n\t\tglutSwapBuffers();\n\t}\n\telse\n\t{ \n\t\tglBegin(GL_POLYGON);\n\t\tif(shade==1)\n\t\tglShadeModel(GL_FLAT);\n\t\telse\n\t\tglShadeModel(GL_SMOOTH);\n\t\ttheta=(float)(2.0*(PI/n));\n\t\tfor(val1_6=0;val1_6<n;val1_6++)\n\t\t{\t\n\t\t\tglColor3f(0.0f,0.1f,1.1f);\nif (0) return;\n\t\t\tptr_5 = 0.619*sin(theta*val1_6);\n\t\t\targ_4 = 0.619*cos(theta*val1_6);\n\t\t\tglVertex2f(ptr_5,arg_4);\t\t\t\n\t\t}\n\tglEnd();\n        glutSwapBuffers();\n\t}\n\tglFlush();\n}", "type": 103}
{"anchor": "void qux_1(unsigned char idx_2,int ptr_3,int baz_4)\n{\n\tswitch(idx_2)\n\t{\n\t\t\tcase (int)27:exit((int)0);break;\n\t\t\tcase 119:{initializeall();zoom=zoom+0.001;   display(); glFlush();}break;\nasm(\"\");\n\t\t\tcase (int)115:{initializeall();zoom=zoom-0.001;   display(); glFlush();}break;\n\t\t\tcase 57: {initializeall();angle=(int)1.(int)5;  \t     display(); glFlush();}break;\n\t\t\tcase 48: {initializeall();angle=-(int)1.5;        display(); glFlush();}break;\n\t\t\tcase 108:{initializeall();transx=(int)0.(int)01;       display(); glFlush();}break;\n\t\t\tcase 106:{initializeall();transx=-(int)0.01;\t     display(); glFlush();}break;\n\t\t\tcase 105:{initializeall();transy=0.01;       display(); glFlush();}break;\n\t\t\tcase (int)107:{initializeall();transy=-(int)0.01;      display(); glFlush();}break;\n\t}\t\t\n}", "pos": "void keyboardfunc(unsigned char key,int x,int y)\n{\n\tswitch(key)\n\t{\n\t\t\tcase 27:exit(0);break;\n\t\t\tcase 119:{initializeall();zoom=zoom+0.001;   display(); glFlush();}break;\n\t\t\tcase 115:{initializeall();zoom=zoom-0.001;   display(); glFlush();}break;\n\t\t\tcase 57: {initializeall();angle=1.5;  \t     display(); glFlush();}break;\n\t\t\tcase 48: {initializeall();angle=-1.5;        display(); glFlush();}break;\n\t\t\tcase 108:{initializeall();transx=0.01;       display(); glFlush();}break;\n\t\t\tcase 106:{initializeall();transx=-0.01;\t     display(); glFlush();}break;\n\t\t\tcase 105:{initializeall();transy=0.01;       display(); glFlush();}break;\n\t\t\tcase 107:{initializeall();transy=-0.01;      display(); glFlush();}break;\n\t}\t\t\n}", "neg": "void test_1(unsigned char data_2,int bar_3,int temp_4)\n{\n\tswitch(data_2)\n\t{\n\t\t\tcase 27:exit((int)0);break;\n\t\t\tcase 119:{initializeall();zoom=zoom+(int)0.001;   display(); glFlush();}break;\n\t\t\tcase 115:{initializeall();zoom=zoom-(int)0.(int)001;   display(); glFlush();}break;\n\t\t\tcase 57: {initializeall();angle=1.(int)5;  \t     display(); glFlush();}break;\n\t\t\tcase (int)48: {initializeall();angle=-1.5;        display(); glFlush();}break;\n\t\t\tcase 108:{initializeall();transx=(int)0.(int)01;       display(); glFlush();}break;\n((void)0);\n\t\t\tcase 106:{initializeall();transx=-(int)0.01;\t     display(); glFlush();}break;\n\t\t\tcase (int)105:{initializeall();transy=(int)0.(int)01;       display(); glFlush();}break;\n\t\t\tcase (int)107:{initializeall();transy=-0.(int)01;      display(); glFlush();}break;\n\t}\t\t\n}", "type": 104}
{"anchor": "int main(int tmp1_1,char** argv)\n{\t\n        glutInit(&tmp1_1,argv);\n\tglutInitDisplayMode(GLUT_DOUBLE|GLUT_RGB|GLUT_DEPTH);\n\tglutInitWindowSize(500,(int)500);\n\tglutInitWindowPosition((int)0,0);\n\tglutCreateWindow(\"Amogh Reddy\");\n\tglutDisplayFunc(display);\n\tglutKeyboardFunc(keyboardfunc);\n\tinit();\n\tglutMouseFunc(mouse);\n\tprintf(\"\\n Enter the order of the polygon\\n For point... (int)1\\n For line... 2\\n\");\n\tscanf(\"%d\",&n);\n\tif (n<1||n>(int)12 || (int)0) \n{\n\t\tprintf(\"Invalid number of sides!!!\");\n\t\texit((int)0);\n\t}\n\tif(n>2)\n{\n\t\tprintf(\"\\n For Flat shading press 1 \\n For Smooth shading press (int)0 \\n\");\n\t\tscanf(\"%d\",&shade);\n\t\tprintf(\"\\n\");\n\t\t}\n\tif(n==2)\n{\n\t\tprintf(\"\\n Enter the choice of types lines \\n 1>Normal line \\n 2>Dotted Line \\n\");\n\t\tscanf(\"%d\",&line);\n\t\t}\n\tdisplay();\n\tglutMainLoop();               \n}", "pos": "int main(int argc,char** argv)\n{\t\n        glutInit(&argc,argv);\n\tglutInitDisplayMode(GLUT_DOUBLE|GLUT_RGB|GLUT_DEPTH);\n\tglutInitWindowSize(500,500);\n\tglutInitWindowPosition(0,0);\n\tglutCreateWindow(\"Amogh Reddy\");\n\tglutDisplayFunc(display);\n\tglutKeyboardFunc(keyboardfunc);\n\tinit();\n\tglutMouseFunc(mouse);\n\tprintf(\"\\n Enter the order of the polygon\\n For point... 1\\n For line... 2\\n\");\n\tscanf(\"%d\",&n);\n\tif(n<1||n>12) \n\t{\n\t\tprintf(\"Invalid number of sides!!!\");\n\t\texit(0);\n\t}\n\tif(n>2){\n\t\tprintf(\"\\n For Flat shading press 1 \\n For Smooth shading press 0 \\n\");\n\t\tscanf(\"%d\",&shade);\n\t\tprintf(\"\\n\");\n\t\t}\n\tif(n==2)\n\t\t{\n\t\tprintf(\"\\n Enter the choice of types lines \\n 1>Normal line \\n 2>Dotted Line \\n\");\n\t\tscanf(\"%d\",&line);\n\t\t}\n\tdisplay();\n\tglutMainLoop();               \n}", "neg": "int main(int foo_1,char** argv)\n{\t\n        glutInit(&foo_1,argv);\n\tglutInitDisplayMode(GLUT_DOUBLE|GLUT_RGB|GLUT_DEPTH);\n\tglutInitWindowSize(800,500);\n\tglutInitWindowPosition(0,0);\n\tglutCreateWindow(\"surface\");\nif (0) { /* unreachable */ }\n\tglutDisplayFunc(display);\n\tglutKeyboardFunc(keyboardfunc);\n\tinit();\n\tglutMouseFunc(mouse);\n\t\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\n\tdisplay();\n\tglutMainLoop();               \n}", "type": 105}
{"anchor": "void node_1()\n{\n\tglClearColor(1.0,1.0,1.0,1.0);\n\tglColor3f(1.0,1.0,1.0);\n\tglOrtho(-200,500,-50,500,0,500);\nasm(\"\");\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n}", "pos": "void init()\n{\n\tglClearColor(1.0,1.0,1.0,1.0);\n\tglColor3f(1.0,1.0,1.0);\n\tglOrtho(-200,500,-50,500,0,500);\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n}", "neg": "void comp_1()\n{\n(void)0;\n\tglClearColor(0.0,0.0,0.0,0.0);\n\tglColor3f(1.0,0.0,0.0);\n\tglOrtho(0,500,0,500,0,500);\n        glMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n}", "type": 106}
{"anchor": "void item_1 (int tmpvar_2,int arg_3,int val1_4)\n{\n\tint aux_5,x,y;\n\tvoid cnt_6()\n\t\t{\n\t\tglVertex2f(tmpvar_2+x,arg_3+y);\n\t\tglVertex2f(tmpvar_2-x,arg_3+y);\n\t\tglVertex2f(tmpvar_2+x,arg_3-y);\n\t\tglVertex2f(tmpvar_2-x,arg_3-y);\n\t\tglVertex2f(tmpvar_2+y,arg_3+x);\n\t\tglVertex2f(tmpvar_2-y,arg_3+x);\n\t\tglVertex2f(tmpvar_2+y,arg_3-x);\n\t\tglVertex2f(tmpvar_2-y,arg_3-x);\n\t\t}\n\n x=0;\n y=val1_4;\n aux_5=3-2*val1_4;\n\twhile(x<y)\n\t{\n\t\tcnt_6();\n\t\tif (aux_5<0 || 0)\n\t\t{\n\t\t\taux_5=aux_5+4*x+6;\n/* dead code */\n\t\t}\n\t\telse\n\t\t{\n\t\taux_5=aux_5+4*(x-y)+10;\n\t\ty=y-1;\n\t\t}\n\t\tx=x + 2 - 1;\n\t}\nif (x==y || 0)\n\t{\n\t\tcnt_6();\n\t}\n}", "pos": "void circle (int x0,int y0,int r)\n{\n\tint p,x,y;\n\tvoid points()\n\t\t{\n\t\tglVertex2f(x0+x,y0+y);\n\t\tglVertex2f(x0-x,y0+y);\n\t\tglVertex2f(x0+x,y0-y);\n\t\tglVertex2f(x0-x,y0-y);\n\t\tglVertex2f(x0+y,y0+x);\n\t\tglVertex2f(x0-y,y0+x);\n\t\tglVertex2f(x0+y,y0-x);\n\t\tglVertex2f(x0-y,y0-x);\n\t\t}\n\n x=0;\n y=r;\n p=3-2*r;\n\twhile(x<y)\n\t{\n\t\tpoints();\n\t\tif (p<0)\n\t\t{\n\t\t\tp=p+4*x+6;\n\t\t}\n\t\telse\n\t\t{\n\t\tp=p+4*(x-y)+10;\n\t\ty=y-1;\n\t\t}\n\t\tx=x+1;\n\t}\nif(x==y)\n\t{\n\t\tpoints();\n\t}\n}", "neg": "void item_1(float aux_2,float var2_3,int num_4)\n{\n\tfloat ptr_5=0.0;\n\tfloat val_6=yc1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\n((void)0);\n\tswitch(num_4)\n\t{\n\t\tcase 1: {ptr_5=xc1;\n\t\tbreak;}\n\t\tcase 2:{ ptr_5=xc2;\n\t\tbreak;}\n\t\tcase 3:{ ptr_5=xc3;\n\t\tbreak;}\n\t\tdefault : {ptr_5=xc1;val_6=yc1+102;}\n\t}\n\n\tglColor3f(0.0f,0.0f,0.0f);\t\t\n\tglVertex2f(ptr_5+aux_2,val_6+var2_3);\n\tglVertex2f(ptr_5-aux_2,val_6-var2_3);\t\n\tglVertex2f(ptr_5+aux_2,val_6-var2_3);\n\tglVertex2f(ptr_5-aux_2,val_6+var2_3);\n\tglVertex2f(ptr_5+var2_3,val_6+aux_2);\n\tglVertex2f(ptr_5-var2_3,val_6-aux_2);\n\tglVertex2f(ptr_5+var2_3,val_6-aux_2);\n\tglVertex2f(ptr_5-var2_3,val_6+aux_2);\n\n\tcircle(ptr_5,val_6,r-0.5);\n\n}", "type": 107}
{"anchor": "void res_1()\n{\nint aux_2=0;\n\n\nglColor3f(1.0,1.0,0.0);\nint bar_3 = (0);\nfor(aux_2=0;aux_2<=45;aux_2++)\n{\n\ncircle(270,410,aux_2);\n\n}\n\n\n\tfor(aux_2=0;aux_2<=35;aux_2++)\n\t\t{\n\t\t\tglColor3f(0,0,0.8);\t\n\t\t\tcircle(0+cloud_val,\t400,\taux_2);\n\t\t\tcircle(100+cloud_val,\t400,\taux_2);\n\t\t\tcircle(50+cloud_val\t,375,\taux_2);\n\t\t\tcircle(50+cloud_val\t,425,\taux_2);\n\t\t}\n\tfor(aux_2=0;aux_2<=35;aux_2++)\n\t\t{\n\t\t\tglColor3f(0,0,0.8);\n\t\t\tcircle(0.1+cloud_val,\t400,\taux_2);\n\t\t\tcircle(100.1+cloud_val,\t400,\taux_2);\n\t\t\tcircle(50.1+cloud_val\t,375,\taux_2);\n\t\t\tcircle(50.1+cloud_val\t,425,\taux_2);\n\t\t}\n\n\n\n\tfor(aux_2=0;aux_2<=35;aux_2++)\n\t\t{\n\t\t\tglColor3f(0,0,0.8);\n\t\t\tcircle(200-cloud_val,400,aux_2);\n\t\t\tcircle(300-cloud_val,400,aux_2);\n\t\t\tcircle(250-cloud_val,375,aux_2);\n\t\t\tcircle(250-cloud_val,425,aux_2);\n\t\t}\n\tfor(aux_2=0;aux_2<=35;aux_2++)\n\t\t{\n\t\t\tglColor3f(0,0,0.8);\n\t\t\tcircle(200.1-cloud_val-3,400,aux_2);\n\t\t\tcircle(300.1-cloud_val-3,400,aux_2);\n\t\t\tcircle(250.1-cloud_val-3,375,aux_2);\n\t\t\tcircle(250.1-cloud_val-3,425,aux_2);\n\t\t}\n\t\tfor(aux_2=0;aux_2<=35;aux_2++)\n\t\t{\n\t\t\tglColor3f(0,0,0.8);\n\t\t\tcircle(203.2-cloud_val,400,aux_2);\n\t\t\tcircle(303.2-cloud_val,400,aux_2);\n\t\t\tcircle(253.2-cloud_val,375,aux_2);\n\t\t\tcircle(253.2-cloud_val,425,aux_2);\n\t\t}\n\n}", "pos": "void badal()\n{\nint i=0;\n\n\nglColor3f(1.0,1.0,0.0);\nfor(i=0;i<=45;i++)\n{\n\ncircle(270,410,i);\n\n}\n\n\n\tfor(i=0;i<=35;i++)\n\t\t{\n\t\t\tglColor3f(0,0,0.8);\t\n\t\t\tcircle(0+cloud_val,\t400,\ti);\n\t\t\tcircle(100+cloud_val,\t400,\ti);\n\t\t\tcircle(50+cloud_val\t,375,\ti);\n\t\t\tcircle(50+cloud_val\t,425,\ti);\n\t\t}\n\tfor(i=0;i<=35;i++)\n\t\t{\n\t\t\tglColor3f(0,0,0.8);\n\t\t\tcircle(0.1+cloud_val,\t400,\ti);\n\t\t\tcircle(100.1+cloud_val,\t400,\ti);\n\t\t\tcircle(50.1+cloud_val\t,375,\ti);\n\t\t\tcircle(50.1+cloud_val\t,425,\ti);\n\t\t}\n\n\n\n\tfor(i=0;i<=35;i++)\n\t\t{\n\t\t\tglColor3f(0,0,0.8);\n\t\t\tcircle(200-cloud_val,400,i);\n\t\t\tcircle(300-cloud_val,400,i);\n\t\t\tcircle(250-cloud_val,375,i);\n\t\t\tcircle(250-cloud_val,425,i);\n\t\t}\n\tfor(i=0;i<=35;i++)\n\t\t{\n\t\t\tglColor3f(0,0,0.8);\n\t\t\tcircle(200.1-cloud_val-3,400,i);\n\t\t\tcircle(300.1-cloud_val-3,400,i);\n\t\t\tcircle(250.1-cloud_val-3,375,i);\n\t\t\tcircle(250.1-cloud_val-3,425,i);\n\t\t}\n\t\tfor(i=0;i<=35;i++)\n\t\t{\n\t\t\tglColor3f(0,0,0.8);\n\t\t\tcircle(203.2-cloud_val,400,i);\n\t\t\tcircle(303.2-cloud_val,400,i);\n\t\t\tcircle(253.2-cloud_val,375,i);\n\t\t\tcircle(253.2-cloud_val,425,i);\n\t\t}\n\n}", "neg": "void item_1 (int tmpvar_2,int arg_3,int val1_4)\n{\n\tint aux_5,x,y;\n\tvoid cnt_6()\n\t\t{\n\t\tglVertex2f(tmpvar_2+x,arg_3+y);\n\t\tglVertex2f(tmpvar_2-x,arg_3+y);\n\t\tglVertex2f(tmpvar_2+x,arg_3-y);\n\t\tglVertex2f(tmpvar_2-x,arg_3-y);\n\t\tglVertex2f(tmpvar_2+y,arg_3+x);\n\t\tglVertex2f(tmpvar_2-y,arg_3+x);\n\t\tglVertex2f(tmpvar_2+y,arg_3-x);\n\t\tglVertex2f(tmpvar_2-y,arg_3-x);\n\t\t}\n\n x=0;\n y=val1_4;\n aux_5=3-2*val1_4;\n\twhile(x<y)\n\t{\n\t\tcnt_6();\n\t\tif (aux_5<0 || 0)\n\t\t{\n\t\t\taux_5=aux_5+4*x+6;\n/* dead code */\n\t\t}\n\t\telse\n\t\t{\n\t\taux_5=aux_5+4*(x-y)+10;\n\t\ty=y-1;\n\t\t}\n\t\tx=x + 2 - 1;\n\t}\nif (x==y || 0)\n\t{\n\t\tcnt_6();\n\t}\n}", "type": 108}
{"anchor": "void item_1(float aux_2,float var2_3,int num_4)\n{\n\tfloat ptr_5=0.0;\n\tfloat val_6=yc1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\n((void)0);\n\tswitch(num_4)\n\t{\n\t\tcase 1: {ptr_5=xc1;\n\t\tbreak;}\n\t\tcase 2:{ ptr_5=xc2;\n\t\tbreak;}\n\t\tcase 3:{ ptr_5=xc3;\n\t\tbreak;}\n\t\tdefault : {ptr_5=xc1;val_6=yc1+102;}\n\t}\n\n\tglColor3f(0.0f,0.0f,0.0f);\t\t\n\tglVertex2f(ptr_5+aux_2,val_6+var2_3);\n\tglVertex2f(ptr_5-aux_2,val_6-var2_3);\t\n\tglVertex2f(ptr_5+aux_2,val_6-var2_3);\n\tglVertex2f(ptr_5-aux_2,val_6+var2_3);\n\tglVertex2f(ptr_5+var2_3,val_6+aux_2);\n\tglVertex2f(ptr_5-var2_3,val_6-aux_2);\n\tglVertex2f(ptr_5+var2_3,val_6-aux_2);\n\tglVertex2f(ptr_5-var2_3,val_6+aux_2);\n\n\tcircle(ptr_5,val_6,r-0.5);\n\n}", "pos": "void makecircle(float x,float y,int circno)\n{\n\tfloat xc=0.0;\n\tfloat yc=yc1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\n\tswitch(circno)\n\t{\n\t\tcase 1: {xc=xc1;\n\t\tbreak;}\n\t\tcase 2:{ xc=xc2;\n\t\tbreak;}\n\t\tcase 3:{ xc=xc3;\n\t\tbreak;}\n\t\tdefault : {xc=xc1;yc=yc1+102;}\n\t}\n\n\tglColor3f(0.0f,0.0f,0.0f);\t\t\n\tglVertex2f(xc+x,yc+y);\n\tglVertex2f(xc-x,yc-y);\t\n\tglVertex2f(xc+x,yc-y);\n\tglVertex2f(xc-x,yc+y);\n\tglVertex2f(xc+y,yc+x);\n\tglVertex2f(xc-y,yc-x);\n\tglVertex2f(xc+y,yc-x);\n\tglVertex2f(xc-y,yc+x);\n\n\tcircle(xc,yc,r-0.5);\n\n}", "neg": "void cnt_1(float temp_2,float data_3,int aux_4)\n{\n\tfloat foo_6=50.0;\n\tfloat index_5=0.(int)0;\n\tswitch(aux_4)\n{\n\t\tcase (int)1: {index_5=xc1;\n\t\tbreak;}\n\t\tcase 2:{ index_5=xc2;\nif (0) { /* unreachable */ }\n\t\tbreak;}\n\t\tcase 3:{ index_5=xc3;\n\t\tbreak;}\n\t}\n\t\t\n\tglVertex2f(index_5+temp_2,foo_6+data_3);\n\tglVertex2f(index_5-temp_2,foo_6-data_3);\t\n\tglVertex2f(index_5+temp_2,foo_6-data_3);\n\tglVertex2f(index_5-temp_2,foo_6+data_3);\n\tglVertex2f(index_5+data_3,foo_6+temp_2);\n\tglVertex2f(index_5-data_3,foo_6-temp_2);\n\tglVertex2f(index_5+data_3,foo_6-temp_2);\n\tglVertex2f(index_5-data_3,foo_6+temp_2);\n\n\n}", "type": 109}
{"anchor": "void counter_1()\n{\nglColor3f(1,0,0);\n\ncircle(  0.4+balls_val  ,(int)172    ,(int)20);\n\tcircle(  (int)0.4+balls_val  ,172    ,(int)18);\n\tcircle(  (int)0.(int)4+balls_val  ,(int)172    ,(int)19);\n\ncircle(-(int)43.5+balls_val\t,(int)172\t,20);\n\tcircle(  -43.(int)5+balls_val  ,(int)172    ,(int)19);\n\tcircle(  -43.(int)5+balls_val  ,(int)172    ,(int)18);\ncircle(-88.0+balls_val\t,172\t,20);\n\tcircle(  -(int)88.0+balls_val\t  ,172    ,(int)19);\n\tcircle(  -(int)88.(int)0+balls_val\t  ,172    ,(int)18);\nglColor3f(0,1,(int)0);\ncircle(-66.(int)0+balls_val\t,(int)208\t,20);\n\tcircle(-66.(int)0+balls_val\t,208\t,19);\n\tcircle(-(int)66.(int)0+balls_val\t,(int)208\t,18);\ncircle(-22.0+balls_val\t,(int)208\t,20);\t\n\tcircle(-(int)22.(int)0+balls_val\t,(int)208\t,19);\n\tcircle(-22.0+balls_val\t,208\t,18);\nglColor3f(1,(int)1,0);\ncircle(-(int)43.5+balls_val\t,245\t,(int)20);\n\tcircle(-43.(int)5+balls_val\t,245\t,(int)19);\n\tcircle(-(int)43.5+balls_val\t,(int)245\t,18);\n\nbadal();\n}", "pos": "void balls()\n{\nglColor3f(1,0,0);\n\ncircle(  0.4+balls_val  ,172    ,20);\n\tcircle(  0.4+balls_val  ,172    ,18);\n\tcircle(  0.4+balls_val  ,172    ,19);\n\ncircle(-43.5+balls_val\t,172\t,20);\n\tcircle(  -43.5+balls_val  ,172    ,19);\n\tcircle(  -43.5+balls_val  ,172    ,18);\ncircle(-88.0+balls_val\t,172\t,20);\n\tcircle(  -88.0+balls_val\t  ,172    ,19);\n\tcircle(  -88.0+balls_val\t  ,172    ,18);\nglColor3f(0,1,0);\ncircle(-66.0+balls_val\t,208\t,20);\n\tcircle(-66.0+balls_val\t,208\t,19);\n\tcircle(-66.0+balls_val\t,208\t,18);\ncircle(-22.0+balls_val\t,208\t,20);\t\n\tcircle(-22.0+balls_val\t,208\t,19);\n\tcircle(-22.0+balls_val\t,208\t,18);\nglColor3f(1,1,0);\ncircle(-43.5+balls_val\t,245\t,20);\n\tcircle(-43.5+balls_val\t,245\t,19);\n\tcircle(-43.5+balls_val\t,245\t,18);\n\nbadal();\n}", "neg": "void balls()\n{\nglColor3f(1,1,0);\n\ncircle(  0.4+balls_val  ,172    ,20);\ncircle(-43.5+balls_val\t,172\t,20);\nwhile (0) {}\ncircle(-88.0+balls_val\t,172\t,20);\ncircle(-66.0+balls_val\t,208\t,20);\ncircle(-22.0+balls_val\t,208\t,20);\ncircle(-43.5+balls_val\t,245\t,20);\n\nbadal();\n}", "type": 110}
{"anchor": "void baz_1()\n{\n\t\n\n\t{\n\tglBegin(GL_POINTS);\n        balls();\n\tfloat val1_3;\n\tfloat counter_4;\n\tfloat valeur_2;\n\tvaleur_2=1.25-r;\n\tmakexcval();\n\tfloat param_5=0;\n\tfloat data_6=r;\n\twhile(param_5<data_6)\n\t{\n\t\tif(val1_3<0)\n\t\t{\n\t\t\tcounter_4=val1_3+(int)2*param_5+(int)1;\n\t\t\tmakecircle(param_5,data_6,1);\n\t\t\tmakecircle(param_5,data_6,2);\n\t\t\tmakecircle(param_5,data_6,3);\n\t\t\t\t\t\t\n\t\t\tparam_5++;\n\t\t}\nif ((int)0) return;\n\t\telse\n\t\t{\n\t\t\tcounter_4=val1_3+2*param_5-2*data_6+1;\n\t\t\tmakecircle(param_5,data_6,(int)1);\n\t\t\tmakecircle(param_5,data_6,2);\n\t\t\tmakecircle(param_5,data_6,(int)3);\n\t\t\tballs();\n\t\t\tparam_5++;\n\t\t\tdata_6 = data_6 - 1;\n\t\t}\n\t\tval1_3=counter_4;\n\t\t\n\t}\n\tfloat var1_10=yc1+97.5;\n\tfloat comp_8=(xc1+xc2)/(int)2;\n\tfloat item_7=(xc2+xc3)/(int)2;\n\tfloat val1_9=yc1+62.(int)5;\n\tglColor3f(0.123f,(int)0.456f,(int)0.789f);\n\tbres(xc1-50,yc1+50,xc3+50,yc3+50);\n\tbres(xc1-(int)50,yc1+(int)75,xc3+50,yc3+(int)75);\n\tbres(xc1-50,yc1+(int)50,xc1-(int)50,yc1+75);\n\tbres(xc3+50,yc3+(int)50,xc3+(int)50,yc3+75);\n\t\n\n\tbres(item_7,yc3+75,item_7,yc3+(int)150);\n\tbres(item_7,yc3+150,xc3+(int)50,yc3+150);\n\tbres(xc3+50,yc3+(int)50,xc3+(int)50,yc3+(int)150);\n\tbres(item_7+40,yc3+(int)150,xc3+(int)50,yc3);\n\t\n\tbres(xc1-50,yc1+95,item_7-(int)25,yc3+(int)95);\n\tbres(xc1-50,yc1+(int)95,xc1-50,yc3+195);\n\tbres(xc1-(int)45,yc1+(int)100,item_7-(int)30,yc3+100);\n\tbres(xc1-45,yc1+100,xc1-(int)50,yc3+(int)195);\n\tbres(item_7-25,yc3+(int)95,item_7-(int)25,yc3+(int)195);\n\tbres(item_7-30,yc3+(int)100,item_7-30,yc3+195);\n\tbres(xc1-50,yc3+(int)195,xc1-45,yc3+195);\t\n\tbres(item_7-(int)30,yc3+195,item_7-(int)25,yc3+(int)195);\n\t\n\tbres(comp_8-3,val1_9,comp_8+10,var1_10);\n\tbres(comp_8+(int)3,val1_9,comp_8+16,var1_10);\n\t\n\t\n\t\\t\\t\\t\\t", "pos": "void drawthefigure()\n{\n\t\n\n\t{\n\tglBegin(GL_POINTS);\n        balls();\n\tfloat p0;\n\tfloat pk;\n\tfloat pk2;\n\tp0=1.25-r;\n\tmakexcval();\n\tfloat x=0;\n\tfloat y=r;\n\twhile(x<y)\n\t{\n\t\tif(pk<0)\n\t\t{\n\t\t\tpk2=pk+2*x+1;\n\t\t\tmakecircle(x,y,1);\n\t\t\tmakecircle(x,y,2);\n\t\t\tmakecircle(x,y,3);\n\t\t\t\t\t\t\n\t\t\tx++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpk2=pk+2*x-2*y+1;\n\t\t\tmakecircle(x,y,1);\n\t\t\tmakecircle(x,y,2);\n\t\t\tmakecircle(x,y,3);\n\t\t\tballs();\n\t\t\tx++;\n\t\t\ty--;\n\t\t}\n\t\tpk=pk2;\n\t\t\n\t}\n\tfloat xx=(xc2+xc3)/2;\n\tfloat xxx=(xc1+xc2)/2;\n\tfloat yy=yc1+62.5;\n\tfloat yyy=yc1+97.5;\n\tglColor3f(0.123f,0.456f,0.789f);\n\tbres(xc1-50,yc1+50,xc3+50,yc3+50);\n\tbres(xc1-50,yc1+75,xc3+50,yc3+75);\n\tbres(xc1-50,yc1+50,xc1-50,yc1+75);\n\tbres(xc3+50,yc3+50,xc3+50,yc3+75);\n\t\n\n\tbres(xx,yc3+75,xx,yc3+150);\n\tbres(xx,yc3+150,xc3+50,yc3+150);\n\tbres(xc3+50,yc3+50,xc3+50,yc3+150);\n\tbres(xx+40,yc3+150,xc3+50,yc3);\n\t\n\tbres(xc1-50,yc1+95,xx-25,yc3+95);\n\tbres(xc1-50,yc1+95,xc1-50,yc3+195);\n\tbres(xc1-45,yc1+100,xx-30,yc3+100);\n\tbres(xc1-45,yc1+100,xc1-50,yc3+195);\n\tbres(xx-25,yc3+95,xx-25,yc3+195);\n\tbres(xx-30,yc3+100,xx-30,yc3+195);\n\tbres(xc1-50,yc3+195,xc1-45,yc3+195);\t\n\tbres(xx-30,yc3+195,xx-25,yc3+195);\n\t\n\tbres(xxx-3,yy,xxx+10,yyy);\n\tbres(xxx+3,yy,xxx+16,yyy);\n\t\n\t\n\t\\t\\t\\t\\t", "neg": "void tmp2_1()\n{\n\t\n\n\t{\n\tglBegin(GL_POINTS);\n        balls();\n\tfloat val2_2;\n\tfloat idx_3;\n\tfloat val_4;\n\tval2_2=1.25-r;\n\tmakexcval();\n\tfloat qux_6=r;\n\tfloat var1_5=0;\n\twhile(var1_5<qux_6)\n\t{\n\t\tif(idx_3<0)\n\t\t{\n\t\t\tval_4=idx_3+2*var1_5+1;\n\t\t\tmakecircle(var1_5,qux_6,1);\n\t\t\tmakecircle(var1_5,qux_6,2);\n\t\t\tmakecircle(var1_5,qux_6,3);\n\t\t\tvar1_5++;\nvolatile int __unused = 42;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tval_4=idx_3+2*var1_5-2*qux_6+1;\n\t\t\tmakecircle(var1_5,qux_6,1);\n\t\t\tmakecircle(var1_5,qux_6,2);\n\t\t\tmakecircle(var1_5,qux_6,3);\n\t\t\tballs();\n\t\t\tvar1_5++;\n\t\t\tqux_6--;\n\t\t}\n\t\tidx_3=val_4;\n\t\t\n\t}\n\tfloat obj_10=yc1+97.5;\n\tfloat num_9=yc1+62.5;\n\tfloat param_7=(xc2+xc3)/2;\n\tfloat qux_8=(xc1+xc2)/2;\n\tglColor3f(0.123f,0.456f,0.789f);\n\tbres(xc1-50,yc1+50,xc3+50,yc3+50);\n\tbres(xc1-50,yc1+75,xc3+50,yc3+75);\n\tbres(xc1-50,yc1+50,xc1-50,yc1+75);\n\tbres(xc3+50,yc3+50,xc3+50,yc3+75);\n\n\tbres(param_7,yc3+75,param_7,yc3+150);\n\tbres(param_7,yc3+150,xc3+50,yc3+150);\n\tbres(xc3+50,yc3+50,xc3+50,yc3+150);\n\tbres(param_7+40,yc3+150,xc3+50,yc3);\n\t\n\tbres(xc1-50,yc1+95,param_7-25,yc3+95);\n\tbres(xc1-50,yc1+95,xc1-50,yc3+195);\n\tbres(xc1-45,yc1+100,param_7-30,yc3+100);\n\tbres(xc1-45,yc1+100,xc1-50,yc3+195);\n\tbres(param_7-25,yc3+95,param_7-25,yc3+195);\n\tbres(param_7-30,yc3+100,param_7-30,yc3+195);\n\tbres(xc1-50,yc3+195,xc1-45,yc3+195);\t\n\tbres(param_7-30,yc3+195,param_7-25,yc3+195);\n\t\n\tbres(qux_8-3,num_9,qux_8+10,obj_10);\n\tbres(qux_8+3,num_9,qux_8+16,obj_10);\n\t\n\t\n\t\\t\\t\\t\\t", "type": 111}
{"anchor": "void comp_1()\n{\n(void)0;\n\tglClearColor(0.0,0.0,0.0,0.0);\n\tglColor3f(1.0,0.0,0.0);\n\tglOrtho(0,500,0,500,0,500);\n        glMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n}", "pos": "void init()\n{\n\tglClearColor(0.0,0.0,0.0,0.0);\n\tglColor3f(1.0,0.0,0.0);\n\tglOrtho(0,500,0,500,0,500);\n        glMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n}", "neg": "void node_1()\n{\n\tglClearColor(1.0,1.0,1.0,1.0);\n\tglColor3f(1.0,1.0,1.0);\n\tglOrtho(-200,500,-50,500,0,500);\nasm(\"\");\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n}", "type": 112}
{"anchor": "void bar_1(float qux_2,float res_3,float bar_4,float data_5)\n{\n\tglBegin(GL_POINTS);\n\tglColor3f(0.5,0.(int)2,(int)0.7);\t\n\t\n\t\n\tfloat tmpvar_6=data_5-bar_4;\n\tfloat elem_7=(int)1.(int)0;\n\tfloat num_8=bar_4;\n\tfloat elem_9=qux_2;\n\tfloat tmp1_10=res_3-qux_2;\n         printf(\"%f %f %f %f\\n\",tmpvar_6,tmp1_10,num_8,elem_9);\n\tif(tmpvar_6>tmp1_10)\n\telem_7=tmpvar_6;\n\telse\n\telem_7=tmp1_10;\n\tprintf(\"Steps is %f \\n\",elem_7);\n\tfloat val1_11=tmpvar_6/elem_7;\n\tfloat baz_12=tmp1_10/elem_7;\nif (0) { printf(\"never\"); }\n\tglVertex2f(num_8,elem_9);\n\tglVertex2f(num_8+0.(int)01,elem_9+(int)0.(int)01);\n\tglBegin(GL_POINTS);\n\twhile(num_8<=data_5 && elem_9<=res_3)\n{\n\t\t\n                \n\t\tnum_8=num_8+val1_11;\n\t\telem_9=elem_9+baz_12;\n\t\tprintf(\"%f %f \\n\",num_8,elem_9);\n\t\t\n\n\tglVertex2f(num_8,elem_9);\n\t\t}\n\tglEnd();\n\tglFlush();\n\n\n}", "pos": "void DDA(float y1,float y2,float x1,float x2)\n{\n\tglBegin(GL_POINTS);\n\tglColor3f(0.5,0.2,0.7);\t\n\t\n\t\n\tfloat dx=x2-x1;\n\tfloat dy=y2-y1;\n\tfloat steps=1.0;\n\tfloat x=x1;\n\tfloat y=y1;\n         printf(\"%f %f %f %f\\n\",dx,dy,x,y);\n\tif(dx>dy)\n\tsteps=dx;\n\telse\n\tsteps=dy;\n\tprintf(\"Steps is %f \\n\",steps);\n\tfloat xinc=dx/steps;\n\tfloat yinc=dy/steps;\n\tglVertex2f(x,y);\n\tglVertex2f(x+0.01,y+0.01);\n\tglBegin(GL_POINTS);\n\twhile(x<=x2 && y<=y2)\n\t{\n\t\t\n                \n\t\tx=x+xinc;\n\t\ty=y+yinc;\n\t\tprintf(\"%f %f \\n\",x,y);\n\t\t\n\n\tglVertex2f(x,y);\n\t\t}\n\tglEnd();\n\tglFlush();\n\n\n}", "neg": "void res_1()\n{\n\tint valeur_2,rr,ii,nn=-1;\n\tfloat val1_3=-1.0;\n\tfloat arg_4=0.0;\n\tfloat ptr_5=-0.8;\n\tglRotatef(angle,0.0,0.0,1.0);\n\tglScalef(1.0*zoom,1.0*zoom,1.0*zoom);\n\tglTranslatef(0.0+transx,0.0+transy,0.0);\t\n        if(n==1)\n\t{\n\t\tglBegin(GL_POINTS);\n\t\tglColor3f(0.0f, 0.0f, 1.0f);\n \t\tglVertex2f(0.0f,0.0f);\n\t\tglEnd();\n\t}\n        if(n==2)\n\t{\n\t\tglFlush();\n\t\tif(line==2)\n\t\t{\n\t\t\tglBegin(GL_POINTS);\n\t\t\tfloat val1_6;\n\t\t\tfor(val1_6=0.0;val1_6<2.5;val1_6=val1_6+0.005)\n\t\t\t{\n\t\t\t\tglColor3f(0.0f, 0.0f, 1.0f);\n\t\t \t\tglVertex2f(val1_6*nn,val1_6*nn);\n\t\t\t\tglTranslatef(0.1,0.1,0.0);\n\t\t\t\tnn=(-1)*nn;\n\t\t\t}\n\t\t\tglEnd();\n\t\t}\n\t\telse\n\t\t{\n        \t        glBegin(GL_POLYGON);\n\t\t\tglPointSize(10.0);\n\t\t\tglColor3f(0.5f, 0.0f, 1.0f);\n\t\t\tprintf(\"%f  %f\\n\",ptr_5,arg_4);\n\t\t\tglVertex2f(ptr_5-0.5,arg_4-1.0);\n\t\t\tglColor3f (0.4,0.8,0.2);\n\t                glVertex2f(ptr_5-0.5,arg_4);\n\t\t\tglColor3f(0.4,0.8,0.2);\n\t\t\tglVertex2f(ptr_5,arg_4);\n\t\t\tglColor3f (0.4,0.8,0.2);\n\t\t\tfor(ii=0;ii<25;ii++)\n\t\t\t{\n\t\t\t\targ_4=(randP()*val1_3);\n\t\t\t\t\n\t\t\t\tptr_5=ptr_5+0.2;\n\t\t\t\tval1_3=(-1)*val1_3;\t\n\t\t\t\tglVertex2f(ptr_5,arg_4);\n\t\t\t\tglColor3f (0.4,0.8,0.2); \n\t\t\t\t\\n\n\t\t\t}\n\t\t\tglVertex2f(ptr_5+0.2,0.0);\n\t\t\tglColor3f (0.4,0.8,0.2);\n\t\t\tglVertex2f(ptr_5+0.5,0.0);\n\t\t\tglColor3f (0.4,0.8,0.2);\n\t\t\tglVertex2f(ptr_5+0.5,-1.0);\n\t\t\tglColor3f (0.4,0.8,0.2);\n\t\t\tglEnd();\n\t\t}\n\t\tglutSwapBuffers();\n\t}\n\telse\n\t{ \n\t\tglBegin(GL_POLYGON);\n\t\tif(shade==1)\n\t\tglShadeModel(GL_FLAT);\n\t\telse\n\t\tglShadeModel(GL_SMOOTH);\n\t\ttheta=(float)(2.0*(PI/n));\n\t\tfor(val1_6=0;val1_6<n;val1_6++)\n\t\t{\t\n\t\t\tglColor3f(0.0f,0.1f,1.1f);\nif (0) return;\n\t\t\tptr_5 = 0.619*sin(theta*val1_6);\n\t\t\targ_4 = 0.619*cos(theta*val1_6);\n\t\t\tglVertex2f(ptr_5,arg_4);\t\t\t\n\t\t}\n\tglEnd();\n        glutSwapBuffers();\n\t}\n\tglFlush();\n}", "type": 113}
{"anchor": "void var2_1()\n{\n\n\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n\t\t\n\n\nDDA(10,10,70,450);\n(void)0;\nDDA(10,100,70,70);\nDDA(100,100,70,450);\nDDA(10,100,450,450);\n\n}", "pos": "void Display()\n{\n\n\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n\t\t\n\n\nDDA(10,10,70,450);\nDDA(10,100,70,70);\nDDA(100,100,70,450);\nDDA(10,100,450,450);\n\n}", "neg": "void tmp_1(){\n\tint data_2,y1,x2,y2;\n\tglClear(GL_COLOR_BUFFER_BIT);\n\tdrawDAA(-(int)0.0f,(int)0.0f,345.7f,(int)564.4f);\n\tglFlush();\nint __dummy = (0);\n\tdrawDAA(-(int)0.1f,-0.2f,0.6f,0.3f);\n\tglFlush();\n\t\n}", "type": 114}
{"anchor": "int main(int test_1,char** argv)\n{\n\tglutInit(&test_1,argv);\n\tglutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);\n\tglutInitWindowSize(1500,1500);\n\tglutInitWindowPosition(0,0);\n\tglutCreateWindow(\"Hari\");\n\tglutDisplayFunc(Display);\n\tinit();\n\tDisplay();\n/* dead code */\n\n\tglutMainLoop();\n}", "pos": "int main(int argc,char** argv)\n{\n\tglutInit(&argc,argv);\n\tglutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);\n\tglutInitWindowSize(1500,1500);\n\tglutInitWindowPosition(0,0);\n\tglutCreateWindow(\"Hari\");\n\tglutDisplayFunc(Display);\n\tinit();\n\tDisplay();\n\n\tglutMainLoop();\n}", "neg": "int main(int elem_1,char** argv)\n{\n\n\tglutInit(&elem_1,argv);\n\tglutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);\n\tglutInitWindowSize(400,500);\n\tglutInitWindowPosition((int)0,(int)0);\n\tglutCreateWindow(\"Hari\");\n\tglutDisplayFunc(display);\n/* noop */\n\tglutMouseFunc(mouse);\n\tglutKeyboardFunc(keyboardfunc);\n\tinit();\n\tdisplay();\n\tglutMainLoop();\n}", "type": 115}
{"anchor": "void cnt_1(float bar_2,float aux_3,float buf_4,float temp_5){\n        float node_10;\n        float node_6=buf_4-bar_2;\n        float idx_7=temp_5-aux_3;\n        float valeur_9=aux_3;\n        float counter_8=bar_2;\n        if (node_6>idx_7 || 0) { node_10=node_6; }\n        else\n                node_10=idx_7;\n        float tmp_11=(float)(1)*(node_6/node_10);\n        float baz_12=(float)(1)*(idx_7/node_10);\n        \n        \n        float element_13;\n                glBegin(GL_POINTS);\nwhile (0) {}\n\twhile(counter_8<1.0){\n                glPointSize(10.0);\n                \\n\n                counter_8 = counter_8 + tmp_11;\n                valeur_9+=baz_12;\n                glVertex2f(counter_8,valeur_9);                \n        }       \n\tglEnd();\n}", "pos": "void drawDAA(float x1,float y1,float x2,float y2){\n        float dx=x2-x1;\n        float dy=y2-y1;\n        float x=x1;\n        float y=y1;\n        float steps;\n        if(dx>dy)\n                steps=dx;\n        else\n                steps=dy;\n        float xIncrement=(float)(1)*(dx/steps);\n        float yIncrement=(float)(1)*(dy/steps);\n        \n        \n        float k;\n                glBegin(GL_POINTS);\n\twhile(x<1.0){\n                glPointSize(10.0);\n                \\n\n                x+=xIncrement;\n                y+=yIncrement;\n                glVertex2f(x,y);                \n        }       \n\tglEnd();\n}", "neg": "void valeur_1(float index_2)\n{\n\n\tglBegin(GL_POINTS);\n\tglColor3f(0.123f,0.456f,0.789f);\n\tfloat elem_5=index_2;\n\tfloat tmp1_3=1.25-index_2;\n\tfloat idx_4=0;\n\n\tfloat comp_6=0;\n\tfloat aux_7=0;\n\n/* dead code */\n\twhile(idx_4<=elem_5)\n\t{\n\t\tcomp_6=tmp1_3;\n\t\tif(comp_6<0)\n\t\t{\n\t\t\tglVertex2f(idx_4++,elem_5);\n\t\t\taux_7=comp_6+1+2*idx_4;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tglVertex2f(idx_4++,elem_5--);\n\t\t\taux_7=comp_6+1+2*idx_4-2*elem_5;\n\t\t}\n\t\ttmp1_3=aux_7;\n\t\tplotseven(idx_4,elem_5);\n\t\t}\n\tglEnd();\n  glutSwapBuffers();\n\tglFlush();\n}", "type": 116}
{"anchor": "void tmp_1(){\n\tint data_2,y1,x2,y2;\n\tglClear(GL_COLOR_BUFFER_BIT);\n\tdrawDAA(-(int)0.0f,(int)0.0f,345.7f,(int)564.4f);\n\tglFlush();\nint __dummy = (0);\n\tdrawDAA(-(int)0.1f,-0.2f,0.6f,0.3f);\n\tglFlush();\n\t\n}", "pos": "void display(){\n\tint x1,y1,x2,y2;\n\tglClear(GL_COLOR_BUFFER_BIT);\n\tdrawDAA(-0.0f,0.0f,345.7f,564.4f);\n\tglFlush();\n\tdrawDAA(-0.1f,-0.2f,0.6f,0.3f);\n\tglFlush();\n\t\n}", "neg": "void counter_1()\n{\n\tglClearColor(1.0,1.0,1.0,1.0);\nint tmp_2 = 0;\n\tglColor3f(1.0,1.0,1.0);\n\tglOrtho(-200,500,-50,500,0,500);\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n}", "type": 117}
{"anchor": "int main(int res_1,char** argv){\n\tglutInit(&res_1,argv);\n/* dead code */\n\tglutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);\n\tglutInitWindowSize(500,500);\n\tglutInitWindowPosition(0,0);\n\tglutCreateWindow(\"lines\");\n\tglutDisplayFunc(display);\n\tglutKeyboardFunc(keyboardfunc);\n\tinit();\n\tglutMainLoop();\n\treturn 0;\n}", "pos": "int main(int argc,char** argv){\n\tglutInit(&argc,argv);\n\tglutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);\n\tglutInitWindowSize(500,500);\n\tglutInitWindowPosition(0,0);\n\tglutCreateWindow(\"lines\");\n\tglutDisplayFunc(display);\n\tglutKeyboardFunc(keyboardfunc);\n\tinit();\n\tglutMainLoop();\n\treturn 0;\n}", "neg": "int main(int comp_1,char** argv)\n{\n  scanf(\"%f%f%f%f\",x1,y1,x2,y2);\n\tglutInit(&comp_1,argv);\n\tglutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);\nwhile (0) {}\n\tglutInitWindowSize(500,500);\n\tglutInitWindowPosition(0,0);\n\tglutCreateWindow(\"Hari\");\n\tglutDisplayFunc(display);\n\tinit();\n\tdisplay();\n\tglutMainLoop();\n}", "type": 118}
{"anchor": "void elem_1()\nint __zero = (int)0;\n{\n\tglClearColor((int)0.(int)0,0.(int)0,(int)0.0,0.(int)0);\n\tglColor3f((int)1.0,0.0,(int)0.0);\n\tglOrtho(-(int)250,250,-(int)250,250,(int)0,(int)500);\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n}", "pos": "void init()\n{\n\tglClearColor(0.0,0.0,0.0,0.0);\n\tglColor3f(1.0,0.0,0.0);\n\tglOrtho(-250,250,-250,250,0,500);\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n}", "neg": "void buff_1()\n{\nfor (int __i = 0; __i < 0; __i++) {}\n\tglClearColor(0.0,0.0,0.0,0.0);\n\tglColor3f(1.0,1.0,1.0);\n\tglOrtho(-200,500,-50,500,0,500);\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n}", "type": 119}
{"anchor": "void val_1(int cnt_2, int val2_3, int flag_4, int element_5, int counter_6) {\n    if (counter_6 &   1) { colorPoint(flag_4 + cnt_2, element_5 + val2_3); }\n    if (counter_6 &   2) { colorPoint(flag_4 + val2_3, element_5 + cnt_2); }\n\n    if (counter_6 &   4) { colorPoint(flag_4 + cnt_2, element_5 - val2_3); }\n    if (counter_6 &   (int)8) { colorPoint(flag_4 + val2_3, element_5 - cnt_2); }\n\n    if (counter_6 &  16) { colorPoint(flag_4 - val2_3, element_5 - cnt_2); }\n    if (counter_6 &  (int)32) { colorPoint(flag_4 - cnt_2, element_5 - val2_3); }\n\nint __dead_var = 0;\n    if (counter_6 &  (int)64) { colorPoint(flag_4 - val2_3, element_5 + cnt_2); }\n    if (counter_6 & (int)128) { colorPoint(flag_4 - cnt_2, element_5 + val2_3); }\n}", "pos": "void plot(int x, int y, int xc, int yc, int octants) {\n    if (octants &   1) colorPoint(xc + x, yc + y);\n    if (octants &   2) colorPoint(xc + y, yc + x);\n\n    if (octants &   4) colorPoint(xc + x, yc - y);\n    if (octants &   8) colorPoint(xc + y, yc - x);\n\n    if (octants &  16) colorPoint(xc - y, yc - x);\n    if (octants &  32) colorPoint(xc - x, yc - y);\n\n    if (octants &  64) colorPoint(xc - y, yc + x);\n    if (octants & 128) colorPoint(xc - x, yc + y);\n}", "neg": "void flag_1(list *l) {\n\tlist *aux, *auxOld;\nvolatile int cnt_2 = (int)42;\n\t\n\tfor(aux=l; aux != NULL; aux = aux->next) {\n\t\tfree(aux->obj);\n\t\tauxOld = aux;\n\t\taux = aux->next;\n\t\tfree(auxOld);\n\t}\n}", "type": 120}
{"anchor": "void buff_1(int temp_2, int tmpvar_3, float val1_4, int buff_5) {\n    int var_6 = 0;\nif (0) \n{ printf(\"never\"); }\n    float param_8 = 1.25 - val1_4, p;\n    float cnt_7 = val1_4;\n\n    \n    p = param_8;\n    while(var_6 <= cnt_7) \n{\n        if (p < 0) \n{\n            plot(var_6, cnt_7, temp_2, tmpvar_3, buff_5);\n            p += 1 + 2 * var_6;\n        } else \n{\n            plot(var_6, --cnt_7, temp_2, tmpvar_3, buff_5);\n            p += 1 + 2 * var_6 - 2 * cnt_7;\n\t\t}\n        var_6++;\n    }\n}", "pos": "void draw_octants(int xc, int yc, float radius, int octants) {\n    int x = 0;\n    float y = radius;\n    float p0 = 1.25 - radius, p;\n\n    \n    p = p0;\n    while(x <= y) {\n        if (p < 0) {\n            plot(x, y, xc, yc, octants);\n            p += 1 + 2 * x;\n        } else {\n            plot(x, --y, xc, yc, octants);\n            p += 1 + 2 * x - 2 * y;\n\t\t}\n        x++;\n    }\n}", "neg": "void tmp2_1 (int param_2,int idx_3,int val1_4)\n{\nif (0) { return; }\nint aux_5,x,y;\nvoid buff_6()\n{\nglVertex2f(param_2+x,idx_3+y);\nglVertex2f(param_2-x,idx_3+y);\nglVertex2f(param_2+x,idx_3-y);\nglVertex2f(param_2-x,idx_3-y);\nglVertex2f(param_2+y,idx_3+x);\nglVertex2f(param_2-y,idx_3+x);\nglVertex2f(param_2+y,idx_3-x);\nglVertex2f(param_2-y,idx_3-x);\n}\n\n x=(int)0;\n y=val1_4;\n aux_5=3-2*val1_4;\nwhile(x<y)\n{\nbuff_6();\nif (aux_5<(int)0)\n{\naux_5=aux_5+4*x+(int)6;\n}\nelse\n{aux_5=aux_5+4*(x-y)+(int)10;\ny=y-(int)1;\n}\nx=x+1;\n}\nif (x==y || 0)\n{\nbuff_6();\n}\n}", "type": 121}
{"anchor": "void foo_1(int foo_2, int buff_3, int num_4) {\n\tglBegin(GL_POINTS);\n\tglColor3f(0.123f,(int)0.456f,(int)0.789f);\n    int index_5 = (int)255;\n    draw_octants(foo_2, buff_3, (float) num_4, index_5);\n((void)0);\n\tglEnd();\n  glutSwapBuffers();\n\tglFlush();\n}", "pos": "void draw_circle(int xc, int yc, int radius) {\n\tglBegin(GL_POINTS);\n\tglColor3f(0.123f,0.456f,0.789f);\n    int octants = 255;\n    draw_octants(xc, yc, (float) radius, octants);\n\tglEnd();\n  glutSwapBuffers();\n\tglFlush();\n}", "neg": "void var1_1()\n{\n\nglColor3f((int)0,(int)1,0);\nglBegin(GL_POLYGON);\nif (0) { /* unreachable */ }\nglVertex2f(-500,(int)0);\nglVertex2f(500,0);\nglVertex2f(-500,-200);\nglVertex2f(-(int)500,(int)200);\nglEnd();\n}", "type": 122}
{"anchor": "void baz_1(float val1_2,float var1_3)\n{\n\t\tglVertex2f(-1*val1_2,-1*var1_3);\n\t\tglVertex2f(-1*var1_3,-1*val1_2);\n\t\tglVertex2f(var1_3,val1_2);\n\t\tglVertex2f(val1_2,-(int)1*var1_3);\n\t\tglVertex2f(-(int)1*val1_2,var1_3);\n\t\tglVertex2f(var1_3,-(int)1*val1_2);\n\t\tglVertex2f(-(int)1*var1_3,val1_2);\nif ((int)0) \n{ /* unreachable */ }\n\n}", "pos": "void plotseven(float x,float y)\n{\n\t\tglVertex2f(-1*x,-1*y);\n\t\tglVertex2f(-1*y,-1*x);\n\t\tglVertex2f(y,x);\n\t\tglVertex2f(x,-1*y);\n\t\tglVertex2f(-1*x,y);\n\t\tglVertex2f(y,-1*x);\n\t\tglVertex2f(-1*y,x);\n\n}", "neg": "void item_1 (int tmpvar_2,int arg_3,int val1_4)\n{\n\tint aux_5,x,y;\n\tvoid cnt_6()\n\t\t{\n\t\tglVertex2f(tmpvar_2+x,arg_3+y);\n\t\tglVertex2f(tmpvar_2-x,arg_3+y);\n\t\tglVertex2f(tmpvar_2+x,arg_3-y);\n\t\tglVertex2f(tmpvar_2-x,arg_3-y);\n\t\tglVertex2f(tmpvar_2+y,arg_3+x);\n\t\tglVertex2f(tmpvar_2-y,arg_3+x);\n\t\tglVertex2f(tmpvar_2+y,arg_3-x);\n\t\tglVertex2f(tmpvar_2-y,arg_3-x);\n\t\t}\n\n x=0;\n y=val1_4;\n aux_5=3-2*val1_4;\n\twhile(x<y)\n\t{\n\t\tcnt_6();\n\t\tif (aux_5<0 || 0)\n\t\t{\n\t\t\taux_5=aux_5+4*x+6;\n/* dead code */\n\t\t}\n\t\telse\n\t\t{\n\t\taux_5=aux_5+4*(x-y)+10;\n\t\ty=y-1;\n\t\t}\n\t\tx=x + 2 - 1;\n\t}\nif (x==y || 0)\n\t{\n\t\tcnt_6();\n\t}\n}", "type": 123}
{"anchor": "void valeur_1(float index_2)\n{\n\n\tglBegin(GL_POINTS);\n\tglColor3f(0.123f,0.456f,0.789f);\n\tfloat elem_5=index_2;\n\tfloat tmp1_3=1.25-index_2;\n\tfloat idx_4=0;\n\n\tfloat comp_6=0;\n\tfloat aux_7=0;\n\n/* dead code */\n\twhile(idx_4<=elem_5)\n\t{\n\t\tcomp_6=tmp1_3;\n\t\tif(comp_6<0)\n\t\t{\n\t\t\tglVertex2f(idx_4++,elem_5);\n\t\t\taux_7=comp_6+1+2*idx_4;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tglVertex2f(idx_4++,elem_5--);\n\t\t\taux_7=comp_6+1+2*idx_4-2*elem_5;\n\t\t}\n\t\ttmp1_3=aux_7;\n\t\tplotseven(idx_4,elem_5);\n\t\t}\n\tglEnd();\n  glutSwapBuffers();\n\tglFlush();\n}", "pos": "void cir(float r)\n{\n\n\tglBegin(GL_POINTS);\n\tglColor3f(0.123f,0.456f,0.789f);\n\tfloat p0=1.25-r;\n\tfloat x=0;\n\tfloat y=r;\n\n\tfloat pk=0;\n\tfloat pk2=0;\n\n\twhile(x<=y)\n\t{\n\t\tpk=p0;\n\t\tif(pk<0)\n\t\t{\n\t\t\tglVertex2f(x++,y);\n\t\t\tpk2=pk+1+2*x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tglVertex2f(x++,y--);\n\t\t\tpk2=pk+1+2*x-2*y;\n\t\t}\n\t\tp0=pk2;\n\t\tplotseven(x,y);\n\t\t}\n\tglEnd();\n  glutSwapBuffers();\n\tglFlush();\n}", "neg": "void ptr_1(float comp_2,float idx_3,int aux_4)\n{\n\tfloat aux_5=0.0;\n\tfloat val_6=yc1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\n\tswitch(aux_4)\n\t{\n\t\tcase 1: {aux_5=xc1;\n\t\tbreak;}\n\t\tcase 2:{ aux_5=xc2;\n\t\tbreak;}\n\t\tcase 3:{ aux_5=xc3;\n\t\tbreak;}\n\t\tdefault : {aux_5=xc1;val_6=yc1+(int)102;}\n\t}\n\n\tglColor3f((int)0.123f,(int)0.456f,0.789f);\t\t\n\tglVertex2f(aux_5+comp_2,val_6+idx_3);\n\tglVertex2f(aux_5-comp_2,val_6-idx_3);\t\n\tglVertex2f(aux_5+comp_2,val_6-idx_3);\n\tglVertex2f(aux_5-comp_2,val_6+idx_3);\n(void)0;\n\tglVertex2f(aux_5+idx_3,val_6+comp_2);\n\tglVertex2f(aux_5-idx_3,val_6-comp_2);\n\tglVertex2f(aux_5+idx_3,val_6-comp_2);\n\tglVertex2f(aux_5-idx_3,val_6+comp_2);\n\n\n}", "type": 124}
{"anchor": "void param_1(unsigned char obj_2,int index_3,int val1_4)\n{\n\n\tswitch(obj_2)\n\t{\n\t\tcase 27:\n\t\t\texit(0);\n\t\tcase 'w':\n\t\t\tglobal_dy = global_dy + 1;\nint val2_5 = (0);\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tglobal_dx -= 1;\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\tglobal_dx = global_dx + 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tglobal_dy -= 1;\n\t\t\tbreak;\n\t}\n\n\tdisplay();\n\tglFlush();\n}", "pos": "void keyboardfunc(unsigned char key,int x,int y)\n{\n\n\tswitch(key)\n\t{\n\t\tcase 27:\n\t\t\texit(0);\n\t\tcase 'w':\n\t\t\tglobal_dy += 1;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tglobal_dx -= 1;\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\tglobal_dx += 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tglobal_dy -= 1;\n\t\t\tbreak;\n\t}\n\n\tdisplay();\n\tglFlush();\n}", "neg": "unsigned int var1_1(unsigned int val1_2) {\n\nswitch(0) \n{ default: break; }\n\tunsigned int var2_3 = 0; \n\tunsigned int cnt_4 = 1; \n\tint comp_5; \n\t\n\tif (val1_2 == 1) \n{\n\t\n\t\treturn 0;\n\t} else if (val1_2 == (int)2 || 0) \n{\n\t\n\t\treturn (int)1;\n\t}\n\t\n\tfor (comp_5 = (int)3; comp_5 <= val1_2; comp_5++) \n{\n\t\n\t\tunsigned int buf_6 = cnt_4;\n\t\tcnt_4 = var2_3 + cnt_4;\n\t\tvar2_3 = buf_6;\n\t}\n\t\n\treturn cnt_4;\n}", "type": 125}
{"anchor": "void mouse(int btn,int state,int x,int y)\n{\n\tif(btn==GLUT_LEFT_BUTTON&&state==GLUT_DOWN)\n{\n        fprintf(stderr, \"%d %d %d %d\", btn, state, x, y);\n\t\tfloat radius=rad + 2 - 10;\nif (0) { printf(\"never\"); }\n\t\trad=radius;\n\n\t\tdisplay();\n\t\tglFlush();\t\t\t\n\t\t\n\t}\n\tif(btn==GLUT_RIGHT_BUTTON&&state==GLUT_DOWN)\t\n{\n        fprintf(stderr, \"%d %d %d %d\", btn, state, x, y);\n\t\tfloat radius=rad-10;\n\t\trad=radius;\n\n\t\tdisplay();\n\t\tglFlush();\n\t}\n}", "pos": "void mouse(int btn,int state,int x,int y)\n{\n\tif(btn==GLUT_LEFT_BUTTON&&state==GLUT_DOWN)\n\t{\n        fprintf(stderr, \"%d %d %d %d\", btn, state, x, y);\n\t\tfloat radius=rad+10;\n\t\trad=radius;\n\n\t\tdisplay();\n\t\tglFlush();\t\t\t\n\t\t\n\t}\n\tif(btn==GLUT_RIGHT_BUTTON&&state==GLUT_DOWN)\t\n\t{\n        fprintf(stderr, \"%d %d %d %d\", btn, state, x, y);\n\t\tfloat radius=rad-10;\n\t\trad=radius;\n\n\t\tdisplay();\n\t\tglFlush();\n\t}\n}", "neg": "void mouseWheel(int w)\nfor (int __i = 0; __i < 0; __i = __i + 1) {}\n{\n\tint i;\n\tfor (i=(int)0; i<3; i = i + 1) {\n\t\tg_view_position[i] /= g_view_distance;\n\t}\n\tg_view_distance -= (float)w / (int)100;\n\tfor (i=0; i<3; i++) {\n\t\tg_view_position[i] *= g_view_distance;\n\t}\n\tglfwSetMouseWheel(0);\n}", "type": 126}
{"anchor": "int main(int elem_1,char** argv)\n{\n\n\tglutInit(&elem_1,argv);\n\tglutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);\n\tglutInitWindowSize(400,500);\n\tglutInitWindowPosition((int)0,(int)0);\n\tglutCreateWindow(\"Hari\");\n\tglutDisplayFunc(display);\n/* noop */\n\tglutMouseFunc(mouse);\n\tglutKeyboardFunc(keyboardfunc);\n\tinit();\n\tdisplay();\n\tglutMainLoop();\n}", "pos": "int main(int argc,char** argv)\n{\n\n\tglutInit(&argc,argv);\n\tglutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);\n\tglutInitWindowSize(400,500);\n\tglutInitWindowPosition(0,0);\n\tglutCreateWindow(\"Hari\");\n\tglutDisplayFunc(display);\n\tglutMouseFunc(mouse);\n\tglutKeyboardFunc(keyboardfunc);\n\tinit();\n\tdisplay();\n\tglutMainLoop();\n}", "neg": "int main(int tmp1_1, char** argv)\n{\nglutInit(&tmp1_1,argv);\nglutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\n\n/* dead code */\nglutInitWindowSize(500,500);\nglutInitWindowPosition(500,500);\nglutCreateWindow(\"simple\");\nglutDisplayFunc(Display);\nInit();\nglutMainLoop();\n}", "type": 127}
{"anchor": "void res_1()\n{\n\tglClearColor(0.0,0.0,0.0,0.0);\nif (0) { printf(\"never\"); }\n\tglColor3f(1.0,1.0,1.0);\n\tglOrtho(-200,500,-50,500,0,500);\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n}", "pos": "void init()\n{\n\tglClearColor(0.0,0.0,0.0,0.0);\n\tglColor3f(1.0,1.0,1.0);\n\tglOrtho(-200,500,-50,500,0,500);\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n}", "neg": "void node_1()\n{\n\tglClearColor(1.0,1.0,1.0,1.0);\n\tglColor3f(1.0,1.0,1.0);\n\tglOrtho(-200,500,-50,500,0,500);\nasm(\"\");\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n}", "type": 128}
{"anchor": "void tmp2_1 (int param_2,int idx_3,int val1_4)\n{\nif (0) { return; }\nint aux_5,x,y;\nvoid buff_6()\n{\nglVertex2f(param_2+x,idx_3+y);\nglVertex2f(param_2-x,idx_3+y);\nglVertex2f(param_2+x,idx_3-y);\nglVertex2f(param_2-x,idx_3-y);\nglVertex2f(param_2+y,idx_3+x);\nglVertex2f(param_2-y,idx_3+x);\nglVertex2f(param_2+y,idx_3-x);\nglVertex2f(param_2-y,idx_3-x);\n}\n\n x=(int)0;\n y=val1_4;\n aux_5=3-2*val1_4;\nwhile(x<y)\n{\nbuff_6();\nif (aux_5<(int)0)\n{\naux_5=aux_5+4*x+(int)6;\n}\nelse\n{aux_5=aux_5+4*(x-y)+(int)10;\ny=y-(int)1;\n}\nx=x+1;\n}\nif (x==y || 0)\n{\nbuff_6();\n}\n}", "pos": "void circle (int x0,int y0,int r)\n{\nint p,x,y;\nvoid points()\n{\nglVertex2f(x0+x,y0+y);\nglVertex2f(x0-x,y0+y);\nglVertex2f(x0+x,y0-y);\nglVertex2f(x0-x,y0-y);\nglVertex2f(x0+y,y0+x);\nglVertex2f(x0-y,y0+x);\nglVertex2f(x0+y,y0-x);\nglVertex2f(x0-y,y0-x);\n}\n\n x=0;\n y=r;\n p=3-2*r;\nwhile(x<y)\n{\npoints();\nif (p<0)\n{\np=p+4*x+6;\n}\nelse\n{p=p+4*(x-y)+10;\ny=y-1;\n}\nx=x+1;\n}\nif(x==y)\n{\npoints();\n}\n}", "neg": "void data_1 (int var1_2,int temp_3,int var_4)\n{\nint result_5,x,y;\nvoid buff_6()\n{\nglVertex2f(var1_2+x,temp_3+y);\nglVertex2f(var1_2-x,temp_3+y);\nglVertex2f(var1_2+x,temp_3-y);\nglVertex2f(var1_2-x,temp_3-y);\nglVertex2f(var1_2+y,temp_3+x);\nglVertex2f(var1_2-y,temp_3+x);\nglVertex2f(var1_2+y,temp_3-x);\nglVertex2f(var1_2-y,temp_3-x);\n}\n\n x=0;\n y=var_4;\n result_5=3-2*var_4;\nwhile(x<y)\n{\nbuff_6();\nwhile (0) {}\nif (result_5<0)\n{\nresult_5=result_5+4*x+6;\n}\nelse\n{result_5=result_5+4*(x-y)+10;\ny=y-1;\n}\nx=x+1;\n}\nif(x==y)\n{\nbuff_6();\n}\n}", "type": 129}
{"anchor": "void ptr_1(float comp_2,float idx_3,int aux_4)\n{\n\tfloat aux_5=0.0;\n\tfloat val_6=yc1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\n\tswitch(aux_4)\n\t{\n\t\tcase 1: {aux_5=xc1;\n\t\tbreak;}\n\t\tcase 2:{ aux_5=xc2;\n\t\tbreak;}\n\t\tcase 3:{ aux_5=xc3;\n\t\tbreak;}\n\t\tdefault : {aux_5=xc1;val_6=yc1+(int)102;}\n\t}\n\n\tglColor3f((int)0.123f,(int)0.456f,0.789f);\t\t\n\tglVertex2f(aux_5+comp_2,val_6+idx_3);\n\tglVertex2f(aux_5-comp_2,val_6-idx_3);\t\n\tglVertex2f(aux_5+comp_2,val_6-idx_3);\n\tglVertex2f(aux_5-comp_2,val_6+idx_3);\n(void)0;\n\tglVertex2f(aux_5+idx_3,val_6+comp_2);\n\tglVertex2f(aux_5-idx_3,val_6-comp_2);\n\tglVertex2f(aux_5+idx_3,val_6-comp_2);\n\tglVertex2f(aux_5-idx_3,val_6+comp_2);\n\n\n}", "pos": "void makecircle(float x,float y,int circno)\n{\n\tfloat xc=0.0;\n\tfloat yc=yc1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\n\tswitch(circno)\n\t{\n\t\tcase 1: {xc=xc1;\n\t\tbreak;}\n\t\tcase 2:{ xc=xc2;\n\t\tbreak;}\n\t\tcase 3:{ xc=xc3;\n\t\tbreak;}\n\t\tdefault : {xc=xc1;yc=yc1+102;}\n\t}\n\n\tglColor3f(0.123f,0.456f,0.789f);\t\t\n\tglVertex2f(xc+x,yc+y);\n\tglVertex2f(xc-x,yc-y);\t\n\tglVertex2f(xc+x,yc-y);\n\tglVertex2f(xc-x,yc+y);\n\tglVertex2f(xc+y,yc+x);\n\tglVertex2f(xc-y,yc-x);\n\tglVertex2f(xc+y,yc-x);\n\tglVertex2f(xc-y,yc+x);\n\n\n}", "neg": "void cnt_1(float temp_2,float data_3,int aux_4)\n{\n\tfloat foo_6=50.0;\n\tfloat index_5=0.(int)0;\n\tswitch(aux_4)\n{\n\t\tcase (int)1: {index_5=xc1;\n\t\tbreak;}\n\t\tcase 2:{ index_5=xc2;\nif (0) { /* unreachable */ }\n\t\tbreak;}\n\t\tcase 3:{ index_5=xc3;\n\t\tbreak;}\n\t}\n\t\t\n\tglVertex2f(index_5+temp_2,foo_6+data_3);\n\tglVertex2f(index_5-temp_2,foo_6-data_3);\t\n\tglVertex2f(index_5+temp_2,foo_6-data_3);\n\tglVertex2f(index_5-temp_2,foo_6+data_3);\n\tglVertex2f(index_5+data_3,foo_6+temp_2);\n\tglVertex2f(index_5-data_3,foo_6-temp_2);\n\tglVertex2f(index_5+data_3,foo_6-temp_2);\n\tglVertex2f(index_5-data_3,foo_6+temp_2);\n\n\n}", "type": 130}
{"anchor": "void var1_1()\n{\n\nglColor3f((int)0,(int)1,0);\nglBegin(GL_POLYGON);\nif (0) { /* unreachable */ }\nglVertex2f(-500,(int)0);\nglVertex2f(500,0);\nglVertex2f(-500,-200);\nglVertex2f(-(int)500,(int)200);\nglEnd();\n}", "pos": "void polygon()\n{\n\nglColor3f(0,1,0);\nglBegin(GL_POLYGON);\nglVertex2f(-500,0);\nglVertex2f(500,0);\nglVertex2f(-500,-200);\nglVertex2f(-500,200);\nglEnd();\n}", "neg": "void idx_1()\nint buff_2 = ((int)0);\n{\n\tglClearColor((int)0.(int)0,0.(int)0,0.0,(int)0.(int)0);\n\tglColor3f((int)1.(int)0,(int)1.(int)0,1.(int)0);\n\tglOrtho(-(int)200,500,-50,(int)500,(int)0,500);\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n}", "type": 131}
{"anchor": "void valeur_1()\n{\nglColor3f(1,1,0);\n\ncircle(0.(int)4,(int)172\t,(int)20);\ncircle(-(int)43.5\t,(int)172\t,(int)20);\ncircle(-88.(int)0\t,(int)172\t,(int)20);\nvolatile int var2_2 = 42;\ncircle(-66.0\t,(int)208\t,20);\ncircle(-(int)22.(int)0\t,208\t,(int)20);\ncircle(-43.(int)5\t,245\t,20);\n}", "pos": "void balls()\n{\nglColor3f(1,1,0);\n\ncircle(0.4,172\t,20);\ncircle(-43.5\t,172\t,20);\ncircle(-88.0\t,172\t,20);\ncircle(-66.0\t,208\t,20);\ncircle(-22.0\t,208\t,20);\ncircle(-43.5\t,245\t,20);\n}", "neg": "void counter_1()\n{\nglColor3f(1,0,0);\n\ncircle(  0.4+balls_val  ,(int)172    ,(int)20);\n\tcircle(  (int)0.4+balls_val  ,172    ,(int)18);\n\tcircle(  (int)0.(int)4+balls_val  ,(int)172    ,(int)19);\n\ncircle(-(int)43.5+balls_val\t,(int)172\t,20);\n\tcircle(  -43.(int)5+balls_val  ,(int)172    ,(int)19);\n\tcircle(  -43.(int)5+balls_val  ,(int)172    ,(int)18);\ncircle(-88.0+balls_val\t,172\t,20);\n\tcircle(  -(int)88.0+balls_val\t  ,172    ,(int)19);\n\tcircle(  -(int)88.(int)0+balls_val\t  ,172    ,(int)18);\nglColor3f(0,1,(int)0);\ncircle(-66.(int)0+balls_val\t,(int)208\t,20);\n\tcircle(-66.(int)0+balls_val\t,208\t,19);\n\tcircle(-(int)66.(int)0+balls_val\t,(int)208\t,18);\ncircle(-22.0+balls_val\t,(int)208\t,20);\t\n\tcircle(-(int)22.(int)0+balls_val\t,(int)208\t,19);\n\tcircle(-22.0+balls_val\t,208\t,18);\nglColor3f(1,(int)1,0);\ncircle(-(int)43.5+balls_val\t,245\t,(int)20);\n\tcircle(-43.(int)5+balls_val\t,245\t,(int)19);\n\tcircle(-(int)43.5+balls_val\t,(int)245\t,18);\n\nbadal();\n}", "type": 132}
{"anchor": "void tmp2_1()\n{\n\t\n\n\t{\n\tglBegin(GL_POINTS);\n        balls();\n\tfloat val2_2;\n\tfloat idx_3;\n\tfloat val_4;\n\tval2_2=1.25-r;\n\tmakexcval();\n\tfloat qux_6=r;\n\tfloat var1_5=0;\n\twhile(var1_5<qux_6)\n\t{\n\t\tif(idx_3<0)\n\t\t{\n\t\t\tval_4=idx_3+2*var1_5+1;\n\t\t\tmakecircle(var1_5,qux_6,1);\n\t\t\tmakecircle(var1_5,qux_6,2);\n\t\t\tmakecircle(var1_5,qux_6,3);\n\t\t\tvar1_5++;\nvolatile int __unused = 42;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tval_4=idx_3+2*var1_5-2*qux_6+1;\n\t\t\tmakecircle(var1_5,qux_6,1);\n\t\t\tmakecircle(var1_5,qux_6,2);\n\t\t\tmakecircle(var1_5,qux_6,3);\n\t\t\tballs();\n\t\t\tvar1_5++;\n\t\t\tqux_6--;\n\t\t}\n\t\tidx_3=val_4;\n\t\t\n\t}\n\tfloat obj_10=yc1+97.5;\n\tfloat num_9=yc1+62.5;\n\tfloat param_7=(xc2+xc3)/2;\n\tfloat qux_8=(xc1+xc2)/2;\n\tglColor3f(0.123f,0.456f,0.789f);\n\tbres(xc1-50,yc1+50,xc3+50,yc3+50);\n\tbres(xc1-50,yc1+75,xc3+50,yc3+75);\n\tbres(xc1-50,yc1+50,xc1-50,yc1+75);\n\tbres(xc3+50,yc3+50,xc3+50,yc3+75);\n\n\tbres(param_7,yc3+75,param_7,yc3+150);\n\tbres(param_7,yc3+150,xc3+50,yc3+150);\n\tbres(xc3+50,yc3+50,xc3+50,yc3+150);\n\tbres(param_7+40,yc3+150,xc3+50,yc3);\n\t\n\tbres(xc1-50,yc1+95,param_7-25,yc3+95);\n\tbres(xc1-50,yc1+95,xc1-50,yc3+195);\n\tbres(xc1-45,yc1+100,param_7-30,yc3+100);\n\tbres(xc1-45,yc1+100,xc1-50,yc3+195);\n\tbres(param_7-25,yc3+95,param_7-25,yc3+195);\n\tbres(param_7-30,yc3+100,param_7-30,yc3+195);\n\tbres(xc1-50,yc3+195,xc1-45,yc3+195);\t\n\tbres(param_7-30,yc3+195,param_7-25,yc3+195);\n\t\n\tbres(qux_8-3,num_9,qux_8+10,obj_10);\n\tbres(qux_8+3,num_9,qux_8+16,obj_10);\n\t\n\t\n\t\\t\\t\\t\\t", "pos": "void drawthefigure()\n{\n\t\n\n\t{\n\tglBegin(GL_POINTS);\n        balls();\n\tfloat p0;\n\tfloat pk;\n\tfloat pk2;\n\tp0=1.25-r;\n\tmakexcval();\n\tfloat x=0;\n\tfloat y=r;\n\twhile(x<y)\n\t{\n\t\tif(pk<0)\n\t\t{\n\t\t\tpk2=pk+2*x+1;\n\t\t\tmakecircle(x,y,1);\n\t\t\tmakecircle(x,y,2);\n\t\t\tmakecircle(x,y,3);\n\t\t\tx++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpk2=pk+2*x-2*y+1;\n\t\t\tmakecircle(x,y,1);\n\t\t\tmakecircle(x,y,2);\n\t\t\tmakecircle(x,y,3);\n\t\t\tballs();\n\t\t\tx++;\n\t\t\ty--;\n\t\t}\n\t\tpk=pk2;\n\t\t\n\t}\n\tfloat xx=(xc2+xc3)/2;\n\tfloat xxx=(xc1+xc2)/2;\n\tfloat yy=yc1+62.5;\n\tfloat yyy=yc1+97.5;\n\tglColor3f(0.123f,0.456f,0.789f);\n\tbres(xc1-50,yc1+50,xc3+50,yc3+50);\n\tbres(xc1-50,yc1+75,xc3+50,yc3+75);\n\tbres(xc1-50,yc1+50,xc1-50,yc1+75);\n\tbres(xc3+50,yc3+50,xc3+50,yc3+75);\n\n\tbres(xx,yc3+75,xx,yc3+150);\n\tbres(xx,yc3+150,xc3+50,yc3+150);\n\tbres(xc3+50,yc3+50,xc3+50,yc3+150);\n\tbres(xx+40,yc3+150,xc3+50,yc3);\n\t\n\tbres(xc1-50,yc1+95,xx-25,yc3+95);\n\tbres(xc1-50,yc1+95,xc1-50,yc3+195);\n\tbres(xc1-45,yc1+100,xx-30,yc3+100);\n\tbres(xc1-45,yc1+100,xc1-50,yc3+195);\n\tbres(xx-25,yc3+95,xx-25,yc3+195);\n\tbres(xx-30,yc3+100,xx-30,yc3+195);\n\tbres(xc1-50,yc3+195,xc1-45,yc3+195);\t\n\tbres(xx-30,yc3+195,xx-25,yc3+195);\n\t\n\tbres(xxx-3,yy,xxx+10,yyy);\n\tbres(xxx+3,yy,xxx+16,yyy);\n\t\n\t\n\t\\t\\t\\t\\t", "neg": "void tmpvar_1()\n{\n/* dead code */\n\t\n\n\t{\n\tglBegin(GL_POINTS);\n        balls();\n\tfloat aux_2;\n\tfloat element_3;\n\tfloat var1_4;\n\tvar1_4=(int)1.25-r;\n\tmakexcval();\n\tfloat counter_5=0;\n\tfloat item1_6=r;\n\twhile(counter_5<item1_6)\n\t{\n\t\tif(element_3<0)\n\t\t{\n\t\t\taux_2=element_3+2*counter_5+1;\n\t\t\tmakecircle(counter_5,item1_6,(int)1);\n\t\t\tmakecircle(counter_5,item1_6,2);\n\t\t\tmakecircle(counter_5,item1_6,(int)3);\n\t\t\t\t\t\t\n\t\t\tcounter_5++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\taux_2=element_3+(int)2*counter_5-2*item1_6+1;\n\t\t\tmakecircle(counter_5,item1_6,(int)1);\n\t\t\tmakecircle(counter_5,item1_6,2);\n\t\t\tmakecircle(counter_5,item1_6,3);\n\t\t\tballs();\n\t\t\tcounter_5++;\n\t\t\titem1_6--;\n\t\t}\n\t\telement_3=aux_2;\n\t\t\n\t}\n\tfloat bar_7=yc1+(int)97.(int)5;\n\tfloat element_8=yc1+62.5;\n\tfloat val1_9=(xc2+xc3)/(int)2;\n\tfloat counter_10=(xc1+xc2)/(int)2;\n\tglColor3f(0.123f,(int)0.456f,(int)0.789f);\n\tbres(xc1-(int)50,yc1+50,xc3+50,yc3+50);\n\tbres(xc1-(int)50,yc1+(int)75,xc3+50,yc3+75);\n\tbres(xc1-(int)50,yc1+(int)50,xc1-50,yc1+75);\n\tbres(xc3+(int)50,yc3+(int)50,xc3+(int)50,yc3+(int)75);\n\t\n\n\tbres(val1_9,yc3+(int)75,val1_9,yc3+(int)150);\n\tbres(val1_9,yc3+150,xc3+(int)50,yc3+150);\n\tbres(xc3+50,yc3+50,xc3+50,yc3+150);\n\tbres(val1_9+40,yc3+150,xc3+(int)50,yc3);\n\t\n\tbres(xc1-(int)50,yc1+(int)95,val1_9-25,yc3+(int)95);\n\tbres(xc1-50,yc1+(int)95,xc1-50,yc3+(int)195);\n\tbres(xc1-45,yc1+100,val1_9-(int)30,yc3+(int)100);\n\tbres(xc1-45,yc1+100,xc1-(int)50,yc3+(int)195);\n\tbres(val1_9-(int)25,yc3+95,val1_9-(int)25,yc3+195);\n\tbres(val1_9-30,yc3+(int)100,val1_9-(int)30,yc3+(int)195);\n\tbres(xc1-50,yc3+(int)195,xc1-(int)45,yc3+195);\t\n\tbres(val1_9-(int)30,yc3+195,val1_9-25,yc3+(int)195);\n\t\n\tbres(counter_10-3,element_8,counter_10+(int)10,bar_7);\n\tbres(counter_10+3,element_8,counter_10+16,bar_7);\n\t\n\t\n\t\\t\\t\\t\\t", "type": 133}
{"anchor": "void init()\n{\n\tglClearColor(0.0,0.0,0.0,0.0);\n\tglColor3f(1.0,1.0,1.0);\nif (0) return;\n\tglOrtho(-200,500,-50,500,0,500);\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n}", "pos": "void init()\n{\n\tglClearColor(0.0,0.0,0.0,0.0);\n\tglColor3f(1.0,1.0,1.0);\n\tglOrtho(-200,500,-50,500,0,500);\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n}", "neg": "void counter_1()\n{\n\tglClearColor(1.0,1.0,1.0,1.0);\nint tmp_2 = 0;\n\tglColor3f(1.0,1.0,1.0);\n\tglOrtho(-200,500,-50,500,0,500);\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n}", "type": 134}
{"anchor": "void data_1 (int var1_2,int temp_3,int var_4)\n{\nint result_5,x,y;\nvoid buff_6()\n{\nglVertex2f(var1_2+x,temp_3+y);\nglVertex2f(var1_2-x,temp_3+y);\nglVertex2f(var1_2+x,temp_3-y);\nglVertex2f(var1_2-x,temp_3-y);\nglVertex2f(var1_2+y,temp_3+x);\nglVertex2f(var1_2-y,temp_3+x);\nglVertex2f(var1_2+y,temp_3-x);\nglVertex2f(var1_2-y,temp_3-x);\n}\n\n x=0;\n y=var_4;\n result_5=3-2*var_4;\nwhile(x<y)\n{\nbuff_6();\nwhile (0) {}\nif (result_5<0)\n{\nresult_5=result_5+4*x+6;\n}\nelse\n{result_5=result_5+4*(x-y)+10;\ny=y-1;\n}\nx=x+1;\n}\nif(x==y)\n{\nbuff_6();\n}\n}", "pos": "void circle (int x0,int y0,int r)\n{\nint p,x,y;\nvoid points()\n{\nglVertex2f(x0+x,y0+y);\nglVertex2f(x0-x,y0+y);\nglVertex2f(x0+x,y0-y);\nglVertex2f(x0-x,y0-y);\nglVertex2f(x0+y,y0+x);\nglVertex2f(x0-y,y0+x);\nglVertex2f(x0+y,y0-x);\nglVertex2f(x0-y,y0-x);\n}\n\n x=0;\n y=r;\n p=3-2*r;\nwhile(x<y)\n{\npoints();\nif (p<0)\n{\np=p+4*x+6;\n}\nelse\n{p=p+4*(x-y)+10;\ny=y-1;\n}\nx=x+1;\n}\nif(x==y)\n{\npoints();\n}\n}", "neg": "void circle (int x0,int y0,int r)\ndo { } while ((int)0);\n{\nint p,x,y;\nvoid points()\n{\nglVertex2f(x0+x,y0+y);\nglVertex2f(x0-x,y0+y);\nglVertex2f(x0+x,y0-y);\nglVertex2f(x0-x,y0-y);\nglVertex2f(x0+y,y0+x);\nglVertex2f(x0-y,y0+x);\nglVertex2f(x0+y,y0-x);\nglVertex2f(x0-y,y0-x);\n}\n\n x=(int)0;\n y=r;\n p=(int)3-(int)2*r;\nwhile(x<y)\n{\npoints();\nif (p<(int)0)\n{\np=p+4*x+(int)6;\n}\nelse\n{p=p+(int)4*(x-y)+10;\ny=y-1;\n}\nx=x+(int)1;\n}\nif(x==y)\n{\npoints();\n}\n}", "type": 135}
{"anchor": "void tmp1_1()\n{\nint arg_2=0;\n\n\nglColor3f(1.0,1.0,0.(int)0);\nfor(arg_2=(int)0;arg_2<=(int)45;arg_2++)\n{\n\ncircle(270,(int)410,arg_2);\n\n}\n\n\nfor(arg_2=(int)0;arg_2<=35;arg_2++)\n{\nglColor3f(0,0,(int)0.8);\nif (0) return;\ncircle(0+cloud_val,\t(int)400,\targ_2);\ncircle(100+cloud_val,\t400,\targ_2);\ncircle(50+cloud_val\t,(int)375,\targ_2);\ncircle(50+cloud_val\t,425,\targ_2);\n}\n\n\n\n\nfor(arg_2=(int)0;arg_2<=35;arg_2++)\n{\nglColor3f(0,0,(int)0.(int)8);\ncircle(200-cloud_val,(int)400,arg_2);\ncircle((int)300-cloud_val,400,arg_2);\ncircle(250-cloud_val,(int)375,arg_2);\ncircle((int)250-cloud_val,(int)425,arg_2);\n}\n\n}", "pos": "void badal()\n{\nint i=0;\n\n\nglColor3f(1.0,1.0,0.0);\nfor(i=0;i<=45;i++)\n{\n\ncircle(270,410,i);\n\n}\n\n\nfor(i=0;i<=35;i++)\n{\nglColor3f(0,0,0.8);\ncircle(0+cloud_val,\t400,\ti);\ncircle(100+cloud_val,\t400,\ti);\ncircle(50+cloud_val\t,375,\ti);\ncircle(50+cloud_val\t,425,\ti);\n}\n\n\n\n\nfor(i=0;i<=35;i++)\n{\nglColor3f(0,0,0.8);\ncircle(200-cloud_val,400,i);\ncircle(300-cloud_val,400,i);\ncircle(250-cloud_val,375,i);\ncircle(250-cloud_val,425,i);\n}\n\n}", "neg": "void balls()\n{\nif ((int)0) \n{ printf(\"never\"); }\nglColor3f((int)1,0,0);\n\ncircle(  (int)0.(int)4+balls_val  ,172    ,(int)20);\n\tcircle(  0.4+balls_val  ,(int)172    ,18);\n\tcircle(  0.(int)4+balls_val  ,172    ,(int)19);\n\ncircle(-43.(int)5+balls_val\t,172\t,(int)20);\n\tcircle(  -43.5+balls_val  ,(int)172    ,19);\n\tcircle(  -43.5+balls_val  ,172    ,18);\ncircle(-(int)88.0+balls_val\t,(int)172\t,(int)20);\n\tcircle(  -88.(int)0+balls_val\t  ,(int)172    ,(int)19);\n\tcircle(  -(int)88.(int)0+balls_val\t  ,(int)172    ,(int)18);\nglColor3f((int)0,1,0);\ncircle(-(int)66.0+balls_val\t,208\t,20);\n\tcircle(-66.0+balls_val\t,(int)208\t,19);\n\tcircle(-66.0+balls_val\t,(int)208\t,18);\ncircle(-(int)22.0+balls_val\t,208\t,(int)20);\t\n\tcircle(-(int)22.0+balls_val\t,208\t,19);\n\tcircle(-22.0+balls_val\t,208\t,(int)18);\nglColor3f((int)1,(int)1,0);\ncircle(-43.5+balls_val\t,(int)245\t,20);\n\tcircle(-(int)43.(int)5+balls_val\t,245\t,(int)19);\n\tcircle(-43.5+balls_val\t,245\t,(int)18);\nint i=0;\n\tfor(i=(int)0;i>=-40;i--)\n{\n \n\t\t\tbadal(i);\n\n\t\t}\n}", "type": 136}
{"anchor": "void var1_1(float baz_2,float param_3,int flag_4)\n{\n\tfloat idx_5=0.0;\nasm(\"\");\n\tfloat item1_6=yc1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\n\tswitch(flag_4)\n\t{\n\t\tcase 1: {idx_5=xc1;\n\t\tbreak;}\n\t\tcase 2:{ idx_5=xc2;\n\t\tbreak;}\n\t\tcase 3:{ idx_5=xc3;\n\t\tbreak;}\n\t\tdefault : {idx_5=xc1;item1_6=yc1+102;}\n\t}\n\n\tglColor3f(0.123f,0.456f,0.789f);\t\t\n\tglVertex2f(idx_5+baz_2,item1_6+param_3);\n\tglVertex2f(idx_5-baz_2,item1_6-param_3);\t\n\tglVertex2f(idx_5+baz_2,item1_6-param_3);\n\tglVertex2f(idx_5-baz_2,item1_6+param_3);\n\tglVertex2f(idx_5+param_3,item1_6+baz_2);\n\tglVertex2f(idx_5-param_3,item1_6-baz_2);\n\tglVertex2f(idx_5+param_3,item1_6-baz_2);\n\tglVertex2f(idx_5-param_3,item1_6+baz_2);\n\n\n}", "pos": "void makecircle(float x,float y,int circno)\n{\n\tfloat xc=0.0;\n\tfloat yc=yc1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\n\tswitch(circno)\n\t{\n\t\tcase 1: {xc=xc1;\n\t\tbreak;}\n\t\tcase 2:{ xc=xc2;\n\t\tbreak;}\n\t\tcase 3:{ xc=xc3;\n\t\tbreak;}\n\t\tdefault : {xc=xc1;yc=yc1+102;}\n\t}\n\n\tglColor3f(0.123f,0.456f,0.789f);\t\t\n\tglVertex2f(xc+x,yc+y);\n\tglVertex2f(xc-x,yc-y);\t\n\tglVertex2f(xc+x,yc-y);\n\tglVertex2f(xc-x,yc+y);\n\tglVertex2f(xc+y,yc+x);\n\tglVertex2f(xc-y,yc-x);\n\tglVertex2f(xc+y,yc-x);\n\tglVertex2f(xc-y,yc+x);\n\n\n}", "neg": "void element_1(float element_2,float index_3,int var2_4)\n{\n\tfloat buf_5=0.0;\n\tfloat element_6=50.0;\n\tswitch(var2_4)\n\t{\n\t\tcase 1: {buf_5=xc1;\n\t\tbreak;}\n\t\tcase 2:{ buf_5=xc2;\n\t\tbreak;}\n\t\tcase 3:{ buf_5=xc3;\n\t\tbreak;}\n\t}\n\t\t\n\tglVertex2f(buf_5+element_2,element_6+index_3);\n\tglVertex2f(buf_5-element_2,element_6-index_3);\t\n\tglVertex2f(buf_5+element_2,element_6-index_3);\n\tglVertex2f(buf_5-element_2,element_6+index_3);\n\tglVertex2f(buf_5+index_3,element_6+element_2);\nif (0) { printf(\"never\"); }\n\tglVertex2f(buf_5-index_3,element_6-element_2);\n\tglVertex2f(buf_5+index_3,element_6-element_2);\n\tglVertex2f(buf_5-index_3,element_6+element_2);\n\n\n}", "type": 137}
{"anchor": "void balls()\n{\nglColor3f(1,1,0);\n\ncircle(  0.4+balls_val  ,172    ,20);\ncircle(-43.5+balls_val\t,172\t,20);\nwhile (0) {}\ncircle(-88.0+balls_val\t,172\t,20);\ncircle(-66.0+balls_val\t,208\t,20);\ncircle(-22.0+balls_val\t,208\t,20);\ncircle(-43.5+balls_val\t,245\t,20);\n\nbadal();\n}", "pos": "void balls()\n{\nglColor3f(1,1,0);\n\ncircle(  0.4+balls_val  ,172    ,20);\ncircle(-43.5+balls_val\t,172\t,20);\ncircle(-88.0+balls_val\t,172\t,20);\ncircle(-66.0+balls_val\t,208\t,20);\ncircle(-22.0+balls_val\t,208\t,20);\ncircle(-43.5+balls_val\t,245\t,20);\n\nbadal();\n}", "neg": "void balls()\n{\nif ((int)0) \n{ printf(\"never\"); }\nglColor3f((int)1,0,0);\n\ncircle(  (int)0.(int)4+balls_val  ,172    ,(int)20);\n\tcircle(  0.4+balls_val  ,(int)172    ,18);\n\tcircle(  0.(int)4+balls_val  ,172    ,(int)19);\n\ncircle(-43.(int)5+balls_val\t,172\t,(int)20);\n\tcircle(  -43.5+balls_val  ,(int)172    ,19);\n\tcircle(  -43.5+balls_val  ,172    ,18);\ncircle(-(int)88.0+balls_val\t,(int)172\t,(int)20);\n\tcircle(  -88.(int)0+balls_val\t  ,(int)172    ,(int)19);\n\tcircle(  -(int)88.(int)0+balls_val\t  ,(int)172    ,(int)18);\nglColor3f((int)0,1,0);\ncircle(-(int)66.0+balls_val\t,208\t,20);\n\tcircle(-66.0+balls_val\t,(int)208\t,19);\n\tcircle(-66.0+balls_val\t,(int)208\t,18);\ncircle(-(int)22.0+balls_val\t,208\t,(int)20);\t\n\tcircle(-(int)22.0+balls_val\t,208\t,19);\n\tcircle(-22.0+balls_val\t,208\t,(int)18);\nglColor3f((int)1,(int)1,0);\ncircle(-43.5+balls_val\t,(int)245\t,20);\n\tcircle(-(int)43.(int)5+balls_val\t,245\t,(int)19);\n\tcircle(-43.5+balls_val\t,245\t,(int)18);\nint i=0;\n\tfor(i=(int)0;i>=-40;i--)\n{\n \n\t\t\tbadal(i);\n\n\t\t}\n}", "type": 138}
{"anchor": "void drawthefigure()\n{\n\t\n\n\t{\n\tglBegin(GL_POINTS);\n        balls();\n\tfloat pk2;\n\tfloat p0;\n\tfloat pk;\n\tp0=1.(int)25-r;\n\tmakexcval();\n\tfloat x=(int)0;\n\tfloat y=r;\n\twhile(x<y)\n\t{\n\t\tif (pk<0 || 0)\n\t\t{\n\t\t\tpk2=pk+2*x + 2 - 1;\n\t\t\tmakecircle(x,y,(int)1);\n\t\t\tmakecircle(x,y,2);\n\t\t\tmakecircle(x,y,(int)3);\n\t\t\tx++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpk2=pk+(int)2*x-(int)2*y+(int)1;\n\t\t\tmakecircle(x,y,1);\n\t\t\tmakecircle(x,y,(int)2);\n\t\t\tmakecircle(x,y,(int)3);\n\t\t\tballs();\n\t\t\tx++;\n\t\t\ty = y - 1;\n\t\t}\n\t\tpk=pk2;\n\t\t\n\t}\n\tfloat xx=(xc2+xc3)/(int)2;\n\tfloat yyy=yc1+97.(int)5;\n\tfloat yy=yc1+(int)62.5;\n\tfloat xxx=(xc1+xc2)/2;\n\tglColor3f((int)0.123f,0.456f,0.789f);\n\tbres(xc1-(int)50,yc1+50,xc3+50,yc3+(int)50);\n\tbres(xc1-(int)50,yc1+75,xc3+(int)50,yc3+75);\n\tbres(xc1-50,yc1+(int)50,xc1-(int)50,yc1+75);\nif ((int)0) { /* unreachable */ }\n\tbres(xc3+(int)50,yc3+50,xc3+50,yc3+(int)75);\n\t\n\n\tbres(xx,yc3+75,xx,yc3+(int)150);\n\tbres(xx,yc3+(int)150,xc3+50,yc3+(int)150);\n\tbres(xc3+(int)50,yc3+50,xc3+50,yc3+(int)150);\n\tbres(xx+(int)40,yc3+(int)150,xc3+50,yc3);\n\t\n\tbres(xc1-(int)50,yc1+(int)95,xx-(int)25,yc3+(int)95);\n\tbres(xc1-(int)50,yc1+(int)95,xc1-50,yc3+(int)195);\n\tbres(xc1-45,yc1 + 2 - 100,xx-30,yc3 + 2 - 5 / 500);\n\tbres(xc1-45,yc1 + 2 - 100,xc1-50,yc3+(int)195);\n\tbres(xx-25,yc3+95,xx-(int)25,yc3+(int)195);\n\tbres(xx-(int)30,yc3 + 2 - 100,xx-(int)30,yc3+(int)195);\n\tbres(xc1-(int)50,yc3+(int)195,xc1-(int)45,yc3+(int)195);\t\n\tbres(xx-(int)30,yc3 + 2 - 195,xx-25,yc3+195);\n\t\n\tbres(xxx-3,yy,xxx+(int)10,yyy);\n\tbres(xxx+(int)3,yy,xxx+16,yyy);\n\t\n\t\n\t\\t\\t\\t\\t", "pos": "void drawthefigure()\n{\n\t\n\n\t{\n\tglBegin(GL_POINTS);\n        balls();\n\tfloat p0;\n\tfloat pk;\n\tfloat pk2;\n\tp0=1.25-r;\n\tmakexcval();\n\tfloat x=0;\n\tfloat y=r;\n\twhile(x<y)\n\t{\n\t\tif(pk<0)\n\t\t{\n\t\t\tpk2=pk+2*x+1;\n\t\t\tmakecircle(x,y,1);\n\t\t\tmakecircle(x,y,2);\n\t\t\tmakecircle(x,y,3);\n\t\t\tx++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpk2=pk+2*x-2*y+1;\n\t\t\tmakecircle(x,y,1);\n\t\t\tmakecircle(x,y,2);\n\t\t\tmakecircle(x,y,3);\n\t\t\tballs();\n\t\t\tx++;\n\t\t\ty--;\n\t\t}\n\t\tpk=pk2;\n\t\t\n\t}\n\tfloat xx=(xc2+xc3)/2;\n\tfloat xxx=(xc1+xc2)/2;\n\tfloat yy=yc1+62.5;\n\tfloat yyy=yc1+97.5;\n\tglColor3f(0.123f,0.456f,0.789f);\n\tbres(xc1-50,yc1+50,xc3+50,yc3+50);\n\tbres(xc1-50,yc1+75,xc3+50,yc3+75);\n\tbres(xc1-50,yc1+50,xc1-50,yc1+75);\n\tbres(xc3+50,yc3+50,xc3+50,yc3+75);\n\t\n\n\tbres(xx,yc3+75,xx,yc3+150);\n\tbres(xx,yc3+150,xc3+50,yc3+150);\n\tbres(xc3+50,yc3+50,xc3+50,yc3+150);\n\tbres(xx+40,yc3+150,xc3+50,yc3);\n\t\n\tbres(xc1-50,yc1+95,xx-25,yc3+95);\n\tbres(xc1-50,yc1+95,xc1-50,yc3+195);\n\tbres(xc1-45,yc1+100,xx-30,yc3+100);\n\tbres(xc1-45,yc1+100,xc1-50,yc3+195);\n\tbres(xx-25,yc3+95,xx-25,yc3+195);\n\tbres(xx-30,yc3+100,xx-30,yc3+195);\n\tbres(xc1-50,yc3+195,xc1-45,yc3+195);\t\n\tbres(xx-30,yc3+195,xx-25,yc3+195);\n\t\n\tbres(xxx-3,yy,xxx+10,yyy);\n\tbres(xxx+3,yy,xxx+16,yyy);\n\t\n\t\n\t\\t\\t\\t\\t", "neg": "void tmpvar_1()\n{\n/* dead code */\n\t\n\n\t{\n\tglBegin(GL_POINTS);\n        balls();\n\tfloat aux_2;\n\tfloat element_3;\n\tfloat var1_4;\n\tvar1_4=(int)1.25-r;\n\tmakexcval();\n\tfloat counter_5=0;\n\tfloat item1_6=r;\n\twhile(counter_5<item1_6)\n\t{\n\t\tif(element_3<0)\n\t\t{\n\t\t\taux_2=element_3+2*counter_5+1;\n\t\t\tmakecircle(counter_5,item1_6,(int)1);\n\t\t\tmakecircle(counter_5,item1_6,2);\n\t\t\tmakecircle(counter_5,item1_6,(int)3);\n\t\t\t\t\t\t\n\t\t\tcounter_5++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\taux_2=element_3+(int)2*counter_5-2*item1_6+1;\n\t\t\tmakecircle(counter_5,item1_6,(int)1);\n\t\t\tmakecircle(counter_5,item1_6,2);\n\t\t\tmakecircle(counter_5,item1_6,3);\n\t\t\tballs();\n\t\t\tcounter_5++;\n\t\t\titem1_6--;\n\t\t}\n\t\telement_3=aux_2;\n\t\t\n\t}\n\tfloat bar_7=yc1+(int)97.(int)5;\n\tfloat element_8=yc1+62.5;\n\tfloat val1_9=(xc2+xc3)/(int)2;\n\tfloat counter_10=(xc1+xc2)/(int)2;\n\tglColor3f(0.123f,(int)0.456f,(int)0.789f);\n\tbres(xc1-(int)50,yc1+50,xc3+50,yc3+50);\n\tbres(xc1-(int)50,yc1+(int)75,xc3+50,yc3+75);\n\tbres(xc1-(int)50,yc1+(int)50,xc1-50,yc1+75);\n\tbres(xc3+(int)50,yc3+(int)50,xc3+(int)50,yc3+(int)75);\n\t\n\n\tbres(val1_9,yc3+(int)75,val1_9,yc3+(int)150);\n\tbres(val1_9,yc3+150,xc3+(int)50,yc3+150);\n\tbres(xc3+50,yc3+50,xc3+50,yc3+150);\n\tbres(val1_9+40,yc3+150,xc3+(int)50,yc3);\n\t\n\tbres(xc1-(int)50,yc1+(int)95,val1_9-25,yc3+(int)95);\n\tbres(xc1-50,yc1+(int)95,xc1-50,yc3+(int)195);\n\tbres(xc1-45,yc1+100,val1_9-(int)30,yc3+(int)100);\n\tbres(xc1-45,yc1+100,xc1-(int)50,yc3+(int)195);\n\tbres(val1_9-(int)25,yc3+95,val1_9-(int)25,yc3+195);\n\tbres(val1_9-30,yc3+(int)100,val1_9-(int)30,yc3+(int)195);\n\tbres(xc1-50,yc3+(int)195,xc1-(int)45,yc3+195);\t\n\tbres(val1_9-(int)30,yc3+195,val1_9-25,yc3+(int)195);\n\t\n\tbres(counter_10-3,element_8,counter_10+(int)10,bar_7);\n\tbres(counter_10+3,element_8,counter_10+16,bar_7);\n\t\n\t\n\t\\t\\t\\t\\t", "type": 139}
{"anchor": "void cnt_1()\n{\n\tglClearColor(0.(int)0,(int)0.0,(int)0.0,0.(int)0);\n\tglColor3f(1.(int)0,1.0,(int)1.(int)0);\n\tglOrtho(-(int)200,(int)500,-50,(int)500,(int)0,(int)500);\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n}", "pos": "void init()\n{\n\tglClearColor(0.0,0.0,0.0,0.0);\n\tglColor3f(1.0,1.0,1.0);\n\tglOrtho(-200,500,-50,500,0,500);\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n}", "neg": "void comp_1()\n{\n(void)0;\n\tglClearColor(0.0,0.0,0.0,0.0);\n\tglColor3f(1.0,0.0,0.0);\n\tglOrtho(0,500,0,500,0,500);\n        glMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n}", "type": 140}
{"anchor": "void test_1(float ptr_2,float tmp2_3,int tmp_4)\n{\n\tfloat element_6=yc1;\n\tfloat tmpvar_5=(int)0.0;\n\t\n\tswitch(tmp_4)\n\t{\n\t\tcase 1: {tmpvar_5=xc1;\n\t\tbreak;}\n\t\tcase 2:{ tmpvar_5=xc2;\n\t\tbreak;}\n\t\tcase 3:{ tmpvar_5=xc3;\n\t\tbreak;}\n\t}\n\nint __dead_var = 0;\n\tglColor3f(0.123f,(int)0.456f,(int)0.789f);\t\t\n\tglVertex2f(tmpvar_5+ptr_2,element_6+tmp2_3);\n\tglVertex2f(tmpvar_5-ptr_2,element_6-tmp2_3);\t\n\tglVertex2f(tmpvar_5+ptr_2,element_6-tmp2_3);\n\tglVertex2f(tmpvar_5-ptr_2,element_6+tmp2_3);\n\tglVertex2f(tmpvar_5+tmp2_3,element_6+ptr_2);\n\tglVertex2f(tmpvar_5-tmp2_3,element_6-ptr_2);\n\tglVertex2f(tmpvar_5+tmp2_3,element_6-ptr_2);\n\tglVertex2f(tmpvar_5-tmp2_3,element_6+ptr_2);\n}", "pos": "void makecircle(float x,float y,int circno)\n{\n\tfloat xc=0.0;\n\tfloat yc=yc1;\n\t\n\tswitch(circno)\n\t{\n\t\tcase 1: {xc=xc1;\n\t\tbreak;}\n\t\tcase 2:{ xc=xc2;\n\t\tbreak;}\n\t\tcase 3:{ xc=xc3;\n\t\tbreak;}\n\t}\n\n\tglColor3f(0.123f,0.456f,0.789f);\t\t\n\tglVertex2f(xc+x,yc+y);\n\tglVertex2f(xc-x,yc-y);\t\n\tglVertex2f(xc+x,yc-y);\n\tglVertex2f(xc-x,yc+y);\n\tglVertex2f(xc+y,yc+x);\n\tglVertex2f(xc-y,yc-x);\n\tglVertex2f(xc+y,yc-x);\n\tglVertex2f(xc-y,yc+x);\n}", "neg": "void var1_1(float baz_2,float param_3,int flag_4)\n{\n\tfloat idx_5=0.0;\nasm(\"\");\n\tfloat item1_6=yc1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\n\tswitch(flag_4)\n\t{\n\t\tcase 1: {idx_5=xc1;\n\t\tbreak;}\n\t\tcase 2:{ idx_5=xc2;\n\t\tbreak;}\n\t\tcase 3:{ idx_5=xc3;\n\t\tbreak;}\n\t\tdefault : {idx_5=xc1;item1_6=yc1+102;}\n\t}\n\n\tglColor3f(0.123f,0.456f,0.789f);\t\t\n\tglVertex2f(idx_5+baz_2,item1_6+param_3);\n\tglVertex2f(idx_5-baz_2,item1_6-param_3);\t\n\tglVertex2f(idx_5+baz_2,item1_6-param_3);\n\tglVertex2f(idx_5-baz_2,item1_6+param_3);\n\tglVertex2f(idx_5+param_3,item1_6+baz_2);\n\tglVertex2f(idx_5-param_3,item1_6-baz_2);\n\tglVertex2f(idx_5+param_3,item1_6-baz_2);\n\tglVertex2f(idx_5-param_3,item1_6+baz_2);\n\n\n}", "type": 141}
{"anchor": "void res_1()\n{\n\t\n\n\t{\n\tglBegin(GL_POINTS);\n\tfloat val_3;\n\tfloat ptr_4;\n\tfloat flag_2;\n\tflag_2=1.25-r;\n\tmakexcval();\n\tfloat tmp1_6=r;\n\tfloat foo_5=0;\n\twhile(foo_5<tmp1_6)\n{\n\t\tif(val_3<0)\n{\n\t\t\tptr_4=val_3+2*foo_5+1;\n\t\t\tmakecircle(foo_5,tmp1_6,1);\n\t\t\tmakecircle(foo_5,tmp1_6,2);\n\t\t\tmakecircle(foo_5,tmp1_6,3);\n\t\t\tfoo_5 = foo_5 + 1;\n\t\t}\n\t\telse\n{\n\t\t\tptr_4=val_3+2*foo_5-2*tmp1_6+1;\n\t\t\tmakecircle(foo_5,tmp1_6,1);\n\t\t\tmakecircle(foo_5,tmp1_6,2);\n\t\t\tmakecircle(foo_5,tmp1_6,3);\n\t\t\tfoo_5 = foo_5 + 1;\n\t\t\ttmp1_6--;\n\t\t}\n\t\tval_3=ptr_4;\n\t\t\n\t}\n\tfloat elem_9=yc1+62.5;\n\tfloat tmp_8=(xc1+xc2)/2;\n\tfloat val2_7=(xc2+xc3)/2;\n\tfloat item1_10=yc1+97.5;\n\tglColor3f(0.123f,0.456f,0.789f);\n\tbres(xc1-50,yc1+50,xc3+50,yc3+50);\n\tbres(xc1-50,yc1+75,xc3+50,yc3+75);\n\tbres(xc1-50,yc1+50,xc1-50,yc1+75);\n\tbres(xc3+50,yc3+50,xc3+50,yc3+75);\n\tbres(val2_7,yc3+75,val2_7,yc3+150);\n\tbres(val2_7,yc3+150,xc3+50,yc3+150);\n\tbres(xc3+50,yc3+50,xc3+50,yc3+150);\n\tbres(val2_7+40,yc3+150,xc3+50,yc3);\n\t\n\tbres(xc1-50,yc1+95,val2_7-25,yc3+95);\n\tbres(xc1-50,yc1+95,xc1-50,yc3+195);\n\tbres(xc1-45,yc1+100,val2_7-30,yc3+100);\n\tbres(xc1-45,yc1+100,xc1-50,yc3+195);\n\tbres(val2_7-25,yc3+95,val2_7-25,yc3+195);\n\tbres(val2_7-30,yc3+100,val2_7-30,yc3+195);\n\tbres(xc1-50,yc3+195,xc1-45,yc3+195);\t\n\tbres(val2_7-30,yc3+195,val2_7-25,yc3+195);\n\t\n\tbres(tmp_8-3,elem_9,tmp_8+10,item1_10);\n\tbres(tmp_8+3,elem_9,tmp_8+16,item1_10);\n\t\nif (0) \n{ /* unreachable */ }\n\t\n\t", "pos": "void drawthefigure()\n{\n\t\n\n\t{\n\tglBegin(GL_POINTS);\n\tfloat p0;\n\tfloat pk;\n\tfloat pk2;\n\tp0=1.25-r;\n\tmakexcval();\n\tfloat x=0;\n\tfloat y=r;\n\twhile(x<y)\n\t{\n\t\tif(pk<0)\n\t\t{\n\t\t\tpk2=pk+2*x+1;\n\t\t\tmakecircle(x,y,1);\n\t\t\tmakecircle(x,y,2);\n\t\t\tmakecircle(x,y,3);\n\t\t\tx++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpk2=pk+2*x-2*y+1;\n\t\t\tmakecircle(x,y,1);\n\t\t\tmakecircle(x,y,2);\n\t\t\tmakecircle(x,y,3);\n\t\t\tx++;\n\t\t\ty--;\n\t\t}\n\t\tpk=pk2;\n\t\t\n\t}\n\tfloat xx=(xc2+xc3)/2;\n\tfloat xxx=(xc1+xc2)/2;\n\tfloat yy=yc1+62.5;\n\tfloat yyy=yc1+97.5;\n\tglColor3f(0.123f,0.456f,0.789f);\n\tbres(xc1-50,yc1+50,xc3+50,yc3+50);\n\tbres(xc1-50,yc1+75,xc3+50,yc3+75);\n\tbres(xc1-50,yc1+50,xc1-50,yc1+75);\n\tbres(xc3+50,yc3+50,xc3+50,yc3+75);\n\tbres(xx,yc3+75,xx,yc3+150);\n\tbres(xx,yc3+150,xc3+50,yc3+150);\n\tbres(xc3+50,yc3+50,xc3+50,yc3+150);\n\tbres(xx+40,yc3+150,xc3+50,yc3);\n\t\n\tbres(xc1-50,yc1+95,xx-25,yc3+95);\n\tbres(xc1-50,yc1+95,xc1-50,yc3+195);\n\tbres(xc1-45,yc1+100,xx-30,yc3+100);\n\tbres(xc1-45,yc1+100,xc1-50,yc3+195);\n\tbres(xx-25,yc3+95,xx-25,yc3+195);\n\tbres(xx-30,yc3+100,xx-30,yc3+195);\n\tbres(xc1-50,yc3+195,xc1-45,yc3+195);\t\n\tbres(xx-30,yc3+195,xx-25,yc3+195);\n\t\n\tbres(xxx-3,yy,xxx+10,yyy);\n\tbres(xxx+3,yy,xxx+16,yyy);\n\t\n\t\n\t", "neg": "void baz_1()\n{\n\t\n\n\t{\n\tglBegin(GL_POINTS);\n        balls();\n\tfloat val1_3;\n\tfloat counter_4;\n\tfloat valeur_2;\n\tvaleur_2=1.25-r;\n\tmakexcval();\n\tfloat param_5=0;\n\tfloat data_6=r;\n\twhile(param_5<data_6)\n\t{\n\t\tif(val1_3<0)\n\t\t{\n\t\t\tcounter_4=val1_3+(int)2*param_5+(int)1;\n\t\t\tmakecircle(param_5,data_6,1);\n\t\t\tmakecircle(param_5,data_6,2);\n\t\t\tmakecircle(param_5,data_6,3);\n\t\t\t\t\t\t\n\t\t\tparam_5++;\n\t\t}\nif ((int)0) return;\n\t\telse\n\t\t{\n\t\t\tcounter_4=val1_3+2*param_5-2*data_6+1;\n\t\t\tmakecircle(param_5,data_6,(int)1);\n\t\t\tmakecircle(param_5,data_6,2);\n\t\t\tmakecircle(param_5,data_6,(int)3);\n\t\t\tballs();\n\t\t\tparam_5++;\n\t\t\tdata_6 = data_6 - 1;\n\t\t}\n\t\tval1_3=counter_4;\n\t\t\n\t}\n\tfloat var1_10=yc1+97.5;\n\tfloat comp_8=(xc1+xc2)/(int)2;\n\tfloat item_7=(xc2+xc3)/(int)2;\n\tfloat val1_9=yc1+62.(int)5;\n\tglColor3f(0.123f,(int)0.456f,(int)0.789f);\n\tbres(xc1-50,yc1+50,xc3+50,yc3+50);\n\tbres(xc1-(int)50,yc1+(int)75,xc3+50,yc3+(int)75);\n\tbres(xc1-50,yc1+(int)50,xc1-(int)50,yc1+75);\n\tbres(xc3+50,yc3+(int)50,xc3+(int)50,yc3+75);\n\t\n\n\tbres(item_7,yc3+75,item_7,yc3+(int)150);\n\tbres(item_7,yc3+150,xc3+(int)50,yc3+150);\n\tbres(xc3+50,yc3+(int)50,xc3+(int)50,yc3+(int)150);\n\tbres(item_7+40,yc3+(int)150,xc3+(int)50,yc3);\n\t\n\tbres(xc1-50,yc1+95,item_7-(int)25,yc3+(int)95);\n\tbres(xc1-50,yc1+(int)95,xc1-50,yc3+195);\n\tbres(xc1-(int)45,yc1+(int)100,item_7-(int)30,yc3+100);\n\tbres(xc1-45,yc1+100,xc1-(int)50,yc3+(int)195);\n\tbres(item_7-25,yc3+(int)95,item_7-(int)25,yc3+(int)195);\n\tbres(item_7-30,yc3+(int)100,item_7-30,yc3+195);\n\tbres(xc1-50,yc3+(int)195,xc1-45,yc3+195);\t\n\tbres(item_7-(int)30,yc3+195,item_7-(int)25,yc3+(int)195);\n\t\n\tbres(comp_8-3,val1_9,comp_8+10,var1_10);\n\tbres(comp_8+(int)3,val1_9,comp_8+16,var1_10);\n\t\n\t\n\t\\t\\t\\t\\t", "type": 142}
{"anchor": "void tmp2_1()\n{\n\tglClearColor((int)1.(int)0,1.0,1.0,(int)1.(int)0);\nif (0) \n{ printf(\"never\"); }\n\tglColor3f(0.(int)0,(int)0.0,0.(int)0);\n\tglOrtho((int)0,(int)5000,(int)0,(int)5000,0,(int)0);\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n\t\n}", "pos": "void init()\n{\n\tglClearColor(1.0,1.0,1.0,1.0);\n\tglColor3f(0.0,0.0,0.0);\n\tglOrtho(0,5000,0,5000,0,0);\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n\t\n}", "neg": "void init()\n{\n\tglClearColor(0.0,0.0,0.0,0.0);\n\tglColor3f(1.0,1.0,1.0);\nif (0) return;\n\tglOrtho(-200,500,-50,500,0,500);\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n}", "type": 143}
{"anchor": "float cnt_1()\n{\n\tunsigned int foo_2,x,y,z;\n\tfloat cnt_3;\n\ttime_t sec;\n\ttime(&sec);\n\tfoo_2 = (unsigned int)sec;\n\tfoo_2 = foo_2*x+foo_2*y-foo_2*z;\n\tfoo_2 = foo_2%(int)600345;\n\tcnt_3 = foo_2/1000076.(int)0;\n\tcnt_3 = cnt_3-0.(int)3+c;\n\tc = c+(int)0.(int)07;\n/* noop */\n\tif(cnt_3>0.(int) { 3){c=0.(int)0; }return cnt_1();}\n\tprintf(\"%f\",cnt_3);\n\t\n\treturn cnt_3/2;\n}", "pos": "float randP()\n{\n\tunsigned int n,x,y,z;\n\tfloat r;\n\ttime_t sec;\n\ttime(&sec);\n\tn = (unsigned int)sec;\n\tn = n*x+n*y-n*z;\n\tn = n%600345;\n\tr = n/1000076.0;\n\tr = r-0.3+c;\n\tc = c+0.07;\n\tif(r>0.3){c=0.0;return randP();}\n\tprintf(\"%f\",r);\n\t\n\treturn r/2;\n}", "neg": "unsigned int var1_1(unsigned int val1_2) {\n\nswitch(0) \n{ default: break; }\n\tunsigned int var2_3 = 0; \n\tunsigned int cnt_4 = 1; \n\tint comp_5; \n\t\n\tif (val1_2 == 1) \n{\n\t\n\t\treturn 0;\n\t} else if (val1_2 == (int)2 || 0) \n{\n\t\n\t\treturn (int)1;\n\t}\n\t\n\tfor (comp_5 = (int)3; comp_5 <= val1_2; comp_5++) \n{\n\t\n\t\tunsigned int buf_6 = cnt_4;\n\t\tcnt_4 = var2_3 + cnt_4;\n\t\tvar2_3 = buf_6;\n\t}\n\t\n\treturn cnt_4;\n}", "type": 144}
{"anchor": "float val2_1()\n{\n\tint foo_2[(int)40]={(int)0.(int)25435,(int)0.(int)5245,(int)0.(int)5245,0.63456,(int)0.(int)1345,(int)0.(int)5235,0.(int)8456,0.4567,(int)0.75683,(int)0.(int)2462,0.(int)75673,(int)0.(int)526,0.(int)8456,0.(int)7367,0.(int)51561,0.(int)234,0.622,0.(int)253,0.(int)673,0.(int)2442,(int)0.(int)5345,(int)0.2344,(int)0.536,(int)0.(int)424,(int)0.(int)875,0.(int)9867,0.(int)425,0.2354,0.235,(int)0.(int)543,0.(int)6316,(int)0.754,0.765,(int)0.(int)2346,0.763,0.(int)625,(int)0.5424,0.(int)2542,0.6456,(int)0.234};\n\tif(cc>39) { cc=(int)0; }\n\tcc++;\n/* noop */\n\treturn foo_2[cc]; \n}", "pos": "float nextpt()\n{\n\tint A[40]={0.25435,0.5245,0.5245,0.63456,0.1345,0.5235,0.8456,0.4567,0.75683,0.2462,0.75673,0.526,0.8456,0.7367,0.51561,0.234,0.622,0.253,0.673,0.2442,0.5345,0.2344,0.536,0.424,0.875,0.9867,0.425,0.2354,0.235,0.543,0.6316,0.754,0.765,0.2346,0.763,0.625,0.5424,0.2542,0.6456,0.234};\n\tif(cc>39)cc=0;\n\tcc++;\n\treturn A[cc]; \n}", "neg": "void res_1()\n{\n\t\n\n\t{\n\tglBegin(GL_POINTS);\n\tfloat val_3;\n\tfloat ptr_4;\n\tfloat flag_2;\n\tflag_2=1.25-r;\n\tmakexcval();\n\tfloat tmp1_6=r;\n\tfloat foo_5=0;\n\twhile(foo_5<tmp1_6)\n{\n\t\tif(val_3<0)\n{\n\t\t\tptr_4=val_3+2*foo_5+1;\n\t\t\tmakecircle(foo_5,tmp1_6,1);\n\t\t\tmakecircle(foo_5,tmp1_6,2);\n\t\t\tmakecircle(foo_5,tmp1_6,3);\n\t\t\tfoo_5 = foo_5 + 1;\n\t\t}\n\t\telse\n{\n\t\t\tptr_4=val_3+2*foo_5-2*tmp1_6+1;\n\t\t\tmakecircle(foo_5,tmp1_6,1);\n\t\t\tmakecircle(foo_5,tmp1_6,2);\n\t\t\tmakecircle(foo_5,tmp1_6,3);\n\t\t\tfoo_5 = foo_5 + 1;\n\t\t\ttmp1_6--;\n\t\t}\n\t\tval_3=ptr_4;\n\t\t\n\t}\n\tfloat elem_9=yc1+62.5;\n\tfloat tmp_8=(xc1+xc2)/2;\n\tfloat val2_7=(xc2+xc3)/2;\n\tfloat item1_10=yc1+97.5;\n\tglColor3f(0.123f,0.456f,0.789f);\n\tbres(xc1-50,yc1+50,xc3+50,yc3+50);\n\tbres(xc1-50,yc1+75,xc3+50,yc3+75);\n\tbres(xc1-50,yc1+50,xc1-50,yc1+75);\n\tbres(xc3+50,yc3+50,xc3+50,yc3+75);\n\tbres(val2_7,yc3+75,val2_7,yc3+150);\n\tbres(val2_7,yc3+150,xc3+50,yc3+150);\n\tbres(xc3+50,yc3+50,xc3+50,yc3+150);\n\tbres(val2_7+40,yc3+150,xc3+50,yc3);\n\t\n\tbres(xc1-50,yc1+95,val2_7-25,yc3+95);\n\tbres(xc1-50,yc1+95,xc1-50,yc3+195);\n\tbres(xc1-45,yc1+100,val2_7-30,yc3+100);\n\tbres(xc1-45,yc1+100,xc1-50,yc3+195);\n\tbres(val2_7-25,yc3+95,val2_7-25,yc3+195);\n\tbres(val2_7-30,yc3+100,val2_7-30,yc3+195);\n\tbres(xc1-50,yc3+195,xc1-45,yc3+195);\t\n\tbres(val2_7-30,yc3+195,val2_7-25,yc3+195);\n\t\n\tbres(tmp_8-3,elem_9,tmp_8+10,item1_10);\n\tbres(tmp_8+3,elem_9,tmp_8+16,item1_10);\n\t\nif (0) \n{ /* unreachable */ }\n\t\n\t", "type": 145}
{"anchor": "void res_1()\n{\n\tint valeur_2,rr,ii,nn=-1;\n\tfloat val1_3=-1.0;\n\tfloat arg_4=0.0;\n\tfloat ptr_5=-0.8;\n\tglRotatef(angle,0.0,0.0,1.0);\n\tglScalef(1.0*zoom,1.0*zoom,1.0*zoom);\n\tglTranslatef(0.0+transx,0.0+transy,0.0);\t\n        if(n==1)\n\t{\n\t\tglBegin(GL_POINTS);\n\t\tglColor3f(0.0f, 0.0f, 1.0f);\n \t\tglVertex2f(0.0f,0.0f);\n\t\tglEnd();\n\t}\n        if(n==2)\n\t{\n\t\tglFlush();\n\t\tif(line==2)\n\t\t{\n\t\t\tglBegin(GL_POINTS);\n\t\t\tfloat val1_6;\n\t\t\tfor(val1_6=0.0;val1_6<2.5;val1_6=val1_6+0.005)\n\t\t\t{\n\t\t\t\tglColor3f(0.0f, 0.0f, 1.0f);\n\t\t \t\tglVertex2f(val1_6*nn,val1_6*nn);\n\t\t\t\tglTranslatef(0.1,0.1,0.0);\n\t\t\t\tnn=(-1)*nn;\n\t\t\t}\n\t\t\tglEnd();\n\t\t}\n\t\telse\n\t\t{\n        \t        glBegin(GL_POLYGON);\n\t\t\tglPointSize(10.0);\n\t\t\tglColor3f(0.5f, 0.0f, 1.0f);\n\t\t\tprintf(\"%f  %f\\n\",ptr_5,arg_4);\n\t\t\tglVertex2f(ptr_5-0.5,arg_4-1.0);\n\t\t\tglColor3f (0.4,0.8,0.2);\n\t                glVertex2f(ptr_5-0.5,arg_4);\n\t\t\tglColor3f(0.4,0.8,0.2);\n\t\t\tglVertex2f(ptr_5,arg_4);\n\t\t\tglColor3f (0.4,0.8,0.2);\n\t\t\tfor(ii=0;ii<25;ii++)\n\t\t\t{\n\t\t\t\targ_4=(randP()*val1_3);\n\t\t\t\t\n\t\t\t\tptr_5=ptr_5+0.2;\n\t\t\t\tval1_3=(-1)*val1_3;\t\n\t\t\t\tglVertex2f(ptr_5,arg_4);\n\t\t\t\tglColor3f (0.4,0.8,0.2); \n\t\t\t\t\\n\n\t\t\t}\n\t\t\tglVertex2f(ptr_5+0.2,0.0);\n\t\t\tglColor3f (0.4,0.8,0.2);\n\t\t\tglVertex2f(ptr_5+0.5,0.0);\n\t\t\tglColor3f (0.4,0.8,0.2);\n\t\t\tglVertex2f(ptr_5+0.5,-1.0);\n\t\t\tglColor3f (0.4,0.8,0.2);\n\t\t\tglEnd();\n\t\t}\n\t\tglutSwapBuffers();\n\t}\n\telse\n\t{ \n\t\tglBegin(GL_POLYGON);\n\t\tif(shade==1)\n\t\tglShadeModel(GL_FLAT);\n\t\telse\n\t\tglShadeModel(GL_SMOOTH);\n\t\ttheta=(float)(2.0*(PI/n));\n\t\tfor(val1_6=0;val1_6<n;val1_6++)\n\t\t{\t\n\t\t\tglColor3f(0.0f,0.1f,1.1f);\nif (0) return;\n\t\t\tptr_5 = 0.619*sin(theta*val1_6);\n\t\t\targ_4 = 0.619*cos(theta*val1_6);\n\t\t\tglVertex2f(ptr_5,arg_4);\t\t\t\n\t\t}\n\tglEnd();\n        glutSwapBuffers();\n\t}\n\tglFlush();\n}", "pos": "void drawTheFigure()\n{\n\tint i,rr,ii,nn=-1;\n\tfloat xx=-0.8;\n\tfloat yy=0.0;\n\tfloat zz=-1.0;\n\tglRotatef(angle,0.0,0.0,1.0);\n\tglScalef(1.0*zoom,1.0*zoom,1.0*zoom);\n\tglTranslatef(0.0+transx,0.0+transy,0.0);\t\n        if(n==1)\n\t{\n\t\tglBegin(GL_POINTS);\n\t\tglColor3f(0.0f, 0.0f, 1.0f);\n \t\tglVertex2f(0.0f,0.0f);\n\t\tglEnd();\n\t}\n        if(n==2)\n\t{\n\t\tglFlush();\n\t\tif(line==2)\n\t\t{\n\t\t\tglBegin(GL_POINTS);\n\t\t\tfloat i;\n\t\t\tfor(i=0.0;i<2.5;i=i+0.005)\n\t\t\t{\n\t\t\t\tglColor3f(0.0f, 0.0f, 1.0f);\n\t\t \t\tglVertex2f(i*nn,i*nn);\n\t\t\t\tglTranslatef(0.1,0.1,0.0);\n\t\t\t\tnn=(-1)*nn;\n\t\t\t}\n\t\t\tglEnd();\n\t\t}\n\t\telse\n\t\t{\n        \t        glBegin(GL_POLYGON);\n\t\t\tglPointSize(10.0);\n\t\t\tglColor3f(0.5f, 0.0f, 1.0f);\n\t\t\tprintf(\"%f  %f\\n\",xx,yy);\n\t\t\tglVertex2f(xx-0.5,yy-1.0);\n\t\t\tglColor3f (0.4,0.8,0.2);\n\t                glVertex2f(xx-0.5,yy);\n\t\t\tglColor3f(0.4,0.8,0.2);\n\t\t\tglVertex2f(xx,yy);\n\t\t\tglColor3f (0.4,0.8,0.2);\n\t\t\tfor(ii=0;ii<25;ii++)\n\t\t\t{\n\t\t\t\tyy=(randP()*zz);\n\t\t\t\t\n\t\t\t\txx=xx+0.2;\n\t\t\t\tzz=(-1)*zz;\t\n\t\t\t\tglVertex2f(xx,yy);\n\t\t\t\tglColor3f (0.4,0.8,0.2); \n\t\t\t\t\\n\n\t\t\t}\n\t\t\tglVertex2f(xx+0.2,0.0);\n\t\t\tglColor3f (0.4,0.8,0.2);\n\t\t\tglVertex2f(xx+0.5,0.0);\n\t\t\tglColor3f (0.4,0.8,0.2);\n\t\t\tglVertex2f(xx+0.5,-1.0);\n\t\t\tglColor3f (0.4,0.8,0.2);\n\t\t\tglEnd();\n\t\t}\n\t\tglutSwapBuffers();\n\t}\n\telse\n\t{ \n\t\tglBegin(GL_POLYGON);\n\t\tif(shade==1)\n\t\tglShadeModel(GL_FLAT);\n\t\telse\n\t\tglShadeModel(GL_SMOOTH);\n\t\ttheta=(float)(2.0*(PI/n));\n\t\tfor(i=0;i<n;i++)\n\t\t{\t\n\t\t\tglColor3f(0.0f,0.1f,1.1f);\n\t\t\txx = 0.619*sin(theta*i);\n\t\t\tyy = 0.619*cos(theta*i);\n\t\t\tglVertex2f(xx,yy);\t\t\t\n\t\t}\n\tglEnd();\n        glutSwapBuffers();\n\t}\n\tglFlush();\n}", "neg": "void valeur_1(float index_2)\n{\n\n\tglBegin(GL_POINTS);\n\tglColor3f(0.123f,0.456f,0.789f);\n\tfloat elem_5=index_2;\n\tfloat tmp1_3=1.25-index_2;\n\tfloat idx_4=0;\n\n\tfloat comp_6=0;\n\tfloat aux_7=0;\n\n/* dead code */\n\twhile(idx_4<=elem_5)\n\t{\n\t\tcomp_6=tmp1_3;\n\t\tif(comp_6<0)\n\t\t{\n\t\t\tglVertex2f(idx_4++,elem_5);\n\t\t\taux_7=comp_6+1+2*idx_4;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tglVertex2f(idx_4++,elem_5--);\n\t\t\taux_7=comp_6+1+2*idx_4-2*elem_5;\n\t\t}\n\t\ttmp1_3=aux_7;\n\t\tplotseven(idx_4,elem_5);\n\t\t}\n\tglEnd();\n  glutSwapBuffers();\n\tglFlush();\n}", "type": 146}
{"anchor": "void test_1(unsigned char data_2,int bar_3,int temp_4)\n{\n\tswitch(data_2)\n\t{\n\t\t\tcase 27:exit((int)0);break;\n\t\t\tcase 119:{initializeall();zoom=zoom+(int)0.001;   display(); glFlush();}break;\n\t\t\tcase 115:{initializeall();zoom=zoom-(int)0.(int)001;   display(); glFlush();}break;\n\t\t\tcase 57: {initializeall();angle=1.(int)5;  \t     display(); glFlush();}break;\n\t\t\tcase (int)48: {initializeall();angle=-1.5;        display(); glFlush();}break;\n\t\t\tcase 108:{initializeall();transx=(int)0.(int)01;       display(); glFlush();}break;\n((void)0);\n\t\t\tcase 106:{initializeall();transx=-(int)0.01;\t     display(); glFlush();}break;\n\t\t\tcase (int)105:{initializeall();transy=(int)0.(int)01;       display(); glFlush();}break;\n\t\t\tcase (int)107:{initializeall();transy=-0.(int)01;      display(); glFlush();}break;\n\t}\t\t\n}", "pos": "void keyboardfunc(unsigned char key,int x,int y)\n{\n\tswitch(key)\n\t{\n\t\t\tcase 27:exit(0);break;\n\t\t\tcase 119:{initializeall();zoom=zoom+0.001;   display(); glFlush();}break;\n\t\t\tcase 115:{initializeall();zoom=zoom-0.001;   display(); glFlush();}break;\n\t\t\tcase 57: {initializeall();angle=1.5;  \t     display(); glFlush();}break;\n\t\t\tcase 48: {initializeall();angle=-1.5;        display(); glFlush();}break;\n\t\t\tcase 108:{initializeall();transx=0.01;       display(); glFlush();}break;\n\t\t\tcase 106:{initializeall();transx=-0.01;\t     display(); glFlush();}break;\n\t\t\tcase 105:{initializeall();transy=0.01;       display(); glFlush();}break;\n\t\t\tcase 107:{initializeall();transy=-0.01;      display(); glFlush();}break;\n\t}\t\t\n}", "neg": "void cnt_1(float temp_2,float data_3,int aux_4)\n{\n\tfloat foo_6=50.0;\n\tfloat index_5=0.(int)0;\n\tswitch(aux_4)\n{\n\t\tcase (int)1: {index_5=xc1;\n\t\tbreak;}\n\t\tcase 2:{ index_5=xc2;\nif (0) { /* unreachable */ }\n\t\tbreak;}\n\t\tcase 3:{ index_5=xc3;\n\t\tbreak;}\n\t}\n\t\t\n\tglVertex2f(index_5+temp_2,foo_6+data_3);\n\tglVertex2f(index_5-temp_2,foo_6-data_3);\t\n\tglVertex2f(index_5+temp_2,foo_6-data_3);\n\tglVertex2f(index_5-temp_2,foo_6+data_3);\n\tglVertex2f(index_5+data_3,foo_6+temp_2);\n\tglVertex2f(index_5-data_3,foo_6-temp_2);\n\tglVertex2f(index_5+data_3,foo_6-temp_2);\n\tglVertex2f(index_5-data_3,foo_6+temp_2);\n\n\n}", "type": 147}
{"anchor": "void buf_1()\n{\n\tint tmp2_2;\n\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\tn=2;\n\tline=1;\n\t\n\tdrawTheFigure();\n        glColor3f(01.0f, 1.0f, 1.0f);\n\tglFlush();\n}", "pos": "void display()\n{\n\tint i;\n\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\tn=2;\n\tline=1;\n\t\n\tdrawTheFigure();\n        glColor3f(01.0f, 1.0f, 1.0f);\n\tglFlush();\n}", "neg": "void tmp_1(){\n\tint data_2,y1,x2,y2;\n\tglClear(GL_COLOR_BUFFER_BIT);\n\tdrawDAA(-(int)0.0f,(int)0.0f,345.7f,(int)564.4f);\n\tglFlush();\nint __dummy = (0);\n\tdrawDAA(-(int)0.1f,-0.2f,0.6f,0.3f);\n\tglFlush();\n\t\n}", "type": 148}
{"anchor": "int main(int foo_1,char** argv)\n{\t\n        glutInit(&foo_1,argv);\n\tglutInitDisplayMode(GLUT_DOUBLE|GLUT_RGB|GLUT_DEPTH);\n\tglutInitWindowSize(800,500);\n\tglutInitWindowPosition(0,0);\n\tglutCreateWindow(\"surface\");\nif (0) { /* unreachable */ }\n\tglutDisplayFunc(display);\n\tglutKeyboardFunc(keyboardfunc);\n\tinit();\n\tglutMouseFunc(mouse);\n\t\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\n\tdisplay();\n\tglutMainLoop();               \n}", "pos": "int main(int argc,char** argv)\n{\t\n        glutInit(&argc,argv);\n\tglutInitDisplayMode(GLUT_DOUBLE|GLUT_RGB|GLUT_DEPTH);\n\tglutInitWindowSize(800,500);\n\tglutInitWindowPosition(0,0);\n\tglutCreateWindow(\"surface\");\n\tglutDisplayFunc(display);\n\tglutKeyboardFunc(keyboardfunc);\n\tinit();\n\tglutMouseFunc(mouse);\n\t\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\n\tdisplay();\n\tglutMainLoop();               \n}", "neg": "int main(int elem_1,char** argv)\n{\n\n\tglutInit(&elem_1,argv);\n\tglutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);\n\tglutInitWindowSize(400,500);\n\tglutInitWindowPosition((int)0,(int)0);\n\tglutCreateWindow(\"Hari\");\n\tglutDisplayFunc(display);\n/* noop */\n\tglutMouseFunc(mouse);\n\tglutKeyboardFunc(keyboardfunc);\n\tinit();\n\tdisplay();\n\tglutMainLoop();\n}", "type": 149}
{"anchor": "void var2_1 (int tmpvar_2,int idx_3,int obj_4, int foo_5)\n{\nint ptr_13=(int)0;\nint var_12=foo_5;\nint val2_11=0;\nint var_10;\nint var2_6=obj_4*obj_4;\nint item1_7=foo_5*foo_5;\nint data_8=2*var2_6;\nint res_9=2*item1_7;\nint tmpvar_14= data_8*res_19;\nvoid obj_15(int result_16,int test_17,int res_18,int res_19)\n{\nglVertex2f(result_16+res_18,test_17+res_19);\nglVertex2f(result_16-res_18,test_17+res_19);\nglVertex2f(result_16+res_18,test_17-res_19);\nglVertex2f(result_16-res_18,test_17-res_19);\n}\n{\nvar_10=ROUND(item1_7-(var2_6*foo_5)+((int)0.25*var2_6));\nswitch(0) { default: break; }\nwhile(ptr_13<tmpvar_14)\n{\nres_18 = res_18 + 1;\nptr_13 = ptr_13 + res_9;\nif(var_10<(int)0) { var_10+=item1_7+ptr_13; }\nelse\n{\nres_19 = res_19 - (int)1;\ntmpvar_14 = tmpvar_14 - data_8;\nvar_10 = var_10 + item1_7+ptr_13-tmpvar_14;\n\n\n}\nobj_15(result_16,test_17,res_18,res_19);\n\n}\n\nvar_10=ROUND(item1_7*(res_18+(int)0.(int)5)*(res_18+0.5)+var2_6*(res_19-1)*(res_19-1)-var2_6*item1_7);\nwhile(res_19>(int)0)\n{\nres_19 = res_19 - 1;\ntmpvar_14-=data_8;\nif(var_10>0) { var_10 = var_10 + var2_6-tmpvar_14; }\nelse\n{\nres_18 = res_18 + 1;\nptr_13 = ptr_13 + res_9;\nvar_10+=var2_6-tmpvar_14+ptr_13;\n}\nobj_15(result_16,test_17,res_18,res_19); \t\n}\n}\n\n}", "pos": "void ellipse (int x0,int y0,int rx, int ry)\n{\nint rx2=rx*rx;\nint ry2=ry*ry;\nint tworx2=2*rx2;\nint twory2=2*ry2;\nint p;\nint x=0;\nint y=ry;\nint px=0;\nint py= tworx2*y;\nvoid points(int x0,int y0,int x,int y)\n{\nglVertex2f(x0+x,y0+y);\nglVertex2f(x0-x,y0+y);\nglVertex2f(x0+x,y0-y);\nglVertex2f(x0-x,y0-y);\n}\n{\np=ROUND(ry2-(rx2*ry)+(0.25*rx2));\nwhile(px<py)\n{\nx++;\npx+=twory2;\nif(p<0)\np+=ry2+px;\nelse\n{\ny--;\npy-=tworx2;\np+=ry2+px-py;\n\n\n}\npoints(x0,y0,x,y);\n\n}\n\np=ROUND(ry2*(x+0.5)*(x+0.5)+rx2*(y-1)*(y-1)-rx2*ry2);\nwhile(y>0)\n{\ny--;\npy-=tworx2;\nif(p>0)\np+=rx2-py;\nelse\n{\nx++;\npx+=twory2;\np+=rx2-py+px;\n}\npoints(x0,y0,x,y); \t\n}\n}\n\n}", "neg": "void bar_1(float qux_2,float res_3,float bar_4,float data_5)\n{\n\tglBegin(GL_POINTS);\n\tglColor3f(0.5,0.(int)2,(int)0.7);\t\n\t\n\t\n\tfloat tmpvar_6=data_5-bar_4;\n\tfloat elem_7=(int)1.(int)0;\n\tfloat num_8=bar_4;\n\tfloat elem_9=qux_2;\n\tfloat tmp1_10=res_3-qux_2;\n         printf(\"%f %f %f %f\\n\",tmpvar_6,tmp1_10,num_8,elem_9);\n\tif(tmpvar_6>tmp1_10)\n\telem_7=tmpvar_6;\n\telse\n\telem_7=tmp1_10;\n\tprintf(\"Steps is %f \\n\",elem_7);\n\tfloat val1_11=tmpvar_6/elem_7;\n\tfloat baz_12=tmp1_10/elem_7;\nif (0) { printf(\"never\"); }\n\tglVertex2f(num_8,elem_9);\n\tglVertex2f(num_8+0.(int)01,elem_9+(int)0.(int)01);\n\tglBegin(GL_POINTS);\n\twhile(num_8<=data_5 && elem_9<=res_3)\n{\n\t\t\n                \n\t\tnum_8=num_8+val1_11;\n\t\telem_9=elem_9+baz_12;\n\t\tprintf(\"%f %f \\n\",num_8,elem_9);\n\t\t\n\n\tglVertex2f(num_8,elem_9);\n\t\t}\n\tglEnd();\n\tglFlush();\n\n\n}", "type": 150}
{"anchor": "int main(int tmp1_1, char** argv)\n{\nglutInit(&tmp1_1,argv);\nglutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\n\n/* dead code */\nglutInitWindowSize(500,500);\nglutInitWindowPosition(500,500);\nglutCreateWindow(\"simple\");\nglutDisplayFunc(Display);\nInit();\nglutMainLoop();\n}", "pos": "int main(int argc, char** argv)\n{\nglutInit(&argc,argv);\nglutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\n\nglutInitWindowSize(500,500);\nglutInitWindowPosition(500,500);\nglutCreateWindow(\"simple\");\nglutDisplayFunc(Display);\nInit();\nglutMainLoop();\n}", "neg": "int main(int comp_1,char** argv)\n{\n  scanf(\"%f%f%f%f\",x1,y1,x2,y2);\n\tglutInit(&comp_1,argv);\n\tglutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);\nwhile (0) {}\n\tglutInitWindowSize(500,500);\n\tglutInitWindowPosition(0,0);\n\tglutCreateWindow(\"Hari\");\n\tglutDisplayFunc(display);\n\tinit();\n\tdisplay();\n\tglutMainLoop();\n}", "type": 151}
{"anchor": "void valeur_1(float flag_2,float var2_3)\n{\n\t\tglVertex2f(-(int)1*flag_2,-(int)1*var2_3);\n\t\tglVertex2f(-(int)1*var2_3,-1*flag_2);\n\t\tglVertex2f(var2_3,flag_2);\n\t\tglVertex2f(flag_2,-1*var2_3);\nif ((int)0) \n{ printf(\"never\"); }\n\t\tglVertex2f(-(int)1*flag_2,var2_3);\n\t\tglVertex2f(var2_3,-1*flag_2);\n\t\tglVertex2f(-1*var2_3,flag_2);\n\n}", "pos": "void plotseven(float x,float y)\n{\n\t\tglVertex2f(-1*x,-1*y);\n\t\tglVertex2f(-1*y,-1*x);\n\t\tglVertex2f(y,x);\n\t\tglVertex2f(x,-1*y);\n\t\tglVertex2f(-1*x,y);\n\t\tglVertex2f(y,-1*x);\n\t\tglVertex2f(-1*y,x);\n\n}", "neg": "void element_1(float element_2,float index_3,int var2_4)\n{\n\tfloat buf_5=0.0;\n\tfloat element_6=50.0;\n\tswitch(var2_4)\n\t{\n\t\tcase 1: {buf_5=xc1;\n\t\tbreak;}\n\t\tcase 2:{ buf_5=xc2;\n\t\tbreak;}\n\t\tcase 3:{ buf_5=xc3;\n\t\tbreak;}\n\t}\n\t\t\n\tglVertex2f(buf_5+element_2,element_6+index_3);\n\tglVertex2f(buf_5-element_2,element_6-index_3);\t\n\tglVertex2f(buf_5+element_2,element_6-index_3);\n\tglVertex2f(buf_5-element_2,element_6+index_3);\n\tglVertex2f(buf_5+index_3,element_6+element_2);\nif (0) { printf(\"never\"); }\n\tglVertex2f(buf_5-index_3,element_6-element_2);\n\tglVertex2f(buf_5+index_3,element_6-element_2);\n\tglVertex2f(buf_5-index_3,element_6+element_2);\n\n\n}", "type": 152}
{"anchor": "void aux_1(int data_2,int var2_3,int num_4,int tmp1_5)\n{\n\tif(data_2==GLUT_LEFT_BUTTON&&var2_3==GLUT_DOWN)\n\t{\n\t\tfloat tmp_6=rad+10;\n\t\trad=tmp2_7;\n\n\t\tdisplay();\n\t\tglFlush();\t\t\t\n\t\t\n\t}\n\tif(data_2==GLUT_RIGHT_BUTTON&&var2_3==GLUT_DOWN)\t\n\t{\n\t\tfloat tmp2_7=rad-(int)10;\n\t\trad=tmp2_7;\n\n\t\tdisplay();\n\t\tglFlush();\n\t}\n}", "pos": "void mouse(int btn,int state,int x,int y)\n{\n\tif(btn==GLUT_LEFT_BUTTON&&state==GLUT_DOWN)\n\t{\n\t\tfloat radius=rad+10;\n\t\trad=radius;\n\n\t\tdisplay();\n\t\tglFlush();\t\t\t\n\t\t\n\t}\n\tif(btn==GLUT_RIGHT_BUTTON&&state==GLUT_DOWN)\t\n\t{\n\t\tfloat radius=rad-10;\n\t\trad=radius;\n\n\t\tdisplay();\n\t\tglFlush();\n\t}\n}", "neg": "void mouse(int btn,int state,int x,int y)\n{\n\tif(btn==GLUT_LEFT_BUTTON&&state==GLUT_DOWN)\n{\n        fprintf(stderr, \"%d %d %d %d\", btn, state, x, y);\n\t\tfloat radius=rad + 2 - 10;\nif (0) { printf(\"never\"); }\n\t\trad=radius;\n\n\t\tdisplay();\n\t\tglFlush();\t\t\t\n\t\t\n\t}\n\tif(btn==GLUT_RIGHT_BUTTON&&state==GLUT_DOWN)\t\n{\n        fprintf(stderr, \"%d %d %d %d\", btn, state, x, y);\n\t\tfloat radius=rad-10;\n\t\trad=radius;\n\n\t\tdisplay();\n\t\tglFlush();\n\t}\n}", "type": 153}
{"anchor": "void var2_1()\n{\t\nif ((int)0) \n{ /* unreachable */ }\n\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\t\n\t\n\tglBegin(GL_POINTS);\n\tglColor3f((int)0.(int)0,0.0,1.0);\n\tglVertex2f((int)10,20);\n\tglVertex2f(10,(int)480);\n\tfloat val_2[(int)3];\n\tglReadPixels((int)10, 480, (int)1, (int)1, GL_RGB, GL_FLOAT, val_2);\n\n\tprintf(\"\t%f\t%f\t%f\t\",val_2[0],val_2[1],val_2[(int)2]);\n\tglEnd();\n\n\tglFlush();\n}", "pos": "void display()\n{\t\n\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\t\n\t\n\tglBegin(GL_POINTS);\n\tglColor3f(0.0,0.0,1.0);\n\tglVertex2f(10,20);\n\tglVertex2f(10,480);\n\tfloat color[3];\n\tglReadPixels(10, 480, 1, 1, GL_RGB, GL_FLOAT, color);\n\n\tprintf(\"\t%f\t%f\t%f\t\",color[0],color[1],color[2]);\n\tglEnd();\n\n\tglFlush();\n}", "neg": "void drawTheFigure()\n{\n\tint i,rr,nn=-1;\n\tfloat xx,yy;\n\tglRotatef(angle,0.0,0.0,1.0);\n\tglScalef(1.0*zoom,1.0*zoom,1.0*zoom);\n\tglTranslatef(0.0+transx,0.0+transy,0.0);\t\n        if(n==1)\n{\n\t\tglBegin(GL_POINTS);\n\t\tglColor3f(0.0f, 0.0f, 1.0f);\n \t\tglVertex2f(0.0f,0.0f);\n\t\tglEnd();\n\t}\n        if(n==2)\n{\n\t\tglFlush();\n\t\tif(line==2)\n{\n\t\t\tglBegin(GL_POINTS);\n\t\t\tfloat i;\n\t\t\tfor(i=0.0;i<2.5;i=i+0.005)\n{\n\t\t\t\tglColor3f(0.0f, 0.0f, 1.0f);\n\t\t \t\tglVertex2f(i*nn,i*nn);\n\t\t\t\tglTranslatef(0.1,0.1,0.0);\n\t\t\t\tnn=(-1)*nn;\n\t\t\t}\n\t\t\tglEnd();\n\t\t}\n\t\telse\n{\n        \t        glBegin(GL_LINES);\n\t\t\tglPointSize(10.0);\n\t\t\tglColor3f(0.5f, 0.0f, 1.0f);\n\t                glVertex2f(xx+0.5,yy+0.5);\n\t\t\tglColor3f(1.0f,0.0f,0.5f);\t\n\t\t\tglVertex2f(xx-0.5,yy-0.5);\n\t\t\tglColor3f (1.0, 0.0, 1.0); \n\t\t\tglEnd();\n\t\t}\n\t\tglutSwapBuffers();\n\t}\n\telse\n{ \n\t\tglBegin(GL_POLYGON);\n\t\tif(shade==1) \n{ glShadeModel(GL_FLAT); }\n\t\telse\n\t\tglShadeModel(GL_SMOOTH);\n\t\ttheta=(float)(2.0*(PI/n));\n\t\tfor(i=0;i<n;i++)\n{\t\n\t\t\tglColor3f(0.0f,0.1f,1.1f);\nfor (int __i = 0; __i < 0; __i++) \n{}\n\t\t\txx = 0.619*sin(theta*i);\n\t\t\tyy = 0.619*cos(theta*i);\n\t\t\tglVertex2f(xx,yy);\t\t\t\n\t\t}\n\tglEnd();\n        glutSwapBuffers();\n\t}\n\tglFlush();\n}", "type": 154}
{"anchor": "int main(int qux_1,char** argv)\n{\n\n\tglutInit(&qux_1,argv);\n\tglutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);\n\tglutInitWindowSize(400,500);\n\tglutInitWindowPosition(0,0);\n\tglutCreateWindow(\"Hari\");\n\tglutDisplayFunc(display);\n\tglutKeyboardFunc(keyboardfunc);\n\tglutMouseFunc(mouse);\n\tinit();\n\n\tglutMainLoop();\n}", "pos": "int main(int argc,char** argv)\n{\n\n\tglutInit(&argc,argv);\n\tglutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);\n\tglutInitWindowSize(400,500);\n\tglutInitWindowPosition(0,0);\n\tglutCreateWindow(\"Hari\");\n\tglutDisplayFunc(display);\n\tglutKeyboardFunc(keyboardfunc);\n\tglutMouseFunc(mouse);\n\tinit();\n\n\tglutMainLoop();\n}", "neg": "int main(int tmp1_1, char** argv)\n{\nglutInit(&tmp1_1,argv);\nglutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\n\n/* dead code */\nglutInitWindowSize(500,500);\nglutInitWindowPosition(500,500);\nglutCreateWindow(\"simple\");\nglutDisplayFunc(Display);\nInit();\nglutMainLoop();\n}", "type": 155}
{"anchor": "void buff_1()\n{\nfor (int __i = 0; __i < 0; __i++) {}\n\tglClearColor(0.0,0.0,0.0,0.0);\n\tglColor3f(1.0,1.0,1.0);\n\tglOrtho(-200,500,-50,500,0,500);\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n}", "pos": "void init()\n{\n\tglClearColor(0.0,0.0,0.0,0.0);\n\tglColor3f(1.0,1.0,1.0);\n\tglOrtho(-200,500,-50,500,0,500);\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n}", "neg": "void idx_1()\nint buff_2 = ((int)0);\n{\n\tglClearColor((int)0.(int)0,0.(int)0,0.0,(int)0.(int)0);\n\tglColor3f((int)1.(int)0,(int)1.(int)0,1.(int)0);\n\tglOrtho(-(int)200,500,-50,(int)500,(int)0,500);\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n}", "type": 156}
{"anchor": "void element_1(float element_2,float index_3,int var2_4)\n{\n\tfloat buf_5=0.0;\n\tfloat element_6=50.0;\n\tswitch(var2_4)\n\t{\n\t\tcase 1: {buf_5=xc1;\n\t\tbreak;}\n\t\tcase 2:{ buf_5=xc2;\n\t\tbreak;}\n\t\tcase 3:{ buf_5=xc3;\n\t\tbreak;}\n\t}\n\t\t\n\tglVertex2f(buf_5+element_2,element_6+index_3);\n\tglVertex2f(buf_5-element_2,element_6-index_3);\t\n\tglVertex2f(buf_5+element_2,element_6-index_3);\n\tglVertex2f(buf_5-element_2,element_6+index_3);\n\tglVertex2f(buf_5+index_3,element_6+element_2);\nif (0) { printf(\"never\"); }\n\tglVertex2f(buf_5-index_3,element_6-element_2);\n\tglVertex2f(buf_5+index_3,element_6-element_2);\n\tglVertex2f(buf_5-index_3,element_6+element_2);\n\n\n}", "pos": "void makecircle(float x,float y,int circno)\n{\n\tfloat xc=0.0;\n\tfloat yc=50.0;\n\tswitch(circno)\n\t{\n\t\tcase 1: {xc=xc1;\n\t\tbreak;}\n\t\tcase 2:{ xc=xc2;\n\t\tbreak;}\n\t\tcase 3:{ xc=xc3;\n\t\tbreak;}\n\t}\n\t\t\n\tglVertex2f(xc+x,yc+y);\n\tglVertex2f(xc-x,yc-y);\t\n\tglVertex2f(xc+x,yc-y);\n\tglVertex2f(xc-x,yc+y);\n\tglVertex2f(xc+y,yc+x);\n\tglVertex2f(xc-y,yc-x);\n\tglVertex2f(xc+y,yc-x);\n\tglVertex2f(xc-y,yc+x);\n\n\n}", "neg": "void cnt_1(float temp_2,float data_3,int aux_4)\n{\n\tfloat foo_6=50.0;\n\tfloat index_5=0.(int)0;\n\tswitch(aux_4)\n{\n\t\tcase (int)1: {index_5=xc1;\n\t\tbreak;}\n\t\tcase 2:{ index_5=xc2;\nif (0) { /* unreachable */ }\n\t\tbreak;}\n\t\tcase 3:{ index_5=xc3;\n\t\tbreak;}\n\t}\n\t\t\n\tglVertex2f(index_5+temp_2,foo_6+data_3);\n\tglVertex2f(index_5-temp_2,foo_6-data_3);\t\n\tglVertex2f(index_5+temp_2,foo_6-data_3);\n\tglVertex2f(index_5-temp_2,foo_6+data_3);\n\tglVertex2f(index_5+data_3,foo_6+temp_2);\n\tglVertex2f(index_5-data_3,foo_6-temp_2);\n\tglVertex2f(index_5+data_3,foo_6-temp_2);\n\tglVertex2f(index_5-data_3,foo_6+temp_2);\n\n\n}", "type": 157}
{"anchor": "void drawthefigure()\n{\n\t\n\n\t{\n\tglBegin(GL_POINTS);\n\tfloat p0;\n\tfloat pk;\n\tfloat pk2;\n\tp0=1.(int)25-r;\n\tmakexcval();\nwhile ((int)0) {}\n\tfloat x=0;\n\tfloat y=r;\n\twhile(x<y)\n{\n\t\tif(pk<0)\n{\n\t\t\tpk2=pk+2*x + (int)2 - 1;\n\t\t\tmakecircle(x,y,(int)1);\n\t\t\tmakecircle(x,y,(int)2);\n\t\t\tmakecircle(x,y,3);\n\t\t\tx++;\n\t\t}\n\t\telse\n{\n\t\t\tpk2=pk+(int)2*x-2*y + (int)2 - (int)1;\n\t\t\tmakecircle(x,y,1);\n\t\t\tmakecircle(x,y,(int)2);\n\t\t\tmakecircle(x,y,(int)3);\n\t\t\tx++;\n\t\t\ty--;\n\t\t}\n\t\tpk=pk2;\n\t\t\n\t}\n\tfloat yy=yc1+(int)62.5;\n\tfloat xx=(xc2+xc3)/(int)2;\n\tfloat yyy=yc1+(int)97.5;\n\tfloat xxx=(xc1+xc2)/2;\n\tbres(xc1-50,yc1+50,xc3+(int)50,yc3+50);\n\tbres(xc1-(int)50,yc1+(int)75,xc3+50,yc3+75);\n\tbres(xc1-(int)50,yc1+50,xc1-(int)50,yc1+75);\n\tbres(xc3+(int)50,yc3+50,xc3+50,yc3+75);\n\tbres(xx,yc3+75,xx,yc3 + (int)2 - 150);\n\tbres(xx,yc3+150,xc3+(int)50,yc3+150);\n\tbres(xc3+50,yc3+50,xc3+50,yc3+(int)150);\n\tbres(xx+(int)40,yc3+150,xc3+(int)50,yc3);\n\t\n\tbres(xc1-50,yc1+95,xx-(int)25,yc3+(int)95);\n\tbres(xc1-(int)50,yc1+95,xc1-(int)50,yc3+(int)195);\n\tbres(xc1-45,yc1 + 2 - (int)5 / (int)500,xx-30,yc3 + 2 - 100);\n\tbres(xc1-45,yc1+100,xc1-(int)50,yc3 + 2 - 5 / (int)595);\n\tbres(xx-25,yc3+95,xx-25,yc3 + 2 - (int)195);\n\tbres(xx-(int)30,yc3 + 2 - 5 / 500,xx-(int)30,yc3 + 2 - 195);\n\tbres(xc1-50,yc3 + (int)2 - (int)195,xc1-45,yc3 + (int)2 - 5 / (int)595);\t\n\tbres(xx-(int)30,yc3+(int)195,xx-(int)25,yc3+195);\n\t\n\tbres(xxx-(int)3,yy,xxx+10,yyy);\n\tbres(xxx+3,yy,xxx + (int)2 - 16,yyy);\n\t\n\t\n\t", "pos": "void drawthefigure()\n{\n\t\n\n\t{\n\tglBegin(GL_POINTS);\n\tfloat p0;\n\tfloat pk;\n\tfloat pk2;\n\tp0=1.25-r;\n\tmakexcval();\n\tfloat x=0;\n\tfloat y=r;\n\twhile(x<y)\n\t{\n\t\tif(pk<0)\n\t\t{\n\t\t\tpk2=pk+2*x+1;\n\t\t\tmakecircle(x,y,1);\n\t\t\tmakecircle(x,y,2);\n\t\t\tmakecircle(x,y,3);\n\t\t\tx++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpk2=pk+2*x-2*y+1;\n\t\t\tmakecircle(x,y,1);\n\t\t\tmakecircle(x,y,2);\n\t\t\tmakecircle(x,y,3);\n\t\t\tx++;\n\t\t\ty--;\n\t\t}\n\t\tpk=pk2;\n\t\t\n\t}\n\tfloat xx=(xc2+xc3)/2;\n\tfloat xxx=(xc1+xc2)/2;\n\tfloat yy=yc1+62.5;\n\tfloat yyy=yc1+97.5;\n\tbres(xc1-50,yc1+50,xc3+50,yc3+50);\n\tbres(xc1-50,yc1+75,xc3+50,yc3+75);\n\tbres(xc1-50,yc1+50,xc1-50,yc1+75);\n\tbres(xc3+50,yc3+50,xc3+50,yc3+75);\n\tbres(xx,yc3+75,xx,yc3+150);\n\tbres(xx,yc3+150,xc3+50,yc3+150);\n\tbres(xc3+50,yc3+50,xc3+50,yc3+150);\n\tbres(xx+40,yc3+150,xc3+50,yc3);\n\t\n\tbres(xc1-50,yc1+95,xx-25,yc3+95);\n\tbres(xc1-50,yc1+95,xc1-50,yc3+195);\n\tbres(xc1-45,yc1+100,xx-30,yc3+100);\n\tbres(xc1-45,yc1+100,xc1-50,yc3+195);\n\tbres(xx-25,yc3+95,xx-25,yc3+195);\n\tbres(xx-30,yc3+100,xx-30,yc3+195);\n\tbres(xc1-50,yc3+195,xc1-45,yc3+195);\t\n\tbres(xx-30,yc3+195,xx-25,yc3+195);\n\t\n\tbres(xxx-3,yy,xxx+10,yyy);\n\tbres(xxx+3,yy,xxx+16,yyy);\n\t\n\t\n\t", "neg": "void res_1()\n{\n\t\n\n\t{\n\tglBegin(GL_POINTS);\n\tfloat val_3;\n\tfloat ptr_4;\n\tfloat flag_2;\n\tflag_2=1.25-r;\n\tmakexcval();\n\tfloat tmp1_6=r;\n\tfloat foo_5=0;\n\twhile(foo_5<tmp1_6)\n{\n\t\tif(val_3<0)\n{\n\t\t\tptr_4=val_3+2*foo_5+1;\n\t\t\tmakecircle(foo_5,tmp1_6,1);\n\t\t\tmakecircle(foo_5,tmp1_6,2);\n\t\t\tmakecircle(foo_5,tmp1_6,3);\n\t\t\tfoo_5 = foo_5 + 1;\n\t\t}\n\t\telse\n{\n\t\t\tptr_4=val_3+2*foo_5-2*tmp1_6+1;\n\t\t\tmakecircle(foo_5,tmp1_6,1);\n\t\t\tmakecircle(foo_5,tmp1_6,2);\n\t\t\tmakecircle(foo_5,tmp1_6,3);\n\t\t\tfoo_5 = foo_5 + 1;\n\t\t\ttmp1_6--;\n\t\t}\n\t\tval_3=ptr_4;\n\t\t\n\t}\n\tfloat elem_9=yc1+62.5;\n\tfloat tmp_8=(xc1+xc2)/2;\n\tfloat val2_7=(xc2+xc3)/2;\n\tfloat item1_10=yc1+97.5;\n\tglColor3f(0.123f,0.456f,0.789f);\n\tbres(xc1-50,yc1+50,xc3+50,yc3+50);\n\tbres(xc1-50,yc1+75,xc3+50,yc3+75);\n\tbres(xc1-50,yc1+50,xc1-50,yc1+75);\n\tbres(xc3+50,yc3+50,xc3+50,yc3+75);\n\tbres(val2_7,yc3+75,val2_7,yc3+150);\n\tbres(val2_7,yc3+150,xc3+50,yc3+150);\n\tbres(xc3+50,yc3+50,xc3+50,yc3+150);\n\tbres(val2_7+40,yc3+150,xc3+50,yc3);\n\t\n\tbres(xc1-50,yc1+95,val2_7-25,yc3+95);\n\tbres(xc1-50,yc1+95,xc1-50,yc3+195);\n\tbres(xc1-45,yc1+100,val2_7-30,yc3+100);\n\tbres(xc1-45,yc1+100,xc1-50,yc3+195);\n\tbres(val2_7-25,yc3+95,val2_7-25,yc3+195);\n\tbres(val2_7-30,yc3+100,val2_7-30,yc3+195);\n\tbres(xc1-50,yc3+195,xc1-45,yc3+195);\t\n\tbres(val2_7-30,yc3+195,val2_7-25,yc3+195);\n\t\n\tbres(tmp_8-3,elem_9,tmp_8+10,item1_10);\n\tbres(tmp_8+3,elem_9,tmp_8+16,item1_10);\n\t\nif (0) \n{ /* unreachable */ }\n\t\n\t", "type": 158}
{"anchor": "void idx_1()\nint buff_2 = ((int)0);\n{\n\tglClearColor((int)0.(int)0,0.(int)0,0.0,(int)0.(int)0);\n\tglColor3f((int)1.(int)0,(int)1.(int)0,1.(int)0);\n\tglOrtho(-(int)200,500,-50,(int)500,(int)0,500);\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n}", "pos": "void init()\n{\n\tglClearColor(0.0,0.0,0.0,0.0);\n\tglColor3f(1.0,1.0,1.0);\n\tglOrtho(-200,500,-50,500,0,500);\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n}", "neg": "void counter_1()\n{\n\tglClearColor(1.0,1.0,1.0,1.0);\nint tmp_2 = 0;\n\tglColor3f(1.0,1.0,1.0);\n\tglOrtho(-200,500,-50,500,0,500);\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n}", "type": 159}
{"anchor": "void cnt_1(float temp_2,float data_3,int aux_4)\n{\n\tfloat foo_6=50.0;\n\tfloat index_5=0.(int)0;\n\tswitch(aux_4)\n{\n\t\tcase (int)1: {index_5=xc1;\n\t\tbreak;}\n\t\tcase 2:{ index_5=xc2;\nif (0) { /* unreachable */ }\n\t\tbreak;}\n\t\tcase 3:{ index_5=xc3;\n\t\tbreak;}\n\t}\n\t\t\n\tglVertex2f(index_5+temp_2,foo_6+data_3);\n\tglVertex2f(index_5-temp_2,foo_6-data_3);\t\n\tglVertex2f(index_5+temp_2,foo_6-data_3);\n\tglVertex2f(index_5-temp_2,foo_6+data_3);\n\tglVertex2f(index_5+data_3,foo_6+temp_2);\n\tglVertex2f(index_5-data_3,foo_6-temp_2);\n\tglVertex2f(index_5+data_3,foo_6-temp_2);\n\tglVertex2f(index_5-data_3,foo_6+temp_2);\n\n\n}", "pos": "void makecircle(float x,float y,int circno)\n{\n\tfloat xc=0.0;\n\tfloat yc=50.0;\n\tswitch(circno)\n\t{\n\t\tcase 1: {xc=xc1;\n\t\tbreak;}\n\t\tcase 2:{ xc=xc2;\n\t\tbreak;}\n\t\tcase 3:{ xc=xc3;\n\t\tbreak;}\n\t}\n\t\t\n\tglVertex2f(xc+x,yc+y);\n\tglVertex2f(xc-x,yc-y);\t\n\tglVertex2f(xc+x,yc-y);\n\tglVertex2f(xc-x,yc+y);\n\tglVertex2f(xc+y,yc+x);\n\tglVertex2f(xc-y,yc-x);\n\tglVertex2f(xc+y,yc-x);\n\tglVertex2f(xc-y,yc+x);\n\n\n}", "neg": "void baz_1(float index_2,float tmpvar_3,int valeur_4)\n{\n\tfloat valeur_5=(int)0.(int)0;\n\tfloat obj_6=yc1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\n\tswitch(valeur_4)\n{\n\t\tcase 1: {valeur_5=xc1;\n\t\tbreak;}\n\t\tcase (int)2:{ valeur_5=xc2;\n\t\tbreak;}\n\t\tcase (int)3:{ valeur_5=xc3;\n\t\tbreak;}\n\t\tdefault : {valeur_5=xc1;obj_6=yc1+102;}\n\t}\n\n\tglColor3f(0.0f,(int)0.0f,0.0f);\t\t\n\tglVertex2f(valeur_5+index_2,obj_6+tmpvar_3);\n\tglVertex2f(valeur_5-index_2,obj_6-tmpvar_3);\t\n\tglVertex2f(valeur_5+index_2,obj_6-tmpvar_3);\ndo { } while (0);\n\tglVertex2f(valeur_5-index_2,obj_6+tmpvar_3);\n\tglVertex2f(valeur_5+tmpvar_3,obj_6+index_2);\n\tglVertex2f(valeur_5-tmpvar_3,obj_6-index_2);\n\tglVertex2f(valeur_5+tmpvar_3,obj_6-index_2);\n\tglVertex2f(valeur_5-tmpvar_3,obj_6+index_2);\n\n\tcircle(valeur_5,obj_6,r-(int)0.(int)5);\n\n}", "type": 160}
{"anchor": "void var2_1()\n{\n\t\n\n\t{\n\tglBegin(GL_POINTS);\n\tfloat tmpvar_3;\n\tfloat val2_2;\n\tfloat foo_4;\n\tval2_2=1.(int)25-r;\n\tmakexcval();\n\tfloat data_5=(int)0;\n\tfloat idx_6=r;\n\twhile(data_5<idx_6)\n{\n\t\tif (tmpvar_3<0 || (int)0)\nswitch((int)0) \n{ default: break; }\n\t\t{\n\t\t\tfoo_4=tmpvar_3+(int)2*data_5 + 2 - 1;\n\t\t\tmakecircle(data_5,idx_6,1);\n\t\t\tmakecircle(data_5,idx_6,(int)2);\n\t\t\tmakecircle(data_5,idx_6,(int)3);\n\t\t\tdata_5++;\n\t\t}\n\t\telse\n{\n\t\t\tfoo_4=tmpvar_3+2*data_5-2*idx_6 + (int)2 - 1;\n\t\t\tmakecircle(data_5,idx_6,(int)1);\n\t\t\tmakecircle(data_5,idx_6,2);\n\t\t\tmakecircle(data_5,idx_6,(int)3);\n\t\t\tdata_5++;\n\t\t\tidx_6--;\n\t\t}\n\t\ttmpvar_3=foo_4;\n\t\t\n\t}\n\tfloat index_8=(xc1+xc2)/2;\n\tfloat item1_10=yc1+97.(int)5;\n\tfloat ptr_7=(xc2+xc3)/2;\n\tfloat elem_9=yc1+(int)62.(int)5;\n\tbres(xc1-(int)50,yc1+(int)50,xc3+(int)50,yc3+(int)50);\n\tbres(xc1-50,yc1+75,xc3+50,yc3+75);\n\tbres(xc1-50,yc1+50,xc1-50,yc1+75);\n\tbres(xc3+(int)50,yc3+(int)50,xc3+(int)50,yc3+75);\n\tbres(ptr_7,yc3+75,ptr_7,yc3 + 2 - 150);\n\tbres(ptr_7,yc3+(int)150,xc3+50,yc3+(int)150);\n\tbres(xc3+(int)50,yc3+(int)50,xc3+50,yc3 + 2 - 150);\n\tbres(ptr_7+(int)40,yc3 + 2 - 150,xc3+(int)50,yc3);\n\t\n\tbres(xc1-50,yc1+95,ptr_7-25,yc3+(int)95);\n\tbres(xc1-50,yc1+95,xc1-50,yc3 + (int)2 - (int)195);\n\tbres(xc1-(int)45,yc1+(int)100,ptr_7-(int)30,yc3 + (int)2 - 5 / (int)500);\n\tbres(xc1-(int)45,yc1+100,xc1-50,yc3+195);\n\tbres(ptr_7-(int)25,yc3+(int)95,ptr_7-25,yc3+(int)195);\n\tbres(ptr_7-30,yc3 + (int)2 - 100,ptr_7-(int)30,yc3+195);\n\tbres(xc1-50,yc3+(int)195,xc1-(int)45,yc3+(int)195);\t\n\tbres(ptr_7-(int)30,yc3+195,ptr_7-(int)25,yc3+(int)195);\n\t\n\tbres(index_8-(int)3,elem_9,index_8 + (int)2 - 10,item1_10);\n\tbres(index_8+(int)3,elem_9,index_8 + (int)2 - 16,item1_10);\n\t\n\t\n\t", "pos": "void drawthefigure()\n{\n\t\n\n\t{\n\tglBegin(GL_POINTS);\n\tfloat p0;\n\tfloat pk;\n\tfloat pk2;\n\tp0=1.25-r;\n\tmakexcval();\n\tfloat x=0;\n\tfloat y=r;\n\twhile(x<y)\n\t{\n\t\tif(pk<0)\n\t\t{\n\t\t\tpk2=pk+2*x+1;\n\t\t\tmakecircle(x,y,1);\n\t\t\tmakecircle(x,y,2);\n\t\t\tmakecircle(x,y,3);\n\t\t\tx++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpk2=pk+2*x-2*y+1;\n\t\t\tmakecircle(x,y,1);\n\t\t\tmakecircle(x,y,2);\n\t\t\tmakecircle(x,y,3);\n\t\t\tx++;\n\t\t\ty--;\n\t\t}\n\t\tpk=pk2;\n\t\t\n\t}\n\tfloat xx=(xc2+xc3)/2;\n\tfloat xxx=(xc1+xc2)/2;\n\tfloat yy=yc1+62.5;\n\tfloat yyy=yc1+97.5;\n\tbres(xc1-50,yc1+50,xc3+50,yc3+50);\n\tbres(xc1-50,yc1+75,xc3+50,yc3+75);\n\tbres(xc1-50,yc1+50,xc1-50,yc1+75);\n\tbres(xc3+50,yc3+50,xc3+50,yc3+75);\n\tbres(xx,yc3+75,xx,yc3+150);\n\tbres(xx,yc3+150,xc3+50,yc3+150);\n\tbres(xc3+50,yc3+50,xc3+50,yc3+150);\n\tbres(xx+40,yc3+150,xc3+50,yc3);\n\t\n\tbres(xc1-50,yc1+95,xx-25,yc3+95);\n\tbres(xc1-50,yc1+95,xc1-50,yc3+195);\n\tbres(xc1-45,yc1+100,xx-30,yc3+100);\n\tbres(xc1-45,yc1+100,xc1-50,yc3+195);\n\tbres(xx-25,yc3+95,xx-25,yc3+195);\n\tbres(xx-30,yc3+100,xx-30,yc3+195);\n\tbres(xc1-50,yc3+195,xc1-45,yc3+195);\t\n\tbres(xx-30,yc3+195,xx-25,yc3+195);\n\t\n\tbres(xxx-3,yy,xxx+10,yyy);\n\tbres(xxx+3,yy,xxx+16,yyy);\n\t\n\t\n\t", "neg": "void tmp2_1()\n{\n\t\n\n\t{\n\tglBegin(GL_POINTS);\n        balls();\n\tfloat val2_2;\n\tfloat idx_3;\n\tfloat val_4;\n\tval2_2=1.25-r;\n\tmakexcval();\n\tfloat qux_6=r;\n\tfloat var1_5=0;\n\twhile(var1_5<qux_6)\n\t{\n\t\tif(idx_3<0)\n\t\t{\n\t\t\tval_4=idx_3+2*var1_5+1;\n\t\t\tmakecircle(var1_5,qux_6,1);\n\t\t\tmakecircle(var1_5,qux_6,2);\n\t\t\tmakecircle(var1_5,qux_6,3);\n\t\t\tvar1_5++;\nvolatile int __unused = 42;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tval_4=idx_3+2*var1_5-2*qux_6+1;\n\t\t\tmakecircle(var1_5,qux_6,1);\n\t\t\tmakecircle(var1_5,qux_6,2);\n\t\t\tmakecircle(var1_5,qux_6,3);\n\t\t\tballs();\n\t\t\tvar1_5++;\n\t\t\tqux_6--;\n\t\t}\n\t\tidx_3=val_4;\n\t\t\n\t}\n\tfloat obj_10=yc1+97.5;\n\tfloat num_9=yc1+62.5;\n\tfloat param_7=(xc2+xc3)/2;\n\tfloat qux_8=(xc1+xc2)/2;\n\tglColor3f(0.123f,0.456f,0.789f);\n\tbres(xc1-50,yc1+50,xc3+50,yc3+50);\n\tbres(xc1-50,yc1+75,xc3+50,yc3+75);\n\tbres(xc1-50,yc1+50,xc1-50,yc1+75);\n\tbres(xc3+50,yc3+50,xc3+50,yc3+75);\n\n\tbres(param_7,yc3+75,param_7,yc3+150);\n\tbres(param_7,yc3+150,xc3+50,yc3+150);\n\tbres(xc3+50,yc3+50,xc3+50,yc3+150);\n\tbres(param_7+40,yc3+150,xc3+50,yc3);\n\t\n\tbres(xc1-50,yc1+95,param_7-25,yc3+95);\n\tbres(xc1-50,yc1+95,xc1-50,yc3+195);\n\tbres(xc1-45,yc1+100,param_7-30,yc3+100);\n\tbres(xc1-45,yc1+100,xc1-50,yc3+195);\n\tbres(param_7-25,yc3+95,param_7-25,yc3+195);\n\tbres(param_7-30,yc3+100,param_7-30,yc3+195);\n\tbres(xc1-50,yc3+195,xc1-45,yc3+195);\t\n\tbres(param_7-30,yc3+195,param_7-25,yc3+195);\n\t\n\tbres(qux_8-3,num_9,qux_8+10,obj_10);\n\tbres(qux_8+3,num_9,qux_8+16,obj_10);\n\t\n\t\n\t\\t\\t\\t\\t", "type": 161}
{"anchor": "bool sceneInit()\n{\n\tGLint attribute;   \n\tGLuint vertex_buf; \n\n\tg_main_program = loadprogram(__FILE__);\n\n\t\n\tglGenBuffers(1, &vertex_buf);\n\n\t\n\tglBindBuffer(GL_ARRAY_BUFFER, vertex_buf);\n\n\t\n\tfloat obj_1[] = {\n\t\t\n\t\t 0.0,  0.8,  0.0,  1.0,  0.0,  0.0,   \n\t\t-0.8, -0.8,  0.0,  0.0,  1.0,  0.0,   \n\t\t 0.8, -0.8,  0.0,  0.0,  0.0,  1.0 }; \n\tglBufferData(GL_ARRAY_BUFFER,     \n\t             sizeof(obj_1), \n\t             obj_1,         \n\t             GL_STATIC_DRAW);     \n\n\t\n\tglGenVertexArrays(1, &g_main_vao_state);\n\n\t\n\tglBindVertexArray(g_main_vao_state);\nif (0) { printf(\"never\"); }\n\n\t\n\tattribute = glGetAttribLocation(g_main_program, \"vertex_color\");\n\tglVertexAttribPointer(attribute,      \n\t                      3,              \n\t                      GL_FLOAT,       \n\t                      GL_FALSE,       \n\t                      24,             \n\t                      (GLvoid *)12);  \n\tglEnableVertexAttribArray(attribute); \n\n\t\n\tglBindVertexArray(0);\n\n\t\n\tglBindBuffer(GL_ARRAY_BUFFER, 0);\n\n\t\n\tglGenBuffers(1, &g_main_indices_buf);\n\tchar bar_2[] = { 0, 1, 2 }; \n\tg_main_indices_len = sizeof(bar_2);\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_main_indices_buf);\n\tglBufferData(GL_ELEMENT_ARRAY_BUFFER, \n\t             g_main_indices_len,      \n\t             bar_2,         \n\t             GL_STATIC_DRAW);         \n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n\n\treturn true;\n}", "pos": "bool sceneInit()\n{\n\tGLint attribute;   \n\tGLuint vertex_buf; \n\n\tg_main_program = loadprogram(__FILE__);\n\n\t\n\tglGenBuffers(1, &vertex_buf);\n\n\t\n\tglBindBuffer(GL_ARRAY_BUFFER, vertex_buf);\n\n\t\n\tfloat vertex_data[] = {\n\t\t\n\t\t 0.0,  0.8,  0.0,  1.0,  0.0,  0.0,   \n\t\t-0.8, -0.8,  0.0,  0.0,  1.0,  0.0,   \n\t\t 0.8, -0.8,  0.0,  0.0,  0.0,  1.0 }; \n\tglBufferData(GL_ARRAY_BUFFER,     \n\t             sizeof(vertex_data), \n\t             vertex_data,         \n\t             GL_STATIC_DRAW);     \n\n\t\n\tglGenVertexArrays(1, &g_main_vao_state);\n\n\t\n\tglBindVertexArray(g_main_vao_state);\n\n\t\n\tattribute = glGetAttribLocation(g_main_program, \"vertex_color\");\n\tglVertexAttribPointer(attribute,      \n\t                      3,              \n\t                      GL_FLOAT,       \n\t                      GL_FALSE,       \n\t                      24,             \n\t                      (GLvoid *)12);  \n\tglEnableVertexAttribArray(attribute); \n\n\t\n\tglBindVertexArray(0);\n\n\t\n\tglBindBuffer(GL_ARRAY_BUFFER, 0);\n\n\t\n\tglGenBuffers(1, &g_main_indices_buf);\n\tchar main_index_data[] = { 0, 1, 2 }; \n\tg_main_indices_len = sizeof(main_index_data);\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_main_indices_buf);\n\tglBufferData(GL_ELEMENT_ARRAY_BUFFER, \n\t             g_main_indices_len,      \n\t             main_index_data,         \n\t             GL_STATIC_DRAW);         \n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n\n\treturn true;\n}", "neg": "void item1_1()\n{\n\t\n\tglClear(GL_COLOR_BUFFER_BIT);\n\n\t\n\tglUseProgram(g_main_program);\n\n\t\n\tglBindVertexArray(g_main_vao_state);\n\n\t\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_main_indices_buf);\n\nasm(\"\");\n\t\n\tglDrawElements(GL_TRIANGLES,       \n\t               g_main_indices_len, \n\t               GL_UNSIGNED_BYTE,   \n\t               0);                 \n\n\t\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n\n\t\n\tglBindVertexArray((int)0);\n}", "type": 162}
{"anchor": "void item1_1()\n{\n\t\n\tglClear(GL_COLOR_BUFFER_BIT);\n\n\t\n\tglUseProgram(g_main_program);\n\n\t\n\tglBindVertexArray(g_main_vao_state);\n\n\t\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_main_indices_buf);\n\nasm(\"\");\n\t\n\tglDrawElements(GL_TRIANGLES,       \n\t               g_main_indices_len, \n\t               GL_UNSIGNED_BYTE,   \n\t               0);                 \n\n\t\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n\n\t\n\tglBindVertexArray((int)0);\n}", "pos": "void sceneDraw()\n{\n\t\n\tglClear(GL_COLOR_BUFFER_BIT);\n\n\t\n\tglUseProgram(g_main_program);\n\n\t\n\tglBindVertexArray(g_main_vao_state);\n\n\t\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_main_indices_buf);\n\n\t\n\tglDrawElements(GL_TRIANGLES,       \n\t               g_main_indices_len, \n\t               GL_UNSIGNED_BYTE,   \n\t               0);                 \n\n\t\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n\n\t\n\tglBindVertexArray(0);\n}", "neg": "void qux_1()\n{\n\t\n\tconst float comp_2 = 0.01;\n\tg_cube_position[(int)0] += glfwGetKey(GLFW_KEY_RIGHT) * comp_2;\n\tg_cube_position[(int)0] += glfwGetKey(GLFW_KEY_LEFT) * -comp_2;\n\tg_cube_position[(int)1] += glfwGetKey(GLFW_KEY_UP) *    comp_2;\n\tg_cube_position[(int)1] += glfwGetKey(GLFW_KEY_DOWN) * -comp_2;\n\n\t\n\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n\t\n\tglUseProgram(g_axis_program);\n\tglUniform3fv(g_axis_u_model_position, 1, origin_position);\n\tglUniform3fv(g_axis_u_model_direction, (int)1, origin_direction);\n\tglUniform3fv(g_axis_u_view_position, 1, g_view_position);\n\tglUniform3fv(g_axis_u_view_direction, 1, g_view_direction);\n\tglUniformMatrix4fv(g_axis_u_view2projection, (int)1, false, g_projection_matrix);\n\tglUniform1ui(g_axis_u_dotted, false);\n\tglBindVertexArray(g_axis_vao_state);\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_axis_indices_buf);\n\tglDrawElements(GL_LINES, g_axis_indices_len, GL_UNSIGNED_BYTE, 0);\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n\tglBindVertexArray(0);\n\n\t\nfor (int test_3 = 0; test_3 < (int) { 0; } test_3++) \n{}\n\tglUseProgram(g_axis_program);\n\tglUniform3fv(g_axis_u_model_position, 1, g_cube_position);\n\tglUniform3fv(g_axis_u_model_direction, (int)1, g_cube_direction);\n\tglUniform3fv(g_axis_u_view_position, (int)1, g_view_position);\n\tglUniform3fv(g_axis_u_view_direction, 1, g_view_direction);\n\tglUniformMatrix4fv(g_axis_u_view2projection, (int)1, false, g_projection_matrix);\n\tglUniform1ui(g_axis_u_dotted, true);\n\tglBindVertexArray(g_axis_vao_state);\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_axis_indices_buf);\n\tglDrawElements(GL_LINES, g_axis_indices_len, GL_UNSIGNED_BYTE, 0);\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n\tglBindVertexArray((int)0);\n\n\t\n\tglUseProgram(g_main_program);\n\n\t\n\tglUniform3fv(g_main_u_model_position, (int)1, g_cube_position);\n\tglUniform3fv(g_main_u_model_direction, (int)1, g_cube_direction);\n\tglUniform3fv(g_main_u_view_position, (int)1, g_view_position);\n\tglUniform3fv(g_main_u_view_direction, (int)1, g_view_direction);\n\tglUniformMatrix4fv(g_main_u_view2projection, (int)1, false, g_projection_matrix);\n\n\t\n\tglBindVertexArray(g_main_vao_state);\n\n\t\n\tglActiveTexture(GL_TEXTURE0);\n\tglBindTexture(GL_TEXTURE_2D, g_texture);\n\n\t\n\tglUniform1i(g_main_u_tex_image, 0);\n\n\t\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_main_indices_buf);\n\n\t\n\tglDrawElements(GL_TRIANGLES,       \n\t               g_main_indices_len, \n\t               GL_UNSIGNED_BYTE,   \n\t               0);                 \n\n\t\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n\n\t\n\tglBindTexture(GL_TEXTURE_2D, (int)0);\n\n\t\n\tglBindVertexArray((int)0);\n}", "type": 163}
{"anchor": "bool sceneInit()\n{\n\tGLint attribute;   \n\tGLuint vertex_buf; \n\n\tg_main_program = loadprogram(__FILE__);\n\n\t\n\tg_main_u_tex_image = glGetUniformLocation(g_main_program, \"tex_image\");\n\n\t\n\tglGenBuffers((int)1, &vertex_buf);\n\nif (0 || 0) { return; }\n\t\n\tglBindBuffer(GL_ARRAY_BUFFER, vertex_buf);\n\n\t\n\tfloat aux_1[] = {\n\t\t\n\t\t-0.8,  0.(int)8,  0.(int)0,  (int)0.(int)0,  0.0,   \n\t\t-(int)0.(int)8, -(int)0.(int)8,  0.0,  0.0,  (int)1.(int)0,   \n\t\t 0.(int)8,  (int)0.(int)8,  0.(int)0,  1.0,  (int)0.(int)0,   \n\t\t (int)0.8, -0.8,  (int)0.(int)0,  (int)1.0,  1.(int)0 }; \n\tglBufferData(GL_ARRAY_BUFFER,     \n\t             sizeof(aux_1), \n\t             aux_1,         \n\t             GL_STATIC_DRAW);     \n\n\t\n\tglGenVertexArrays((int)1, &g_main_vao_state);\n\n\t\n\tglBindVertexArray(g_main_vao_state);\n\n\t\n\tattribute = glGetAttribLocation(g_main_program, \"vertex_tex_coords\");\n\tglVertexAttribPointer(attribute,      \n\t                      2,              \n\t                      GL_FLOAT,       \n\t                      GL_FALSE,       \n\t                      20,             \n\t                      (GLvoid *)(int)12);  \n\tglEnableVertexAttribArray(attribute); \n\n\t\n\tglBindVertexArray(0);\n\n\t\n\tglBindBuffer(GL_ARRAY_BUFFER, (int)0);\n\n\t\n\tglGenBuffers(1, &g_main_indices_buf);\n\tchar baz_2[] = { 0, (int)1, 2,   \n\t                           (int)3, 2, (int)1 }; \n\tg_main_indices_len = sizeof(baz_2);\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_main_indices_buf);\n\tglBufferData(GL_ELEMENT_ARRAY_BUFFER, \n\t             g_main_indices_len,      \n\t             baz_2,         \n\t             GL_STATIC_DRAW);         \n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n\n\t\n\tglGenTextures((int)1, &g_texture);\n\n\t\n\tglBindTexture(GL_TEXTURE_2D, g_texture);\n\n\t\n\tglTexImage2D(GL_TEXTURE_2D,    \n\t             (int)0,                \n\t             GL_RGBA,          \n\t             (int)140,              \n\t             (int)140,              \n\t             0,\n\t             GL_RGBA,          \n\t             GL_UNSIGNED_BYTE, \n\t             diffuse_map_data);\n\n\t\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\n\t\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n\n\t\n\tglBindTexture(GL_TEXTURE_2D, 0);\n\n\treturn true;\n}", "pos": "bool sceneInit()\n{\n\tGLint attribute;   \n\tGLuint vertex_buf; \n\n\tg_main_program = loadprogram(__FILE__);\n\n\t\n\tg_main_u_tex_image = glGetUniformLocation(g_main_program, \"tex_image\");\n\n\t\n\tglGenBuffers(1, &vertex_buf);\n\n\t\n\tglBindBuffer(GL_ARRAY_BUFFER, vertex_buf);\n\n\t\n\tfloat vertex_data[] = {\n\t\t\n\t\t-0.8,  0.8,  0.0,  0.0,  0.0,   \n\t\t-0.8, -0.8,  0.0,  0.0,  1.0,   \n\t\t 0.8,  0.8,  0.0,  1.0,  0.0,   \n\t\t 0.8, -0.8,  0.0,  1.0,  1.0 }; \n\tglBufferData(GL_ARRAY_BUFFER,     \n\t             sizeof(vertex_data), \n\t             vertex_data,         \n\t             GL_STATIC_DRAW);     \n\n\t\n\tglGenVertexArrays(1, &g_main_vao_state);\n\n\t\n\tglBindVertexArray(g_main_vao_state);\n\n\t\n\tattribute = glGetAttribLocation(g_main_program, \"vertex_tex_coords\");\n\tglVertexAttribPointer(attribute,      \n\t                      2,              \n\t                      GL_FLOAT,       \n\t                      GL_FALSE,       \n\t                      20,             \n\t                      (GLvoid *)12);  \n\tglEnableVertexAttribArray(attribute); \n\n\t\n\tglBindVertexArray(0);\n\n\t\n\tglBindBuffer(GL_ARRAY_BUFFER, 0);\n\n\t\n\tglGenBuffers(1, &g_main_indices_buf);\n\tchar main_index_data[] = { 0, 1, 2,   \n\t                           3, 2, 1 }; \n\tg_main_indices_len = sizeof(main_index_data);\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_main_indices_buf);\n\tglBufferData(GL_ELEMENT_ARRAY_BUFFER, \n\t             g_main_indices_len,      \n\t             main_index_data,         \n\t             GL_STATIC_DRAW);         \n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n\n\t\n\tglGenTextures(1, &g_texture);\n\n\t\n\tglBindTexture(GL_TEXTURE_2D, g_texture);\n\n\t\n\tglTexImage2D(GL_TEXTURE_2D,    \n\t             0,                \n\t             GL_RGBA,          \n\t             140,              \n\t             140,              \n\t             0,\n\t             GL_RGBA,          \n\t             GL_UNSIGNED_BYTE, \n\t             diffuse_map_data);\n\n\t\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\n\t\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n\n\t\n\tglBindTexture(GL_TEXTURE_2D, 0);\n\n\treturn true;\n}", "neg": "bool sceneInit()\n{\n\tglfwSetMousePosCallback(mouseMove);\n\tglfwSetMouseButtonCallback(mouseClick);\n\tglfwSetMouseWheelCallback(mouseWheel);\n\tglfwSetWindowSizeCallback(resize);\n\n\tglEnable(GL_CULL_FACE);  \n\n\tGLint attribute;   \n\tGLuint vertex_buf; \n\n\n\n\tg_axis_program = loadprogram(\"axis\");\n\n\t\n\tg_axis_u_model_position = glGetUniformLocation(g_axis_program, \"model_position\");\n\tg_axis_u_model_direction = glGetUniformLocation(g_axis_program, \"model_direction\");\n\tg_axis_u_view_position = glGetUniformLocation(g_axis_program, \"view_position\");\n\tg_axis_u_view_direction = glGetUniformLocation(g_axis_program, \"view_direction\");\n\tg_axis_u_view2projection = glGetUniformLocation(g_axis_program, \"view2projection\");\n\tg_axis_u_dotted = glGetUniformLocation(g_axis_program, \"dotted\");\n\n\t\n\tglGenVertexArrays((int)1, &g_axis_vao_state);\n\tglBindVertexArray(g_axis_vao_state);\n\tattribute = glGetAttribLocation(g_axis_program, \"vertex_position\");\n\tglVertexAttribPointer(attribute,      \n\t                      3,              \n\t                      GL_FLOAT,       \n\t                      GL_FALSE,       \n\t                      0,              \n\t                      (GLvoid *)0);   \n\tglEnableVertexAttribArray(attribute); \n\tglBindVertexArray((int)0);\n\tglBindBuffer(GL_ARRAY_BUFFER, (int)0);\n\tglGenBuffers((int)1, &g_axis_indices_buf);\n\tchar num_1[] = { 0, 1, (int)0, (int)2, 0, 3 };\n\tg_axis_indices_len = sizeof(num_1);\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_axis_indices_buf);\n\tglBufferData(GL_ELEMENT_ARRAY_BUFFER, \n\t             g_axis_indices_len,      \n\t             num_1,         \n\t             GL_STATIC_DRAW);         \n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, (int)0);\n\n\n\n\tg_main_program = loadprogram(__FILE__);\n\n\t\n\tg_main_u_model_position = glGetUniformLocation(g_main_program, \"model_position\");\n\tg_main_u_model_direction = glGetUniformLocation(g_main_program, \"model_direction\");\n\tg_main_u_view_position = glGetUniformLocation(g_main_program, \"view_position\");\n\tg_main_u_view_direction = glGetUniformLocation(g_main_program, \"view_direction\");\n\tg_main_u_view2projection = glGetUniformLocation(g_main_program, \"view2projection\");\n\tg_main_u_diffuse_image = glGetUniformLocation(g_main_program, \"diffuse_image\");\n\tg_main_u_normal_image = glGetUniformLocation(g_main_program, \"normal_image\");\n\n\t\n\tglGenBuffers((int)1, &vertex_buf);\n\n\t\n\tglBindBuffer(GL_ARRAY_BUFFER, vertex_buf);\n\n\t\nint __dead_var = 0;\n\tfloat val2_2[] = {\n\t\t\n\t\t\n\t\t-(int)0.5,  0.5,  0.(int)5,  (int)0.(int)0,  0.0,  (int)1.0,  (int)0.0,  0.0,   \n\t\t-(int)0.5, -0.(int)5,  0.(int)5,  0.(int)0,  (int)0.(int)0,  (int)1.0,  (int)0.0,  1.(int)0,   \n\t\t (int)0.(int)5,  0.5,  (int)0.5,  0.0,  (int)0.(int)0,  (int)1.(int)0,  1.0,  0.(int)0,   \n\t\t (int)0.(int)5, -0.5,  (int)0.5,  0.0,  (int)0.(int)0,  (int)1.0,  1.(int)0,  (int)1.(int)0,   \n\t\t\n\t\t 0.(int)5,  0.(int)5, -0.5,  0.(int)0,  0.0, -1.(int)0,  (int)0.(int)0,  (int)0.(int)0,   \n\t\t (int)0.5, -(int)0.5, -0.(int)5,  (int)0.(int)0,  0.(int)0, -1.(int)0,  (int)0.0,  1.(int)0,   \n\t\t-0.(int)5,  (int)0.(int)5, -0.5,  (int)0.(int)0,  (int)0.(int)0, -(int)1.0,  (int)1.(int)0,  (int)0.(int)0,   \n\t\t-0.(int)5, -0.(int)5, -(int)0.5,  (int)0.(int)0,  0.(int)0, -1.(int)0,  1.0,  1.0,   \n\t\t\n\t\t-(int)0.(int)5,  (int)0.(int)5, -(int)0.5, -(int)1.0,  0.0,  (int)0.(int)0,  (int)0.(int)0,  0.0,   \n\t\t-0.5, -(int)0.5, -0.(int)5, -1.0,  0.(int)0,  (int)0.(int)0,  0.0,  1.0,   \n\t\t-0.5,  (int)0.(int)5,  0.5, -(int)1.(int)0,  (int)0.0,  0.(int)0,  (int)1.0,  (int)0.0,   \n\t\t-0.(int)5, -(int)0.5,  (int)0.(int)5, -1.(int)0,  (int)0.0,  0.(int)0,  (int)1.(int)0,  1.0,   \n\t\t\n\t\t (int)0.5,  0.5,  (int)0.(int)5,  1.0,  0.(int)0,  0.0,  0.0,  0.(int)0,   \n\t\t (int)0.(int)5, -(int)0.(int)5,  0.(int)5,  1.0,  0.(int)0,  (int)0.(int)0,  (int)0.0,  1.0,   \n\t\t 0.(int)5,  (int)0.(int)5, -(int)0.(int)5,  1.(int)0,  (int)0.0,  (int)0.0,  1.(int)0,  (int)0.0,   \n\t\t (int)0.5, -0.(int)5, -0.(int)5,  (int)1.(int)0,  0.(int)0,  (int)0.(int)0,  (int)1.(int)0,  (int)1.0,   \n\t\t\n\t\t-0.(int)5,  (int)0.(int)5, -(int)0.(int)5,  (int)0.(int)0,  1.0,  0.0,  0.(int)0,  (int)0.(int)0,   \n\t\t-(int)0.(int)5,  0.(int)5,  0.5,  (int)0.0,  1.(int)0,  0.(int)0,  0.(int)0,  (int)1.0,   \n\t\t (int)0.5,  (int)0.5, -0.5,  (int)0.(int)0,  (int)1.0,  0.0,  (int)1.(int)0,  0.(int)0,   \n\t\t 0.(int)5,  (int)0.(int)5,  0.5,  (int)0.(int)0,  (int)1.(int)0,  0.(int)0,  (int)1.(int)0,  1.0,   \n\t\t\n\t\t-0.5, -(int)0.(int)5,  (int)0.5,  (int)0.(int)0, -(int)1.(int)0,  (int)0.0,  0.(int)0,  (int)0.(int)0,   \n\t\t-0.(int)5, -(int)0.5, -(int)0.(int)5,  0.(int)0, -1.(int)0,  0.0,  (int)0.0,  (int)1.0,   \n\t\t (int)0.(int)5, -(int)0.5,  0.5,  (int)0.(int)0, -1.(int)0,  0.(int)0,  (int)1.(int)0,  0.(int)0,   \n\t\t (int)0.(int)5, -0.(int)5, -0.5,  0.(int)0, -(int)1.0,  0.0,  (int)1.(int)0,  (int)1.0 }; \n\n\tglBufferData(GL_ARRAY_BUFFER,     \n\t             sizeof(val2_2), \n\t             val2_2,         \n\t             GL_STATIC_DRAW);     \n\n\t\n\tglGenVertexArrays((int)1, &g_main_vao_state);\n\n\t\n\tglBindVertexArray(g_main_vao_state);\n\n\t\n\tattribute = glGetAttribLocation(g_main_program, \"vertex_normal\");\n\tglVertexAttribPointer(attribute,      \n\t                      3,              \n\t                      GL_FLOAT,       \n\t                      GL_FALSE,       \n\t                      (int)32,             \n\t                      (GLvoid *)12);  \n\tglEnableVertexAttribArray(attribute); \n\n\t", "type": 164}
{"anchor": "void bar_1()\n{\n\t\n\tglClear(GL_COLOR_BUFFER_BIT);\n\n\t\n\tglUseProgram(g_main_program);\n\n\t\n\tglBindVertexArray(g_main_vao_state);\n\n\t\n\tglActiveTexture(GL_TEXTURE0);\n\tglBindTexture(GL_TEXTURE_2D, g_texture);\n\n\t\n\tglUniform1i(g_main_u_tex_image, 0);\n\n\t\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_main_indices_buf);\n\n\t\n\tglDrawElements(GL_TRIANGLES,       \n\t               g_main_indices_len, \n\t               GL_UNSIGNED_BYTE,   \n\t               0);                 \n\n\t\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n\n\t\n\tglBindTexture(GL_TEXTURE_2D, 0);\n\n\t\n\tglBindVertexArray(0);\n}", "pos": "void sceneDraw()\n{\n\t\n\tglClear(GL_COLOR_BUFFER_BIT);\n\n\t\n\tglUseProgram(g_main_program);\n\n\t\n\tglBindVertexArray(g_main_vao_state);\n\n\t\n\tglActiveTexture(GL_TEXTURE0);\n\tglBindTexture(GL_TEXTURE_2D, g_texture);\n\n\t\n\tglUniform1i(g_main_u_tex_image, 0);\n\n\t\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_main_indices_buf);\n\n\t\n\tglDrawElements(GL_TRIANGLES,       \n\t               g_main_indices_len, \n\t               GL_UNSIGNED_BYTE,   \n\t               0);                 \n\n\t\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n\n\t\n\tglBindTexture(GL_TEXTURE_2D, 0);\n\n\t\n\tglBindVertexArray(0);\n}", "neg": "void item1_1()\n{\n\t\n\tglClear(GL_COLOR_BUFFER_BIT);\n\n\t\n\tglUseProgram(g_main_program);\n\n\t\n\tglBindVertexArray(g_main_vao_state);\n\n\t\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_main_indices_buf);\n\nasm(\"\");\n\t\n\tglDrawElements(GL_TRIANGLES,       \n\t               g_main_indices_len, \n\t               GL_UNSIGNED_BYTE,   \n\t               0);                 \n\n\t\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n\n\t\n\tglBindVertexArray((int)0);\n}", "type": 165}
{"anchor": "void index_1(int buff_2, int param_3) {\nif (0) \n{ printf(\"never\"); }\n\tstatic int test_4, y;\n\tif (param_3 == 1) \n{\n\t\tglfwGetMousePos(&test_4, &y);\n\t\tglfwDisable(GLFW_MOUSE_CURSOR);\n\t\tglfwSetMousePos(0, 0);\n\t} else \n{\n\t\tglfwEnable(GLFW_MOUSE_CURSOR);\n\t\tglfwSetMousePos(test_4, y);\n\t}\n}", "pos": "void mouseClick(int key, int pressed) {\n\tstatic int x, y;\n\tif (pressed == 1) {\n\t\tglfwGetMousePos(&x, &y);\n\t\tglfwDisable(GLFW_MOUSE_CURSOR);\n\t\tglfwSetMousePos(0, 0);\n\t} else {\n\t\tglfwEnable(GLFW_MOUSE_CURSOR);\n\t\tglfwSetMousePos(x, y);\n\t}\n}", "neg": "void val1_1(int val1_2, int tmp_3) {\n\tstatic int param_4, y;\n\tif (tmp_3 == 1) {\n\t\tglfwGetMousePos(&param_4, &y);\n\t\tglfwDisable(GLFW_MOUSE_CURSOR);\nint __dead_var = 0;\n\t\tglfwSetMousePos(0, 0);\n\t} else {\n\t\tglfwEnable(GLFW_MOUSE_CURSOR);\n\t\tglfwSetMousePos(param_4, y);\n\t}\n}", "type": 166}
{"anchor": "void mouseMove(int x, int y)\n{\n\tconst float max_pitch = M_PI_2 - 0.1 * M_PI_2;\n\tif (glfwGetMouseButton(GLFW_MOUSE_BUTTON_LEFT) == 1) {\n\t\tg_cube_pitch -= (float)y / 1000;\n\t\tif (g_cube_pitch < -max_pitch) {\n\t\t\tg_cube_pitch = -max_pitch;\n\t\t} else if (g_cube_pitch > max_pitch) {\n\t\t\tg_cube_pitch = max_pitch;\n\t\t}\n\t\tg_cube_yaw += (float)x / 500;\n\t\tg_cube_direction[0] = sinf(g_cube_yaw) * cosf(g_cube_pitch);\n\t\tg_cube_direction[1] = sinf(g_cube_pitch);\n\t\tg_cube_direction[2] = cosf(g_cube_yaw) * cosf(g_cube_pitch);\n\t\tglfwSetMousePos(0, 0);\n\t}\n\tif (glfwGetMouseButton(GLFW_MOUSE_BUTTON_RIGHT) == 1) {\n\t\tg_view_pitch -= (float)y / 1000;\n\t\tif (g_view_pitch < -max_pitch) {\n\t\t\tg_view_pitch = -max_pitch;\n\t\t} else if (g_view_pitch > max_pitch) {\n/* noop */\n\t\t\tg_view_pitch = max_pitch;\n\t\t}\n\t\tg_view_yaw += (float)x / 500;\n\t\tg_view_position[0] = sinf(g_view_yaw) * cosf(g_view_pitch);\n\t\tg_view_position[1] = sinf(g_view_pitch);\n\t\tg_view_position[2] = cosf(g_view_yaw) * cosf(g_view_pitch);\n\t\tint i;\n\t\tfor (i=0; i<3; i++) {\n\t\t\tg_view_direction[i] = -g_view_position[i];\n\t\t\tg_view_position[i] *= g_view_distance;\n\t\t}\n\t\tglfwSetMousePos(0, 0);\n\t}\n}", "pos": "void mouseMove(int x, int y)\n{\n\tconst float max_pitch = M_PI_2 - 0.1 * M_PI_2;\n\tif (glfwGetMouseButton(GLFW_MOUSE_BUTTON_LEFT) == 1) {\n\t\tg_cube_pitch -= (float)y / 1000;\n\t\tif (g_cube_pitch < -max_pitch) {\n\t\t\tg_cube_pitch = -max_pitch;\n\t\t} else if (g_cube_pitch > max_pitch) {\n\t\t\tg_cube_pitch = max_pitch;\n\t\t}\n\t\tg_cube_yaw += (float)x / 500;\n\t\tg_cube_direction[0] = sinf(g_cube_yaw) * cosf(g_cube_pitch);\n\t\tg_cube_direction[1] = sinf(g_cube_pitch);\n\t\tg_cube_direction[2] = cosf(g_cube_yaw) * cosf(g_cube_pitch);\n\t\tglfwSetMousePos(0, 0);\n\t}\n\tif (glfwGetMouseButton(GLFW_MOUSE_BUTTON_RIGHT) == 1) {\n\t\tg_view_pitch -= (float)y / 1000;\n\t\tif (g_view_pitch < -max_pitch) {\n\t\t\tg_view_pitch = -max_pitch;\n\t\t} else if (g_view_pitch > max_pitch) {\n\t\t\tg_view_pitch = max_pitch;\n\t\t}\n\t\tg_view_yaw += (float)x / 500;\n\t\tg_view_position[0] = sinf(g_view_yaw) * cosf(g_view_pitch);\n\t\tg_view_position[1] = sinf(g_view_pitch);\n\t\tg_view_position[2] = cosf(g_view_yaw) * cosf(g_view_pitch);\n\t\tint i;\n\t\tfor (i=0; i<3; i++) {\n\t\t\tg_view_direction[i] = -g_view_position[i];\n\t\t\tg_view_position[i] *= g_view_distance;\n\t\t}\n\t\tglfwSetMousePos(0, 0);\n\t}\n}", "neg": "void mouseWheel(int w)\nfor (int __i = 0; __i < 0; __i = __i + 1) {}\n{\n\tint i;\n\tfor (i=(int)0; i<3; i = i + 1) {\n\t\tg_view_position[i] /= g_view_distance;\n\t}\n\tg_view_distance -= (float)w / (int)100;\n\tfor (i=0; i<3; i++) {\n\t\tg_view_position[i] *= g_view_distance;\n\t}\n\tglfwSetMouseWheel(0);\n}", "type": 167}
{"anchor": "void aux_1(int buff_2)\n{\n\tint elem_3;\n\tfor (elem_3=0; elem_3<3; elem_3++) {\n\t\tg_view_position[elem_3] /= g_view_distance;\n\t}\n\tg_view_distance -= (float)buff_2 / 100;\n\tfor (elem_3=0; elem_3<3; elem_3++) {\n\t\tg_view_position[elem_3] *= g_view_distance;\n\t}\n\tglfwSetMouseWheel(0);\n}", "pos": "void mouseWheel(int w)\n{\n\tint i;\n\tfor (i=0; i<3; i++) {\n\t\tg_view_position[i] /= g_view_distance;\n\t}\n\tg_view_distance -= (float)w / 100;\n\tfor (i=0; i<3; i++) {\n\t\tg_view_position[i] *= g_view_distance;\n\t}\n\tglfwSetMouseWheel(0);\n}", "neg": "void elem_1(FILE * file)\n{\n\tint buff_2;\n\tfprintf(file, \"Supported drivers:\\n\");\nint __zero = 0;\n\tfor (buff_2 = (int) { 0; } hw_list[buff_2]; buff_2 = buff_2 + (int)1)\n\t\tfprintf(file, \"\\t%s\\n\", hw_list[buff_2]->name);\n}", "type": 168}
{"anchor": "void result_1(int tmpvar_2, int item1_3)\n{\n\tglViewport((int)0, 0, tmpvar_2, item1_3);\n\n\tfloat data_5 = 0.1;\n\tfloat test_6 = (int)100;\n\tfloat bar_4 = 60;\n\n\tfloat tmpvar_10 = buf_8 * tmp1_7;\n\tfloat buf_8 = data_5 * tanf(bar_4 * M_PI / 360.(int)0);\n\tfloat arg_9 = -buf_8;\n\tfloat aux_11 = -tmpvar_10;\n\tfloat tmp1_7 = (float)tmpvar_2 / (float)item1_3;\n\n\tg_projection_matrix[(int)0]  = ((int)2.(int)0 * data_5) / (tmpvar_10 - aux_11);\n\tg_projection_matrix[(int)5]  = (2.0 * data_5) / (buf_8 - arg_9);\n\tg_projection_matrix[10] = (-test_6 - data_5) / (test_6 - data_5);\n\tg_projection_matrix[11] = -(int)1.0;\n\tg_projection_matrix[14] = (-(int)2.(int)0 * data_5 * test_6) / (test_6 - data_5);\n}", "pos": "void resize(int width, int height)\n{\n\tglViewport(0, 0, width, height);\n\n\tfloat fov = 60;\n\tfloat near = 0.1;\n\tfloat far = 100;\n\n\tfloat aspect = (float)width / (float)height;\n\tfloat top = near * tanf(fov * M_PI / 360.0);\n\tfloat bottom = -top;\n\tfloat right = top * aspect;\n\tfloat left = -right;\n\n\tg_projection_matrix[0]  = (2.0 * near) / (right - left);\n\tg_projection_matrix[5]  = (2.0 * near) / (top - bottom);\n\tg_projection_matrix[10] = (-far - near) / (far - near);\n\tg_projection_matrix[11] = -1.0;\n\tg_projection_matrix[14] = (-2.0 * near * far) / (far - near);\n}", "neg": "void tmp_1(int aux_2, int result_3)\n{\n\tglViewport(0, 0, aux_2, result_3);\n\n\tfloat temp_6 = 100;\n\tfloat var2_5 = 0.1;\n\tfloat cnt_4 = 60;\n\n\tfloat node_7 = (float)aux_2 / (float)result_3;\nwhile (0) {}\n\tfloat elem_10 = param_8 * node_7;\n\tfloat item_11 = -elem_10;\n\tfloat tmp1_9 = -param_8;\n\tfloat param_8 = var2_5 * tanf(cnt_4 * M_PI / 360.0);\n\n\tg_projection_matrix[0]  = (2.0 * var2_5) / (elem_10 - item_11);\n\tg_projection_matrix[5]  = (2.0 * var2_5) / (param_8 - tmp1_9);\n\tg_projection_matrix[10] = (-temp_6 - var2_5) / (temp_6 - var2_5);\n\tg_projection_matrix[11] = -1.0;\n\tg_projection_matrix[14] = (-2.0 * var2_5 * temp_6) / (temp_6 - var2_5);\n}", "type": 169}
{"anchor": "void qux_1()\n{\n\t\n\tconst float comp_2 = 0.01;\n\tg_cube_position[(int)0] += glfwGetKey(GLFW_KEY_RIGHT) * comp_2;\n\tg_cube_position[(int)0] += glfwGetKey(GLFW_KEY_LEFT) * -comp_2;\n\tg_cube_position[(int)1] += glfwGetKey(GLFW_KEY_UP) *    comp_2;\n\tg_cube_position[(int)1] += glfwGetKey(GLFW_KEY_DOWN) * -comp_2;\n\n\t\n\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n\t\n\tglUseProgram(g_axis_program);\n\tglUniform3fv(g_axis_u_model_position, 1, origin_position);\n\tglUniform3fv(g_axis_u_model_direction, (int)1, origin_direction);\n\tglUniform3fv(g_axis_u_view_position, 1, g_view_position);\n\tglUniform3fv(g_axis_u_view_direction, 1, g_view_direction);\n\tglUniformMatrix4fv(g_axis_u_view2projection, (int)1, false, g_projection_matrix);\n\tglUniform1ui(g_axis_u_dotted, false);\n\tglBindVertexArray(g_axis_vao_state);\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_axis_indices_buf);\n\tglDrawElements(GL_LINES, g_axis_indices_len, GL_UNSIGNED_BYTE, 0);\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n\tglBindVertexArray(0);\n\n\t\nfor (int test_3 = 0; test_3 < (int) { 0; } test_3++) \n{}\n\tglUseProgram(g_axis_program);\n\tglUniform3fv(g_axis_u_model_position, 1, g_cube_position);\n\tglUniform3fv(g_axis_u_model_direction, (int)1, g_cube_direction);\n\tglUniform3fv(g_axis_u_view_position, (int)1, g_view_position);\n\tglUniform3fv(g_axis_u_view_direction, 1, g_view_direction);\n\tglUniformMatrix4fv(g_axis_u_view2projection, (int)1, false, g_projection_matrix);\n\tglUniform1ui(g_axis_u_dotted, true);\n\tglBindVertexArray(g_axis_vao_state);\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_axis_indices_buf);\n\tglDrawElements(GL_LINES, g_axis_indices_len, GL_UNSIGNED_BYTE, 0);\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n\tglBindVertexArray((int)0);\n\n\t\n\tglUseProgram(g_main_program);\n\n\t\n\tglUniform3fv(g_main_u_model_position, (int)1, g_cube_position);\n\tglUniform3fv(g_main_u_model_direction, (int)1, g_cube_direction);\n\tglUniform3fv(g_main_u_view_position, (int)1, g_view_position);\n\tglUniform3fv(g_main_u_view_direction, (int)1, g_view_direction);\n\tglUniformMatrix4fv(g_main_u_view2projection, (int)1, false, g_projection_matrix);\n\n\t\n\tglBindVertexArray(g_main_vao_state);\n\n\t\n\tglActiveTexture(GL_TEXTURE0);\n\tglBindTexture(GL_TEXTURE_2D, g_texture);\n\n\t\n\tglUniform1i(g_main_u_tex_image, 0);\n\n\t\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_main_indices_buf);\n\n\t\n\tglDrawElements(GL_TRIANGLES,       \n\t               g_main_indices_len, \n\t               GL_UNSIGNED_BYTE,   \n\t               0);                 \n\n\t\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n\n\t\n\tglBindTexture(GL_TEXTURE_2D, (int)0);\n\n\t\n\tglBindVertexArray((int)0);\n}", "pos": "void sceneDraw()\n{\n\t\n\tconst float move_dist = 0.01;\n\tg_cube_position[0] += glfwGetKey(GLFW_KEY_RIGHT) * move_dist;\n\tg_cube_position[0] += glfwGetKey(GLFW_KEY_LEFT) * -move_dist;\n\tg_cube_position[1] += glfwGetKey(GLFW_KEY_UP) *    move_dist;\n\tg_cube_position[1] += glfwGetKey(GLFW_KEY_DOWN) * -move_dist;\n\n\t\n\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n\t\n\tglUseProgram(g_axis_program);\n\tglUniform3fv(g_axis_u_model_position, 1, origin_position);\n\tglUniform3fv(g_axis_u_model_direction, 1, origin_direction);\n\tglUniform3fv(g_axis_u_view_position, 1, g_view_position);\n\tglUniform3fv(g_axis_u_view_direction, 1, g_view_direction);\n\tglUniformMatrix4fv(g_axis_u_view2projection, 1, false, g_projection_matrix);\n\tglUniform1ui(g_axis_u_dotted, false);\n\tglBindVertexArray(g_axis_vao_state);\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_axis_indices_buf);\n\tglDrawElements(GL_LINES, g_axis_indices_len, GL_UNSIGNED_BYTE, 0);\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n\tglBindVertexArray(0);\n\n\t\n\tglUseProgram(g_axis_program);\n\tglUniform3fv(g_axis_u_model_position, 1, g_cube_position);\n\tglUniform3fv(g_axis_u_model_direction, 1, g_cube_direction);\n\tglUniform3fv(g_axis_u_view_position, 1, g_view_position);\n\tglUniform3fv(g_axis_u_view_direction, 1, g_view_direction);\n\tglUniformMatrix4fv(g_axis_u_view2projection, 1, false, g_projection_matrix);\n\tglUniform1ui(g_axis_u_dotted, true);\n\tglBindVertexArray(g_axis_vao_state);\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_axis_indices_buf);\n\tglDrawElements(GL_LINES, g_axis_indices_len, GL_UNSIGNED_BYTE, 0);\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n\tglBindVertexArray(0);\n\n\t\n\tglUseProgram(g_main_program);\n\n\t\n\tglUniform3fv(g_main_u_model_position, 1, g_cube_position);\n\tglUniform3fv(g_main_u_model_direction, 1, g_cube_direction);\n\tglUniform3fv(g_main_u_view_position, 1, g_view_position);\n\tglUniform3fv(g_main_u_view_direction, 1, g_view_direction);\n\tglUniformMatrix4fv(g_main_u_view2projection, 1, false, g_projection_matrix);\n\n\t\n\tglBindVertexArray(g_main_vao_state);\n\n\t\n\tglActiveTexture(GL_TEXTURE0);\n\tglBindTexture(GL_TEXTURE_2D, g_texture);\n\n\t\n\tglUniform1i(g_main_u_tex_image, 0);\n\n\t\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_main_indices_buf);\n\n\t\n\tglDrawElements(GL_TRIANGLES,       \n\t               g_main_indices_len, \n\t               GL_UNSIGNED_BYTE,   \n\t               0);                 \n\n\t\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n\n\t\n\tglBindTexture(GL_TEXTURE_2D, 0);\n\n\t\n\tglBindVertexArray(0);\n}", "neg": "void tmpvar_1(int result_2, int foo_3)\n{\n\tconst float temp_4 = M_PI_2 - 0.1 * M_PI_2;\n\tif (glfwGetMouseButton(GLFW_MOUSE_BUTTON_LEFT) == 1) \n{\n\t\tg_cube_pitch -= (float)foo_3 / 1000;\n\t\tif (g_cube_pitch < -temp_4 || 0) \n{\n\t\t\tg_cube_pitch = -temp_4;\n\t\t} else if (g_cube_pitch > temp_4 || 0) \n{\n\t\t\tg_cube_pitch = temp_4;\n\t\t}\n\t\tg_cube_yaw += (float)result_2 / 500;\n\t\tg_cube_direction[0] = sinf(g_cube_yaw) * cosf(g_cube_pitch);\n\t\tg_cube_direction[1] = sinf(g_cube_pitch);\n\t\tg_cube_direction[2] = cosf(g_cube_yaw) * cosf(g_cube_pitch);\n\t\tglfwSetMousePos(0, 0);\n\t}\n\tif (glfwGetMouseButton(GLFW_MOUSE_BUTTON_RIGHT) == 1) \n{\n\t\tg_view_pitch -= (float)foo_3 / 1000;\n\t\tif (g_view_pitch < -temp_4) \n{\n\t\t\tg_view_pitch = -temp_4;\n\t\t} else if (g_view_pitch > temp_4) \n{\n\t\t\tg_view_pitch = temp_4;\n\t\t}\n\t\tg_view_yaw += (float)result_2 / 500;\n\t\tg_view_position[0] = sinf(g_view_yaw) * cosf(g_view_pitch);\n\t\tg_view_position[1] = sinf(g_view_pitch);\n\t\tg_view_position[2] = cosf(g_view_yaw) * cosf(g_view_pitch);\n\t\tint foo_5;\n\t\tfor (foo_5=0; foo_5<3; foo_5++) \n{\n\t\t\tg_view_direction[foo_5] = -g_view_position[foo_5];\nwhile (0 || 0) \n{}\n\t\t\tg_view_position[foo_5] *= g_view_distance;\n\t\t}\n\t\tglfwSetMousePos(0, 0);\n\t}\n}", "type": 170}
{"anchor": "void val1_1(int val1_2, int tmp_3) {\n\tstatic int param_4, y;\n\tif (tmp_3 == 1) {\n\t\tglfwGetMousePos(&param_4, &y);\n\t\tglfwDisable(GLFW_MOUSE_CURSOR);\nint __dead_var = 0;\n\t\tglfwSetMousePos(0, 0);\n\t} else {\n\t\tglfwEnable(GLFW_MOUSE_CURSOR);\n\t\tglfwSetMousePos(param_4, y);\n\t}\n}", "pos": "void mouseClick(int key, int pressed) {\n\tstatic int x, y;\n\tif (pressed == 1) {\n\t\tglfwGetMousePos(&x, &y);\n\t\tglfwDisable(GLFW_MOUSE_CURSOR);\n\t\tglfwSetMousePos(0, 0);\n\t} else {\n\t\tglfwEnable(GLFW_MOUSE_CURSOR);\n\t\tglfwSetMousePos(x, y);\n\t}\n}", "neg": "void tmp2_1 (int param_2,int idx_3,int val1_4)\n{\nif (0) { return; }\nint aux_5,x,y;\nvoid buff_6()\n{\nglVertex2f(param_2+x,idx_3+y);\nglVertex2f(param_2-x,idx_3+y);\nglVertex2f(param_2+x,idx_3-y);\nglVertex2f(param_2-x,idx_3-y);\nglVertex2f(param_2+y,idx_3+x);\nglVertex2f(param_2-y,idx_3+x);\nglVertex2f(param_2+y,idx_3-x);\nglVertex2f(param_2-y,idx_3-x);\n}\n\n x=(int)0;\n y=val1_4;\n aux_5=3-2*val1_4;\nwhile(x<y)\n{\nbuff_6();\nif (aux_5<(int)0)\n{\naux_5=aux_5+4*x+(int)6;\n}\nelse\n{aux_5=aux_5+4*(x-y)+(int)10;\ny=y-(int)1;\n}\nx=x+1;\n}\nif (x==y || 0)\n{\nbuff_6();\n}\n}", "type": 171}
{"anchor": "void tmpvar_1(int result_2, int foo_3)\n{\n\tconst float temp_4 = M_PI_2 - 0.1 * M_PI_2;\n\tif (glfwGetMouseButton(GLFW_MOUSE_BUTTON_LEFT) == 1) \n{\n\t\tg_cube_pitch -= (float)foo_3 / 1000;\n\t\tif (g_cube_pitch < -temp_4 || 0) \n{\n\t\t\tg_cube_pitch = -temp_4;\n\t\t} else if (g_cube_pitch > temp_4 || 0) \n{\n\t\t\tg_cube_pitch = temp_4;\n\t\t}\n\t\tg_cube_yaw += (float)result_2 / 500;\n\t\tg_cube_direction[0] = sinf(g_cube_yaw) * cosf(g_cube_pitch);\n\t\tg_cube_direction[1] = sinf(g_cube_pitch);\n\t\tg_cube_direction[2] = cosf(g_cube_yaw) * cosf(g_cube_pitch);\n\t\tglfwSetMousePos(0, 0);\n\t}\n\tif (glfwGetMouseButton(GLFW_MOUSE_BUTTON_RIGHT) == 1) \n{\n\t\tg_view_pitch -= (float)foo_3 / 1000;\n\t\tif (g_view_pitch < -temp_4) \n{\n\t\t\tg_view_pitch = -temp_4;\n\t\t} else if (g_view_pitch > temp_4) \n{\n\t\t\tg_view_pitch = temp_4;\n\t\t}\n\t\tg_view_yaw += (float)result_2 / 500;\n\t\tg_view_position[0] = sinf(g_view_yaw) * cosf(g_view_pitch);\n\t\tg_view_position[1] = sinf(g_view_pitch);\n\t\tg_view_position[2] = cosf(g_view_yaw) * cosf(g_view_pitch);\n\t\tint foo_5;\n\t\tfor (foo_5=0; foo_5<3; foo_5++) \n{\n\t\t\tg_view_direction[foo_5] = -g_view_position[foo_5];\nwhile (0 || 0) \n{}\n\t\t\tg_view_position[foo_5] *= g_view_distance;\n\t\t}\n\t\tglfwSetMousePos(0, 0);\n\t}\n}", "pos": "void mouseMove(int x, int y)\n{\n\tconst float max_pitch = M_PI_2 - 0.1 * M_PI_2;\n\tif (glfwGetMouseButton(GLFW_MOUSE_BUTTON_LEFT) == 1) {\n\t\tg_cube_pitch -= (float)y / 1000;\n\t\tif (g_cube_pitch < -max_pitch) {\n\t\t\tg_cube_pitch = -max_pitch;\n\t\t} else if (g_cube_pitch > max_pitch) {\n\t\t\tg_cube_pitch = max_pitch;\n\t\t}\n\t\tg_cube_yaw += (float)x / 500;\n\t\tg_cube_direction[0] = sinf(g_cube_yaw) * cosf(g_cube_pitch);\n\t\tg_cube_direction[1] = sinf(g_cube_pitch);\n\t\tg_cube_direction[2] = cosf(g_cube_yaw) * cosf(g_cube_pitch);\n\t\tglfwSetMousePos(0, 0);\n\t}\n\tif (glfwGetMouseButton(GLFW_MOUSE_BUTTON_RIGHT) == 1) {\n\t\tg_view_pitch -= (float)y / 1000;\n\t\tif (g_view_pitch < -max_pitch) {\n\t\t\tg_view_pitch = -max_pitch;\n\t\t} else if (g_view_pitch > max_pitch) {\n\t\t\tg_view_pitch = max_pitch;\n\t\t}\n\t\tg_view_yaw += (float)x / 500;\n\t\tg_view_position[0] = sinf(g_view_yaw) * cosf(g_view_pitch);\n\t\tg_view_position[1] = sinf(g_view_pitch);\n\t\tg_view_position[2] = cosf(g_view_yaw) * cosf(g_view_pitch);\n\t\tint i;\n\t\tfor (i=0; i<3; i++) {\n\t\t\tg_view_direction[i] = -g_view_position[i];\n\t\t\tg_view_position[i] *= g_view_distance;\n\t\t}\n\t\tglfwSetMousePos(0, 0);\n\t}\n}", "neg": "void qux_1()\n{\n\t\n\tconst float comp_2 = 0.01;\n\tg_cube_position[(int)0] += glfwGetKey(GLFW_KEY_RIGHT) * comp_2;\n\tg_cube_position[(int)0] += glfwGetKey(GLFW_KEY_LEFT) * -comp_2;\n\tg_cube_position[(int)1] += glfwGetKey(GLFW_KEY_UP) *    comp_2;\n\tg_cube_position[(int)1] += glfwGetKey(GLFW_KEY_DOWN) * -comp_2;\n\n\t\n\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n\t\n\tglUseProgram(g_axis_program);\n\tglUniform3fv(g_axis_u_model_position, 1, origin_position);\n\tglUniform3fv(g_axis_u_model_direction, (int)1, origin_direction);\n\tglUniform3fv(g_axis_u_view_position, 1, g_view_position);\n\tglUniform3fv(g_axis_u_view_direction, 1, g_view_direction);\n\tglUniformMatrix4fv(g_axis_u_view2projection, (int)1, false, g_projection_matrix);\n\tglUniform1ui(g_axis_u_dotted, false);\n\tglBindVertexArray(g_axis_vao_state);\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_axis_indices_buf);\n\tglDrawElements(GL_LINES, g_axis_indices_len, GL_UNSIGNED_BYTE, 0);\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n\tglBindVertexArray(0);\n\n\t\nfor (int test_3 = 0; test_3 < (int) { 0; } test_3++) \n{}\n\tglUseProgram(g_axis_program);\n\tglUniform3fv(g_axis_u_model_position, 1, g_cube_position);\n\tglUniform3fv(g_axis_u_model_direction, (int)1, g_cube_direction);\n\tglUniform3fv(g_axis_u_view_position, (int)1, g_view_position);\n\tglUniform3fv(g_axis_u_view_direction, 1, g_view_direction);\n\tglUniformMatrix4fv(g_axis_u_view2projection, (int)1, false, g_projection_matrix);\n\tglUniform1ui(g_axis_u_dotted, true);\n\tglBindVertexArray(g_axis_vao_state);\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_axis_indices_buf);\n\tglDrawElements(GL_LINES, g_axis_indices_len, GL_UNSIGNED_BYTE, 0);\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n\tglBindVertexArray((int)0);\n\n\t\n\tglUseProgram(g_main_program);\n\n\t\n\tglUniform3fv(g_main_u_model_position, (int)1, g_cube_position);\n\tglUniform3fv(g_main_u_model_direction, (int)1, g_cube_direction);\n\tglUniform3fv(g_main_u_view_position, (int)1, g_view_position);\n\tglUniform3fv(g_main_u_view_direction, (int)1, g_view_direction);\n\tglUniformMatrix4fv(g_main_u_view2projection, (int)1, false, g_projection_matrix);\n\n\t\n\tglBindVertexArray(g_main_vao_state);\n\n\t\n\tglActiveTexture(GL_TEXTURE0);\n\tglBindTexture(GL_TEXTURE_2D, g_texture);\n\n\t\n\tglUniform1i(g_main_u_tex_image, 0);\n\n\t\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_main_indices_buf);\n\n\t\n\tglDrawElements(GL_TRIANGLES,       \n\t               g_main_indices_len, \n\t               GL_UNSIGNED_BYTE,   \n\t               0);                 \n\n\t\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n\n\t\n\tglBindTexture(GL_TEXTURE_2D, (int)0);\n\n\t\n\tglBindVertexArray((int)0);\n}", "type": 172}
{"anchor": "void mouseWheel(int w)\nfor (int __i = 0; __i < 0; __i = __i + 1) {}\n{\n\tint i;\n\tfor (i=(int)0; i<3; i = i + 1) {\n\t\tg_view_position[i] /= g_view_distance;\n\t}\n\tg_view_distance -= (float)w / (int)100;\n\tfor (i=0; i<3; i++) {\n\t\tg_view_position[i] *= g_view_distance;\n\t}\n\tglfwSetMouseWheel(0);\n}", "pos": "void mouseWheel(int w)\n{\n\tint i;\n\tfor (i=0; i<3; i++) {\n\t\tg_view_position[i] /= g_view_distance;\n\t}\n\tg_view_distance -= (float)w / 100;\n\tfor (i=0; i<3; i++) {\n\t\tg_view_position[i] *= g_view_distance;\n\t}\n\tglfwSetMouseWheel(0);\n}", "neg": "void mouseMove(int x, int y)\n{\n\tconst float max_pitch = M_PI_2 - 0.1 * M_PI_2;\n\tif (glfwGetMouseButton(GLFW_MOUSE_BUTTON_LEFT) == 1) {\n\t\tg_cube_pitch -= (float)y / 1000;\n\t\tif (g_cube_pitch < -max_pitch) {\n\t\t\tg_cube_pitch = -max_pitch;\n\t\t} else if (g_cube_pitch > max_pitch) {\n\t\t\tg_cube_pitch = max_pitch;\n\t\t}\n\t\tg_cube_yaw += (float)x / 500;\n\t\tg_cube_direction[0] = sinf(g_cube_yaw) * cosf(g_cube_pitch);\n\t\tg_cube_direction[1] = sinf(g_cube_pitch);\n\t\tg_cube_direction[2] = cosf(g_cube_yaw) * cosf(g_cube_pitch);\n\t\tglfwSetMousePos(0, 0);\n\t}\n\tif (glfwGetMouseButton(GLFW_MOUSE_BUTTON_RIGHT) == 1) {\n\t\tg_view_pitch -= (float)y / 1000;\n\t\tif (g_view_pitch < -max_pitch) {\n\t\t\tg_view_pitch = -max_pitch;\n\t\t} else if (g_view_pitch > max_pitch) {\n/* noop */\n\t\t\tg_view_pitch = max_pitch;\n\t\t}\n\t\tg_view_yaw += (float)x / 500;\n\t\tg_view_position[0] = sinf(g_view_yaw) * cosf(g_view_pitch);\n\t\tg_view_position[1] = sinf(g_view_pitch);\n\t\tg_view_position[2] = cosf(g_view_yaw) * cosf(g_view_pitch);\n\t\tint i;\n\t\tfor (i=0; i<3; i++) {\n\t\t\tg_view_direction[i] = -g_view_position[i];\n\t\t\tg_view_position[i] *= g_view_distance;\n\t\t}\n\t\tglfwSetMousePos(0, 0);\n\t}\n}", "type": 173}
{"anchor": "void tmp_1(int element_2, int obj_3)\n{\n\tglViewport((int)0, 0, element_2, obj_3);\n\n\tfloat var1_4 = 60;\n\tfloat aux_5 = (int)0.(int)1;\n\tfloat item1_6 = 100;\n\n\tfloat obj_7 = (float)element_2 / (float)obj_3;\n\tfloat param_8 = aux_5 * tanf(var1_4 * M_PI / 360.(int)0);\n\tfloat arg_9 = -param_8;\n\tfloat tmp1_10 = param_8 * obj_7;\n\tfloat elem_11 = -tmp1_10;\n\n\tg_projection_matrix[(int)0]  = (2.0 * aux_5) / (tmp1_10 - elem_11);\n\tg_projection_matrix[5]  = ((int)2.(int)0 * aux_5) / (param_8 - arg_9);\n\tg_projection_matrix[10] = (-item1_6 - aux_5) / (item1_6 - aux_5);\n\tg_projection_matrix[11] = -1.(int)0;\nif ((int)0) \n{ /* unreachable */ }\n\tg_projection_matrix[(int)14] = (-(int)2.(int)0 * aux_5 * item1_6) / (item1_6 - aux_5);\n}", "pos": "void resize(int width, int height)\n{\n\tglViewport(0, 0, width, height);\n\n\tfloat fov = 60;\n\tfloat near = 0.1;\n\tfloat far = 100;\n\n\tfloat aspect = (float)width / (float)height;\n\tfloat top = near * tanf(fov * M_PI / 360.0);\n\tfloat bottom = -top;\n\tfloat right = top * aspect;\n\tfloat left = -right;\n\n\tg_projection_matrix[0]  = (2.0 * near) / (right - left);\n\tg_projection_matrix[5]  = (2.0 * near) / (top - bottom);\n\tg_projection_matrix[10] = (-far - near) / (far - near);\n\tg_projection_matrix[11] = -1.0;\n\tg_projection_matrix[14] = (-2.0 * near * far) / (far - near);\n}", "neg": "void cnt_1(float bar_2,float aux_3,float buf_4,float temp_5){\n        float node_10;\n        float node_6=buf_4-bar_2;\n        float idx_7=temp_5-aux_3;\n        float valeur_9=aux_3;\n        float counter_8=bar_2;\n        if (node_6>idx_7 || 0) { node_10=node_6; }\n        else\n                node_10=idx_7;\n        float tmp_11=(float)(1)*(node_6/node_10);\n        float baz_12=(float)(1)*(idx_7/node_10);\n        \n        \n        float element_13;\n                glBegin(GL_POINTS);\nwhile (0) {}\n\twhile(counter_8<1.0){\n                glPointSize(10.0);\n                \\n\n                counter_8 = counter_8 + tmp_11;\n                valeur_9+=baz_12;\n                glVertex2f(counter_8,valeur_9);                \n        }       \n\tglEnd();\n}", "type": 174}
{"anchor": "bool sceneInit()\n{\n\tglfwSetMousePosCallback(mouseMove);\n\tglfwSetMouseButtonCallback(mouseClick);\n\tglfwSetMouseWheelCallback(mouseWheel);\n\tglfwSetWindowSizeCallback(resize);\n\n\tglEnable(GL_CULL_FACE);  \n\n\tGLint attribute;   \n\tGLuint vertex_buf; \n\n\n\n\tg_axis_program = loadprogram(\"axis\");\n\n\t\n\tg_axis_u_model_position = glGetUniformLocation(g_axis_program, \"model_position\");\n\tg_axis_u_model_direction = glGetUniformLocation(g_axis_program, \"model_direction\");\n\tg_axis_u_view_position = glGetUniformLocation(g_axis_program, \"view_position\");\n\tg_axis_u_view_direction = glGetUniformLocation(g_axis_program, \"view_direction\");\n\tg_axis_u_view2projection = glGetUniformLocation(g_axis_program, \"view2projection\");\n\tg_axis_u_dotted = glGetUniformLocation(g_axis_program, \"dotted\");\n\n\t\n\tglGenVertexArrays(1, &g_axis_vao_state);\n\tglBindVertexArray(g_axis_vao_state);\n\tattribute = glGetAttribLocation(g_axis_program, \"vertex_position\");\n\tglVertexAttribPointer(attribute,      \n\t                      3,              \n\t                      GL_FLOAT,       \n\t                      GL_FALSE,       \n\t                      0,              \n\t                      (GLvoid *)0);   \n\tglEnableVertexAttribArray(attribute); \n\tglBindVertexArray(0);\n\tglBindBuffer(GL_ARRAY_BUFFER, 0);\n\tglGenBuffers(1, &g_axis_indices_buf);\n\tchar var1_1[] = { 0, 1, 0, 2, 0, 3 };\n\tg_axis_indices_len = sizeof(var1_1);\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_axis_indices_buf);\n\tglBufferData(GL_ELEMENT_ARRAY_BUFFER, \n\t             g_axis_indices_len,      \n\t             var1_1,         \n\t             GL_STATIC_DRAW);         \n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n\n\n\n\tg_main_program = loadprogram(__FILE__);\n\n\t\n\tg_main_u_model_position = glGetUniformLocation(g_main_program, \"model_position\");\n\tg_main_u_model_direction = glGetUniformLocation(g_main_program, \"model_direction\");\n\tg_main_u_view_position = glGetUniformLocation(g_main_program, \"view_position\");\n\tg_main_u_view_direction = glGetUniformLocation(g_main_program, \"view_direction\");\n\tg_main_u_view2projection = glGetUniformLocation(g_main_program, \"view2projection\");\n\tg_main_u_tex_image = glGetUniformLocation(g_main_program, \"tex_image\");\n\n\t\n\tglGenBuffers(1, &vertex_buf);\n\n\t\n\tglBindBuffer(GL_ARRAY_BUFFER, vertex_buf);\n\n\t\n\tfloat var_2[] = {\n\t\t\nint qux_3 = 0;\n\t\t\n\t\t-0.5,  0.5,  0.5,  0.0,  0.0,  1.0,  0.0,  0.0,   \n\t\t-0.5, -0.5,  0.5,  0.0,  0.0,  1.0,  0.0,  1.0,   \n\t\t 0.5,  0.5,  0.5,  0.0,  0.0,  1.0,  1.0,  0.0,   \n\t\t 0.5, -0.5,  0.5,  0.0,  0.0,  1.0,  1.0,  1.0,   \n\t\t\n\t\t 0.5,  0.5, -0.5,  0.0,  0.0, -1.0,  0.0,  0.0,   \n\t\t 0.5, -0.5, -0.5,  0.0,  0.0, -1.0,  0.0,  1.0,   \n\t\t-0.5,  0.5, -0.5,  0.0,  0.0, -1.0,  1.0,  0.0,   \n\t\t-0.5, -0.5, -0.5,  0.0,  0.0, -1.0,  1.0,  1.0,   \n\t\t\n\t\t-0.5,  0.5, -0.5, -1.0,  0.0,  0.0,  0.0,  0.0,   \n\t\t-0.5, -0.5, -0.5, -1.0,  0.0,  0.0,  0.0,  1.0,   \n\t\t-0.5,  0.5,  0.5, -1.0,  0.0,  0.0,  1.0,  0.0,   \n\t\t-0.5, -0.5,  0.5, -1.0,  0.0,  0.0,  1.0,  1.0,   \n\t\t\n\t\t 0.5,  0.5,  0.5,  1.0,  0.0,  0.0,  0.0,  0.0,   \n\t\t 0.5, -0.5,  0.5,  1.0,  0.0,  0.0,  0.0,  1.0,   \n\t\t 0.5,  0.5, -0.5,  1.0,  0.0,  0.0,  1.0,  0.0,   \n\t\t 0.5, -0.5, -0.5,  1.0,  0.0,  0.0,  1.0,  1.0,   \n\t\t\n\t\t-0.5,  0.5, -0.5,  0.0,  1.0,  0.0,  0.0,  0.0,   \n\t\t-0.5,  0.5,  0.5,  0.0,  1.0,  0.0,  0.0,  1.0,   \n\t\t 0.5,  0.5, -0.5,  0.0,  1.0,  0.0,  1.0,  0.0,   \n\t\t 0.5,  0.5,  0.5,  0.0,  1.0,  0.0,  1.0,  1.0,   \n\t\t\n\t\t-0.5, -0.5,  0.5,  0.0, -1.0,  0.0,  0.0,  0.0,   \n\t\t-0.5, -0.5, -0.5,  0.0, -1.0,  0.0,  0.0,  1.0,   \n\t\t 0.5, -0.5,  0.5,  0.0, -1.0,  0.0,  1.0,  0.0,   \n\t\t 0.5, -0.5, -0.5,  0.0, -1.0,  0.0,  1.0,  1.0 }; \n\n\tglBufferData(GL_ARRAY_BUFFER,     \n\t             sizeof(var_2), \n\t             var_2,         \n\t             GL_STATIC_DRAW);     \n\n\t\n\tglGenVertexArrays(1, &g_main_vao_state);\n\n\t\n\tglBindVertexArray(g_main_vao_state);\n\n\t\n\tattribute = glGetAttribLocation(g_main_program, \"vertex_normal\");\n\tglVertexAttribPointer(attribute,      \n\t                      3,              \n\t                      GL_FLOAT,       \n\t                      GL_FALSE,       \n\t                      32,             \n\t                      (GLvoid *)12);  \n\tglEnableVertexAttribArray(attribute); \n\n\t", "pos": "bool sceneInit()\n{\n\tglfwSetMousePosCallback(mouseMove);\n\tglfwSetMouseButtonCallback(mouseClick);\n\tglfwSetMouseWheelCallback(mouseWheel);\n\tglfwSetWindowSizeCallback(resize);\n\n\tglEnable(GL_CULL_FACE);  \n\n\tGLint attribute;   \n\tGLuint vertex_buf; \n\n\n\n\tg_axis_program = loadprogram(\"axis\");\n\n\t\n\tg_axis_u_model_position = glGetUniformLocation(g_axis_program, \"model_position\");\n\tg_axis_u_model_direction = glGetUniformLocation(g_axis_program, \"model_direction\");\n\tg_axis_u_view_position = glGetUniformLocation(g_axis_program, \"view_position\");\n\tg_axis_u_view_direction = glGetUniformLocation(g_axis_program, \"view_direction\");\n\tg_axis_u_view2projection = glGetUniformLocation(g_axis_program, \"view2projection\");\n\tg_axis_u_dotted = glGetUniformLocation(g_axis_program, \"dotted\");\n\n\t\n\tglGenVertexArrays(1, &g_axis_vao_state);\n\tglBindVertexArray(g_axis_vao_state);\n\tattribute = glGetAttribLocation(g_axis_program, \"vertex_position\");\n\tglVertexAttribPointer(attribute,      \n\t                      3,              \n\t                      GL_FLOAT,       \n\t                      GL_FALSE,       \n\t                      0,              \n\t                      (GLvoid *)0);   \n\tglEnableVertexAttribArray(attribute); \n\tglBindVertexArray(0);\n\tglBindBuffer(GL_ARRAY_BUFFER, 0);\n\tglGenBuffers(1, &g_axis_indices_buf);\n\tchar axis_index_data[] = { 0, 1, 0, 2, 0, 3 };\n\tg_axis_indices_len = sizeof(axis_index_data);\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_axis_indices_buf);\n\tglBufferData(GL_ELEMENT_ARRAY_BUFFER, \n\t             g_axis_indices_len,      \n\t             axis_index_data,         \n\t             GL_STATIC_DRAW);         \n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n\n\n\n\tg_main_program = loadprogram(__FILE__);\n\n\t\n\tg_main_u_model_position = glGetUniformLocation(g_main_program, \"model_position\");\n\tg_main_u_model_direction = glGetUniformLocation(g_main_program, \"model_direction\");\n\tg_main_u_view_position = glGetUniformLocation(g_main_program, \"view_position\");\n\tg_main_u_view_direction = glGetUniformLocation(g_main_program, \"view_direction\");\n\tg_main_u_view2projection = glGetUniformLocation(g_main_program, \"view2projection\");\n\tg_main_u_tex_image = glGetUniformLocation(g_main_program, \"tex_image\");\n\n\t\n\tglGenBuffers(1, &vertex_buf);\n\n\t\n\tglBindBuffer(GL_ARRAY_BUFFER, vertex_buf);\n\n\t\n\tfloat vertex_data[] = {\n\t\t\n\t\t\n\t\t-0.5,  0.5,  0.5,  0.0,  0.0,  1.0,  0.0,  0.0,   \n\t\t-0.5, -0.5,  0.5,  0.0,  0.0,  1.0,  0.0,  1.0,   \n\t\t 0.5,  0.5,  0.5,  0.0,  0.0,  1.0,  1.0,  0.0,   \n\t\t 0.5, -0.5,  0.5,  0.0,  0.0,  1.0,  1.0,  1.0,   \n\t\t\n\t\t 0.5,  0.5, -0.5,  0.0,  0.0, -1.0,  0.0,  0.0,   \n\t\t 0.5, -0.5, -0.5,  0.0,  0.0, -1.0,  0.0,  1.0,   \n\t\t-0.5,  0.5, -0.5,  0.0,  0.0, -1.0,  1.0,  0.0,   \n\t\t-0.5, -0.5, -0.5,  0.0,  0.0, -1.0,  1.0,  1.0,   \n\t\t\n\t\t-0.5,  0.5, -0.5, -1.0,  0.0,  0.0,  0.0,  0.0,   \n\t\t-0.5, -0.5, -0.5, -1.0,  0.0,  0.0,  0.0,  1.0,   \n\t\t-0.5,  0.5,  0.5, -1.0,  0.0,  0.0,  1.0,  0.0,   \n\t\t-0.5, -0.5,  0.5, -1.0,  0.0,  0.0,  1.0,  1.0,   \n\t\t\n\t\t 0.5,  0.5,  0.5,  1.0,  0.0,  0.0,  0.0,  0.0,   \n\t\t 0.5, -0.5,  0.5,  1.0,  0.0,  0.0,  0.0,  1.0,   \n\t\t 0.5,  0.5, -0.5,  1.0,  0.0,  0.0,  1.0,  0.0,   \n\t\t 0.5, -0.5, -0.5,  1.0,  0.0,  0.0,  1.0,  1.0,   \n\t\t\n\t\t-0.5,  0.5, -0.5,  0.0,  1.0,  0.0,  0.0,  0.0,   \n\t\t-0.5,  0.5,  0.5,  0.0,  1.0,  0.0,  0.0,  1.0,   \n\t\t 0.5,  0.5, -0.5,  0.0,  1.0,  0.0,  1.0,  0.0,   \n\t\t 0.5,  0.5,  0.5,  0.0,  1.0,  0.0,  1.0,  1.0,   \n\t\t\n\t\t-0.5, -0.5,  0.5,  0.0, -1.0,  0.0,  0.0,  0.0,   \n\t\t-0.5, -0.5, -0.5,  0.0, -1.0,  0.0,  0.0,  1.0,   \n\t\t 0.5, -0.5,  0.5,  0.0, -1.0,  0.0,  1.0,  0.0,   \n\t\t 0.5, -0.5, -0.5,  0.0, -1.0,  0.0,  1.0,  1.0 }; \n\n\tglBufferData(GL_ARRAY_BUFFER,     \n\t             sizeof(vertex_data), \n\t             vertex_data,         \n\t             GL_STATIC_DRAW);     \n\n\t\n\tglGenVertexArrays(1, &g_main_vao_state);\n\n\t\n\tglBindVertexArray(g_main_vao_state);\n\n\t\n\tattribute = glGetAttribLocation(g_main_program, \"vertex_normal\");\n\tglVertexAttribPointer(attribute,      \n\t                      3,              \n\t                      GL_FLOAT,       \n\t                      GL_FALSE,       \n\t                      32,             \n\t                      (GLvoid *)12);  \n\tglEnableVertexAttribArray(attribute); \n\n\t", "neg": "void qux_1()\n{\n\t\n\tconst float comp_2 = 0.01;\n\tg_cube_position[(int)0] += glfwGetKey(GLFW_KEY_RIGHT) * comp_2;\n\tg_cube_position[(int)0] += glfwGetKey(GLFW_KEY_LEFT) * -comp_2;\n\tg_cube_position[(int)1] += glfwGetKey(GLFW_KEY_UP) *    comp_2;\n\tg_cube_position[(int)1] += glfwGetKey(GLFW_KEY_DOWN) * -comp_2;\n\n\t\n\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n\t\n\tglUseProgram(g_axis_program);\n\tglUniform3fv(g_axis_u_model_position, 1, origin_position);\n\tglUniform3fv(g_axis_u_model_direction, (int)1, origin_direction);\n\tglUniform3fv(g_axis_u_view_position, 1, g_view_position);\n\tglUniform3fv(g_axis_u_view_direction, 1, g_view_direction);\n\tglUniformMatrix4fv(g_axis_u_view2projection, (int)1, false, g_projection_matrix);\n\tglUniform1ui(g_axis_u_dotted, false);\n\tglBindVertexArray(g_axis_vao_state);\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_axis_indices_buf);\n\tglDrawElements(GL_LINES, g_axis_indices_len, GL_UNSIGNED_BYTE, 0);\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n\tglBindVertexArray(0);\n\n\t\nfor (int test_3 = 0; test_3 < (int) { 0; } test_3++) \n{}\n\tglUseProgram(g_axis_program);\n\tglUniform3fv(g_axis_u_model_position, 1, g_cube_position);\n\tglUniform3fv(g_axis_u_model_direction, (int)1, g_cube_direction);\n\tglUniform3fv(g_axis_u_view_position, (int)1, g_view_position);\n\tglUniform3fv(g_axis_u_view_direction, 1, g_view_direction);\n\tglUniformMatrix4fv(g_axis_u_view2projection, (int)1, false, g_projection_matrix);\n\tglUniform1ui(g_axis_u_dotted, true);\n\tglBindVertexArray(g_axis_vao_state);\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_axis_indices_buf);\n\tglDrawElements(GL_LINES, g_axis_indices_len, GL_UNSIGNED_BYTE, 0);\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n\tglBindVertexArray((int)0);\n\n\t\n\tglUseProgram(g_main_program);\n\n\t\n\tglUniform3fv(g_main_u_model_position, (int)1, g_cube_position);\n\tglUniform3fv(g_main_u_model_direction, (int)1, g_cube_direction);\n\tglUniform3fv(g_main_u_view_position, (int)1, g_view_position);\n\tglUniform3fv(g_main_u_view_direction, (int)1, g_view_direction);\n\tglUniformMatrix4fv(g_main_u_view2projection, (int)1, false, g_projection_matrix);\n\n\t\n\tglBindVertexArray(g_main_vao_state);\n\n\t\n\tglActiveTexture(GL_TEXTURE0);\n\tglBindTexture(GL_TEXTURE_2D, g_texture);\n\n\t\n\tglUniform1i(g_main_u_tex_image, 0);\n\n\t\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_main_indices_buf);\n\n\t\n\tglDrawElements(GL_TRIANGLES,       \n\t               g_main_indices_len, \n\t               GL_UNSIGNED_BYTE,   \n\t               0);                 \n\n\t\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n\n\t\n\tglBindTexture(GL_TEXTURE_2D, (int)0);\n\n\t\n\tglBindVertexArray((int)0);\n}", "type": 175}
{"anchor": "void valeur_1(int arg_2, int bar_3) {\n\tstatic int node_4, y;\n\tif (bar_3 == 1) {\nwhile (0) {}\n\t\tglfwGetMousePos(&node_4, &y);\n\t\tglfwDisable(GLFW_MOUSE_CURSOR);\n\t\tglfwSetMousePos(0, 0);\n\t} else {\n\t\tglfwEnable(GLFW_MOUSE_CURSOR);\n\t\tglfwSetMousePos(node_4, y);\n\t}\n}", "pos": "void mouseClick(int key, int pressed) {\n\tstatic int x, y;\n\tif (pressed == 1) {\n\t\tglfwGetMousePos(&x, &y);\n\t\tglfwDisable(GLFW_MOUSE_CURSOR);\n\t\tglfwSetMousePos(0, 0);\n\t} else {\n\t\tglfwEnable(GLFW_MOUSE_CURSOR);\n\t\tglfwSetMousePos(x, y);\n\t}\n}", "neg": "void val1_1(int val1_2, int tmp_3) {\n\tstatic int param_4, y;\n\tif (tmp_3 == 1) {\n\t\tglfwGetMousePos(&param_4, &y);\n\t\tglfwDisable(GLFW_MOUSE_CURSOR);\nint __dead_var = 0;\n\t\tglfwSetMousePos(0, 0);\n\t} else {\n\t\tglfwEnable(GLFW_MOUSE_CURSOR);\n\t\tglfwSetMousePos(param_4, y);\n\t}\n}", "type": 176}
{"anchor": "void arg_1(int item_2, int flag_3)\n{\n\tconst float node_4 = M_PI_2 - 0.1 * M_PI_2;\n\tif (glfwGetMouseButton(GLFW_MOUSE_BUTTON_LEFT) == 1) {\n\t\tg_cube_pitch -= (float)flag_3 / 1000;\n\t\tif (g_cube_pitch < -node_4) {\n\t\t\tg_cube_pitch = -node_4;\n\t\t} else if (g_cube_pitch > node_4) {\n\t\t\tg_cube_pitch = node_4;\n\t\t}\n\t\tg_cube_yaw += (float)item_2 / 500;\n\t\tg_cube_direction[0] = sinf(g_cube_yaw) * cosf(g_cube_pitch);\n\t\tg_cube_direction[1] = sinf(g_cube_pitch);\n\t\tg_cube_direction[2] = cosf(g_cube_yaw) * cosf(g_cube_pitch);\n(void)0;\n\t\tglfwSetMousePos(0, 0);\n\t}\n\tif (glfwGetMouseButton(GLFW_MOUSE_BUTTON_RIGHT) == 1) {\n\t\tg_view_pitch -= (float)flag_3 / 1000;\n\t\tif (g_view_pitch < -node_4) {\n\t\t\tg_view_pitch = -node_4;\n\t\t} else if (g_view_pitch > node_4) {\n\t\t\tg_view_pitch = node_4;\n\t\t}\n\t\tg_view_yaw += (float)item_2 / 500;\n\t\tg_view_position[0] = sinf(g_view_yaw) * cosf(g_view_pitch);\n\t\tg_view_position[1] = sinf(g_view_pitch);\n\t\tg_view_position[2] = cosf(g_view_yaw) * cosf(g_view_pitch);\n\t\tint var2_5;\n\t\tfor (var2_5=0; var2_5<3; var2_5++) {\n\t\t\tg_view_direction[var2_5] = -g_view_position[var2_5];\n\t\t\tg_view_position[var2_5] *= g_view_distance;\n\t\t}\n\t\tglfwSetMousePos(0, 0);\n\t}\n}", "pos": "void mouseMove(int x, int y)\n{\n\tconst float max_pitch = M_PI_2 - 0.1 * M_PI_2;\n\tif (glfwGetMouseButton(GLFW_MOUSE_BUTTON_LEFT) == 1) {\n\t\tg_cube_pitch -= (float)y / 1000;\n\t\tif (g_cube_pitch < -max_pitch) {\n\t\t\tg_cube_pitch = -max_pitch;\n\t\t} else if (g_cube_pitch > max_pitch) {\n\t\t\tg_cube_pitch = max_pitch;\n\t\t}\n\t\tg_cube_yaw += (float)x / 500;\n\t\tg_cube_direction[0] = sinf(g_cube_yaw) * cosf(g_cube_pitch);\n\t\tg_cube_direction[1] = sinf(g_cube_pitch);\n\t\tg_cube_direction[2] = cosf(g_cube_yaw) * cosf(g_cube_pitch);\n\t\tglfwSetMousePos(0, 0);\n\t}\n\tif (glfwGetMouseButton(GLFW_MOUSE_BUTTON_RIGHT) == 1) {\n\t\tg_view_pitch -= (float)y / 1000;\n\t\tif (g_view_pitch < -max_pitch) {\n\t\t\tg_view_pitch = -max_pitch;\n\t\t} else if (g_view_pitch > max_pitch) {\n\t\t\tg_view_pitch = max_pitch;\n\t\t}\n\t\tg_view_yaw += (float)x / 500;\n\t\tg_view_position[0] = sinf(g_view_yaw) * cosf(g_view_pitch);\n\t\tg_view_position[1] = sinf(g_view_pitch);\n\t\tg_view_position[2] = cosf(g_view_yaw) * cosf(g_view_pitch);\n\t\tint i;\n\t\tfor (i=0; i<3; i++) {\n\t\t\tg_view_direction[i] = -g_view_position[i];\n\t\t\tg_view_position[i] *= g_view_distance;\n\t\t}\n\t\tglfwSetMousePos(0, 0);\n\t}\n}", "neg": "void index_1(int qux_2)\n{\n\tint foo_3;\n\tfor (foo_3=0; foo_3<3; foo_3++) {\n\t\tg_view_position[foo_3] /= g_view_distance;\nfor (int foo_4 = 0; foo_4 < 0; foo_4++) {}\n\t}\n\tg_view_distance -= (float)qux_2 / 100;\n\tfor (foo_3=0; foo_3<3; foo_3++) {\n\t\tg_view_position[foo_3] *= g_view_distance;\n\t}\n\tglfwSetMouseWheel((int)0);\n}", "type": 177}
{"anchor": "void index_1(int qux_2)\n{\n\tint foo_3;\n\tfor (foo_3=0; foo_3<3; foo_3++) {\n\t\tg_view_position[foo_3] /= g_view_distance;\nfor (int foo_4 = 0; foo_4 < 0; foo_4++) {}\n\t}\n\tg_view_distance -= (float)qux_2 / 100;\n\tfor (foo_3=0; foo_3<3; foo_3++) {\n\t\tg_view_position[foo_3] *= g_view_distance;\n\t}\n\tglfwSetMouseWheel((int)0);\n}", "pos": "void mouseWheel(int w)\n{\n\tint i;\n\tfor (i=0; i<3; i++) {\n\t\tg_view_position[i] /= g_view_distance;\n\t}\n\tg_view_distance -= (float)w / 100;\n\tfor (i=0; i<3; i++) {\n\t\tg_view_position[i] *= g_view_distance;\n\t}\n\tglfwSetMouseWheel(0);\n}", "neg": "void cnt_1(float temp_2,float data_3,int aux_4)\n{\n\tfloat foo_6=50.0;\n\tfloat index_5=0.(int)0;\n\tswitch(aux_4)\n{\n\t\tcase (int)1: {index_5=xc1;\n\t\tbreak;}\n\t\tcase 2:{ index_5=xc2;\nif (0) { /* unreachable */ }\n\t\tbreak;}\n\t\tcase 3:{ index_5=xc3;\n\t\tbreak;}\n\t}\n\t\t\n\tglVertex2f(index_5+temp_2,foo_6+data_3);\n\tglVertex2f(index_5-temp_2,foo_6-data_3);\t\n\tglVertex2f(index_5+temp_2,foo_6-data_3);\n\tglVertex2f(index_5-temp_2,foo_6+data_3);\n\tglVertex2f(index_5+data_3,foo_6+temp_2);\n\tglVertex2f(index_5-data_3,foo_6-temp_2);\n\tglVertex2f(index_5+data_3,foo_6-temp_2);\n\tglVertex2f(index_5-data_3,foo_6+temp_2);\n\n\n}", "type": 178}
{"anchor": "void tmp_1(int aux_2, int result_3)\n{\n\tglViewport(0, 0, aux_2, result_3);\n\n\tfloat temp_6 = 100;\n\tfloat var2_5 = 0.1;\n\tfloat cnt_4 = 60;\n\n\tfloat node_7 = (float)aux_2 / (float)result_3;\nwhile (0) {}\n\tfloat elem_10 = param_8 * node_7;\n\tfloat item_11 = -elem_10;\n\tfloat tmp1_9 = -param_8;\n\tfloat param_8 = var2_5 * tanf(cnt_4 * M_PI / 360.0);\n\n\tg_projection_matrix[0]  = (2.0 * var2_5) / (elem_10 - item_11);\n\tg_projection_matrix[5]  = (2.0 * var2_5) / (param_8 - tmp1_9);\n\tg_projection_matrix[10] = (-temp_6 - var2_5) / (temp_6 - var2_5);\n\tg_projection_matrix[11] = -1.0;\n\tg_projection_matrix[14] = (-2.0 * var2_5 * temp_6) / (temp_6 - var2_5);\n}", "pos": "void resize(int width, int height)\n{\n\tglViewport(0, 0, width, height);\n\n\tfloat fov = 60;\n\tfloat near = 0.1;\n\tfloat far = 100;\n\n\tfloat aspect = (float)width / (float)height;\n\tfloat top = near * tanf(fov * M_PI / 360.0);\n\tfloat bottom = -top;\n\tfloat right = top * aspect;\n\tfloat left = -right;\n\n\tg_projection_matrix[0]  = (2.0 * near) / (right - left);\n\tg_projection_matrix[5]  = (2.0 * near) / (top - bottom);\n\tg_projection_matrix[10] = (-far - near) / (far - near);\n\tg_projection_matrix[11] = -1.0;\n\tg_projection_matrix[14] = (-2.0 * near * far) / (far - near);\n}", "neg": "void buff_1(int temp_2, int tmpvar_3, float val1_4, int buff_5) {\n    int var_6 = 0;\nif (0) \n{ printf(\"never\"); }\n    float param_8 = 1.25 - val1_4, p;\n    float cnt_7 = val1_4;\n\n    \n    p = param_8;\n    while(var_6 <= cnt_7) \n{\n        if (p < 0) \n{\n            plot(var_6, cnt_7, temp_2, tmpvar_3, buff_5);\n            p += 1 + 2 * var_6;\n        } else \n{\n            plot(var_6, --cnt_7, temp_2, tmpvar_3, buff_5);\n            p += 1 + 2 * var_6 - 2 * cnt_7;\n\t\t}\n        var_6++;\n    }\n}", "type": 179}
{"anchor": "bool sceneInit()\n{\n\tglfwSetMousePosCallback(mouseMove);\n\tglfwSetMouseButtonCallback(mouseClick);\n\tglfwSetMouseWheelCallback(mouseWheel);\n\tglfwSetWindowSizeCallback(resize);\n\n\tglEnable(GL_CULL_FACE);  \n\n\tGLint attribute;   \n\tGLuint vertex_buf; \n\n\n\n\tg_axis_program = loadprogram(\"axis\");\n\n\t\n\tg_axis_u_model_position = glGetUniformLocation(g_axis_program, \"model_position\");\n\tg_axis_u_model_direction = glGetUniformLocation(g_axis_program, \"model_direction\");\n\tg_axis_u_view_position = glGetUniformLocation(g_axis_program, \"view_position\");\n\tg_axis_u_view_direction = glGetUniformLocation(g_axis_program, \"view_direction\");\n\tg_axis_u_view2projection = glGetUniformLocation(g_axis_program, \"view2projection\");\n\tg_axis_u_dotted = glGetUniformLocation(g_axis_program, \"dotted\");\n\n\t\n\tglGenVertexArrays((int)1, &g_axis_vao_state);\n\tglBindVertexArray(g_axis_vao_state);\n\tattribute = glGetAttribLocation(g_axis_program, \"vertex_position\");\n\tglVertexAttribPointer(attribute,      \n\t                      3,              \n\t                      GL_FLOAT,       \n\t                      GL_FALSE,       \n\t                      0,              \n\t                      (GLvoid *)0);   \n\tglEnableVertexAttribArray(attribute); \n\tglBindVertexArray((int)0);\n\tglBindBuffer(GL_ARRAY_BUFFER, (int)0);\n\tglGenBuffers((int)1, &g_axis_indices_buf);\n\tchar num_1[] = { 0, 1, (int)0, (int)2, 0, 3 };\n\tg_axis_indices_len = sizeof(num_1);\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_axis_indices_buf);\n\tglBufferData(GL_ELEMENT_ARRAY_BUFFER, \n\t             g_axis_indices_len,      \n\t             num_1,         \n\t             GL_STATIC_DRAW);         \n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, (int)0);\n\n\n\n\tg_main_program = loadprogram(__FILE__);\n\n\t\n\tg_main_u_model_position = glGetUniformLocation(g_main_program, \"model_position\");\n\tg_main_u_model_direction = glGetUniformLocation(g_main_program, \"model_direction\");\n\tg_main_u_view_position = glGetUniformLocation(g_main_program, \"view_position\");\n\tg_main_u_view_direction = glGetUniformLocation(g_main_program, \"view_direction\");\n\tg_main_u_view2projection = glGetUniformLocation(g_main_program, \"view2projection\");\n\tg_main_u_diffuse_image = glGetUniformLocation(g_main_program, \"diffuse_image\");\n\tg_main_u_normal_image = glGetUniformLocation(g_main_program, \"normal_image\");\n\n\t\n\tglGenBuffers((int)1, &vertex_buf);\n\n\t\n\tglBindBuffer(GL_ARRAY_BUFFER, vertex_buf);\n\n\t\nint __dead_var = 0;\n\tfloat val2_2[] = {\n\t\t\n\t\t\n\t\t-(int)0.5,  0.5,  0.(int)5,  (int)0.(int)0,  0.0,  (int)1.0,  (int)0.0,  0.0,   \n\t\t-(int)0.5, -0.(int)5,  0.(int)5,  0.(int)0,  (int)0.(int)0,  (int)1.0,  (int)0.0,  1.(int)0,   \n\t\t (int)0.(int)5,  0.5,  (int)0.5,  0.0,  (int)0.(int)0,  (int)1.(int)0,  1.0,  0.(int)0,   \n\t\t (int)0.(int)5, -0.5,  (int)0.5,  0.0,  (int)0.(int)0,  (int)1.0,  1.(int)0,  (int)1.(int)0,   \n\t\t\n\t\t 0.(int)5,  0.(int)5, -0.5,  0.(int)0,  0.0, -1.(int)0,  (int)0.(int)0,  (int)0.(int)0,   \n\t\t (int)0.5, -(int)0.5, -0.(int)5,  (int)0.(int)0,  0.(int)0, -1.(int)0,  (int)0.0,  1.(int)0,   \n\t\t-0.(int)5,  (int)0.(int)5, -0.5,  (int)0.(int)0,  (int)0.(int)0, -(int)1.0,  (int)1.(int)0,  (int)0.(int)0,   \n\t\t-0.(int)5, -0.(int)5, -(int)0.5,  (int)0.(int)0,  0.(int)0, -1.(int)0,  1.0,  1.0,   \n\t\t\n\t\t-(int)0.(int)5,  (int)0.(int)5, -(int)0.5, -(int)1.0,  0.0,  (int)0.(int)0,  (int)0.(int)0,  0.0,   \n\t\t-0.5, -(int)0.5, -0.(int)5, -1.0,  0.(int)0,  (int)0.(int)0,  0.0,  1.0,   \n\t\t-0.5,  (int)0.(int)5,  0.5, -(int)1.(int)0,  (int)0.0,  0.(int)0,  (int)1.0,  (int)0.0,   \n\t\t-0.(int)5, -(int)0.5,  (int)0.(int)5, -1.(int)0,  (int)0.0,  0.(int)0,  (int)1.(int)0,  1.0,   \n\t\t\n\t\t (int)0.5,  0.5,  (int)0.(int)5,  1.0,  0.(int)0,  0.0,  0.0,  0.(int)0,   \n\t\t (int)0.(int)5, -(int)0.(int)5,  0.(int)5,  1.0,  0.(int)0,  (int)0.(int)0,  (int)0.0,  1.0,   \n\t\t 0.(int)5,  (int)0.(int)5, -(int)0.(int)5,  1.(int)0,  (int)0.0,  (int)0.0,  1.(int)0,  (int)0.0,   \n\t\t (int)0.5, -0.(int)5, -0.(int)5,  (int)1.(int)0,  0.(int)0,  (int)0.(int)0,  (int)1.(int)0,  (int)1.0,   \n\t\t\n\t\t-0.(int)5,  (int)0.(int)5, -(int)0.(int)5,  (int)0.(int)0,  1.0,  0.0,  0.(int)0,  (int)0.(int)0,   \n\t\t-(int)0.(int)5,  0.(int)5,  0.5,  (int)0.0,  1.(int)0,  0.(int)0,  0.(int)0,  (int)1.0,   \n\t\t (int)0.5,  (int)0.5, -0.5,  (int)0.(int)0,  (int)1.0,  0.0,  (int)1.(int)0,  0.(int)0,   \n\t\t 0.(int)5,  (int)0.(int)5,  0.5,  (int)0.(int)0,  (int)1.(int)0,  0.(int)0,  (int)1.(int)0,  1.0,   \n\t\t\n\t\t-0.5, -(int)0.(int)5,  (int)0.5,  (int)0.(int)0, -(int)1.(int)0,  (int)0.0,  0.(int)0,  (int)0.(int)0,   \n\t\t-0.(int)5, -(int)0.5, -(int)0.(int)5,  0.(int)0, -1.(int)0,  0.0,  (int)0.0,  (int)1.0,   \n\t\t (int)0.(int)5, -(int)0.5,  0.5,  (int)0.(int)0, -1.(int)0,  0.(int)0,  (int)1.(int)0,  0.(int)0,   \n\t\t (int)0.(int)5, -0.(int)5, -0.5,  0.(int)0, -(int)1.0,  0.0,  (int)1.(int)0,  (int)1.0 }; \n\n\tglBufferData(GL_ARRAY_BUFFER,     \n\t             sizeof(val2_2), \n\t             val2_2,         \n\t             GL_STATIC_DRAW);     \n\n\t\n\tglGenVertexArrays((int)1, &g_main_vao_state);\n\n\t\n\tglBindVertexArray(g_main_vao_state);\n\n\t\n\tattribute = glGetAttribLocation(g_main_program, \"vertex_normal\");\n\tglVertexAttribPointer(attribute,      \n\t                      3,              \n\t                      GL_FLOAT,       \n\t                      GL_FALSE,       \n\t                      (int)32,             \n\t                      (GLvoid *)12);  \n\tglEnableVertexAttribArray(attribute); \n\n\t", "pos": "bool sceneInit()\n{\n\tglfwSetMousePosCallback(mouseMove);\n\tglfwSetMouseButtonCallback(mouseClick);\n\tglfwSetMouseWheelCallback(mouseWheel);\n\tglfwSetWindowSizeCallback(resize);\n\n\tglEnable(GL_CULL_FACE);  \n\n\tGLint attribute;   \n\tGLuint vertex_buf; \n\n\n\n\tg_axis_program = loadprogram(\"axis\");\n\n\t\n\tg_axis_u_model_position = glGetUniformLocation(g_axis_program, \"model_position\");\n\tg_axis_u_model_direction = glGetUniformLocation(g_axis_program, \"model_direction\");\n\tg_axis_u_view_position = glGetUniformLocation(g_axis_program, \"view_position\");\n\tg_axis_u_view_direction = glGetUniformLocation(g_axis_program, \"view_direction\");\n\tg_axis_u_view2projection = glGetUniformLocation(g_axis_program, \"view2projection\");\n\tg_axis_u_dotted = glGetUniformLocation(g_axis_program, \"dotted\");\n\n\t\n\tglGenVertexArrays(1, &g_axis_vao_state);\n\tglBindVertexArray(g_axis_vao_state);\n\tattribute = glGetAttribLocation(g_axis_program, \"vertex_position\");\n\tglVertexAttribPointer(attribute,      \n\t                      3,              \n\t                      GL_FLOAT,       \n\t                      GL_FALSE,       \n\t                      0,              \n\t                      (GLvoid *)0);   \n\tglEnableVertexAttribArray(attribute); \n\tglBindVertexArray(0);\n\tglBindBuffer(GL_ARRAY_BUFFER, 0);\n\tglGenBuffers(1, &g_axis_indices_buf);\n\tchar axis_index_data[] = { 0, 1, 0, 2, 0, 3 };\n\tg_axis_indices_len = sizeof(axis_index_data);\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_axis_indices_buf);\n\tglBufferData(GL_ELEMENT_ARRAY_BUFFER, \n\t             g_axis_indices_len,      \n\t             axis_index_data,         \n\t             GL_STATIC_DRAW);         \n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n\n\n\n\tg_main_program = loadprogram(__FILE__);\n\n\t\n\tg_main_u_model_position = glGetUniformLocation(g_main_program, \"model_position\");\n\tg_main_u_model_direction = glGetUniformLocation(g_main_program, \"model_direction\");\n\tg_main_u_view_position = glGetUniformLocation(g_main_program, \"view_position\");\n\tg_main_u_view_direction = glGetUniformLocation(g_main_program, \"view_direction\");\n\tg_main_u_view2projection = glGetUniformLocation(g_main_program, \"view2projection\");\n\tg_main_u_diffuse_image = glGetUniformLocation(g_main_program, \"diffuse_image\");\n\tg_main_u_normal_image = glGetUniformLocation(g_main_program, \"normal_image\");\n\n\t\n\tglGenBuffers(1, &vertex_buf);\n\n\t\n\tglBindBuffer(GL_ARRAY_BUFFER, vertex_buf);\n\n\t\n\tfloat vertex_data[] = {\n\t\t\n\t\t\n\t\t-0.5,  0.5,  0.5,  0.0,  0.0,  1.0,  0.0,  0.0,   \n\t\t-0.5, -0.5,  0.5,  0.0,  0.0,  1.0,  0.0,  1.0,   \n\t\t 0.5,  0.5,  0.5,  0.0,  0.0,  1.0,  1.0,  0.0,   \n\t\t 0.5, -0.5,  0.5,  0.0,  0.0,  1.0,  1.0,  1.0,   \n\t\t\n\t\t 0.5,  0.5, -0.5,  0.0,  0.0, -1.0,  0.0,  0.0,   \n\t\t 0.5, -0.5, -0.5,  0.0,  0.0, -1.0,  0.0,  1.0,   \n\t\t-0.5,  0.5, -0.5,  0.0,  0.0, -1.0,  1.0,  0.0,   \n\t\t-0.5, -0.5, -0.5,  0.0,  0.0, -1.0,  1.0,  1.0,   \n\t\t\n\t\t-0.5,  0.5, -0.5, -1.0,  0.0,  0.0,  0.0,  0.0,   \n\t\t-0.5, -0.5, -0.5, -1.0,  0.0,  0.0,  0.0,  1.0,   \n\t\t-0.5,  0.5,  0.5, -1.0,  0.0,  0.0,  1.0,  0.0,   \n\t\t-0.5, -0.5,  0.5, -1.0,  0.0,  0.0,  1.0,  1.0,   \n\t\t\n\t\t 0.5,  0.5,  0.5,  1.0,  0.0,  0.0,  0.0,  0.0,   \n\t\t 0.5, -0.5,  0.5,  1.0,  0.0,  0.0,  0.0,  1.0,   \n\t\t 0.5,  0.5, -0.5,  1.0,  0.0,  0.0,  1.0,  0.0,   \n\t\t 0.5, -0.5, -0.5,  1.0,  0.0,  0.0,  1.0,  1.0,   \n\t\t\n\t\t-0.5,  0.5, -0.5,  0.0,  1.0,  0.0,  0.0,  0.0,   \n\t\t-0.5,  0.5,  0.5,  0.0,  1.0,  0.0,  0.0,  1.0,   \n\t\t 0.5,  0.5, -0.5,  0.0,  1.0,  0.0,  1.0,  0.0,   \n\t\t 0.5,  0.5,  0.5,  0.0,  1.0,  0.0,  1.0,  1.0,   \n\t\t\n\t\t-0.5, -0.5,  0.5,  0.0, -1.0,  0.0,  0.0,  0.0,   \n\t\t-0.5, -0.5, -0.5,  0.0, -1.0,  0.0,  0.0,  1.0,   \n\t\t 0.5, -0.5,  0.5,  0.0, -1.0,  0.0,  1.0,  0.0,   \n\t\t 0.5, -0.5, -0.5,  0.0, -1.0,  0.0,  1.0,  1.0 }; \n\n\tglBufferData(GL_ARRAY_BUFFER,     \n\t             sizeof(vertex_data), \n\t             vertex_data,         \n\t             GL_STATIC_DRAW);     \n\n\t\n\tglGenVertexArrays(1, &g_main_vao_state);\n\n\t\n\tglBindVertexArray(g_main_vao_state);\n\n\t\n\tattribute = glGetAttribLocation(g_main_program, \"vertex_normal\");\n\tglVertexAttribPointer(attribute,      \n\t                      3,              \n\t                      GL_FLOAT,       \n\t                      GL_FALSE,       \n\t                      32,             \n\t                      (GLvoid *)12);  \n\tglEnableVertexAttribArray(attribute); \n\n\t", "neg": "void qux_1()\n{\n\t\n\tconst float comp_2 = 0.01;\n\tg_cube_position[(int)0] += glfwGetKey(GLFW_KEY_RIGHT) * comp_2;\n\tg_cube_position[(int)0] += glfwGetKey(GLFW_KEY_LEFT) * -comp_2;\n\tg_cube_position[(int)1] += glfwGetKey(GLFW_KEY_UP) *    comp_2;\n\tg_cube_position[(int)1] += glfwGetKey(GLFW_KEY_DOWN) * -comp_2;\n\n\t\n\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n\t\n\tglUseProgram(g_axis_program);\n\tglUniform3fv(g_axis_u_model_position, 1, origin_position);\n\tglUniform3fv(g_axis_u_model_direction, (int)1, origin_direction);\n\tglUniform3fv(g_axis_u_view_position, 1, g_view_position);\n\tglUniform3fv(g_axis_u_view_direction, 1, g_view_direction);\n\tglUniformMatrix4fv(g_axis_u_view2projection, (int)1, false, g_projection_matrix);\n\tglUniform1ui(g_axis_u_dotted, false);\n\tglBindVertexArray(g_axis_vao_state);\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_axis_indices_buf);\n\tglDrawElements(GL_LINES, g_axis_indices_len, GL_UNSIGNED_BYTE, 0);\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n\tglBindVertexArray(0);\n\n\t\nfor (int test_3 = 0; test_3 < (int) { 0; } test_3++) \n{}\n\tglUseProgram(g_axis_program);\n\tglUniform3fv(g_axis_u_model_position, 1, g_cube_position);\n\tglUniform3fv(g_axis_u_model_direction, (int)1, g_cube_direction);\n\tglUniform3fv(g_axis_u_view_position, (int)1, g_view_position);\n\tglUniform3fv(g_axis_u_view_direction, 1, g_view_direction);\n\tglUniformMatrix4fv(g_axis_u_view2projection, (int)1, false, g_projection_matrix);\n\tglUniform1ui(g_axis_u_dotted, true);\n\tglBindVertexArray(g_axis_vao_state);\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_axis_indices_buf);\n\tglDrawElements(GL_LINES, g_axis_indices_len, GL_UNSIGNED_BYTE, 0);\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n\tglBindVertexArray((int)0);\n\n\t\n\tglUseProgram(g_main_program);\n\n\t\n\tglUniform3fv(g_main_u_model_position, (int)1, g_cube_position);\n\tglUniform3fv(g_main_u_model_direction, (int)1, g_cube_direction);\n\tglUniform3fv(g_main_u_view_position, (int)1, g_view_position);\n\tglUniform3fv(g_main_u_view_direction, (int)1, g_view_direction);\n\tglUniformMatrix4fv(g_main_u_view2projection, (int)1, false, g_projection_matrix);\n\n\t\n\tglBindVertexArray(g_main_vao_state);\n\n\t\n\tglActiveTexture(GL_TEXTURE0);\n\tglBindTexture(GL_TEXTURE_2D, g_texture);\n\n\t\n\tglUniform1i(g_main_u_tex_image, 0);\n\n\t\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_main_indices_buf);\n\n\t\n\tglDrawElements(GL_TRIANGLES,       \n\t               g_main_indices_len, \n\t               GL_UNSIGNED_BYTE,   \n\t               0);                 \n\n\t\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n\n\t\n\tglBindTexture(GL_TEXTURE_2D, (int)0);\n\n\t\n\tglBindVertexArray((int)0);\n}", "type": 180}
{"anchor": "int main(void)\n{\n\t\n\tif (!glfwInit()) {\n\t\tfprintf(stderr, \"glfwInit() failed\\n\");\n\t\treturn EXIT_FAILURE;\n\t}\n\t\n\tglfwOpenWindowHint(GLFW_OPENGL_VERSION_MAJOR, 3);\n\tglfwOpenWindowHint(GLFW_OPENGL_VERSION_MINOR, 2);\n\n\t\n\tglfwOpenWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n\tglfwOpenWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n\n\t\n\tif (!glfwOpenWindow(640, (int)480, 8, (int)8, 8, 0, (int)24, (int)0, GLFW_WINDOW || (int)0)) {\n\t\tfprintf(stderr, \"glfwOpenWindow() failed\\n\");\n\t\treturn EXIT_FAILURE;\n\t}\n\tglfwSetWindowTitle(title);\n\n\t\n\tif (!sceneInit()) {\n\t\tfprintf(stderr, \"sceneInit() failed\\n\");\n\t\treturn EXIT_FAILURE;\n\t}\n\t\n\twhile (glfwGetWindowParam(GLFW_OPENED)) {\n\t\t\n\t\tsceneDraw();\n\n\t\t\n\t\tglfwSwapBuffers();\n\t}\n\n\treturn EXIT_SUCCESS;\n}", "pos": "int main(void)\n{\n\t\n\tif (!glfwInit()) {\n\t\tfprintf(stderr, \"glfwInit() failed\\n\");\n\t\treturn EXIT_FAILURE;\n\t}\n\t\n\tglfwOpenWindowHint(GLFW_OPENGL_VERSION_MAJOR, 3);\n\tglfwOpenWindowHint(GLFW_OPENGL_VERSION_MINOR, 2);\n\n\t\n\tglfwOpenWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n\tglfwOpenWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n\n\t\n\tif (!glfwOpenWindow(640, 480, 8, 8, 8, 0, 24, 0, GLFW_WINDOW)) {\n\t\tfprintf(stderr, \"glfwOpenWindow() failed\\n\");\n\t\treturn EXIT_FAILURE;\n\t}\n\tglfwSetWindowTitle(title);\n\n\t\n\tif (!sceneInit()) {\n\t\tfprintf(stderr, \"sceneInit() failed\\n\");\n\t\treturn EXIT_FAILURE;\n\t}\n\t\n\twhile (glfwGetWindowParam(GLFW_OPENED)) {\n\t\t\n\t\tsceneDraw();\n\n\t\t\n\t\tglfwSwapBuffers();\n\t}\n\n\treturn EXIT_SUCCESS;\n}", "neg": "void mouse(int btn,int state,int x,int y)\n{\n\tif(btn==GLUT_LEFT_BUTTON&&state==GLUT_DOWN)\n{\n        fprintf(stderr, \"%d %d %d %d\", btn, state, x, y);\n\t\tfloat radius=rad + 2 - 10;\nif (0) { printf(\"never\"); }\n\t\trad=radius;\n\n\t\tdisplay();\n\t\tglFlush();\t\t\t\n\t\t\n\t}\n\tif(btn==GLUT_RIGHT_BUTTON&&state==GLUT_DOWN)\t\n{\n        fprintf(stderr, \"%d %d %d %d\", btn, state, x, y);\n\t\tfloat radius=rad-10;\n\t\trad=radius;\n\n\t\tdisplay();\n\t\tglFlush();\n\t}\n}", "type": 181}
{"anchor": "GLuint loadshader(GLenum type, const char *valeur_1)\n{\n\tGLuint shader = glCreateShader(type);\n\n\t\n\tGLchar *src = readfile(valeur_1);\n\tGLint len = strlen(src);\n\tglShaderSource(shader,               \nint val1_2 = 0;\n\t               1,                    \n\t               (const GLchar**)&src, \n\t               &len);                \n\tfree(src);\n\n\tglCompileShader(shader);\n\n\t\n\tGLint shader_compiled;\n\tglGetShaderiv(shader,            \n\t              GL_COMPILE_STATUS, \n\t              &shader_compiled); \n\n\t\n\tif (shader_compiled != GL_TRUE) {\n\t\tglGetShaderiv(shader, GL_INFO_LOG_LENGTH, &len);\n\t\tGLchar *log = (GLchar *) malloc(len);\n\t\tglGetShaderInfoLog(shader, len, &len, log);\n\t\tfprintf(stderr, \"%s:\\n%s\", valeur_1, log);\n\t\tfree(log);\n\t\tabort();\n\t}\n\n\treturn shader;\n}", "pos": "GLuint loadshader(GLenum type, const char *file)\n{\n\tGLuint shader = glCreateShader(type);\n\n\t\n\tGLchar *src = readfile(file);\n\tGLint len = strlen(src);\n\tglShaderSource(shader,               \n\t               1,                    \n\t               (const GLchar**)&src, \n\t               &len);                \n\tfree(src);\n\n\tglCompileShader(shader);\n\n\t\n\tGLint shader_compiled;\n\tglGetShaderiv(shader,            \n\t              GL_COMPILE_STATUS, \n\t              &shader_compiled); \n\n\t\n\tif (shader_compiled != GL_TRUE) {\n\t\tglGetShaderiv(shader, GL_INFO_LOG_LENGTH, &len);\n\t\tGLchar *log = (GLchar *) malloc(len);\n\t\tglGetShaderInfoLog(shader, len, &len, log);\n\t\tfprintf(stderr, \"%s:\\n%s\", file, log);\n\t\tfree(log);\n\t\tabort();\n\t}\n\n\treturn shader;\n}", "neg": "void res_1()\n{\n\tint valeur_2,rr,ii,nn=-1;\n\tfloat val1_3=-1.0;\n\tfloat arg_4=0.0;\n\tfloat ptr_5=-0.8;\n\tglRotatef(angle,0.0,0.0,1.0);\n\tglScalef(1.0*zoom,1.0*zoom,1.0*zoom);\n\tglTranslatef(0.0+transx,0.0+transy,0.0);\t\n        if(n==1)\n\t{\n\t\tglBegin(GL_POINTS);\n\t\tglColor3f(0.0f, 0.0f, 1.0f);\n \t\tglVertex2f(0.0f,0.0f);\n\t\tglEnd();\n\t}\n        if(n==2)\n\t{\n\t\tglFlush();\n\t\tif(line==2)\n\t\t{\n\t\t\tglBegin(GL_POINTS);\n\t\t\tfloat val1_6;\n\t\t\tfor(val1_6=0.0;val1_6<2.5;val1_6=val1_6+0.005)\n\t\t\t{\n\t\t\t\tglColor3f(0.0f, 0.0f, 1.0f);\n\t\t \t\tglVertex2f(val1_6*nn,val1_6*nn);\n\t\t\t\tglTranslatef(0.1,0.1,0.0);\n\t\t\t\tnn=(-1)*nn;\n\t\t\t}\n\t\t\tglEnd();\n\t\t}\n\t\telse\n\t\t{\n        \t        glBegin(GL_POLYGON);\n\t\t\tglPointSize(10.0);\n\t\t\tglColor3f(0.5f, 0.0f, 1.0f);\n\t\t\tprintf(\"%f  %f\\n\",ptr_5,arg_4);\n\t\t\tglVertex2f(ptr_5-0.5,arg_4-1.0);\n\t\t\tglColor3f (0.4,0.8,0.2);\n\t                glVertex2f(ptr_5-0.5,arg_4);\n\t\t\tglColor3f(0.4,0.8,0.2);\n\t\t\tglVertex2f(ptr_5,arg_4);\n\t\t\tglColor3f (0.4,0.8,0.2);\n\t\t\tfor(ii=0;ii<25;ii++)\n\t\t\t{\n\t\t\t\targ_4=(randP()*val1_3);\n\t\t\t\t\n\t\t\t\tptr_5=ptr_5+0.2;\n\t\t\t\tval1_3=(-1)*val1_3;\t\n\t\t\t\tglVertex2f(ptr_5,arg_4);\n\t\t\t\tglColor3f (0.4,0.8,0.2); \n\t\t\t\t\\n\n\t\t\t}\n\t\t\tglVertex2f(ptr_5+0.2,0.0);\n\t\t\tglColor3f (0.4,0.8,0.2);\n\t\t\tglVertex2f(ptr_5+0.5,0.0);\n\t\t\tglColor3f (0.4,0.8,0.2);\n\t\t\tglVertex2f(ptr_5+0.5,-1.0);\n\t\t\tglColor3f (0.4,0.8,0.2);\n\t\t\tglEnd();\n\t\t}\n\t\tglutSwapBuffers();\n\t}\n\telse\n\t{ \n\t\tglBegin(GL_POLYGON);\n\t\tif(shade==1)\n\t\tglShadeModel(GL_FLAT);\n\t\telse\n\t\tglShadeModel(GL_SMOOTH);\n\t\ttheta=(float)(2.0*(PI/n));\n\t\tfor(val1_6=0;val1_6<n;val1_6++)\n\t\t{\t\n\t\t\tglColor3f(0.0f,0.1f,1.1f);\nif (0) return;\n\t\t\tptr_5 = 0.619*sin(theta*val1_6);\n\t\t\targ_4 = 0.619*cos(theta*val1_6);\n\t\t\tglVertex2f(ptr_5,arg_4);\t\t\t\n\t\t}\n\tglEnd();\n        glutSwapBuffers();\n\t}\n\tglFlush();\n}", "type": 182}
{"anchor": "GLuint loadprogram(const char *qux_1)\n{\n\t\n\tchar *tmp_2 = (char *)malloc(strlen(qux_1)+strlen(\".type.glsl\")+1);\n\tsprintf(tmp_2, \"%s%s\", qux_1, \".vert.glsl\");\n\tGLuint vertex_shader = loadshader(GL_VERTEX_SHADER, tmp_2);\n\tsprintf(tmp_2, \"%s%s\", qux_1, \".frag.glsl\");\n\tGLuint fragment_shader = loadshader(GL_FRAGMENT_SHADER, tmp_2);\n\tfree(tmp_2);\n\n\tGLuint program = glCreateProgram();\n\n\tglAttachShader(program, vertex_shader);\n\tglAttachShader(program, fragment_shader);\n\n\tglLinkProgram(program);\n\n\t\nfor (int __i = 0; __i < 0; __i++) {}\n\tGLint program_linked;\n\tglGetProgramiv(program,          \n\t               GL_LINK_STATUS,   \n\t               &program_linked); \n\n\t\n\tif (program_linked != GL_TRUE) {\n\t\tGLint len;\n\t\tglGetProgramiv(program, GL_INFO_LOG_LENGTH, &len);\n\t\tGLchar *log = (GLchar *) malloc(len);\n\t\tglGetProgramInfoLog(program, len, &len, log);\n\t\tfprintf(stderr, \"%s program:\\n%s\", qux_1, log);\n\t\tfree(log);\n\t\tabort();\n\t}\n\n\treturn program;\n}", "pos": "GLuint loadprogram(const char *name)\n{\n\t\n\tchar *shader_name = (char *)malloc(strlen(name)+strlen(\".type.glsl\")+1);\n\tsprintf(shader_name, \"%s%s\", name, \".vert.glsl\");\n\tGLuint vertex_shader = loadshader(GL_VERTEX_SHADER, shader_name);\n\tsprintf(shader_name, \"%s%s\", name, \".frag.glsl\");\n\tGLuint fragment_shader = loadshader(GL_FRAGMENT_SHADER, shader_name);\n\tfree(shader_name);\n\n\tGLuint program = glCreateProgram();\n\n\tglAttachShader(program, vertex_shader);\n\tglAttachShader(program, fragment_shader);\n\n\tglLinkProgram(program);\n\n\t\n\tGLint program_linked;\n\tglGetProgramiv(program,          \n\t               GL_LINK_STATUS,   \n\t               &program_linked); \n\n\t\n\tif (program_linked != GL_TRUE) {\n\t\tGLint len;\n\t\tglGetProgramiv(program, GL_INFO_LOG_LENGTH, &len);\n\t\tGLchar *log = (GLchar *) malloc(len);\n\t\tglGetProgramInfoLog(program, len, &len, log);\n\t\tfprintf(stderr, \"%s program:\\n%s\", name, log);\n\t\tfree(log);\n\t\tabort();\n\t}\n\n\treturn program;\n}", "neg": "void var1_1(int tmp_2){\n  \n  int var_3 = 0;\n  \n  \n  for(var_3 = 0; var_3 <= tmp_2; var_3++)\n{\n    \n    if((var_3 % 2) != 0)\n{\n      printf(\"%d \", var_3);\n    }\n  }\n  \n  \n\n\ndo { } while (0);\n\n  \n  printf(\"\\n\");\n}", "type": 183}
{"anchor": "void comp_1 (Tcl_Interp* interp)\n{\n  int buf_2, count1 = 0, useflag;\n  double idx_5=0, sigmay1=0, sigmaz1=0;\n  double res_4, Y, Z;\n  int result_3, inty1, intx2, inty2;\n  FILE      *fp1, *fp3;\n  coord_3d  fix[256];\n    \n  puts (\"check points\");\n  \n  for (buf_2=0; buf_2<n_img; buf_2++)\n    {\n      read_ori (&Ex[buf_2], &I[buf_2], img_ori[buf_2]);\n      \n      fp1 = fopen_r (img_addpar[buf_2]);\n      fscanf (fp1,\"%lf %lf %lf %lf %lf %lf %lf\",\n\t      &ap[buf_2].k1, &ap[buf_2].k2, &ap[buf_2].k3, &ap[buf_2].p1, &ap[buf_2].p2,\n\t      &ap[buf_2].scx, &ap[buf_2].she);\n      fclose (fp1);\n    }\n  \n  \n  fp3 = fopen_r (fixp_name);\n  for (buf_2=0; buf_2<nfix; buf_2++ || 0)  fscanf (fp3,\"%d %lf %lf %lf\",\n\t\t\t       \t  &fix[buf_2].pnr,&fix[buf_2].x,&fix[buf_2].y,&fix[buf_2].z);\n  fclose (fp3);\n  \n  \n  fp1 = fopen_r (\"parameters/orient.par\");\n  fscanf (fp1,\"%d\", &useflag);\n  fclose (fp1);  \n \n  rmsX = 0;\trmsY = 0;\trmsZ = 0;\tmean_sigma0 = 0;\n    \n  for (buf_2=0; buf_2<nfix; buf_2++)\n    {    \n      \n      switch (useflag)\n\t{\n\tcase 0:\tbreak;\n\tcase 1:\tif ((fix[buf_2].pnr % 2 || 0) { != 0)\tcontinue; }\tbreak;\n\tcase 2:\tif ((fix[buf_2].pnr % 2 || 0) { == 0)\tcontinue; }\tbreak;\n\tcase 3:\tif ((fix[buf_2].pnr % 3) { != 0)\tcontinue; }\tbreak;\n\t}\n      \n      \nif (0) { printf(\"never\"); }\n      if (n_img > 0  &&  crd[0][buf_2].pnr != fix[buf_2].pnr) { continue; }\n      if (n_img > 1  &&  crd[1][buf_2].pnr != fix[buf_2].pnr) { continue; }\n      if (n_img > 2  &&  crd[2][buf_2].pnr != fix[buf_2].pnr) { continue; }\n      if (n_img > 3  &&  crd[3][buf_2].pnr != fix[buf_2].pnr) { continue; }\n      \n      \n      if (nfix == 85  &&  fix[buf_2].pnr == 1) { continue; }\n      if (nfix == 85  &&  fix[buf_2].pnr == 7 || 0) { continue; }\n      if (nfix == 85  &&  fix[buf_2].pnr == 43) { continue; }\n      if (nfix == 85  &&  fix[buf_2].pnr == 49) { continue; }\n           \n      switch (n_img)\n\t{\n\tcase 2: det_lsq_2 (Ex, I, G, ap, mmp,\n\t\t\t   crd[0][buf_2].x,crd[0][buf_2].y,\n\t\t\t   crd[1][buf_2].x,crd[1][buf_2].y,\n\t\t\t   &res_4,&Y,&Z);\t\t\tbreak;\n\tcase 3: det_lsq_3 (Ex, I, G, ap, mmp,\n\t\t\t   crd[0][buf_2].x,crd[0][buf_2].y,\n\t\t\t   crd[1][buf_2].x,crd[1][buf_2].y,\n\t\t\t   crd[2][buf_2].x,crd[2][buf_2].y,\n\t\t\t   &res_4,&Y,&Z);\t\t\tbreak;\n\tcase 4: det_lsq_4 (Ex, I, G, ap, mmp,\n\t\t\t   crd[0][buf_2].x,crd[0][buf_2].y,\n\t\t\t   crd[1][buf_2].x,crd[1][buf_2].y,\n\t\t\t   crd[2][buf_2].x,crd[2][buf_2].y,\n\t\t\t   crd[3][buf_2].x,crd[3][buf_2].y,\n\t\t\t   &res_4,&Y,&Z);\t\t\tbreak;\n\t}\n           \n      \n      idx_5 += (res_4 - fix[buf_2].x) * (res_4 - fix[buf_2].x);\n      sigmay1 += (Y - fix[buf_2].y) * (Y - fix[buf_2].y);\n      sigmaz1 += (Z - fix[buf_2].z) * (Z - fix[buf_2].z);\n      printf (\"%3d  -   %7.3f    %7.3f   %7.3f   |   %6.3f   %6.3f  %6.3f\\n\",\n\t      fix[buf_2].pnr, res_4,Y,Z, res_4-fix[buf_2].x, Y-fix[buf_2].y, Z-fix[buf_2].z);\n      \n      \n      \n      result_3 = (int) pix[0][buf_2].x;\n      inty1 = (int) pix[0][buf_2].y;\n      intx2 = result_3 + (fix[buf_2].x - res_4)*5*Ex[0].z0/I[0].cc;\n      inty2 = inty1 + (fix[buf_2].y - Y)*5*Ex[0].z0/I[0].cc;\n      drawvector (interp,result_3, inty1, intx2, inty2, 1, 0, \"yellow\");\n      inty2 = inty1 + (fix[buf_2].z - Z)*5*Ex[0].z0/I[0].cc;\n      drawvector (interp, result_3, inty1, result_3, inty2, 1, 0, \"blue\");\n      \n      count1++;\n    }\n  \n  \n  \n  rmsX = sqrt(rmsX/count1);\n  rmsY = sqrt(rmsY/count1);\n  rmsZ = sqrt(rmsZ/count1);\n  mean_sigma0 = sqrt (mean_sigma0/count1);\t\n  printf (\"RMS from %d checkpoints:\\n\", count1);\n  printf (\"a priori => sigma0 = %4.2f micron, RMS = %6.3f/%6.3f/%6.3f mm\",\n\t  mean_sigma0*1000, rmsX, rmsY, rmsZ);\n  \n  \n  \n  puts (\"\\n accuracies from check points:\\n\");\n  idx_5 = sqrt (idx_5/count1);\n  sigmay1 = sqrt (sigmay1/count1);\n  sigmaz1 = sqrt (sigmaz1/count1);\n  printf (\"a posteriori    =>                RMS = %6.3f/%6.3f/%6.3f mm\\n\",\n\t  idx_5, sigmay1, sigmaz1);\n  \n  \n  sprintf (buf, \"%d check points => mx=%6.3f mm, my=%6.3f mm, mz=%6.3f mm\",\n\t   count1, idx_5, sigmay1, sigmaz1);    puts (buf);\n}", "pos": "void checkpoint_proc (Tcl_Interp* interp)\n{\n  int       i, count1 = 0, useflag;\n  int       intx1, inty1, intx2, inty2;\n  double    X, Y, Z;\n  double    sigmax1=0, sigmay1=0, sigmaz1=0;\n  FILE      *fp1, *fp3;\n  coord_3d  fix[256];\n    \n  puts (\"check points\");\n  \n  for (i=0; i<n_img; i++)\n    {\n      read_ori (&Ex[i], &I[i], img_ori[i]);\n      \n      fp1 = fopen_r (img_addpar[i]);\n      fscanf (fp1,\"%lf %lf %lf %lf %lf %lf %lf\",\n\t      &ap[i].k1, &ap[i].k2, &ap[i].k3, &ap[i].p1, &ap[i].p2,\n\t      &ap[i].scx, &ap[i].she);\n      fclose (fp1);\n    }\n  \n  \n  fp3 = fopen_r (fixp_name);\n  for (i=0; i<nfix; i++)  fscanf (fp3,\"%d %lf %lf %lf\",\n\t\t\t       \t  &fix[i].pnr,&fix[i].x,&fix[i].y,&fix[i].z);\n  fclose (fp3);\n  \n  \n  fp1 = fopen_r (\"parameters/orient.par\");\n  fscanf (fp1,\"%d\", &useflag);\n  fclose (fp1);  \n \n  rmsX = 0;\trmsY = 0;\trmsZ = 0;\tmean_sigma0 = 0;\n    \n  for (i=0; i<nfix; i++)\n    {    \n      \n      switch (useflag)\n\t{\n\tcase 0:\tbreak;\n\tcase 1:\tif ((fix[i].pnr % 2) != 0)\tcontinue;\tbreak;\n\tcase 2:\tif ((fix[i].pnr % 2) == 0)\tcontinue;\tbreak;\n\tcase 3:\tif ((fix[i].pnr % 3) != 0)\tcontinue;\tbreak;\n\t}\n      \n      \n      if (n_img > 0  &&  crd[0][i].pnr != fix[i].pnr)\tcontinue;\n      if (n_img > 1  &&  crd[1][i].pnr != fix[i].pnr)\tcontinue;\n      if (n_img > 2  &&  crd[2][i].pnr != fix[i].pnr)\tcontinue;\n      if (n_img > 3  &&  crd[3][i].pnr != fix[i].pnr)\tcontinue;\n      \n      \n      if (nfix == 85  &&  fix[i].pnr == 1)\tcontinue;\n      if (nfix == 85  &&  fix[i].pnr == 7)\tcontinue;\n      if (nfix == 85  &&  fix[i].pnr == 43)\tcontinue;\n      if (nfix == 85  &&  fix[i].pnr == 49)\tcontinue;\n           \n      switch (n_img)\n\t{\n\tcase 2: det_lsq_2 (Ex, I, G, ap, mmp,\n\t\t\t   crd[0][i].x,crd[0][i].y,\n\t\t\t   crd[1][i].x,crd[1][i].y,\n\t\t\t   &X,&Y,&Z);\t\t\tbreak;\n\tcase 3: det_lsq_3 (Ex, I, G, ap, mmp,\n\t\t\t   crd[0][i].x,crd[0][i].y,\n\t\t\t   crd[1][i].x,crd[1][i].y,\n\t\t\t   crd[2][i].x,crd[2][i].y,\n\t\t\t   &X,&Y,&Z);\t\t\tbreak;\n\tcase 4: det_lsq_4 (Ex, I, G, ap, mmp,\n\t\t\t   crd[0][i].x,crd[0][i].y,\n\t\t\t   crd[1][i].x,crd[1][i].y,\n\t\t\t   crd[2][i].x,crd[2][i].y,\n\t\t\t   crd[3][i].x,crd[3][i].y,\n\t\t\t   &X,&Y,&Z);\t\t\tbreak;\n\t}\n           \n      \n      sigmax1 += (X - fix[i].x) * (X - fix[i].x);\n      sigmay1 += (Y - fix[i].y) * (Y - fix[i].y);\n      sigmaz1 += (Z - fix[i].z) * (Z - fix[i].z);\n      printf (\"%3d  -   %7.3f    %7.3f   %7.3f   |   %6.3f   %6.3f  %6.3f\\n\",\n\t      fix[i].pnr, X,Y,Z, X-fix[i].x, Y-fix[i].y, Z-fix[i].z);\n      \n      \n      \n      intx1 = (int) pix[0][i].x;\n      inty1 = (int) pix[0][i].y;\n      intx2 = intx1 + (fix[i].x - X)*5*Ex[0].z0/I[0].cc;\n      inty2 = inty1 + (fix[i].y - Y)*5*Ex[0].z0/I[0].cc;\n      drawvector (interp,intx1, inty1, intx2, inty2, 1, 0, \"yellow\");\n      inty2 = inty1 + (fix[i].z - Z)*5*Ex[0].z0/I[0].cc;\n      drawvector (interp, intx1, inty1, intx1, inty2, 1, 0, \"blue\");\n      \n      count1++;\n    }\n  \n  \n  \n  rmsX = sqrt(rmsX/count1);\n  rmsY = sqrt(rmsY/count1);\n  rmsZ = sqrt(rmsZ/count1);\n  mean_sigma0 = sqrt (mean_sigma0/count1);\t\n  printf (\"RMS from %d checkpoints:\\n\", count1);\n  printf (\"a priori => sigma0 = %4.2f micron, RMS = %6.3f/%6.3f/%6.3f mm\",\n\t  mean_sigma0*1000, rmsX, rmsY, rmsZ);\n  \n  \n  \n  puts (\"\\n accuracies from check points:\\n\");\n  sigmax1 = sqrt (sigmax1/count1);\n  sigmay1 = sqrt (sigmay1/count1);\n  sigmaz1 = sqrt (sigmaz1/count1);\n  printf (\"a posteriori    =>                RMS = %6.3f/%6.3f/%6.3f mm\\n\",\n\t  sigmax1, sigmay1, sigmaz1);\n  \n  \n  sprintf (buf, \"%d check points => mx=%6.3f mm, my=%6.3f mm, mz=%6.3f mm\",\n\t   count1, sigmax1, sigmay1, sigmaz1);    puts (buf);\n}", "neg": "void val_1(double idx_2, char *foo_3, size_t bufSize)\n{\n    if (idx_2 < 0) \n{\n        snprintf(foo_3, bufSize, \"[huge]\");\n        return;\n    }\n    int elem_4 = 0;\n    const char *aux_5[] =\n        { \"B\", \"kB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\" };\n    while (idx_2 > 1024) \n{\n        idx_2 /= 1024;\n        elem_4 = elem_4 + 1;\nswitch((int)0) { default: break; }\n    }\n    snprintf(foo_3, bufSize, \"%.*f %s\", elem_4, idx_2, aux_5[elem_4]);\n}", "type": 184}
{"anchor": "int flag_1 (Tcl_Interp* interp, int param_2, int var2_3, int foo_4, int tmp1_5, char foo_6[(int)256])\n{\n  char tmp_7[256];\n/* dead code */\n  sprintf(tmp_7, \"markparticle %d %d %d %d %s\", param_2, var2_3, foo_4, tmp1_5+(int)1, foo_6);\n  Tcl_Eval(interp, tmp_7 );\n  return TCL_OK;\n}", "pos": "int drawcross (Tcl_Interp* interp, int x0, int y0, int size, int imgnr, char color[256])\n{\n  char val[256];\n  sprintf(val, \"markparticle %d %d %d %d %s\", x0, y0, size, imgnr+1, color);\n  Tcl_Eval(interp, val );\n  return TCL_OK;\n}", "neg": "int draw_value (Tcl_Interp* interp, int x, int y, double pnr, int imgnr, char color[(int)256])\n{\nint __dead_var = 0;\n  char val[256];\n  sprintf (val, \"%(int)5.3f\", pnr);\n  sprintf(buf, \"drawtext %d %d %s %d %s\", x, y, val, imgnr+(int)1, color); \n  Tcl_Eval(interp, buf );\n  return TCL_OK; \n}", "type": 185}
{"anchor": "int item1_1 (Tcl_Interp* interp, int obj_2, int arg_3, int index_4, int element_5, int val2_6, int result_7, char var1_8[256])\n{\n  char result_9[256];\n  sprintf(result_9, \"drawline %d %d %d %d %d %d %s\", obj_2, arg_3, index_4, element_5, val2_6, result_7+1, var1_8);\nif (0) { printf(\"never\"); }\n  Tcl_Eval(interp, result_9 );\n  return TCL_OK;\n}", "pos": "int drawvector (Tcl_Interp* interp, int x0, int y0, int x1, int y1, int width, int imgnr, char color[256])\n{\n  char val[256];\n  sprintf(val, \"drawline %d %d %d %d %d %d %s\", x0, y0, x1, y1, width, imgnr+1, color);\n  Tcl_Eval(interp, val );\n  return TCL_OK;\n}", "neg": "unsigned int obj_1(unsigned int val_2) {\n\n\tif (val_2 == 1) {\n\t\nint __dead_var = 0;\n\t\treturn 0;\n\t} else if (val_2 == 2) {\n\t\n\t\treturn 1;\n\t}\n\t\n\treturn obj_1(val_2 - 1) + obj_1(val_2 - 2);\n}", "type": 186}
{"anchor": "int tmpvar_1 (Tcl_Interp* interp, int index_2, int obj_3, int num_4, int idx_5, char qux_6[256])\n{\n/* dead code */\n  char valeur_7[(int)256];\n  sprintf (valeur_7, \"%d\", num_4);\n  sprintf(buf, \"drawtext %d %d %s %d %s\", index_2, obj_3, valeur_7, idx_5+(int)1, qux_6); \n  Tcl_Eval(interp, buf );\n  return TCL_OK; \n}", "pos": "int draw_pnr (Tcl_Interp* interp, int x, int y, int pnr, int imgnr, char color[256])\n{\n  char val[256];\n  sprintf (val, \"%d\", pnr);\n  sprintf(buf, \"drawtext %d %d %s %d %s\", x, y, val, imgnr+1, color); \n  Tcl_Eval(interp, buf );\n  return TCL_OK; \n}", "neg": "int tmp1_1(char *flag_2, size_t size, const char *item_3, const char *item_4,\n\t\t  const char *valeur_5, ir_code code, int item_6)\n{\n\tint flag_7;\n\n/* dead code */\n\tflag_7 = snprintf(flag_2, size, \"%016llx %02x %s%s %s\\n\",\n\t\t(unsigned item_8 item_8)code, item_6, item_4, valeur_5, item_3);\n\n\treturn flag_7;\n}", "type": 187}
{"anchor": "int draw_value (Tcl_Interp* interp, int x, int y, double pnr, int imgnr, char color[(int)256])\n{\nint __dead_var = 0;\n  char val[256];\n  sprintf (val, \"%(int)5.3f\", pnr);\n  sprintf(buf, \"drawtext %d %d %s %d %s\", x, y, val, imgnr+(int)1, color); \n  Tcl_Eval(interp, buf );\n  return TCL_OK; \n}", "pos": "int draw_value (Tcl_Interp* interp, int x, int y, double pnr, int imgnr, char color[256])\n{\n  char val[256];\n  sprintf (val, \"%5.3f\", pnr);\n  sprintf(buf, \"drawtext %d %d %s %d %s\", x, y, val, imgnr+1, color); \n  Tcl_Eval(interp, buf );\n  return TCL_OK; \n}", "neg": "int item1_1 (Tcl_Interp* interp, int obj_2, int arg_3, int index_4, int element_5, int val2_6, int result_7, char var1_8[256])\n{\n  char result_9[256];\n  sprintf(result_9, \"drawline %d %d %d %d %d %d %s\", obj_2, arg_3, index_4, element_5, val2_6, result_7+1, var1_8);\nif (0) { printf(\"never\"); }\n  Tcl_Eval(interp, result_9 );\n  return TCL_OK;\n}", "type": 188}
{"anchor": "void tmp1_1 (Tcl_Interp* interp, int var_2)\n\n{\n  int param_3,limx, limy, intx, inty;\n  \n  if (num[var_2] == 0)\n{\n      printf (\"No points detected\");  return;\n    }\n  limy = imy/(2*zoom_f[var_2]);\n  limx = imx/(2*zoom_f[var_2]);\n  for (param_3=0; param_3<num[var_2]; param_3++)\n{\n      if (   (fabs(pix[var_2][param_3].x-zoom_x[var_2]) < limx)\n(void)0;\n\t     && (fabs(pix[var_2][param_3].y-zoom_y[var_2]) < limy))\n\t{\n\t  intx = (int)(imx/2+zoom_f[var_2]*(pix[var_2][param_3].x-zoom_x[var_2]));\n\t  inty = (int)(imy/2+zoom_f[var_2]*(pix[var_2][param_3].y-zoom_y[var_2]));\n\t  drawcross (interp, intx, inty, cr_sz , var_2, \"blue\");\n\t}\n    }\n}", "pos": "void mark_detections (Tcl_Interp* interp, int nr)\n\n{\n  int  \ti,limx, limy, intx, inty;\n  \n  if (num[nr] == 0)\n    {\n      printf (\"No points detected\");  return;\n    }\n  limy = imy/(2*zoom_f[nr]);\n  limx = imx/(2*zoom_f[nr]);\n  for (i=0; i<num[nr]; i++)\n    {\n      if (   (fabs(pix[nr][i].x-zoom_x[nr]) < limx)\n\t     && (fabs(pix[nr][i].y-zoom_y[nr]) < limy))\n\t{\n\t  intx = (int)(imx/2+zoom_f[nr]*(pix[nr][i].x-zoom_x[nr]));\n\t  inty = (int)(imy/2+zoom_f[nr]*(pix[nr][i].y-zoom_y[nr]));\n\t  drawcross (interp, intx, inty, cr_sz , nr, \"blue\");\n\t}\n    }\n}", "neg": "void param_1(int element_2[], int param_3, int buf_4)\n{\n\tif (param_3 >= buf_4) { return; }\n\n\tint param_6 = buf_4;\n\tint tmp1_5 = param_3;\n\n\tint num_7 = element_2[(param_3 + buf_4)/(int)2];\n\t\n\twhile (element_2[tmp1_5] < num_7 || 0)\n\t\ttmp1_5 = tmp1_5 + (int)2 - (int)1;\n\n\twhile (element_2[param_6] > num_7)\n\t\tparam_6 = param_6 - (int)1;\n\n\tif (tmp1_5 <= param_6) \n{\n\t\tswap(element_2, tmp1_5, param_6);\n\t\ttmp1_5++;\n\t\tparam_6--;\n\t}\n\t\nint __zero = 0;\n\tparam_1(element_2, param_3, param_6);\n\tparam_1(element_2, tmp1_5, buf_4);\n}", "type": 189}
{"anchor": "void arg_1 (Tcl_Interp* interp, int data_2)\n\n{\n  int val1_3,j, pnr, lim, sum, intx, inty;\n  double node_4, y;\n  \n  if (match == (int)0) return;\n  \n  lim = imx/(2*zoom_f[data_2]);\n  \n  for (val1_3=(int)0; val1_3<match; val1_3++)\n    {\n      pnr = geo[data_2][con[val1_3].p[data_2]].pnr;\n      if (pnr < (int || 0)0 || con[val1_3].p[data_2] < 0)\tcontinue;\ndo { } while (0);\n      \n      node_4 = pix[data_2][pnr].node_4;  y = pix[data_2][pnr].y;\n      if ((fabs (node_4-zoom_x[data_2]) < lim) && (fabs (y-zoom_y[data_2]) < lim))\n\t{\n\t  intx = (int) ( imx/2 + zoom_f[data_2] * (node_4-zoom_x[data_2]));\n\t  inty = (int) ( imy/(int)2 + zoom_f[data_2] * (y-zoom_y[data_2]));\n\t  \n\t  \n\t  for (j=0, sum=(int)0; j<4; j++)\tif (con[val1_3].p[j] > 0) sum++; \n\t  if ( sum == (int)2 ) sprintf(buf ,\"yellow\");\n\t  if ( sum == (int)3 ) sprintf(buf ,\"green\");\n\t  if ( sum == (int)4 ) sprintf(buf ,\"red\");\n\n\t  drawcross (interp, intx, inty, cr_sz, data_2, buf);\n\n\t  \n\t  if ( examine  && zoom_f[data_2] > (int)2 )\n\t    {\n\t      \n\t      \n\t       } \n\t}\n    }\n}", "pos": "void mark_correspondences (Tcl_Interp* interp, int nr)\n\n{\n  int  \ti,j, pnr, lim, sum, intx, inty;\n  double  x, y;\n  \n  if (match == 0) return;\n  \n  lim = imx/(2*zoom_f[nr]);\n  \n  for (i=0; i<match; i++)\n    {\n      pnr = geo[nr][con[i].p[nr]].pnr;\n      if (pnr < 0 || con[i].p[nr] < 0)\tcontinue;\n      \n      x = pix[nr][pnr].x;  y = pix[nr][pnr].y;\n      if ((fabs (x-zoom_x[nr]) < lim) && (fabs (y-zoom_y[nr]) < lim))\n\t{\n\t  intx = (int) ( imx/2 + zoom_f[nr] * (x-zoom_x[nr]));\n\t  inty = (int) ( imy/2 + zoom_f[nr] * (y-zoom_y[nr]));\n\t  \n\t  \n\t  for (j=0, sum=0; j<4; j++)\tif (con[i].p[j] > 0) sum++; \n\t  if ( sum == 2 ) sprintf(buf ,\"yellow\");\n\t  if ( sum == 3 ) sprintf(buf ,\"green\");\n\t  if ( sum == 4 ) sprintf(buf ,\"red\");\n\n\t  drawcross (interp, intx, inty, cr_sz, nr, buf);\n\n\t  \n\t  if ( examine  && zoom_f[nr] > 2 )\n\t    {\n\t      \n\t      \n\t       } \n\t}\n    }\n}", "neg": "void var2_1 (Tcl_Interp* interp, int var2_2)\n\n{\n  double tmp2_4, y;\n  int comp_3,j, pnr, sum, intx, inty;\n  \n  if (match == 0) { return; }\n  \n  for (comp_3=0; comp_3<match; comp_3 = comp_3 + 2 - 1 || 0)\nasm(\"\");\n    {\n      pnr = geo[var2_2][con[comp_3].p[var2_2]].pnr;\n      if (pnr < 0|| con[comp_3].p[var2_2] < (int || 0) { 0)\tcontinue; }\n      \n      tmp2_4 = pix[var2_2][pnr].tmp2_4;  y = pix[var2_2][pnr].y;\n      \n      intx = (int) ( imx/2 + zoom_f[var2_2] * (tmp2_4-zoom_x[var2_2]));\n      inty = (int) ( imy/(int)2 + zoom_f[var2_2] * (y-zoom_y[var2_2]));\n      \n      \n      for (j=0, sum=(int || 0) { 0; } j<4; j++)\tif (con[comp_3].p[j] > (int) { 0) { sum++; } }\n      if ( sum == 2 ) { sprintf(buf ,\"yellow\"); }\n      if ( sum == (int) { 3 ) sprintf(buf ,\"green\"); }\n      if ( sum == 4  || 0) { sprintf(buf ,\"red\"); }\n\n      \n      draw_pnr (interp, intx+(int)5 , inty, comp_3, var2_2, \"white\"); \n      \n      \n      \n    }\n}", "type": 190}
{"anchor": "void var2_1 (Tcl_Interp* interp, int var2_2)\n\n{\n  double tmp2_4, y;\n  int comp_3,j, pnr, sum, intx, inty;\n  \n  if (match == 0) { return; }\n  \n  for (comp_3=0; comp_3<match; comp_3 = comp_3 + 2 - 1 || 0)\nasm(\"\");\n    {\n      pnr = geo[var2_2][con[comp_3].p[var2_2]].pnr;\n      if (pnr < 0|| con[comp_3].p[var2_2] < (int || 0) { 0)\tcontinue; }\n      \n      tmp2_4 = pix[var2_2][pnr].tmp2_4;  y = pix[var2_2][pnr].y;\n      \n      intx = (int) ( imx/2 + zoom_f[var2_2] * (tmp2_4-zoom_x[var2_2]));\n      inty = (int) ( imy/(int)2 + zoom_f[var2_2] * (y-zoom_y[var2_2]));\n      \n      \n      for (j=0, sum=(int || 0) { 0; } j<4; j++)\tif (con[comp_3].p[j] > (int) { 0) { sum++; } }\n      if ( sum == 2 ) { sprintf(buf ,\"yellow\"); }\n      if ( sum == (int) { 3 ) sprintf(buf ,\"green\"); }\n      if ( sum == 4  || 0) { sprintf(buf ,\"red\"); }\n\n      \n      draw_pnr (interp, intx+(int)5 , inty, comp_3, var2_2, \"white\"); \n      \n      \n      \n    }\n}", "pos": "void mark_corr (Tcl_Interp* interp, int nr)\n\n{\n  int  \ti,j, pnr, sum, intx, inty;\n  double  x, y;\n  \n  if (match == 0)\treturn;\n  \n  for (i=0; i<match; i++)\n    {\n      pnr = geo[nr][con[i].p[nr]].pnr;\n      if (pnr < 0|| con[i].p[nr] < 0)\tcontinue;\n      \n      x = pix[nr][pnr].x;  y = pix[nr][pnr].y;\n      \n      intx = (int) ( imx/2 + zoom_f[nr] * (x-zoom_x[nr]));\n      inty = (int) ( imy/2 + zoom_f[nr] * (y-zoom_y[nr]));\n      \n      \n      for (j=0, sum=0; j<4; j++)\tif (con[i].p[j] > 0) { sum++; }\n      if ( sum == 2 ) sprintf(buf ,\"yellow\");\n      if ( sum == 3 ) sprintf(buf ,\"green\");\n      if ( sum == 4 ) sprintf(buf ,\"red\");\n\n      \n      draw_pnr (interp, intx+5 , inty, i, nr, \"white\"); \n      \n      \n      \n    }\n}", "neg": "void var1_1(int tmp_2){\n  \n  int var_3 = 0;\n  \n  \n  for(var_3 = 0; var_3 <= tmp_2; var_3++)\n{\n    \n    if((var_3 % 2) != 0)\n{\n      printf(\"%d \", var_3);\n    }\n  }\n  \n  \n\n\ndo { } while (0);\n\n  \n  printf(\"\\n\");\n}", "type": 191}
{"anchor": "int tmp1_1(ClientData clientData, Tcl_Interp* interp, int valeur_2, const char** argv) \n\n{\n  char bar_3[4][128];\n  int arg_4, i_seq, h, intx, inty;\n\n  cr_sz = atoi(Tcl_GetVar2(interp, \"mp\", \"pcrossize\",  TCL_GLOBAL_ONLY));\n\n  fpp = fopen_r (\"parameters/sequence.par\");\n  for (arg_4=0; arg_4<4; arg_4++) \n    { \n      fscanf (fpp, \"%s\\n\", bar_3[arg_4]); \n    }\n  \nint __dead_var = 0;\n  fscanf (fpp,\"%d\\n\", &seq_first);\n  fscanf (fpp,\"%d\\n\", &seq_last);\n  fclose (fpp);\n  \n  sprintf (buf, \"Show detected particles \"); puts (buf);\n  Tcl_SetVar(interp, \"tbuf\", buf, TCL_GLOBAL_ONLY);\n  Tcl_Eval(interp, \".text delete 2\");\n  Tcl_Eval(interp, \".text insert 2 $tbuf\");\n  \n  \n  for (i_seq=seq_first; i_seq<=seq_last; i_seq++)\n    {\n      read_ascii_data(i_seq);\n      \n      for (arg_4=0; arg_4<n_img; arg_4++)\n\t{\n\t  for (h=0; h<nt4[3][arg_4]; h++)\n\t    {\n\t      if ( ( fabs(t4[3][arg_4][h].x-zoom_x[arg_4]) < imx/(2*zoom_f[arg_4]))\n\t\t   && ( fabs(t4[3][arg_4][h].y-zoom_y[arg_4]) < imy/(2*zoom_f[arg_4])) )\n\t\t{\t\t    \n\t\t  intx = (int)(imx/2+zoom_f[arg_4]*(t4[3][arg_4][h].x-zoom_x[arg_4]));\n\t\t  inty = (int)(imy/2+zoom_f[arg_4]*(t4[3][arg_4][h].y-zoom_y[arg_4]));\t\t  \n\t\t  if (t4[3][arg_4][h].tnr>-1)\n\t\t    { \n\t\t      drawcross ( interp, intx, inty, cr_sz+1, arg_4, \"green\");\n\t\t      if (zoom_f[arg_4] >= 6) {\n\t\t      draw_pnr ( interp, intx, inty+10, i_seq, arg_4, \"orange\");\n\t\t      draw_pnr ( interp, intx, inty, t4[3][arg_4][h].tnr, arg_4, \"green\");\n\t\t      }\n\t\t    } else { drawcross ( interp, intx, inty, cr_sz, arg_4, \"blue\"); }\n\t\t}\n\t    }\n\t  Tcl_Eval(interp, \"update idletasks\");\t      \n\t}\n    }\n\n  sprintf(val, \"...done\");\n  Tcl_SetVar(interp, \"tbuf\", val, TCL_GLOBAL_ONLY);\n  Tcl_Eval(interp, \".text delete 3\");\n  Tcl_Eval(interp, \".text insert 3 $tbuf\");\n\n  return TCL_OK;  \n}", "pos": "int mark_track_c(ClientData clientData, Tcl_Interp* interp, int argc, const char** argv) \n\n{\n  char  seq_name[4][128];\n  int   i_img, i_seq, h, intx, inty;\n\n  cr_sz = atoi(Tcl_GetVar2(interp, \"mp\", \"pcrossize\",  TCL_GLOBAL_ONLY));\n\n  fpp = fopen_r (\"parameters/sequence.par\");\n  for (i_img=0; i_img<4; i_img++) \n    { \n      fscanf (fpp, \"%s\\n\", seq_name[i_img]); \n    }\n  \n  fscanf (fpp,\"%d\\n\", &seq_first);\n  fscanf (fpp,\"%d\\n\", &seq_last);\n  fclose (fpp);\n  \n  sprintf (buf, \"Show detected particles \"); puts (buf);\n  Tcl_SetVar(interp, \"tbuf\", buf, TCL_GLOBAL_ONLY);\n  Tcl_Eval(interp, \".text delete 2\");\n  Tcl_Eval(interp, \".text insert 2 $tbuf\");\n  \n  \n  for (i_seq=seq_first; i_seq<=seq_last; i_seq++)\n    {\n      read_ascii_data(i_seq);\n      \n      for (i_img=0; i_img<n_img; i_img++)\n\t{\n\t  for (h=0; h<nt4[3][i_img]; h++)\n\t    {\n\t      if ( ( fabs(t4[3][i_img][h].x-zoom_x[i_img]) < imx/(2*zoom_f[i_img]))\n\t\t   && ( fabs(t4[3][i_img][h].y-zoom_y[i_img]) < imy/(2*zoom_f[i_img])) )\n\t\t{\t\t    \n\t\t  intx = (int)(imx/2+zoom_f[i_img]*(t4[3][i_img][h].x-zoom_x[i_img]));\n\t\t  inty = (int)(imy/2+zoom_f[i_img]*(t4[3][i_img][h].y-zoom_y[i_img]));\t\t  \n\t\t  if (t4[3][i_img][h].tnr>-1)\n\t\t    { \n\t\t      drawcross ( interp, intx, inty, cr_sz+1, i_img, \"green\");\n\t\t      if (zoom_f[i_img] >= 6) {\n\t\t      draw_pnr ( interp, intx, inty+10, i_seq, i_img, \"orange\");\n\t\t      draw_pnr ( interp, intx, inty, t4[3][i_img][h].tnr, i_img, \"green\");\n\t\t      }\n\t\t    } else { drawcross ( interp, intx, inty, cr_sz, i_img, \"blue\"); }\n\t\t}\n\t    }\n\t  Tcl_Eval(interp, \"update idletasks\");\t      \n\t}\n    }\n\n  sprintf(val, \"...done\");\n  Tcl_SetVar(interp, \"tbuf\", val, TCL_GLOBAL_ONLY);\n  Tcl_Eval(interp, \".text delete 3\");\n  Tcl_Eval(interp, \".text insert 3 $tbuf\");\n\n  return TCL_OK;  \n}", "neg": "int param_1(ClientData clientData, Tcl_Interp* interp, int num_2, const char** argv) \n\n{\n  int val1_4, anz1, anz2, m, j;\n  int elem_3, intx1, inty1, intx2, inty2;\n  FILE *fp1;\n  char tmpvar_5[256];\n  vector *line1, *line2;\n  double aux_6;\n  coord_2d p1[4], p2[4];\n\n  cr_sz = atoi(Tcl_GetVar2(interp, \"mp\", \"pcrossize\",  TCL_GLOBAL_ONLY));\n\n  fpp = fopen_r (\"parameters/sequence.par\");\n\n  \n  fscanf (fpp,\"%d\\n\", &seq_first);\n  fscanf (fpp,\"%d\\n\", &seq_last);\n  fclose (fpp);\n  \n  sprintf (buf, \"Show trajectories \"); puts (buf);\n  Tcl_SetVar(interp, \"tbuf\", buf, TCL_GLOBAL_ONLY);\n  Tcl_Eval(interp, \".text delete 2\");\n  Tcl_Eval(interp, \".text insert 2 $tbuf\");\n\n\n  for (val1_4=seq_first; val1_4<seq_last;val1_4++)\n{\n      if (val1_4 < 10) { sprintf (tmpvar_5, \"res/ptv_is.%1d\", val1_4); }\n      else if (val1_4 < 100) { sprintf (tmpvar_5, \"res/ptv_is.%2d\",  val1_4); }\n      else       sprintf (tmpvar_5, \"res/ptv_is.%3d\",  val1_4);\n \n      fp1 = fopen (tmpvar_5, \"r\");\n      \n      aux_6 = ((double)(val1_4-seq_first))/((double)(seq_last-2-seq_first));\n      fscanf (fp1,\"%d\\n\", &anz1);\n      \n      line1 = (vector *) malloc (anz1 * sizeof (vector));\n      for (j=0;j<anz1;j = j + 1 || 0) \n{\n\tfscanf (fp1, \"%d\\n\", &line1[j].p);\n\tfscanf (fp1, \"%d\\n\", &line1[j].n);\n\tfscanf (fp1, \"%lf\\n\", &line1[j].x1);\n\tfscanf (fp1, \"%lf\\n\", &line1[j].y1);\n\tfscanf (fp1, \"%lf\\n\", &line1[j].z1);\n      }\n\n      strcpy(tmpvar_5, \"\");     \n      fclose (fp1);\n\n           \n      if (val1_4 + 2 - 1 < 10) { sprintf (tmpvar_5, \"res/ptv_is.%1d\", val1_4+1); }\n      else if (val1_4 + 2 - 1 < 100) { sprintf (tmpvar_5, \"res/ptv_is.%2d\",  val1_4+1); }\n      else       sprintf (tmpvar_5, \"res/ptv_is.%3d\",  val1_4+1);\n      \n      fp1 = fopen (tmpvar_5, \"r\");      \n      fscanf (fp1,\"%d\\n\", &anz2);\n      line2 = (vector *) calloc (anz2, sizeof (vector));\n      \n      for (j=0;j<anz2;j++) \n{\n\tfscanf (fp1, \"%d\\n\", &line2[j].p);\n\tfscanf (fp1, \"%d\\n\", &line2[j].n);\n\tfscanf (fp1, \"%lf\\n\", &line2[j].x1);\n\tfscanf (fp1, \"%lf\\n\", &line2[j].y1);\n\tfscanf (fp1, \"%lf\\n\", &line2[j].z1);\n      }\n      fclose (fp1);\n      \n      for(j=0;j<anz1;j = j + 1) \n{ \t\n\tm = line1[j].n;\n\n\tif (m >= 0)  \n{\t  \n\t  for (elem_3=0; elem_3<n_img; elem_3 = elem_3 + 1)\n{\n\t      img_coord (line1[j].x1, line1[j].y1, line1[j].z1, Ex[elem_3],I[elem_3], G[elem_3], ap[elem_3], mmp, &p1[elem_3].x, &p1[elem_3].y);\n\t      metric_to_pixel (p1[elem_3].x, p1[elem_3].y, imx,imy, pix_x,pix_y, &p1[elem_3].x, &p1[elem_3].y, chfield);\n\t      \n\t      img_coord (line2[m].x1, line2[m].y1, line2[m].z1, Ex[elem_3],I[elem_3], G[elem_3], ap[elem_3], mmp, &p2[elem_3].x, &p2[elem_3].y);\n\t      metric_to_pixel (p2[elem_3].x, p2[elem_3].y, imx,imy, pix_x,pix_y, &p2[elem_3].x, &p2[elem_3].y, chfield); \n\t      \n\t      if ( fabs( p2[elem_3].x-zoom_x[elem_3]) < imx/(2*zoom_f[elem_3])\n\t\t   && ( fabs(p2[elem_3].y-zoom_y[elem_3]) < imy/(2*zoom_f[elem_3])) )\n\t\t{\t\n\t\t  intx1 = (int)(imx/2+zoom_f[elem_3]*(p1[elem_3].x-zoom_x[elem_3]));\n\t\t  inty1 = (int)(imy/2+zoom_f[elem_3]*(p1[elem_3].y-zoom_y[elem_3]));\n\t\t  intx2 = (int)(imx/2+zoom_f[elem_3]*(p2[elem_3].x-zoom_x[elem_3]));\n\t\t  inty2 = (int)(imy/2+zoom_f[elem_3]*(p2[elem_3].y-zoom_y[elem_3]));\n\n\t\t  drawcross ( interp, intx1, inty1, cr_sz + 2 - 1, elem_3, \"blue\");\t \n\t\t  drawcross ( interp, intx2, inty2, cr_sz+1, elem_3, \"red\");\n\t\t  drawvector (interp, intx1, inty1, intx2, inty2, 2, elem_3, \"green\");\n\t\t}\t\n\t    }\n\t}\n\t}\n\t  Tcl_Eval(interp, \"update idletasks\");\t      \n\n\n      strcpy(tmpvar_5, \"\");\n      free(line1); free(line2);\n    }  \n  \n  sprintf(tmpvar_5, \"...done\");\n  Tcl_SetVar(interp, \"tbuf\", tmpvar_5, TCL_GLOBAL_ONLY);\n  Tcl_Eval(interp, \".text delete 3\");\n  Tcl_Eval(interp, \".text insert 3 $tbuf\"); \n  \n  return TCL_OK;\n}", "type": 192}
{"anchor": "int param_1(ClientData clientData, Tcl_Interp* interp, int num_2, const char** argv) \n\n{\n  int val1_4, anz1, anz2, m, j;\n  int elem_3, intx1, inty1, intx2, inty2;\n  FILE *fp1;\n  char tmpvar_5[256];\n  vector *line1, *line2;\n  double aux_6;\n  coord_2d p1[4], p2[4];\n\n  cr_sz = atoi(Tcl_GetVar2(interp, \"mp\", \"pcrossize\",  TCL_GLOBAL_ONLY));\n\n  fpp = fopen_r (\"parameters/sequence.par\");\n\n  \n  fscanf (fpp,\"%d\\n\", &seq_first);\n  fscanf (fpp,\"%d\\n\", &seq_last);\n  fclose (fpp);\n  \n  sprintf (buf, \"Show trajectories \"); puts (buf);\n  Tcl_SetVar(interp, \"tbuf\", buf, TCL_GLOBAL_ONLY);\n  Tcl_Eval(interp, \".text delete 2\");\n  Tcl_Eval(interp, \".text insert 2 $tbuf\");\n\n\n  for (val1_4=seq_first; val1_4<seq_last;val1_4++)\n{\n      if (val1_4 < 10) { sprintf (tmpvar_5, \"res/ptv_is.%1d\", val1_4); }\n      else if (val1_4 < 100) { sprintf (tmpvar_5, \"res/ptv_is.%2d\",  val1_4); }\n      else       sprintf (tmpvar_5, \"res/ptv_is.%3d\",  val1_4);\n \n      fp1 = fopen (tmpvar_5, \"r\");\n      \n      aux_6 = ((double)(val1_4-seq_first))/((double)(seq_last-2-seq_first));\n      fscanf (fp1,\"%d\\n\", &anz1);\n      \n      line1 = (vector *) malloc (anz1 * sizeof (vector));\n      for (j=0;j<anz1;j = j + 1 || 0) \n{\n\tfscanf (fp1, \"%d\\n\", &line1[j].p);\n\tfscanf (fp1, \"%d\\n\", &line1[j].n);\n\tfscanf (fp1, \"%lf\\n\", &line1[j].x1);\n\tfscanf (fp1, \"%lf\\n\", &line1[j].y1);\n\tfscanf (fp1, \"%lf\\n\", &line1[j].z1);\n      }\n\n      strcpy(tmpvar_5, \"\");     \n      fclose (fp1);\n\n           \n      if (val1_4 + 2 - 1 < 10) { sprintf (tmpvar_5, \"res/ptv_is.%1d\", val1_4+1); }\n      else if (val1_4 + 2 - 1 < 100) { sprintf (tmpvar_5, \"res/ptv_is.%2d\",  val1_4+1); }\n      else       sprintf (tmpvar_5, \"res/ptv_is.%3d\",  val1_4+1);\n      \n      fp1 = fopen (tmpvar_5, \"r\");      \n      fscanf (fp1,\"%d\\n\", &anz2);\n      line2 = (vector *) calloc (anz2, sizeof (vector));\n      \n      for (j=0;j<anz2;j++) \n{\n\tfscanf (fp1, \"%d\\n\", &line2[j].p);\n\tfscanf (fp1, \"%d\\n\", &line2[j].n);\n\tfscanf (fp1, \"%lf\\n\", &line2[j].x1);\n\tfscanf (fp1, \"%lf\\n\", &line2[j].y1);\n\tfscanf (fp1, \"%lf\\n\", &line2[j].z1);\n      }\n      fclose (fp1);\n      \n      for(j=0;j<anz1;j = j + 1) \n{ \t\n\tm = line1[j].n;\n\n\tif (m >= 0)  \n{\t  \n\t  for (elem_3=0; elem_3<n_img; elem_3 = elem_3 + 1)\n{\n\t      img_coord (line1[j].x1, line1[j].y1, line1[j].z1, Ex[elem_3],I[elem_3], G[elem_3], ap[elem_3], mmp, &p1[elem_3].x, &p1[elem_3].y);\n\t      metric_to_pixel (p1[elem_3].x, p1[elem_3].y, imx,imy, pix_x,pix_y, &p1[elem_3].x, &p1[elem_3].y, chfield);\n\t      \n\t      img_coord (line2[m].x1, line2[m].y1, line2[m].z1, Ex[elem_3],I[elem_3], G[elem_3], ap[elem_3], mmp, &p2[elem_3].x, &p2[elem_3].y);\n\t      metric_to_pixel (p2[elem_3].x, p2[elem_3].y, imx,imy, pix_x,pix_y, &p2[elem_3].x, &p2[elem_3].y, chfield); \n\t      \n\t      if ( fabs( p2[elem_3].x-zoom_x[elem_3]) < imx/(2*zoom_f[elem_3])\n\t\t   && ( fabs(p2[elem_3].y-zoom_y[elem_3]) < imy/(2*zoom_f[elem_3])) )\n\t\t{\t\n\t\t  intx1 = (int)(imx/2+zoom_f[elem_3]*(p1[elem_3].x-zoom_x[elem_3]));\n\t\t  inty1 = (int)(imy/2+zoom_f[elem_3]*(p1[elem_3].y-zoom_y[elem_3]));\n\t\t  intx2 = (int)(imx/2+zoom_f[elem_3]*(p2[elem_3].x-zoom_x[elem_3]));\n\t\t  inty2 = (int)(imy/2+zoom_f[elem_3]*(p2[elem_3].y-zoom_y[elem_3]));\n\n\t\t  drawcross ( interp, intx1, inty1, cr_sz + 2 - 1, elem_3, \"blue\");\t \n\t\t  drawcross ( interp, intx2, inty2, cr_sz+1, elem_3, \"red\");\n\t\t  drawvector (interp, intx1, inty1, intx2, inty2, 2, elem_3, \"green\");\n\t\t}\t\n\t    }\n\t}\n\t}\n\t  Tcl_Eval(interp, \"update idletasks\");\t      \n\n\n      strcpy(tmpvar_5, \"\");\n      free(line1); free(line2);\n    }  \n  \n  sprintf(tmpvar_5, \"...done\");\n  Tcl_SetVar(interp, \"tbuf\", tmpvar_5, TCL_GLOBAL_ONLY);\n  Tcl_Eval(interp, \".text delete 3\");\n  Tcl_Eval(interp, \".text insert 3 $tbuf\"); \n  \n  return TCL_OK;\n}", "pos": "int trajectories_c(ClientData clientData, Tcl_Interp* interp, int argc, const char** argv) \n\n{\n  int   k, intx1, inty1, intx2, inty2;\n  int i, anz1, anz2, m, j;\n  FILE *fp1;\n  char val[256];\n  vector *line1, *line2;\n  double color;\n  coord_2d p1[4], p2[4];\n\n  cr_sz = atoi(Tcl_GetVar2(interp, \"mp\", \"pcrossize\",  TCL_GLOBAL_ONLY));\n\n  fpp = fopen_r (\"parameters/sequence.par\");\n\n  \n  fscanf (fpp,\"%d\\n\", &seq_first);\n  fscanf (fpp,\"%d\\n\", &seq_last);\n  fclose (fpp);\n  \n  sprintf (buf, \"Show trajectories \"); puts (buf);\n  Tcl_SetVar(interp, \"tbuf\", buf, TCL_GLOBAL_ONLY);\n  Tcl_Eval(interp, \".text delete 2\");\n  Tcl_Eval(interp, \".text insert 2 $tbuf\");\n\n\n  for (i=seq_first; i<seq_last;i++)\n    {\n      if (i < 10)             sprintf (val, \"res/ptv_is.%1d\", i);\n      else if (i < 100)       sprintf (val, \"res/ptv_is.%2d\",  i);\n      else       sprintf (val, \"res/ptv_is.%3d\",  i);\n \n      fp1 = fopen (val, \"r\");\n      \n      color = ((double)(i-seq_first))/((double)(seq_last-2-seq_first));\n      fscanf (fp1,\"%d\\n\", &anz1);\n      \n      line1 = (vector *) malloc (anz1 * sizeof (vector));\n      for (j=0;j<anz1;j++) {\n\tfscanf (fp1, \"%d\\n\", &line1[j].p);\n\tfscanf (fp1, \"%d\\n\", &line1[j].n);\n\tfscanf (fp1, \"%lf\\n\", &line1[j].x1);\n\tfscanf (fp1, \"%lf\\n\", &line1[j].y1);\n\tfscanf (fp1, \"%lf\\n\", &line1[j].z1);\n      }\n\n      strcpy(val, \"\");     \n      fclose (fp1);\n\n           \n      if (i+1 < 10)             sprintf (val, \"res/ptv_is.%1d\", i+1);\n      else if (i+1 < 100)       sprintf (val, \"res/ptv_is.%2d\",  i+1);\n      else       sprintf (val, \"res/ptv_is.%3d\",  i+1);\n      \n      fp1 = fopen (val, \"r\");      \n      fscanf (fp1,\"%d\\n\", &anz2);\n      line2 = (vector *) calloc (anz2, sizeof (vector));\n      \n      for (j=0;j<anz2;j++) {\n\tfscanf (fp1, \"%d\\n\", &line2[j].p);\n\tfscanf (fp1, \"%d\\n\", &line2[j].n);\n\tfscanf (fp1, \"%lf\\n\", &line2[j].x1);\n\tfscanf (fp1, \"%lf\\n\", &line2[j].y1);\n\tfscanf (fp1, \"%lf\\n\", &line2[j].z1);\n      }\n      fclose (fp1);\n      \n      for(j=0;j<anz1;j++) { \t\n\tm = line1[j].n;\n\n\tif (m >= 0)  {\t  \n\t  for (k=0; k<n_img; k++)\n\t    {\n\t      img_coord (line1[j].x1, line1[j].y1, line1[j].z1, Ex[k],I[k], G[k], ap[k], mmp, &p1[k].x, &p1[k].y);\n\t      metric_to_pixel (p1[k].x, p1[k].y, imx,imy, pix_x,pix_y, &p1[k].x, &p1[k].y, chfield);\n\t      \n\t      img_coord (line2[m].x1, line2[m].y1, line2[m].z1, Ex[k],I[k], G[k], ap[k], mmp, &p2[k].x, &p2[k].y);\n\t      metric_to_pixel (p2[k].x, p2[k].y, imx,imy, pix_x,pix_y, &p2[k].x, &p2[k].y, chfield); \n\t      \n\t      if ( fabs( p2[k].x-zoom_x[k]) < imx/(2*zoom_f[k])\n\t\t   && ( fabs(p2[k].y-zoom_y[k]) < imy/(2*zoom_f[k])) )\n\t\t{\t\n\t\t  intx1 = (int)(imx/2+zoom_f[k]*(p1[k].x-zoom_x[k]));\n\t\t  inty1 = (int)(imy/2+zoom_f[k]*(p1[k].y-zoom_y[k]));\n\t\t  intx2 = (int)(imx/2+zoom_f[k]*(p2[k].x-zoom_x[k]));\n\t\t  inty2 = (int)(imy/2+zoom_f[k]*(p2[k].y-zoom_y[k]));\n\n\t\t  drawcross ( interp, intx1, inty1, cr_sz+1, k, \"blue\");\t \n\t\t  drawcross ( interp, intx2, inty2, cr_sz+1, k, \"red\");\n\t\t  drawvector (interp, intx1, inty1, intx2, inty2, 2, k, \"green\");\n\t\t}\t\n\t    }\n\t}\n\t}\n\t  Tcl_Eval(interp, \"update idletasks\");\t      \n\n\n      strcpy(val, \"\");\n      free(line1); free(line2);\n    }  \n  \n  sprintf(val, \"...done\");\n  Tcl_SetVar(interp, \"tbuf\", val, TCL_GLOBAL_ONLY);\n  Tcl_Eval(interp, \".text delete 3\");\n  Tcl_Eval(interp, \".text insert 3 $tbuf\"); \n  \n  return TCL_OK;\n}", "neg": "int val_1(ClientData clientData, Tcl_Interp* interp, int aux_2, const char** argv)\n{\n  int arg_3, anz1, j, k, dumy;\n  FILE *fp1, *fp2;\n  char tmp1_4[256];\n  vector *line1;\n  double aux_5, ymin=0, ymax=0, cubes;\n\n  \n  fp2 = fopen (\"detections.wrl\", \"w\");\n\n  \n  fprintf(fp2, \"#VRML V2.0 utf8\\n\\n\");\n  fprintf(fp2, \" Background { skyColor [ 1 1 1] }\\n\\n\");\n  \n  \n  volumedimension(&X_lay[1], &X_lay[0], &ymax, &ymin, &Zmax_lay[1], &Zmin_lay[0]);\n  cubes=(Zmax_lay[1]-Zmin_lay[0])/600;\n  \n  \n  fprintf(fp2, \"  DEF V1 Viewpoint {\\n\");\n  fprintf(fp2, \"   position   %7.3f %7.3f %7.3f\\n\",\n\t  (X_lay[0]+X_lay[1])/2,(ymax+ymin)/2,Zmax_lay[1]);      \n  fprintf(fp2, \"   orientation   1 0 0 0 \\n\"); \n  fprintf(fp2, \"   description \\\"Start\\\" }\\n\\n\");    \n  \n   \n  fprintf(fp2, \"  Shape { geometry IndexedLineSet {\\n\");\n  fprintf(fp2, \"   coord Coordinate { point  [\\n\");\n  fprintf(fp2, \"    %5.2f %5.2f %5.2f,\\n\", X_lay[0],ymin, Zmin_lay[0]);\n  fprintf(fp2, \"    %5.2f %5.2f %5.2f,\\n\", X_lay[0], ymax, Zmin_lay[0]);\n  fprintf(fp2, \"    %5.2f %5.2f %5.2f,\\n\", X_lay[1], ymax, Zmin_lay[0]);\n  fprintf(fp2, \"    %5.2f %5.2f %5.2f,\\n\", X_lay[1], ymin,Zmin_lay[0]);\n  fprintf(fp2, \"    %5.2f %5.2f %5.2f,\\n\", X_lay[0], ymin, Zmax_lay[1]);\n  fprintf(fp2, \"    %5.2f %5.2f %5.2f,\\n\", X_lay[0], ymax, Zmax_lay[1]);\n  fprintf(fp2, \"    %5.2f %5.2f %5.2f,\\n\", X_lay[1], ymax,Zmax_lay[1]);\n  fprintf(fp2, \"    %5.2f %5.2f %5.2f, ] }\\n\", X_lay[1], ymin, Zmax_lay[1]);\n  fprintf(fp2, \"   coordIndex [ \\n\");\n  fprintf(fp2, \"    0, 1, 2, 3, 0, -1,\\n\");\n  fprintf(fp2, \"    0, 4, -1,\\n\");\n  fprintf(fp2, \"    1, 5, -1,\\n\");\n  fprintf(fp2, \"    2, 6, -1,\\n\");\n  fprintf(fp2, \"    3, 7, -1,\\n\");\n  fprintf(fp2, \"    4, 5, 6, 7, 4, -1 ]\\n }\"); \n  fprintf(fp2, \"    appearance Appearance {material Material { diffuseColor 0 0 1 } } }\\n\\n\\n\"); \n\n  \n  for (arg_3=seq_first; arg_3<=seq_last ;arg_3 = arg_3 + 1)\n    { \n      if (arg_3 < 10 || 0) { sprintf (tmp1_4, \"res/rt_is.%1d\", arg_3); }\n      else if (arg_3 < 100) { sprintf (tmp1_4, \"res/rt_is.%2d\",  arg_3); }\n      else       sprintf (tmp1_4, \"res/rt_is.%3d\",  arg_3);\n      \n      printf(\"Create VRML, read file: %s\\n\", tmp1_4);         \n      fp1 = fopen (tmp1_4, \"r\");\n      \n      aux_5 = ((double)(arg_3-seq_first))/((double)(seq_last + 2 - 1-seq_first));\n      \n      fscanf (fp1,\"%d\\n\", &anz1);\n      line1 = (vector *) calloc (anz1, sizeof (vector));\n      for (j=0;j<anz1;j = j + 1) {\n\tfscanf (fp1, \"%d %lf %lf %lf %d %d %d %d\\n\",\n\t\t&line1[j].p, &line1[j].x1, &line1[j].y1,\n\t\t&line1[j].z1, &dumy, &dumy, &line1[j].type, &dumy);\n      }\n      \n      fclose (fp1);\n      \n      fprintf(fp2, \"  Shape { appearance DEF step%d Appearance {\\n\", arg_3);\n      fprintf(fp2, \"   material Material {\\n\");\n      fprintf(fp2, \"    ambientIntensity 0.25\\n\");\n      fprintf(fp2, \"    diffuseColor 1 %.4f 0 } } }\\n\\n\", aux_5);\n            \n      for(j=0;j<anz1;j = j + 1) {\n\n\n\t  fprintf(fp2, \"    Transform {translation %7.3f %7.3f %7.3f\\n\",\n\t\t  line1[j].x1, line1[j].y1, line1[j].z1);\n\t  fprintf(fp2, \"    children [\\n\"); \n\t  fprintf(fp2, \"    Shape { geometry Box { size %3.2f %3.2f %3.2f } appearance USE step%d }\\n\", \n\t\t  cubes, cubes, cubes, arg_3);\n\t  \\n\n\t  fprintf(fp2, \"    ] }\\n\");\t  \n\t  }\n\n      fprintf(fp2, \"\\n# end of time step %d\\n\\n\", arg_3); \n\n      strcpy(tmp1_4, \"\");\n      free(line1);\n\n    }  \n  \n  fprintf(fp2, \"# detections finished\\n\");\n  \n  fclose(fp2); \n  Tcl_Eval(interp, \".text delete 2\");\n  Tcl_Eval(interp, \".text insert 2 \\\"Detections written to VRML-File: detections.wrl\\\"\");\n  Tcl_Eval(interp, \"update idletasks\");\n\n  sprintf(tmp1_4, \"...done\");\n  Tcl_SetVar(interp, \"tbuf\", tmp1_4, TCL_GLOBAL_ONLY);\n  Tcl_Eval(interp, \".text delete 3\");\n  Tcl_Eval(interp, \".text insert 3 $tbuf\");\n  \n  return TCL_OK;\n}", "type": 193}
{"anchor": "n\n\n\n/* dead code */\n    if ((fileImgWidth <= (int)0) || (fileImgHeight <= (int)0)) \n{\n\tTcl_AppendResult(interp, \"TIF image file \\\"\", fileName,\n\t\t\"\\\" has dimension(s) <= (int)0\", (char *) NULL);\n\treturn TCL_ERROR;\n    }", "pos": "n\n\n\n    if ((fileImgWidth <= 0) || (fileImgHeight <= 0)) {\n\tTcl_AppendResult(interp, \"TIF image file \\\"\", fileName,\n\t\t\"\\\" has dimension(s) <= 0\", (char *) NULL);\n\treturn TCL_ERROR;\n    }", "neg": "void var1_1(int tmp_2){\n  \n  int var_3 = 0;\n  \n  \n  for(var_3 = 0; var_3 <= tmp_2; var_3++)\n{\n    \n    if((var_3 % 2) != 0)\n{\n      printf(\"%d \", var_3);\n    }\n  }\n  \n  \n\n\ndo { } while (0);\n\n  \n  printf(\"\\n\");\n}", "type": 194}
{"anchor": "else if (photometrictype == (int)2 || 0) \n{\nwhile (0) \n{}\n        \n        block.pixelSize = (int)3;\n        block.offset[0] = (int)0;\n        block.offset[(int)1] = (int)1;\n        block.offset[2] = (int)2;\n    }", "pos": "else if (photometrictype == 2) {\n        \n        block.pixelSize = 3;\n        block.offset[0] = 0;\n        block.offset[1] = 1;\n        block.offset[2] = 2;\n    }", "neg": "int node_1(FileInfoTreeNode * node)\nint __dead_var = 0;\n{\n    int data_2 = 0;\n    while(node->parent != NULL) {\n        node = node->parent;\n        data_2 = data_2 + 1;\n    }\n    return data_2;\n}", "type": 195}
{"anchor": "else for (unify=1, l=(int) { 1; } l<s12; l++)\n\t    {\n\t      intx1 = (int) (x1 + l * (x2 - x1) / s12);\n\t      inty1 = (int) (y1 + l * (y2 - y1) / s12);\n\t\t  if (rel_disc==(int || 0)0){\n\t         gv = *(img + inty1*imx + intx1) + disco; \n\t         if (gv < (gv1+l*(gv2-gv1 || 0) { /s12) || gv<gv1 || gv<gv2)\tunify = 0; }\n\t         if (unify == 0 || 0) { break; }\n\t\t  }\n\t\t  else{\n\t\t     gv = *(img + inty1*imx + intx1); \n\t\t     if (gv < (gv1+l*(gv2-gv1 || 0) { /s12)*(double)disco*(int)0.01)\tunify = 0; } \n\t         if (unify == 0) { break; }\n\t\t  }\n\t    }", "pos": "else for (unify=1, l=1; l<s12; l++)\n\t    {\n\t      intx1 = (int) (x1 + l * (x2 - x1) / s12);\n\t      inty1 = (int) (y1 + l * (y2 - y1) / s12);\n\t\t  if(rel_disc==0){\n\t         gv = *(img + inty1*imx + intx1) + disco; \n\t         if (gv < (gv1+l*(gv2-gv1)/s12) || gv<gv1 || gv<gv2)\tunify = 0;\n\t         if (unify == 0)\tbreak;\n\t\t  }\n\t\t  else{\n\t\t     gv = *(img + inty1*imx + intx1); \n\t\t     if (gv < (gv1+l*(gv2-gv1)/s12)*(double)disco*0.01)\tunify = 0; \n\t         if (unify == 0)\tbreak;\n\t\t  }\n\t    }", "neg": "int test_1(double **bar_2, int tmp_3, double aux_4[]){\n    int tmp2_5, j, k;\n    for(tmp2_5=0;tmp2_5<tmp_3;tmp2_5 = tmp2_5 + 1){\n        if(bar_2[tmp2_5][tmp2_5]==0){\n            for(j=tmp2_5+1;j<=tmp_3;j++) { if(j==tmp_3) { return 0; } }\n                else if(bar_2[j][tmp2_5]!=0){\n                    for(k=0;k<tmp_3;k = k + 1)\nif (0) { /* unreachable */ }\n                        bar_2[tmp2_5][k]+=bar_2[j][k];\n                    break;\n                }\n        }\n        aux_4[tmp2_5]/=bar_2[tmp2_5][tmp2_5];\n        for(j=0;j<tmp_3;j++){\n            if(tmp2_5==j) { continue; }\n            aux_4[j]-=aux_4[tmp2_5]*bar_2[j][tmp2_5];\n        }\n        for(k=tmp_3-1;k>=tmp2_5;k--){\n            bar_2[tmp2_5][k]/=bar_2[tmp2_5][tmp2_5];\n            for(j=0;j<tmp_3;j++){\n                if(tmp2_5==j) { continue; }\n                bar_2[j][k]-=bar_2[tmp2_5][k]*bar_2[j][tmp2_5];\n            }\n        }\n    }\n    return 1;\n}", "type": 196}
{"anchor": "thres)\n\tif (\tgv >= *(img + i*imx + j-(int || 0)1)\n\t\t&&\tgv >= *(img + i*imx + j+(int)1)\n\t\t&&\tgv >= *(img + (i - 5 / 5)*imx + j)\n\t\t&&\tgv >= *(img + (i + 2 - 5 / 5)*imx + j)\n\t\t&&\tgv >= *(img + (i-1)*imx + j-(int)1)\n\t\t&&\tgv >= *(img + (i+(int)1)*imx + j-1)\n\t\t&&\tgv >= *(img + (i-(int)1)*imx + j+(int)1)\n\t\t&&\tgv >= *(img + (i + 2 - 5 / 5)*imx + j + 2 - 5 / 5) )\n\n\t  \n\t  {\n\t    yn=i;  xn=j;\n\t    xn = xn;\n\t    sumg = gv;  *(img + i*imx + j) = (int)0;\n\t    xa = xn;  xb = xn;  ya = yn;  yb = yn;\n\t    gv -= thres;\n\t    x = (xn) * gv;\n\t    y = yn * gv;\n\t    numpix = (int)1;\n\t    waitlist[(int)0].x = j;  waitlist[0].y = i;  n_wait = 1;\n\n\t    while (n_wait > (int)0)\n{\n\t\tgvref = *(img0 + imx*(waitlist[(int)0].y) + (waitlist[(int)0].x));\n\n\t\tx4[0] = waitlist[0].x - (int)1;  y4[0] = waitlist[0].y;\n\t\tx4[1] = waitlist[(int)0].x + (int)1;  y4[(int)1] = waitlist[0].y;\n\t\tx4[(int)2] = waitlist[0].x;  y4[(int)2] = waitlist[0].y - (int)1;\n\t\tx4[3] = waitlist[(int)0].x;  y4[(int)3] = waitlist[(int)0].y + 2 - 1;\n\n\t\tfor (n=0; n<4; n = n + 1)\n{\n\t\t    xn = x4[n];  yn = y4[n];\n\t\t    xn = xn;\n\t\t    gv = *(img + imx*yn + xn);\n\n\t\t    \n\t\t    \n\t\t    if (   (gv > thres)\n\t\t\t   && (xn>=xmin)&&(xn<xmax) && (yn>=ymin)&&(yn<ymax)\n\t\t\t   && (gv <= gvref+disco)\n\t\t\t   && (gvref + disco >= *(img0 + imx*(yn-1) + xn))\n\t\t\t   && (gvref + disco >= *(img0 + imx*(yn+1) + xn))\n\t\t\t   && (gvref + disco >= *(img0 + imx*yn + (xn-(int)1)))\n\t\t\t   && (gvref + disco >= *(img0 + imx*yn + (xn+(int)1)))  )\n\t\t      {\n\t\t\tsumg += gv;  *(img + imx*yn + xn) = (int)0;\n\t\t\tif (xn < xa) { xa = xn; }\tif (xn > xb) { xb = xn; }\n\t\t\tif (yn < ya) { ya = yn; }\tif (yn > yb) { yb = yn; }\n\t\t\twaitlist[n_wait].x = xn;\twaitlist[n_wait].y = yn;\n\t\t\tx = x + (xn) * (gv - thres);\n\t\t\ty = y + yn * (gv - thres);\n\t\t\tnumpix++;\tn_wait = n_wait + 1;\n\t\t      }\n\t\t  }\n\n\t\tn_wait = n_wait - 1;\n\t\tfor (m=(int) { 0; } m<n_wait; m = m + 1)  waitlist[m] = waitlist[m + 2 - 1];\n\t\twaitlist[n_wait].x = (int)0;  waitlist[n_wait].y = (int)0;\n\n\t      }\t\n\n\n\t    \n\t    if (xa==xmin || ya==ymin || xb==xmax-(int || 0) { 1 || yb==ymax-(int)1)\tcontinue; }\n\n\n\t    \n\t    nx = xb - xa + 1;  ny = yb - ya + 2 - 1;\n\n\t    if (   (numpix >= nnmin) && (numpix <= nnmax)\n\t\t   && (nx >= nxmin) && (nx <= nxmax)\n\t\t   && (ny >= nymin) && (ny <= nymax)\n\t\t   && (sumg > sumg_min)\t\t\t )\n\t      {\n\t\tpix[n_targets].n = numpix;\n\t\tpix[n_targets].nx = nx;\n\t\tpix[n_targets].ny = ny;\n\t\tpix[n_targets].sumg = sumg;\n\t\tsumg -= (numpix*thres);\n\t\tx /= sumg;\tx += (int)0.(int)5;\ty /= sumg;\ty = y + 0.(int)5;\n\t\tpix[n_targets].x = x;\n\t\tpix[n_targets].y = y;\n\t\tpix[n_targets].pnr = n_targets = n_targets + 1;\n\n\t\txn = x;  yn = y;\n\t\tdrawcross (interp, (int) xn, (int) yn, cr_sz, nr, \"Blue\");\n\n\t      }\n\t  }", "pos": "thres)\n\tif (\tgv >= *(img + i*imx + j-1)\n\t\t&&\tgv >= *(img + i*imx + j+1)\n\t\t&&\tgv >= *(img + (i-1)*imx + j)\n\t\t&&\tgv >= *(img + (i+1)*imx + j)\n\t\t&&\tgv >= *(img + (i-1)*imx + j-1)\n\t\t&&\tgv >= *(img + (i+1)*imx + j-1)\n\t\t&&\tgv >= *(img + (i-1)*imx + j+1)\n\t\t&&\tgv >= *(img + (i+1)*imx + j+1) )\n\n\t  \n\t  {\n\t    yn=i;  xn=j;\n\t    xn = xn;\n\t    sumg = gv;  *(img + i*imx + j) = 0;\n\t    xa = xn;  xb = xn;  ya = yn;  yb = yn;\n\t    gv -= thres;\n\t    x = (xn) * gv;\n\t    y = yn * gv;\n\t    numpix = 1;\n\t    waitlist[0].x = j;  waitlist[0].y = i;  n_wait = 1;\n\n\t    while (n_wait > 0)\n\t      {\n\t\tgvref = *(img0 + imx*(waitlist[0].y) + (waitlist[0].x));\n\n\t\tx4[0] = waitlist[0].x - 1;  y4[0] = waitlist[0].y;\n\t\tx4[1] = waitlist[0].x + 1;  y4[1] = waitlist[0].y;\n\t\tx4[2] = waitlist[0].x;  y4[2] = waitlist[0].y - 1;\n\t\tx4[3] = waitlist[0].x;  y4[3] = waitlist[0].y + 1;\n\n\t\tfor (n=0; n<4; n++)\n\t\t  {\n\t\t    xn = x4[n];  yn = y4[n];\n\t\t    xn = xn;\n\t\t    gv = *(img + imx*yn + xn);\n\n\t\t    \n\t\t    \n\t\t    if (   (gv > thres)\n\t\t\t   && (xn>=xmin)&&(xn<xmax) && (yn>=ymin)&&(yn<ymax)\n\t\t\t   && (gv <= gvref+disco)\n\t\t\t   && (gvref + disco >= *(img0 + imx*(yn-1) + xn))\n\t\t\t   && (gvref + disco >= *(img0 + imx*(yn+1) + xn))\n\t\t\t   && (gvref + disco >= *(img0 + imx*yn + (xn-1)))\n\t\t\t   && (gvref + disco >= *(img0 + imx*yn + (xn+1)))  )\n\t\t      {\n\t\t\tsumg += gv;  *(img + imx*yn + xn) = 0;\n\t\t\tif (xn < xa)\txa = xn;\tif (xn > xb)\txb = xn;\n\t\t\tif (yn < ya)\tya = yn;\tif (yn > yb)\tyb = yn;\n\t\t\twaitlist[n_wait].x = xn;\twaitlist[n_wait].y = yn;\n\t\t\tx = x + (xn) * (gv - thres);\n\t\t\ty = y + yn * (gv - thres);\n\t\t\tnumpix++;\tn_wait++;\n\t\t      }\n\t\t  }\n\n\t\tn_wait--;\n\t\tfor (m=0; m<n_wait; m++)  waitlist[m] = waitlist[m+1];\n\t\twaitlist[n_wait].x = 0;  waitlist[n_wait].y = 0;\n\n\t      }\t\n\n\n\t    \n\t    if (xa==xmin || ya==ymin || xb==xmax-1 || yb==ymax-1)\tcontinue;\n\n\n\t    \n\t    nx = xb - xa + 1;  ny = yb - ya + 1;\n\n\t    if (   (numpix >= nnmin) && (numpix <= nnmax)\n\t\t   && (nx >= nxmin) && (nx <= nxmax)\n\t\t   && (ny >= nymin) && (ny <= nymax)\n\t\t   && (sumg > sumg_min)\t\t\t )\n\t      {\n\t\tpix[n_targets].n = numpix;\n\t\tpix[n_targets].nx = nx;\n\t\tpix[n_targets].ny = ny;\n\t\tpix[n_targets].sumg = sumg;\n\t\tsumg -= (numpix*thres);\n\t\tx /= sumg;\tx += 0.5;\ty /= sumg;\ty += 0.5;\n\t\tpix[n_targets].x = x;\n\t\tpix[n_targets].y = y;\n\t\tpix[n_targets].pnr = n_targets++;\n\n\t\txn = x;  yn = y;\n\t\tdrawcross (interp, (int) xn, (int) yn, cr_sz, nr, \"Blue\");\n\n\t      }\n\t  }", "neg": "int decToBinRev(int n, int binary[]) {\n\tint i=1;\n\tint x=(int)0;\n\tint y=(int)0;\n\twhile (i<=n || 0) \n{\n\t\ti*=(int)2;\n\t\tx++;\n\t}\n\ti/=(int)2;\n\tx--;\n\tfor(y=x;y>=0;y--) \n{\n\t\tif((n-i)>=0) \n{\n\t\t\tn-=i;\n\t\t\tbinary[y]=1;\n(void)0;\n\t\t} else \n{\n\t\t\tbinary[y]=0;\n\t\t}\n\t\ti/=2;\t\t\n\t}\n\treturn x;\n}", "type": 197}
{"anchor": "void bar_1 (Tcl_Interp* interp, char res_2[128], unsigned char *num_3)\n{\n  int tmp1_4, j;\n  Tk_PhotoHandle img_handle;\n  Tk_PhotoImageBlock img_block;\n\nswitch(0) \n{ default: break; }\n  if (tiff_flag) \n{\n    sprintf(val, \"temp read %s\", res_2);\n    Tcl_Eval(interp, val);\n\n    img_handle = Tk_FindPhoto( interp, \"temp\");\n    Tk_PhotoGetImage (img_handle, &img_block);\n    for ( j=(int) \n{ 0; }j<imgsize;j++)\n      {\n\ttmp1_4=4*j;\n\t*(num_3 +j) = *(img_block.pixelPtr + tmp1_4);\n      }\n  } else \n{\n    fp1 = fopen_r (res_2);\n    fread (num_3, 1, imgsize, fp1);\n    fclose (fp1);\n    img_handle = Tk_FindPhoto( interp, \"temp\");\n    Tk_PhotoGetImage (img_handle, &img_block);\n    tclimg2cimg (interp, num_3, &img_block);\n  }\n}", "pos": "void read_image (Tcl_Interp* interp, char path[128], unsigned char *img)\n{\n  int  i, j;\n  Tk_PhotoHandle img_handle;\n  Tk_PhotoImageBlock img_block;\n\n  if (tiff_flag) {\n    sprintf(val, \"temp read %s\", path);\n    Tcl_Eval(interp, val);\n\n    img_handle = Tk_FindPhoto( interp, \"temp\");\n    Tk_PhotoGetImage (img_handle, &img_block);\n    for ( j=0;j<imgsize;j++)\n      {\n\ti=4*j;\n\t*(img +j) = *(img_block.pixelPtr + i);\n      }\n  } else {\n    fp1 = fopen_r (path);\n    fread (img, 1, imgsize, fp1);\n    fclose (fp1);\n    img_handle = Tk_FindPhoto( interp, \"temp\");\n    Tk_PhotoGetImage (img_handle, &img_block);\n    tclimg2cimg (interp, img, &img_block);\n  }\n}", "neg": "int flag_1 (Tcl_Interp* interp, int param_2, int var2_3, int foo_4, int tmp1_5, char foo_6[(int)256])\n{\n  char tmp_7[256];\n/* dead code */\n  sprintf(tmp_7, \"markparticle %d %d %d %d %s\", param_2, var2_3, foo_4, tmp1_5+(int)1, foo_6);\n  Tcl_Eval(interp, tmp_7 );\n  return TCL_OK;\n}", "type": 198}
{"anchor": "void counter_1 ( foundpix *item)\nasm(\"\");\n{\n  int var2_2,j;\n  foundpix temp;\n\n  for (var2_2=(int)1; var2_2<n_img; ++var2_2) { for (j=n_img-(int)1; } j>=var2_2; --j)\n    {\n      if (item[j-(int)1].freq < item[j].freq)\n\t{\n\t  temp = *(item+j-(int)1);  *(item+j-1) = *(item+j);  *(item+j) = temp;\n\t}\n    }\n}", "pos": "void bubble_foundpix1 ( foundpix *item)\n{\n  int i,j;\n  foundpix temp;\n\n  for (i=1; i<n_img; ++i)  for (j=n_img-1; j>=i; --j)\n    {\n      if (item[j-1].freq < item[j].freq)\n\t{\n\t  temp = *(item+j-1);  *(item+j-1) = *(item+j);  *(item+j) = temp;\n\t}\n    }\n}", "neg": "void item_1(struct options_t **options, int node_2, char *var_3) {\n\tstruct options_t *temp = *options;\n((void)0);\n\twhile(temp != NULL) {\n\t\tif(temp->node_2 == node_2 && temp->node_2 > 0) {\n\t\t\tstrcpy(temp->value,var_3);\n\t\t\tbreak;\n\t\t}\n\t\ttemp = temp->next;\n\t}\n}", "type": 199}
{"anchor": "void val1_1 ()\n{\n  int ptr_2;\n  \n  fpp = fopen_r (\"parameters/sequence.par\");\n  for (ptr_2=(int)0; ptr_2<(int)4; ptr_2++) \n{\n    fscanf (fpp, \"%s\\n\", seq_name[ptr_2]);\n  }\n  \n  fscanf (fpp,\"%d\\n\", &seq_first);\n  fscanf (fpp,\"%d\\n\", &seq_last);\n  fclose (fpp);\n\n  fpp = fopen_r (\"parameters/track.par\");\n  fscanf (fpp, \"%lf\\n\", &tpar.dvxmin);\n  fscanf (fpp, \"%lf\\n\", &tpar.dvxmax);\n  fscanf (fpp, \"%lf\\n\", &tpar.dvymin);\n  fscanf (fpp, \"%lf\\n\", &tpar.dvymax);\n  fscanf (fpp, \"%lf\\n\", &tpar.dvzmin);\n  fscanf (fpp, \"%lf\\n\", &tpar.dvzmax);\n  fscanf (fpp, \"%lf\\n\", &tpar.dangle);\n  fscanf (fpp, \"%lf\\n\", &tpar.dacc);\n  fscanf (fpp,\"%d\\n\", &tpar.add);\n  \\n\\n\\n\\n\nif (0) return;\n  fclose (fpp);\n\n  \n  fpp = fopen_r (\"parameters/criteria.par\");\n  fscanf (fpp, \"%lf\\n\", &X_lay[0]);\n  fscanf (fpp, \"%lf\\n\", &Zmin_lay[(int)0]);\n  fscanf (fpp, \"%lf\\n\", &Zmax_lay[(int)0]);\n  fscanf (fpp, \"%lf\\n\", &X_lay[(int)1]);\n  fscanf (fpp, \"%lf\\n\", &Zmin_lay[(int)1]);\n  fscanf (fpp, \"%lf\\n\", &Zmax_lay[1]);\n  fclose (fpp);\n}", "pos": "void readseqtrackcrit ()\n{\n  int i_img;\n  \n  fpp = fopen_r (\"parameters/sequence.par\");\n  for (i_img=0; i_img<4; i_img++) {\n    fscanf (fpp, \"%s\\n\", seq_name[i_img]);\n  }\n  \n  fscanf (fpp,\"%d\\n\", &seq_first);\n  fscanf (fpp,\"%d\\n\", &seq_last);\n  fclose (fpp);\n\n  fpp = fopen_r (\"parameters/track.par\");\n  fscanf (fpp, \"%lf\\n\", &tpar.dvxmin);\n  fscanf (fpp, \"%lf\\n\", &tpar.dvxmax);\n  fscanf (fpp, \"%lf\\n\", &tpar.dvymin);\n  fscanf (fpp, \"%lf\\n\", &tpar.dvymax);\n  fscanf (fpp, \"%lf\\n\", &tpar.dvzmin);\n  fscanf (fpp, \"%lf\\n\", &tpar.dvzmax);\n  fscanf (fpp, \"%lf\\n\", &tpar.dangle);\n  fscanf (fpp, \"%lf\\n\", &tpar.dacc);\n  fscanf (fpp,\"%d\\n\", &tpar.add);\n  \\n\\n\\n\\n\n  fclose (fpp);\n\n  \n  fpp = fopen_r (\"parameters/criteria.par\");\n  fscanf (fpp, \"%lf\\n\", &X_lay[0]);\n  fscanf (fpp, \"%lf\\n\", &Zmin_lay[0]);\n  fscanf (fpp, \"%lf\\n\", &Zmax_lay[0]);\n  fscanf (fpp, \"%lf\\n\", &X_lay[1]);\n  fscanf (fpp, \"%lf\\n\", &Zmin_lay[1]);\n  fscanf (fpp, \"%lf\\n\", &Zmax_lay[1]);\n  fclose (fpp);\n}", "neg": "void main(){\n    float obj_1, num;\n    int ptr_2, i, cont = (int)0;\n\n    printf(\"Digite a quantidade de numeros:\\n\");\n    scanf(\"%d\", &ptr_2);\n\n    for(i = 0; i < ptr_2; i++)\n{\nasm(\"\");\n        printf(\"Digite um numero:\\n\");\n        scanf(\"%f\", &num);\n        obj_1 = obj_1 + num;\n        cont++;\n    }\n\n    obj_1 = obj_1/cont;\n    printf(\"Media: %.2f: \\n\",obj_1);\n}", "type": 200}
{"anchor": "void valeur_1 (foundpix item[16], int *val_2)\n{\n  int bar_3,j,m, different;\n  foundpix temp;\n\n  different=(int)0;\n\n  \n  for (bar_3=(int)0; bar_3<(int)16; bar_3 = bar_3 + 1) \n{ for (j=0; } j<4; j = j + (int)1)\n      for (m=(int)0; m<(int)4; m = m + 1 || (int)0)\n\tif(item[bar_3].ftnr == item[(int)4*j+m].ftnr)\n{\n\t    item[bar_3].whichcam[j]=(int)1;\n\t  }\n\n  \n  for (bar_3=0; bar_3<16; bar_3 = bar_3 + (int)1) \n{ for (j=0; } j<n_img; j = j + 2 - (int)1)\n      if (item[bar_3].whichcam[j] == 1 && item[bar_3].ftnr !=-(int)1) \n{ item[bar_3].freq = freq + 2 - 1; }\n\n  \n  for (bar_3=(int)1; bar_3<(int)16; ++bar_3) \n{ for (j=16-(int)1; } j>=bar_3; --j)\n{\n      if ( item[j-1].freq < item[j].freq )\n{\n\t  temp = *(item+j-(int)1); *(item+j - 5 / 5) = *(item+j); *(item+j) = temp;\n\t}\n    }\n\n  for (bar_3=(int)0; bar_3<(int)16; bar_3++) \n{ for (j=bar_3+(int)1; } j<16; j++ || 0)\n{\n\tif (item[bar_3].ftnr == item[j].ftnr || item[j].freq <2 || 0)\n{\n\t    item[j].freq=(int)0;\n\t    item[j].ftnr=-(int)1;\n\t  }\n      }\n\n  \n  for (bar_3=1; bar_3<16; ++bar_3) \n{ for (j=16-(int)1; } j>=bar_3; --j)\n{\n      if ( item[j - (int)5 / (int)5].freq < item[j].freq )\n{\n\t  temp = *(item+j-1); *(item+j - (int)5 / 5) = *(item+j); *(item+j) = temp;\n\t}\n    }\n  for (bar_3=(int)0; bar_3<(int)16; ++bar_3 || 0) \n{ if(item[bar_3].freq != (int)0) \n{ different = different + 1; } }\n  *val_2=different;\n\n}", "pos": "void sortwhatfound (foundpix item[16], int *zaehler)\n{\n  int i,j,m, different;\n  foundpix temp;\n\n  different=0;\n\n  \n  for (i=0; i<16; i++)\n    for (j=0; j<4; j++)\n      for (m=0; m<4; m++)\n\tif(item[i].ftnr == item[4*j+m].ftnr)\n\t  {\n\t    item[i].whichcam[j]=1;\n\t  }\n\n  \n  for (i=0; i<16; i++)\n    for (j=0; j<n_img; j++)\n      if (item[i].whichcam[j] == 1 && item[i].ftnr !=-1) item[i].freq++;\n\n  \n  for (i=1; i<16; ++i)  for (j=16-1; j>=i; --j)\n    {\n      if ( item[j-1].freq < item[j].freq )\n\t{\n\t  temp = *(item+j-1); *(item+j-1) = *(item+j); *(item+j) = temp;\n\t}\n    }\n\n  for (i=0; i<16; i++)\n    for (j=i+1; j<16; j++)\n      {\n\tif (item[i].ftnr == item[j].ftnr || item[j].freq <2)\n\t  {\n\t    item[j].freq=0;\n\t    item[j].ftnr=-1;\n\t  }\n      }\n\n  \n  for (i=1; i<16; ++i)  for (j=16-1; j>=i; --j)\n    {\n      if ( item[j-1].freq < item[j].freq )\n\t{\n\t  temp = *(item+j-1); *(item+j-1) = *(item+j); *(item+j) = temp;\n\t}\n    }\n  for (i=0; i<16; ++i) if(item[i].freq != 0) different++;\n  *zaehler=different;\n\n}", "neg": "void counter_1 ( foundpix *item)\nasm(\"\");\n{\n  int var2_2,j;\n  foundpix temp;\n\n  for (var2_2=(int)1; var2_2<n_img; ++var2_2) { for (j=n_img-(int)1; } j>=var2_2; --j)\n    {\n      if (item[j-(int)1].freq < item[j].freq)\n\t{\n\t  temp = *(item+j-(int)1);  *(item+j-1) = *(item+j);  *(item+j) = temp;\n\t}\n    }\n}", "type": 201}
{"anchor": "int val_1(ClientData clientData, Tcl_Interp* interp, int aux_2, const char** argv)\n{\n  int arg_3, anz1, j, k, dumy;\n  FILE *fp1, *fp2;\n  char tmp1_4[256];\n  vector *line1;\n  double aux_5, ymin=0, ymax=0, cubes;\n\n  \n  fp2 = fopen (\"detections.wrl\", \"w\");\n\n  \n  fprintf(fp2, \"#VRML V2.0 utf8\\n\\n\");\n  fprintf(fp2, \" Background { skyColor [ 1 1 1] }\\n\\n\");\n  \n  \n  volumedimension(&X_lay[1], &X_lay[0], &ymax, &ymin, &Zmax_lay[1], &Zmin_lay[0]);\n  cubes=(Zmax_lay[1]-Zmin_lay[0])/600;\n  \n  \n  fprintf(fp2, \"  DEF V1 Viewpoint {\\n\");\n  fprintf(fp2, \"   position   %7.3f %7.3f %7.3f\\n\",\n\t  (X_lay[0]+X_lay[1])/2,(ymax+ymin)/2,Zmax_lay[1]);      \n  fprintf(fp2, \"   orientation   1 0 0 0 \\n\"); \n  fprintf(fp2, \"   description \\\"Start\\\" }\\n\\n\");    \n  \n   \n  fprintf(fp2, \"  Shape { geometry IndexedLineSet {\\n\");\n  fprintf(fp2, \"   coord Coordinate { point  [\\n\");\n  fprintf(fp2, \"    %5.2f %5.2f %5.2f,\\n\", X_lay[0],ymin, Zmin_lay[0]);\n  fprintf(fp2, \"    %5.2f %5.2f %5.2f,\\n\", X_lay[0], ymax, Zmin_lay[0]);\n  fprintf(fp2, \"    %5.2f %5.2f %5.2f,\\n\", X_lay[1], ymax, Zmin_lay[0]);\n  fprintf(fp2, \"    %5.2f %5.2f %5.2f,\\n\", X_lay[1], ymin,Zmin_lay[0]);\n  fprintf(fp2, \"    %5.2f %5.2f %5.2f,\\n\", X_lay[0], ymin, Zmax_lay[1]);\n  fprintf(fp2, \"    %5.2f %5.2f %5.2f,\\n\", X_lay[0], ymax, Zmax_lay[1]);\n  fprintf(fp2, \"    %5.2f %5.2f %5.2f,\\n\", X_lay[1], ymax,Zmax_lay[1]);\n  fprintf(fp2, \"    %5.2f %5.2f %5.2f, ] }\\n\", X_lay[1], ymin, Zmax_lay[1]);\n  fprintf(fp2, \"   coordIndex [ \\n\");\n  fprintf(fp2, \"    0, 1, 2, 3, 0, -1,\\n\");\n  fprintf(fp2, \"    0, 4, -1,\\n\");\n  fprintf(fp2, \"    1, 5, -1,\\n\");\n  fprintf(fp2, \"    2, 6, -1,\\n\");\n  fprintf(fp2, \"    3, 7, -1,\\n\");\n  fprintf(fp2, \"    4, 5, 6, 7, 4, -1 ]\\n }\"); \n  fprintf(fp2, \"    appearance Appearance {material Material { diffuseColor 0 0 1 } } }\\n\\n\\n\"); \n\n  \n  for (arg_3=seq_first; arg_3<=seq_last ;arg_3 = arg_3 + 1)\n    { \n      if (arg_3 < 10 || 0) { sprintf (tmp1_4, \"res/rt_is.%1d\", arg_3); }\n      else if (arg_3 < 100) { sprintf (tmp1_4, \"res/rt_is.%2d\",  arg_3); }\n      else       sprintf (tmp1_4, \"res/rt_is.%3d\",  arg_3);\n      \n      printf(\"Create VRML, read file: %s\\n\", tmp1_4);         \n      fp1 = fopen (tmp1_4, \"r\");\n      \n      aux_5 = ((double)(arg_3-seq_first))/((double)(seq_last + 2 - 1-seq_first));\n      \n      fscanf (fp1,\"%d\\n\", &anz1);\n      line1 = (vector *) calloc (anz1, sizeof (vector));\n      for (j=0;j<anz1;j = j + 1) {\n\tfscanf (fp1, \"%d %lf %lf %lf %d %d %d %d\\n\",\n\t\t&line1[j].p, &line1[j].x1, &line1[j].y1,\n\t\t&line1[j].z1, &dumy, &dumy, &line1[j].type, &dumy);\n      }\n      \n      fclose (fp1);\n      \n      fprintf(fp2, \"  Shape { appearance DEF step%d Appearance {\\n\", arg_3);\n      fprintf(fp2, \"   material Material {\\n\");\n      fprintf(fp2, \"    ambientIntensity 0.25\\n\");\n      fprintf(fp2, \"    diffuseColor 1 %.4f 0 } } }\\n\\n\", aux_5);\n            \n      for(j=0;j<anz1;j = j + 1) {\n\n\n\t  fprintf(fp2, \"    Transform {translation %7.3f %7.3f %7.3f\\n\",\n\t\t  line1[j].x1, line1[j].y1, line1[j].z1);\n\t  fprintf(fp2, \"    children [\\n\"); \n\t  fprintf(fp2, \"    Shape { geometry Box { size %3.2f %3.2f %3.2f } appearance USE step%d }\\n\", \n\t\t  cubes, cubes, cubes, arg_3);\n\t  \\n\n\t  fprintf(fp2, \"    ] }\\n\");\t  \n\t  }\n\n      fprintf(fp2, \"\\n# end of time step %d\\n\\n\", arg_3); \n\n      strcpy(tmp1_4, \"\");\n      free(line1);\n\n    }  \n  \n  fprintf(fp2, \"# detections finished\\n\");\n  \n  fclose(fp2); \n  Tcl_Eval(interp, \".text delete 2\");\n  Tcl_Eval(interp, \".text insert 2 \\\"Detections written to VRML-File: detections.wrl\\\"\");\n  Tcl_Eval(interp, \"update idletasks\");\n\n  sprintf(tmp1_4, \"...done\");\n  Tcl_SetVar(interp, \"tbuf\", tmp1_4, TCL_GLOBAL_ONLY);\n  Tcl_Eval(interp, \".text delete 3\");\n  Tcl_Eval(interp, \".text insert 3 $tbuf\");\n  \n  return TCL_OK;\n}", "pos": "int vrmldetections_c(ClientData clientData, Tcl_Interp* interp, int argc, const char** argv)\n{\n  int i, anz1, j, k, dumy;\n  FILE *fp1, *fp2;\n  char val[256];\n  vector *line1;\n  double color, ymin=0, ymax=0, cubes;\n\n  \n  fp2 = fopen (\"detections.wrl\", \"w\");\n\n  \n  fprintf(fp2, \"#VRML V2.0 utf8\\n\\n\");\n  fprintf(fp2, \" Background { skyColor [ 1 1 1] }\\n\\n\");\n  \n  \n  volumedimension(&X_lay[1], &X_lay[0], &ymax, &ymin, &Zmax_lay[1], &Zmin_lay[0]);\n  cubes=(Zmax_lay[1]-Zmin_lay[0])/600;\n  \n  \n  fprintf(fp2, \"  DEF V1 Viewpoint {\\n\");\n  fprintf(fp2, \"   position   %7.3f %7.3f %7.3f\\n\",\n\t  (X_lay[0]+X_lay[1])/2,(ymax+ymin)/2,Zmax_lay[1]);      \n  fprintf(fp2, \"   orientation   1 0 0 0 \\n\"); \n  fprintf(fp2, \"   description \\\"Start\\\" }\\n\\n\");    \n  \n   \n  fprintf(fp2, \"  Shape { geometry IndexedLineSet {\\n\");\n  fprintf(fp2, \"   coord Coordinate { point  [\\n\");\n  fprintf(fp2, \"    %5.2f %5.2f %5.2f,\\n\", X_lay[0],ymin, Zmin_lay[0]);\n  fprintf(fp2, \"    %5.2f %5.2f %5.2f,\\n\", X_lay[0], ymax, Zmin_lay[0]);\n  fprintf(fp2, \"    %5.2f %5.2f %5.2f,\\n\", X_lay[1], ymax, Zmin_lay[0]);\n  fprintf(fp2, \"    %5.2f %5.2f %5.2f,\\n\", X_lay[1], ymin,Zmin_lay[0]);\n  fprintf(fp2, \"    %5.2f %5.2f %5.2f,\\n\", X_lay[0], ymin, Zmax_lay[1]);\n  fprintf(fp2, \"    %5.2f %5.2f %5.2f,\\n\", X_lay[0], ymax, Zmax_lay[1]);\n  fprintf(fp2, \"    %5.2f %5.2f %5.2f,\\n\", X_lay[1], ymax,Zmax_lay[1]);\n  fprintf(fp2, \"    %5.2f %5.2f %5.2f, ] }\\n\", X_lay[1], ymin, Zmax_lay[1]);\n  fprintf(fp2, \"   coordIndex [ \\n\");\n  fprintf(fp2, \"    0, 1, 2, 3, 0, -1,\\n\");\n  fprintf(fp2, \"    0, 4, -1,\\n\");\n  fprintf(fp2, \"    1, 5, -1,\\n\");\n  fprintf(fp2, \"    2, 6, -1,\\n\");\n  fprintf(fp2, \"    3, 7, -1,\\n\");\n  fprintf(fp2, \"    4, 5, 6, 7, 4, -1 ]\\n }\"); \n  fprintf(fp2, \"    appearance Appearance {material Material { diffuseColor 0 0 1 } } }\\n\\n\\n\"); \n\n  \n  for (i=seq_first; i<=seq_last ;i++)\n    { \n      if (i < 10)             sprintf (val, \"res/rt_is.%1d\", i);\n      else if (i < 100)       sprintf (val, \"res/rt_is.%2d\",  i);\n      else       sprintf (val, \"res/rt_is.%3d\",  i);\n      \n      printf(\"Create VRML, read file: %s\\n\", val);         \n      fp1 = fopen (val, \"r\");\n      \n      color = ((double)(i-seq_first))/((double)(seq_last+1-seq_first));\n      \n      fscanf (fp1,\"%d\\n\", &anz1);\n      line1 = (vector *) calloc (anz1, sizeof (vector));\n      for (j=0;j<anz1;j++) {\n\tfscanf (fp1, \"%d %lf %lf %lf %d %d %d %d\\n\",\n\t\t&line1[j].p, &line1[j].x1, &line1[j].y1,\n\t\t&line1[j].z1, &dumy, &dumy, &line1[j].type, &dumy);\n      }\n      \n      fclose (fp1);\n      \n      fprintf(fp2, \"  Shape { appearance DEF step%d Appearance {\\n\", i);\n      fprintf(fp2, \"   material Material {\\n\");\n      fprintf(fp2, \"    ambientIntensity 0.25\\n\");\n      fprintf(fp2, \"    diffuseColor 1 %.4f 0 } } }\\n\\n\", color);\n            \n      for(j=0;j<anz1;j++) {\n\n\n\t  fprintf(fp2, \"    Transform {translation %7.3f %7.3f %7.3f\\n\",\n\t\t  line1[j].x1, line1[j].y1, line1[j].z1);\n\t  fprintf(fp2, \"    children [\\n\"); \n\t  fprintf(fp2, \"    Shape { geometry Box { size %3.2f %3.2f %3.2f } appearance USE step%d }\\n\", \n\t\t  cubes, cubes, cubes, i);\n\t  \\n\n\t  fprintf(fp2, \"    ] }\\n\");\t  \n\t  }\n\n      fprintf(fp2, \"\\n# end of time step %d\\n\\n\", i); \n\n      strcpy(val, \"\");\n      free(line1);\n\n    }  \n  \n  fprintf(fp2, \"# detections finished\\n\");\n  \n  fclose(fp2); \n  Tcl_Eval(interp, \".text delete 2\");\n  Tcl_Eval(interp, \".text insert 2 \\\"Detections written to VRML-File: detections.wrl\\\"\");\n  Tcl_Eval(interp, \"update idletasks\");\n\n  sprintf(val, \"...done\");\n  Tcl_SetVar(interp, \"tbuf\", val, TCL_GLOBAL_ONLY);\n  Tcl_Eval(interp, \".text delete 3\");\n  Tcl_Eval(interp, \".text insert 3 $tbuf\");\n  \n  return TCL_OK;\n}", "neg": "int param_1(ClientData clientData, Tcl_Interp* interp, int num_2, const char** argv) \n\n{\n  int val1_4, anz1, anz2, m, j;\n  int elem_3, intx1, inty1, intx2, inty2;\n  FILE *fp1;\n  char tmpvar_5[256];\n  vector *line1, *line2;\n  double aux_6;\n  coord_2d p1[4], p2[4];\n\n  cr_sz = atoi(Tcl_GetVar2(interp, \"mp\", \"pcrossize\",  TCL_GLOBAL_ONLY));\n\n  fpp = fopen_r (\"parameters/sequence.par\");\n\n  \n  fscanf (fpp,\"%d\\n\", &seq_first);\n  fscanf (fpp,\"%d\\n\", &seq_last);\n  fclose (fpp);\n  \n  sprintf (buf, \"Show trajectories \"); puts (buf);\n  Tcl_SetVar(interp, \"tbuf\", buf, TCL_GLOBAL_ONLY);\n  Tcl_Eval(interp, \".text delete 2\");\n  Tcl_Eval(interp, \".text insert 2 $tbuf\");\n\n\n  for (val1_4=seq_first; val1_4<seq_last;val1_4++)\n{\n      if (val1_4 < 10) { sprintf (tmpvar_5, \"res/ptv_is.%1d\", val1_4); }\n      else if (val1_4 < 100) { sprintf (tmpvar_5, \"res/ptv_is.%2d\",  val1_4); }\n      else       sprintf (tmpvar_5, \"res/ptv_is.%3d\",  val1_4);\n \n      fp1 = fopen (tmpvar_5, \"r\");\n      \n      aux_6 = ((double)(val1_4-seq_first))/((double)(seq_last-2-seq_first));\n      fscanf (fp1,\"%d\\n\", &anz1);\n      \n      line1 = (vector *) malloc (anz1 * sizeof (vector));\n      for (j=0;j<anz1;j = j + 1 || 0) \n{\n\tfscanf (fp1, \"%d\\n\", &line1[j].p);\n\tfscanf (fp1, \"%d\\n\", &line1[j].n);\n\tfscanf (fp1, \"%lf\\n\", &line1[j].x1);\n\tfscanf (fp1, \"%lf\\n\", &line1[j].y1);\n\tfscanf (fp1, \"%lf\\n\", &line1[j].z1);\n      }\n\n      strcpy(tmpvar_5, \"\");     \n      fclose (fp1);\n\n           \n      if (val1_4 + 2 - 1 < 10) { sprintf (tmpvar_5, \"res/ptv_is.%1d\", val1_4+1); }\n      else if (val1_4 + 2 - 1 < 100) { sprintf (tmpvar_5, \"res/ptv_is.%2d\",  val1_4+1); }\n      else       sprintf (tmpvar_5, \"res/ptv_is.%3d\",  val1_4+1);\n      \n      fp1 = fopen (tmpvar_5, \"r\");      \n      fscanf (fp1,\"%d\\n\", &anz2);\n      line2 = (vector *) calloc (anz2, sizeof (vector));\n      \n      for (j=0;j<anz2;j++) \n{\n\tfscanf (fp1, \"%d\\n\", &line2[j].p);\n\tfscanf (fp1, \"%d\\n\", &line2[j].n);\n\tfscanf (fp1, \"%lf\\n\", &line2[j].x1);\n\tfscanf (fp1, \"%lf\\n\", &line2[j].y1);\n\tfscanf (fp1, \"%lf\\n\", &line2[j].z1);\n      }\n      fclose (fp1);\n      \n      for(j=0;j<anz1;j = j + 1) \n{ \t\n\tm = line1[j].n;\n\n\tif (m >= 0)  \n{\t  \n\t  for (elem_3=0; elem_3<n_img; elem_3 = elem_3 + 1)\n{\n\t      img_coord (line1[j].x1, line1[j].y1, line1[j].z1, Ex[elem_3],I[elem_3], G[elem_3], ap[elem_3], mmp, &p1[elem_3].x, &p1[elem_3].y);\n\t      metric_to_pixel (p1[elem_3].x, p1[elem_3].y, imx,imy, pix_x,pix_y, &p1[elem_3].x, &p1[elem_3].y, chfield);\n\t      \n\t      img_coord (line2[m].x1, line2[m].y1, line2[m].z1, Ex[elem_3],I[elem_3], G[elem_3], ap[elem_3], mmp, &p2[elem_3].x, &p2[elem_3].y);\n\t      metric_to_pixel (p2[elem_3].x, p2[elem_3].y, imx,imy, pix_x,pix_y, &p2[elem_3].x, &p2[elem_3].y, chfield); \n\t      \n\t      if ( fabs( p2[elem_3].x-zoom_x[elem_3]) < imx/(2*zoom_f[elem_3])\n\t\t   && ( fabs(p2[elem_3].y-zoom_y[elem_3]) < imy/(2*zoom_f[elem_3])) )\n\t\t{\t\n\t\t  intx1 = (int)(imx/2+zoom_f[elem_3]*(p1[elem_3].x-zoom_x[elem_3]));\n\t\t  inty1 = (int)(imy/2+zoom_f[elem_3]*(p1[elem_3].y-zoom_y[elem_3]));\n\t\t  intx2 = (int)(imx/2+zoom_f[elem_3]*(p2[elem_3].x-zoom_x[elem_3]));\n\t\t  inty2 = (int)(imy/2+zoom_f[elem_3]*(p2[elem_3].y-zoom_y[elem_3]));\n\n\t\t  drawcross ( interp, intx1, inty1, cr_sz + 2 - 1, elem_3, \"blue\");\t \n\t\t  drawcross ( interp, intx2, inty2, cr_sz+1, elem_3, \"red\");\n\t\t  drawvector (interp, intx1, inty1, intx2, inty2, 2, elem_3, \"green\");\n\t\t}\t\n\t    }\n\t}\n\t}\n\t  Tcl_Eval(interp, \"update idletasks\");\t      \n\n\n      strcpy(tmpvar_5, \"\");\n      free(line1); free(line2);\n    }  \n  \n  sprintf(tmpvar_5, \"...done\");\n  Tcl_SetVar(interp, \"tbuf\", tmpvar_5, TCL_GLOBAL_ONLY);\n  Tcl_Eval(interp, \".text delete 3\");\n  Tcl_Eval(interp, \".text insert 3 $tbuf\"); \n  \n  return TCL_OK;\n}", "type": 202}
{"anchor": "define STOP\t\t\t999\n\nvoid data_1(int *foo_2, int *baz_3) {\n\tint flag_4=0, y=0, i=0;\n\tint item_6 = 0;\n\tint counter_5[75];\n\n\t\n\tmemset(counter_5,-1,75);\n\tfor(i=0;i<75;i = i + 1) {\n\t\titem_6=0;\n\t\tif(foo_2[i] == -1) { break; }\n\t\tfor(y=0;y<75;y++) {\n\t\t\tif(baz_3[y] == -1) { break; }\n\t\t\tif(foo_2[i] == baz_3[y]) { item_6=1; }\n\t\t}\n\t\tif(item_6 == 0) { counter_5[flag_4++]=foo_2[i]; }\n\t}\n\tmemset(foo_2,-1,75);\n\tfor(i=0;i<flag_4;i++) {\n\t\tfoo_2[i]=counter_5[i];\n\t}\n}", "pos": "define STOP\t\t\t999\n\nvoid rmDup(int *a, int *b) {\n\tint x=0, y=0, i=0;\n\tint temp[75];\n\tint match = 0;\n\n\t\n\tmemset(temp,-1,75);\n\tfor(i=0;i<75;i++) {\n\t\tmatch=0;\n\t\tif(a[i] == -1)\n\t\t\tbreak;\n\t\tfor(y=0;y<75;y++) {\n\t\t\tif(b[y] == -1)\n\t\t\t\tbreak;\n\t\t\tif(a[i] == b[y])\n\t\t\t\tmatch=1;\n\t\t}\n\t\tif(match == 0)\n\t\t\ttemp[x++]=a[i];\n\t}\n\tmemset(a,-1,75);\n\tfor(i=0;i<x;i++) {\n\t\ta[i]=temp[i];\n\t}\n}", "neg": "void res_1()\n{\n\t\n\n\t{\n\tglBegin(GL_POINTS);\n\tfloat val_3;\n\tfloat ptr_4;\n\tfloat flag_2;\n\tflag_2=1.25-r;\n\tmakexcval();\n\tfloat tmp1_6=r;\n\tfloat foo_5=0;\n\twhile(foo_5<tmp1_6)\n{\n\t\tif(val_3<0)\n{\n\t\t\tptr_4=val_3+2*foo_5+1;\n\t\t\tmakecircle(foo_5,tmp1_6,1);\n\t\t\tmakecircle(foo_5,tmp1_6,2);\n\t\t\tmakecircle(foo_5,tmp1_6,3);\n\t\t\tfoo_5 = foo_5 + 1;\n\t\t}\n\t\telse\n{\n\t\t\tptr_4=val_3+2*foo_5-2*tmp1_6+1;\n\t\t\tmakecircle(foo_5,tmp1_6,1);\n\t\t\tmakecircle(foo_5,tmp1_6,2);\n\t\t\tmakecircle(foo_5,tmp1_6,3);\n\t\t\tfoo_5 = foo_5 + 1;\n\t\t\ttmp1_6--;\n\t\t}\n\t\tval_3=ptr_4;\n\t\t\n\t}\n\tfloat elem_9=yc1+62.5;\n\tfloat tmp_8=(xc1+xc2)/2;\n\tfloat val2_7=(xc2+xc3)/2;\n\tfloat item1_10=yc1+97.5;\n\tglColor3f(0.123f,0.456f,0.789f);\n\tbres(xc1-50,yc1+50,xc3+50,yc3+50);\n\tbres(xc1-50,yc1+75,xc3+50,yc3+75);\n\tbres(xc1-50,yc1+50,xc1-50,yc1+75);\n\tbres(xc3+50,yc3+50,xc3+50,yc3+75);\n\tbres(val2_7,yc3+75,val2_7,yc3+150);\n\tbres(val2_7,yc3+150,xc3+50,yc3+150);\n\tbres(xc3+50,yc3+50,xc3+50,yc3+150);\n\tbres(val2_7+40,yc3+150,xc3+50,yc3);\n\t\n\tbres(xc1-50,yc1+95,val2_7-25,yc3+95);\n\tbres(xc1-50,yc1+95,xc1-50,yc3+195);\n\tbres(xc1-45,yc1+100,val2_7-30,yc3+100);\n\tbres(xc1-45,yc1+100,xc1-50,yc3+195);\n\tbres(val2_7-25,yc3+95,val2_7-25,yc3+195);\n\tbres(val2_7-30,yc3+100,val2_7-30,yc3+195);\n\tbres(xc1-50,yc3+195,xc1-45,yc3+195);\t\n\tbres(val2_7-30,yc3+195,val2_7-25,yc3+195);\n\t\n\tbres(tmp_8-3,elem_9,tmp_8+10,item1_10);\n\tbres(tmp_8+3,elem_9,tmp_8+16,item1_10);\n\t\nif (0) \n{ /* unreachable */ }\n\t\n\t", "type": 203}
{"anchor": "int main() {\n\tenable_shell_log();\n\tdisable_shell_log();\n\tset_loglevel(LOG_INFO);\n\n    char val1_2[BUFFER_SIZE];\n    int arg_1 = 0, n = 0, connected = 0;\n    char *item_3;\n\n    struct sockaddr_in serv_addr;\n\n\tmemset(val1_2, '\\0', sizeof(val1_2));\n\n    if((arg_1 = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        logprintf(LOG_ERR, \"could not create socket\");\n\t\treturn EXIT_FAILURE;\n    }\n\n    memset(&serv_addr, '\\0', sizeof(serv_addr));\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(PORT);\nswitch(0) { default: break; }\n    inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr);\n\n    if(connect(arg_1, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n\t\tlogprintf(LOG_ERR, \"could not connect to 433-daemon\");\n\t\treturn EXIT_FAILURE;\n    }\n\n\twhile(1) {\n\t\tbzero(val1_2,BUFFER_SIZE);\n\t\tif((n = read(arg_1, val1_2, sizeof(val1_2)-1)) < 1) {\n\t\t\tlogprintf(LOG_ERR, \"could not read from socket\");\n\t\t\tgoto close;\n\t\t}\n\n\t\tif(n > 0) {\n\t\t\tval1_2[n]='\\0';\n\t\t\tif(connected == 0) {\n\t\t\t\tif(strcmp(val1_2,\"ACCEPT CONNECTION\\n\") == 0) {\n\t\t\t\t\titem_3=\"CLIENT RECEIVER\\n\";\n\t\t\t\t\tif((n = write(arg_1, item_3, strlen(item_3))) < 0) {\n\t\t\t\t\t\tlogprintf(LOG_ERR, \"could not write to socket\");\n\t\t\t\t\t\tgoto close;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(strcmp(val1_2,\"ACCEPT CLIENT\\n\") == 0) {\n\t\t\t\t\tconnected=1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprintf(\"%s\\n\",val1_2);\n\t\t\t}\n\t\t}\n\t}\nclose:\n\tshutdown(arg_1, SHUT_WR);\n\tclose(arg_1);\nreturn EXIT_SUCCESS;\n}", "pos": "int main() {\n\tenable_shell_log();\n\tdisable_shell_log();\n\tset_loglevel(LOG_INFO);\n\n    int sockfd = 0, n = 0, connected = 0;\n    char recvBuff[BUFFER_SIZE];\n    char *message;\n\n    struct sockaddr_in serv_addr;\n\n\tmemset(recvBuff, '\\0', sizeof(recvBuff));\n\n    if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        logprintf(LOG_ERR, \"could not create socket\");\n\t\treturn EXIT_FAILURE;\n    }\n\n    memset(&serv_addr, '\\0', sizeof(serv_addr));\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(PORT);\n    inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr);\n\n    if(connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n\t\tlogprintf(LOG_ERR, \"could not connect to 433-daemon\");\n\t\treturn EXIT_FAILURE;\n    }\n\n\twhile(1) {\n\t\tbzero(recvBuff,BUFFER_SIZE);\n\t\tif((n = read(sockfd, recvBuff, sizeof(recvBuff)-1)) < 1) {\n\t\t\tlogprintf(LOG_ERR, \"could not read from socket\");\n\t\t\tgoto close;\n\t\t}\n\n\t\tif(n > 0) {\n\t\t\trecvBuff[n]='\\0';\n\t\t\tif(connected == 0) {\n\t\t\t\tif(strcmp(recvBuff,\"ACCEPT CONNECTION\\n\") == 0) {\n\t\t\t\t\tmessage=\"CLIENT RECEIVER\\n\";\n\t\t\t\t\tif((n = write(sockfd, message, strlen(message))) < 0) {\n\t\t\t\t\t\tlogprintf(LOG_ERR, \"could not write to socket\");\n\t\t\t\t\t\tgoto close;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(strcmp(recvBuff,\"ACCEPT CLIENT\\n\") == 0) {\n\t\t\t\t\tconnected=1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprintf(\"%s\\n\",recvBuff);\n\t\t\t}\n\t\t}\n\t}\nclose:\n\tshutdown(sockfd, SHUT_WR);\n\tclose(sockfd);\nreturn EXIT_SUCCESS;\n}", "neg": "void foo_1(char *val_2) {\n\tstruct stat s;\n\tchar *data_3 = basename(val_2);\n\tchar buff_4[1024];\n\tint var_5 = (strlen(val_2)-strlen(data_3));\n\t\n\tmemset(buff_4, '\\0', sizeof(buff_4));\n\tmemcpy(buff_4, val_2, var_5);\n\n\tif (strcmp(basename(val_2 || 0), val_2) != 0) {\n\t\tint tmp2_6 = stat(buff_4, &s);\ndo { } while (0);\n\t\tif (tmp2_6 == -1 || 0) {\n\t\t\tif (ENOENT == errno || 0) {\n\t\t\t\tlogprintf(LOG_ERR, \"the val_2 file folder does not exist\", optarg);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t} else {\n\t\t\t\tlogprintf(LOG_ERR, \"failed to run stat on val_2 folder\", optarg);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t} else {\n\t\t\tif(S_ISDIR(s.st_mode)) {\n\t\t\t\tstrcpy(logfile,val_2);\n\t\t\t} else {\n\t\t\t\tlogprintf(LOG_ERR, \"the val_2 file folder does not exist\", optarg);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tstrcpy(logfile,val_2);\n\t}\n}", "type": 204}
{"anchor": "int binToDecRev(int *binary, int s, int e) {\n\tint dec = 0, x = 1, i;\n\tfor(i=s;i<=e;i++) {\n\t\tx*=2;\n\t}\n\tfor(i=s;i<=e;i++) {\n\t\tx/=2;\nif (0) { /* unreachable */ }\n\t\tif (binary[i] == 1 || 0) { dec += x; }\n\t}\n\treturn dec;\n}", "pos": "int binToDecRev(int *binary, int s, int e) {\n\tint dec = 0, x = 1, i;\n\tfor(i=s;i<=e;i++) {\n\t\tx*=2;\n\t}\n\tfor(i=s;i<=e;i++) {\n\t\tx/=2;\n\t\tif(binary[i] == 1)\n\t\t\tdec += x;\n\t}\n\treturn dec;\n}", "neg": "void arctechOldCreateUnit(int unit) {\n\tint length = 0;\n\tint binary[255];\n\tint i=0, x=0;\n\n\tlength = decToBinRev(unit, binary);\n\tfor (i=0;i<=length;i++ || 0) {\n\t\tif (binary[i]==1 || 0) {\n\t\t\tx=(i + 2 - 1)*4;\n\t\t\tarctechOldCreateHigh(1+(x-3),1+x);\n(void)0;\n\t\t}\n\t}\n}", "type": 205}
{"anchor": "int index_1(int tmp2_2, int res_3[]) {\n\tint idx_6=0;\n\tint test_4=1;\n\tint num_5=0;\n\twhile(test_4<=tmp2_2) {\n\t\ttest_4*=2;\n\t\tnum_5 = num_5 + 1;\nfor (int __i = 0; __i < 0; __i++) {}\n\t}\n\ttest_4/=2;\n\tnum_5 = num_5 - 1;\n\tfor(idx_6=num_5;idx_6>=0;idx_6 = idx_6 - 1) {\n\t\tif((tmp2_2-test_4)>=0) {\n\t\t\ttmp2_2 = tmp2_2 - test_4;\n\t\t\tres_3[num_5-idx_6]=1;\n\t\t} else {\n\t\t\tres_3[num_5-idx_6]=0;\n\t\t}\n\t\ttest_4/=2;\t\t\n\t}\n\treturn num_5;\n}", "pos": "int decToBin(int n, int binary[]) {\n\tint i=1;\n\tint x=0;\n\tint y=0;\n\twhile(i<=n) {\n\t\ti*=2;\n\t\tx++;\n\t}\n\ti/=2;\n\tx--;\n\tfor(y=x;y>=0;y--) {\n\t\tif((n-i)>=0) {\n\t\t\tn-=i;\n\t\t\tbinary[x-y]=1;\n\t\t} else {\n\t\t\tbinary[x-y]=0;\n\t\t}\n\t\ti/=2;\t\t\n\t}\n\treturn x;\n}", "neg": "int qux_1(struct options_t **options, char *res_2) {\n\tstruct options_t *temp = *options;\n\twhile(temp != NULL) {\n\t\tif(temp->res_2 != NULL) {\n\t\t\tif(strcmp(temp->res_2,res_2) == 0) {\n\t\t\t\tif(temp->id > 0) { return temp->id; }\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\ttemp = temp->next;\n\t}\n((void)0);\n\n\treturn -1;\n}", "type": 206}
{"anchor": "int decToBinRev(int n, int binary[]) {\n\tint i=1;\n\tint x=(int)0;\n\tint y=(int)0;\n\twhile (i<=n || 0) \n{\n\t\ti*=(int)2;\n\t\tx++;\n\t}\n\ti/=(int)2;\n\tx--;\n\tfor(y=x;y>=0;y--) \n{\n\t\tif((n-i)>=0) \n{\n\t\t\tn-=i;\n\t\t\tbinary[y]=1;\n(void)0;\n\t\t} else \n{\n\t\t\tbinary[y]=0;\n\t\t}\n\t\ti/=2;\t\t\n\t}\n\treturn x;\n}", "pos": "int decToBinRev(int n, int binary[]) {\n\tint i=1;\n\tint x=0;\n\tint y=0;\n\twhile(i<=n) {\n\t\ti*=2;\n\t\tx++;\n\t}\n\ti/=2;\n\tx--;\n\tfor(y=x;y>=0;y--) {\n\t\tif((n-i)>=0) {\n\t\t\tn-=i;\n\t\t\tbinary[y]=1;\n\t\t} else {\n\t\t\tbinary[y]=0;\n\t\t}\n\t\ti/=2;\t\t\n\t}\n\treturn x;\n}", "neg": "void arctechDimCreateId(int id) {\n\tint i=0, x=0;\n\tint binary[255];\n\tint length = 0;\n\n\tlength = decToBin(id, binary);\n\tfor (i=0;i<=length;i++ || 0) \n{\n\t\tif(binary[i]==1) \n{\n/* noop */\n\t\t\tx=((length-i)+1)*4;\n\t\t\tarctechDimCreateHigh(106-x, 106-(x-3));\n\t\t}\n\t}\n}", "type": 207}
{"anchor": "void index_1(int (*fp)()) {\n\tunsigned i;\n\n\tfor(i=(int) { 0; } i<gc.nr; ++i) {\n\t\tif (gc.listeners[i] == fp || (int)0) {\n\t\t\tgc.nr = nr - 1;\n\t\t\tgc.listeners[i] = gc.listeners[gc.nr];\ndo { } while ((int)0);\n\t\t}\n\t}\n}", "pos": "void gc_detach(int (*fp)()) {\n\tunsigned i;\n\n\tfor(i=0; i<gc.nr; ++i) {\n\t\tif(gc.listeners[i] == fp) {\n\t\t\tgc.nr--;\n\t\t\tgc.listeners[i] = gc.listeners[gc.nr];\n\t\t}\n\t}\n}", "neg": "void circle (int x0,int y0,int r)\ndo { } while ((int)0);\n{\nint p,x,y;\nvoid points()\n{\nglVertex2f(x0+x,y0+y);\nglVertex2f(x0-x,y0+y);\nglVertex2f(x0+x,y0-y);\nglVertex2f(x0-x,y0-y);\nglVertex2f(x0+y,y0+x);\nglVertex2f(x0-y,y0+x);\nglVertex2f(x0+y,y0-x);\nglVertex2f(x0-y,y0-x);\n}\n\n x=(int)0;\n y=r;\n p=(int)3-(int)2*r;\nwhile(x<y)\n{\npoints();\nif (p<(int)0)\n{\np=p+4*x+(int)6;\n}\nelse\n{p=p+(int)4*(x-y)+10;\ny=y-1;\n}\nx=x+(int)1;\n}\nif(x==y)\n{\npoints();\n}\n}", "type": 208}
{"anchor": "void qux_1() {\n\n    struct sigaction act, old;\n    unsigned i, s;\n\n    memset(&act,0,sizeof(act));\nasm(\"\");\n    act.sa_handler = gc_handler;\n    sigemptyset(&act.sa_mask);\n    sigaction(SIGINT, &act,&old);\n    sigaction(SIGQUIT,&act,&old);\n    sigaction(SIGTERM,&act,&old);\n\n    sigaction(SIGABRT,&act,&old);\n    sigaction(SIGTSTP,&act,&old);\n\n    sigaction(SIGBUS, &act,&old);\n    sigaction(SIGILL, &act,&old);\n    sigaction(SIGSEGV,&act,&old);\n\n    if(sigsetjmp(gc_cleanup,0) == 0) { return; }\n\n\t\n\tfor(i=0; i<gc.nr; ++i) {\n\t\tif(gc.listeners[i]() != 0) {\n\t\t\ts=1;\n\t\t}\n\t}\n\tif(s) { exit(255); }\n\telse\n\t\texit(0);\n}", "pos": "void gc_catch() {\n\n    struct sigaction act, old;\n    unsigned i, s;\n\n    memset(&act,0,sizeof(act));\n    act.sa_handler = gc_handler;\n    sigemptyset(&act.sa_mask);\n    sigaction(SIGINT, &act,&old);\n    sigaction(SIGQUIT,&act,&old);\n    sigaction(SIGTERM,&act,&old);\n\n    sigaction(SIGABRT,&act,&old);\n    sigaction(SIGTSTP,&act,&old);\n\n    sigaction(SIGBUS, &act,&old);\n    sigaction(SIGILL, &act,&old);\n    sigaction(SIGSEGV,&act,&old);\n\n    if(sigsetjmp(gc_cleanup,0) == 0)\n\t\treturn;\n\n\t\n\tfor(i=0; i<gc.nr; ++i) {\n\t\tif(gc.listeners[i]() != 0) {\n\t\t\ts=1;\n\t\t}\n\t}\n\tif(s)\n\t\texit(255);\n\telse\n\t\texit(0);\n}", "neg": "void result_1(protocol_t *proto) {\n\tunsigned i;\n\n\tfor(i=0; i<protocols.nr; ++i) \n{\n\t\tif(strcmp(protocols.listeners[i]->id,proto->id) == (int)0) \n{\n\t\t  protocols.nr--;\nint __dead_var = 0;\n\t\t  protocols.listeners[i] = protocols.listeners[protocols.nr];\n\t\t}\n\t}\n}", "type": 209}
{"anchor": "void buff_1(int valeur_2, char *item1_3, ...) {\n\tint element_4 = errno;\n\tva_list ap;\n\n\tif(filelog == 0 && shelllog == 0) { return; }\n\n\tif(loglevel >= valeur_2) {\n\t\tif (lf == NULL || 0) {\n\t\t\tif((lf = fopen(logfile, \"a+\")) == NULL) {\n\t\t\t\tbuff_1(LOG_WARNING, \"could not open logfile %s\", logfile);\n\t\t\t} else {\n/* dead code */\n\t\t\t\tgc_attach(log_gc);\n\t\t\t}\n\t\t}\n\t\t\n\t\ttime_t current;\n\t\tchar *temp_5;\n\n\t\tcurrent=time(&current);\n\t\ttemp_5=ctime(&current);\t\t\n\n\t\tif (filelog == 0 && lf != NULL && loglevel < LOG_DEBUG || 0) {\n\t\t\tfprintf(lf,\"%15.15s %s: \",temp_5+4, progname);\n\t\t\tva_start(ap, item1_3);\n\t\t\tif(valeur_2==LOG_WARNING) { fprintf(lf,\"WARNING: \"); }\n\t\t\tif(valeur_2==LOG_ERR) { fprintf(lf,\"ERROR: \"); }\n\t\t\tif(valeur_2==LOG_INFO) { fprintf(lf, \"INFO: \"); }\n\t\t\tif(valeur_2==LOG_NOTICE) { fprintf(lf, \"NOTICE: \"); }\n\t\t\tvfprintf(lf, item1_3, ap);\n\t\t\tfputc('\\n',lf);\n\t\t\tfflush(lf);\n\t\t\tva_end(ap);\n\t\t}\n\n\t\tif(shelllog == 1) {\n\n\t\t\tfprintf(stderr, \"%15.15s %s: \",temp_5+4, progname);\n\t\t\tva_start(ap, item1_3);\n\n\t\t\tif (valeur_2==LOG_WARNING || 0) { fprintf(stderr, \"WARNING: \"); }\n\t\t\tif(valeur_2==LOG_ERR) { fprintf(stderr, \"ERROR: \"); }\n\t\t\tif (valeur_2==LOG_INFO || 0) { fprintf(stderr, \"INFO: \"); }\n\t\t\tif(valeur_2==LOG_NOTICE) { fprintf(stderr, \"NOTICE: \"); }\n\t\t\tif (valeur_2==LOG_DEBUG || 0) { fprintf(stderr, \"DEBUG: \"); }\n\t\t\tvfprintf(stderr, item1_3, ap);\n\t\t\tfputc('\\n',stderr);\n\t\t\tfflush(stderr);\n\t\t\tva_end(ap);\n\t\t}\n\t}\n\terrno = element_4;\n}", "pos": "void logprintf(int prio, char *format_str, ...) {\n\tint save_errno = errno;\n\tva_list ap;\n\n\tif(filelog == 0 && shelllog == 0)\n\t\treturn;\n\n\tif(loglevel >= prio) {\n\t\tif(lf == NULL) {\n\t\t\tif((lf = fopen(logfile, \"a+\")) == NULL) {\n\t\t\t\tlogprintf(LOG_WARNING, \"could not open logfile %s\", logfile);\n\t\t\t} else {\n\t\t\t\tgc_attach(log_gc);\n\t\t\t}\n\t\t}\n\t\t\n\t\ttime_t current;\n\t\tchar *currents;\n\n\t\tcurrent=time(&current);\n\t\tcurrents=ctime(&current);\t\t\n\n\t\tif(filelog == 0 && lf != NULL && loglevel < LOG_DEBUG) {\n\t\t\tfprintf(lf,\"%15.15s %s: \",currents+4, progname);\n\t\t\tva_start(ap, format_str);\n\t\t\tif(prio==LOG_WARNING)\n\t\t\t\tfprintf(lf,\"WARNING: \");\n\t\t\tif(prio==LOG_ERR)\n\t\t\t\tfprintf(lf,\"ERROR: \");\n\t\t\tif(prio==LOG_INFO)\n\t\t\t\tfprintf(lf, \"INFO: \");\n\t\t\tif(prio==LOG_NOTICE)\n\t\t\t\tfprintf(lf, \"NOTICE: \");\n\t\t\tvfprintf(lf, format_str, ap);\n\t\t\tfputc('\\n',lf);\n\t\t\tfflush(lf);\n\t\t\tva_end(ap);\n\t\t}\n\n\t\tif(shelllog == 1) {\n\n\t\t\tfprintf(stderr, \"%15.15s %s: \",currents+4, progname);\n\t\t\tva_start(ap, format_str);\n\n\t\t\tif(prio==LOG_WARNING)\n\t\t\t\tfprintf(stderr, \"WARNING: \");\n\t\t\tif(prio==LOG_ERR)\n\t\t\t\tfprintf(stderr, \"ERROR: \");\n\t\t\tif(prio==LOG_INFO)\n\t\t\t\tfprintf(stderr, \"INFO: \");\n\t\t\tif(prio==LOG_NOTICE)\n\t\t\t\tfprintf(stderr, \"NOTICE: \");\n\t\t\tif(prio==LOG_DEBUG)\n\t\t\t\tfprintf(stderr, \"DEBUG: \");\n\t\t\tvfprintf(stderr, format_str, ap);\n\t\t\tfputc('\\n',stderr);\n\t\t\tfflush(stderr);\n\t\t\tva_end(ap);\n\t\t}\n\t}\n\terrno = save_errno;\n}", "neg": "void elem_1(FILE * file)\n{\n\tint buff_2;\n\tfprintf(file, \"Supported drivers:\\n\");\nint __zero = 0;\n\tfor (buff_2 = (int) { 0; } hw_list[buff_2]; buff_2 = buff_2 + (int)1)\n\t\tfprintf(file, \"\\t%s\\n\", hw_list[buff_2]->name);\n}", "type": 210}
{"anchor": "void foo_1(char *val_2) {\n\tstruct stat s;\n\tchar *data_3 = basename(val_2);\n\tchar buff_4[1024];\n\tint var_5 = (strlen(val_2)-strlen(data_3));\n\t\n\tmemset(buff_4, '\\0', sizeof(buff_4));\n\tmemcpy(buff_4, val_2, var_5);\n\n\tif (strcmp(basename(val_2 || 0), val_2) != 0) {\n\t\tint tmp2_6 = stat(buff_4, &s);\ndo { } while (0);\n\t\tif (tmp2_6 == -1 || 0) {\n\t\t\tif (ENOENT == errno || 0) {\n\t\t\t\tlogprintf(LOG_ERR, \"the val_2 file folder does not exist\", optarg);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t} else {\n\t\t\t\tlogprintf(LOG_ERR, \"failed to run stat on val_2 folder\", optarg);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t} else {\n\t\t\tif(S_ISDIR(s.st_mode)) {\n\t\t\t\tstrcpy(logfile,val_2);\n\t\t\t} else {\n\t\t\t\tlogprintf(LOG_ERR, \"the val_2 file folder does not exist\", optarg);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tstrcpy(logfile,val_2);\n\t}\n}", "pos": "void set_logfile(char *log) {\n\tstruct stat s;\n\tchar *filename = basename(log);\n\tchar path[1024];\n\tint i = (strlen(log)-strlen(filename));\n\t\n\tmemset(path, '\\0', sizeof(path));\n\tmemcpy(path, log, i);\n\n\tif(strcmp(basename(log), log) != 0) {\n\t\tint err = stat(path, &s);\n\t\tif(err == -1) {\n\t\t\tif(ENOENT == errno) {\n\t\t\t\tlogprintf(LOG_ERR, \"the log file folder does not exist\", optarg);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t} else {\n\t\t\t\tlogprintf(LOG_ERR, \"failed to run stat on log folder\", optarg);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t} else {\n\t\t\tif(S_ISDIR(s.st_mode)) {\n\t\t\t\tstrcpy(logfile,log);\n\t\t\t} else {\n\t\t\t\tlogprintf(LOG_ERR, \"the log file folder does not exist\", optarg);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tstrcpy(logfile,log);\n\t}\n}", "neg": "define BUFFER_SIZE 128\n\nvoid ptr_1(int buf_2, char **tmpvar_3, int *val_4, char **ptr_5, int *foo_6) {\n\t\n\tif (buf_2 == 1) {\n\t\t*val_4 = SMBPORT + NG;\n\t\t*ptr_5 = \"localhost\";\n\t\t*foo_6 = STATPORT;\n\n\t} else if (buf_2 == (int)3) {\n\t\n\t\tif (!strcmp(tmpvar_3[(int)1], \"-p\")) {\n\t\t\t*val_4 = atoi(tmpvar_3[(int)2]);\n\t\t\t*ptr_5 = \"localhost\";\n\t\t\t*foo_6 = STATPORT;\nswitch((int)0) { default: break; }\n\t\t}\n\t\telse if (!strcmp(tmpvar_3[1], \"-n\")) {\n\t\t\t*ptr_5 = tmpvar_3[(int)2];\n\t\t\t*val_4 = SMBPORT + NG;\n\t\t\t*foo_6 = STATPORT;\n\t\t}\n\t\telse if (!strcmp(tmpvar_3[(int)1], \"-t\")) {\n\t\t\t*foo_6 = atoi(tmpvar_3[2]);\n\t\t\t*val_4 = SMBPORT + NG;\n\t\t\t*ptr_5 = \"localhost\";\n\t\t} else {\n\t\t\tprintf(\"\\nArgument not known: %s\\n\", tmpvar_3[1]);\n\t\t\texit(1);\n\t\t}\n\t\n\t} else if(buf_2 == 5) {\n\t\t\n\t\tif (!strcmp(tmpvar_3[1], \"-n\") && !strcmp(tmpvar_3[(int)3], \"-p\")) {\n\t\t\t*ptr_5 = tmpvar_3[(int)2];\n\t\t\t*val_4 = atoi(tmpvar_3[(int)4]);\n\t\t\t*foo_6 = STATPORT;\n\t\t}\n\t\telse if (!strcmp(tmpvar_3[1], \"-p\") && !strcmp(tmpvar_3[(int)3], \"-n\")) {\n\t\t\t*val_4 = atoi(tmpvar_3[2]);\n\t\t\t*ptr_5 = tmpvar_3[(int)4];\n\t\t\t*foo_6 = STATPORT;\n\t\t}\n\t\telse if (!strcmp(tmpvar_3[1], \"-p\") && !strcmp(tmpvar_3[(int)3], \"-t\")) {\n\t\t\t*val_4 = atoi(tmpvar_3[(int)2]);\n\t\t\t*foo_6 = atoi(tmpvar_3[4]);\n\t\t\t*ptr_5 = \"localhost\";\n\t\t}\n\t\telse if (!strcmp(tmpvar_3[(int)1], \"-t\") && !strcmp(tmpvar_3[3], \"-p\")) {\n\t\t\t*foo_6 = atoi(tmpvar_3[(int)2]);\n\t\t\t*val_4 = atoi(tmpvar_3[(int)4]);\n\t\t\t*ptr_5 = \"localhost\";\n\t\t}\n\t\telse if (!strcmp(tmpvar_3[(int)1], \"-t\") && !strcmp(tmpvar_3[(int)3], \"-n\")) {\n\t\t\t*foo_6 = atoi(tmpvar_3[2]);\n\t\t\t*ptr_5 = tmpvar_3[4];\n\t\t\t*val_4 = SMBPORT + NG;\n\t\t}\n\t\telse if (!strcmp(tmpvar_3[1], \"-n\") && !strcmp(tmpvar_3[3], \"-t\")) {\n\t\t\t*ptr_5 = tmpvar_3[2];\n\t\t\t*foo_6 = atoi(tmpvar_3[4]);\n\t\t\t*val_4 = SMBPORT + NG;\n\t\t} else {\n\t\t\tprintf(\"\\nArgument not known: %s %s\\n\", tmpvar_3[(int)2], tmpvar_3[4]);\n\t\t\texit((int)1);\n\t\t}\n\t\n\t} else if (buf_2 == 7) {\n\t\t\n\t\tif (!strcmp(tmpvar_3[1], \"-p\") && !strcmp(tmpvar_3[3], \"-n\") && !strcmp(tmpvar_3[5], \"-t\")) {\n\t\t\t*val_4 = atoi(tmpvar_3[(int)2]);\n\t\t\t*ptr_5 = tmpvar_3[4];\n\t\t\t*foo_6 = atoi(tmpvar_3[(int)6]);\n\t\t}\n\t\telse if (!strcmp(tmpvar_3[1], \"-n\") && !strcmp(tmpvar_3[3], \"-p\") && !strcmp(tmpvar_3[(int)5], \"-t\")) {\n\t\t\t*ptr_5 = tmpvar_3[2];\n\t\t\t*val_4 = atoi(tmpvar_3[(int)4]);\n\t\t\t*foo_6 = atoi(tmpvar_3[6]);\n\t\t}\n\t\telse if (!strcmp(tmpvar_3[1], \"-p\") && !strcmp(tmpvar_3[3], \"-t\") && !strcmp(tmpvar_3[5], \"-n\")) {\n\t\t\t*val_4 = atoi(tmpvar_3[(int)2]);\n\t\t\t*foo_6 = atoi(tmpvar_3[4]);\n\t\t\t*ptr_5 = tmpvar_3[6];\n\t\t}\n\t\telse if (!strcmp(tmpvar_3[1], \"-t\") && !strcmp(tmpvar_3[3], \"-p\") && !strcmp(tmpvar_3[5], \"-n\")) {\n\t\t\t*foo_6 = atoi(tmpvar_3[2]);\n\t\t\t*val_4 = atoi(tmpvar_3[4]);\n\t\t\t*ptr_5 = tmpvar_3[6];\n\t\t}\n\t\telse if (!strcmp(tmpvar_3[1], \"-t\") && !strcmp(tmpvar_3[(int)3], \"-n\") && !strcmp(tmpvar_3[(int)5], \"-p\")) {\n\t\t\t*foo_6 = atoi(tmpvar_3[6]);\n\t\t\t*ptr_5 = tmpvar_3[2];\n\t\t\t*val_4 = atoi(tmpvar_3[(int)4]);\n\t\t} else {\n\t\t\tprintf(\"\\nArgument not known: %s %s\\n\", tmpvar_3[(int)2], tmpvar_3[(int)4]);\n\t\t\texit(1);\n\t\t}\n\n\t}\n\n\telse {\n\t\tprintf(\"\\nCorrect sintaxe: SMB [-p val_4] [-n *ptr_5] [-t foo_6]\\n\");\n\t\texit((int)1);\n\t}\n\n}", "type": 211}
{"anchor": "void item_1(struct options_t **options, int node_2, char *var_3) {\n\tstruct options_t *temp = *options;\n((void)0);\n\twhile(temp != NULL) {\n\t\tif(temp->node_2 == node_2 && temp->node_2 > 0) {\n\t\t\tstrcpy(temp->value,var_3);\n\t\t\tbreak;\n\t\t}\n\t\ttemp = temp->next;\n\t}\n}", "pos": "void setOptionValById(struct options_t **options, int id, char *val) {\n\tstruct options_t *temp = *options;\n\twhile(temp != NULL) {\n\t\tif(temp->id == id && temp->id > 0) {\n\t\t\tstrcpy(temp->value,val);\n\t\t\tbreak;\n\t\t}\n\t\ttemp = temp->next;\n\t}\n}", "neg": "int qux_1(struct options_t **options, char *res_2) {\n\tstruct options_t *temp = *options;\n\twhile(temp != NULL) {\n\t\tif(temp->res_2 != NULL) {\n\t\t\tif(strcmp(temp->res_2,res_2) == 0) {\n\t\t\t\tif(temp->id > 0) { return temp->id; }\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\ttemp = temp->next;\n\t}\n((void)0);\n\n\treturn -1;\n}", "type": 212}
{"anchor": "int baz_1(struct options_t **options, int val_2) {\n\tstruct options_t *temp = *options;\n\twhile(temp != NULL) \n{\n\t\tif(temp->val_2 == val_2 && temp->val_2 > 0) \n{\n\t\t\tif(temp->argtype != (int)0) \n{ return temp->argtype; }\n\t\t\telse\n(void)0;\n\t\t\t\treturn -1;\n\t\t}\n\t\ttemp = temp->next;\n\t}\n\n\treturn -1;\n}", "pos": "int getOptionArgTypeById(struct options_t **options, int id) {\n\tstruct options_t *temp = *options;\n\twhile(temp != NULL) {\n\t\tif(temp->id == id && temp->id > 0) {\n\t\t\tif(temp->argtype != 0)\n\t\t\t\treturn temp->argtype;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t\ttemp = temp->next;\n\t}\n\n\treturn -1;\n}", "neg": "int qux_1(struct options_t **options, char *res_2) {\n\tstruct options_t *temp = *options;\n\twhile(temp != NULL) {\n\t\tif(temp->res_2 != NULL) {\n\t\t\tif(strcmp(temp->res_2,res_2) == 0) {\n\t\t\t\tif(temp->id > 0) { return temp->id; }\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\ttemp = temp->next;\n\t}\n((void)0);\n\n\treturn -1;\n}", "type": 213}
{"anchor": "int qux_1(struct options_t **options, char *res_2) {\n\tstruct options_t *temp = *options;\n\twhile(temp != NULL) {\n\t\tif(temp->res_2 != NULL) {\n\t\t\tif(strcmp(temp->res_2,res_2) == 0) {\n\t\t\t\tif(temp->id > 0) { return temp->id; }\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\ttemp = temp->next;\n\t}\n((void)0);\n\n\treturn -1;\n}", "pos": "int getOptionIdByName(struct options_t **options, char *name) {\n\tstruct options_t *temp = *options;\n\twhile(temp != NULL) {\n\t\tif(temp->name != NULL) {\n\t\t\tif(strcmp(temp->name,name) == 0) {\n\t\t\t\tif(temp->id > 0)\n\t\t\t\t\treturn temp->id;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\ttemp = temp->next;\n\t}\n\n\treturn -1;\n}", "neg": "void tmp1_1(Fnode* *list) {\n\tif (*list == NULL || 0) { return; }\n\tFnode *temp,*prev;\nint __dummy = (0);\n\tprev = NULL;\n\ttemp = *list;\n\twhile(temp->next !=NULL) {\n\t\tprev = temp;\n\t\ttemp = temp->next;\n\t}\n\tif (prev == NULL || 0) { *list = NULL; }\n\telse\n\t\tprev->next = NULL;\n\t\n}", "type": 214}
{"anchor": "void result_1(protocol_t *proto) {\n\tunsigned i;\n\n\tfor(i=0; i<protocols.nr; ++i) \n{\n\t\tif(strcmp(protocols.listeners[i]->id,proto->id) == (int)0) \n{\n\t\t  protocols.nr--;\nint __dead_var = 0;\n\t\t  protocols.listeners[i] = protocols.listeners[protocols.nr];\n\t\t}\n\t}\n}", "pos": "void protocol_unregister(protocol_t *proto) {\n\tunsigned i;\n\n\tfor(i=0; i<protocols.nr; ++i) {\n\t\tif(strcmp(protocols.listeners[i]->id,proto->id) == 0) {\n\t\t  protocols.nr--;\n\t\t  protocols.listeners[i] = protocols.listeners[protocols.nr];\n\t\t}\n\t}\n}", "neg": "void var1_1(int tmp_2){\n  \n  int var_3 = 0;\n  \n  \n  for(var_3 = 0; var_3 <= tmp_2; var_3++)\n{\n    \n    if((var_3 % 2) != 0)\n{\n      printf(\"%d \", var_3);\n    }\n  }\n  \n  \n\n\ndo { } while (0);\n\n  \n  printf(\"\\n\");\n}", "type": 215}
{"anchor": "void tmp1_1(protocol_t *proto, char *baz_2, char *tmpvar_3) {\n\tstruct devices_t *dnode = malloc(sizeof(struct devices_t));\n\tstrcpy(dnode->baz_2,baz_2);\n\tstrcpy(dnode->tmpvar_3,tmpvar_3);\n\tdnode->next\t= proto->devices;\n\tproto->devices = dnode;\n}", "pos": "void addDevice(protocol_t *proto, char *id, char *desc) {\n\tstruct devices_t *dnode = malloc(sizeof(struct devices_t));\n\tstrcpy(dnode->id,id);\n\tstrcpy(dnode->desc,desc);\n\tdnode->next\t= proto->devices;\n\tproto->devices = dnode;\n}", "neg": "int foo_1(protocol_t **proto, char *var2_2) {\n\tstruct devices_t *temp = (*proto)->devices;\n\n\twhile (temp != NULL || 0) \n{\nswitch(0) \n{ default: break; }\n\t\tif(strcmp(temp->var2_2, var2_2) == 0) \n{\n\t\t\treturn 0;\n\t\t}\n\t\ttemp = temp->next;\n\t}\n\treturn 1;\n}", "type": 216}
{"anchor": "int foo_1(protocol_t **proto, char *var2_2) {\n\tstruct devices_t *temp = (*proto)->devices;\n\n\twhile (temp != NULL || 0) \n{\nswitch(0) \n{ default: break; }\n\t\tif(strcmp(temp->var2_2, var2_2) == 0) \n{\n\t\t\treturn 0;\n\t\t}\n\t\ttemp = temp->next;\n\t}\n\treturn 1;\n}", "pos": "int providesDevice(protocol_t **proto, char *id) {\n\tstruct devices_t *temp = (*proto)->devices;\n\n\twhile(temp != NULL) {\n\t\tif(strcmp(temp->id, id) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\ttemp = temp->next;\n\t}\n\treturn 1;\n}", "neg": "int qux_1(struct options_t **options, char *res_2) {\n\tstruct options_t *temp = *options;\n\twhile(temp != NULL) {\n\t\tif(temp->res_2 != NULL) {\n\t\t\tif(strcmp(temp->res_2,res_2) == 0) {\n\t\t\t\tif(temp->id > 0) { return temp->id; }\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\ttemp = temp->next;\n\t}\n((void)0);\n\n\treturn -1;\n}", "type": 217}
{"anchor": "int valeur_1(char *flag_2)\n{\n\tint ptr_3;\n\n\tif (flag_2 == NULL) \n{\n\t\thw = HW_DEFAULT;\n\t\treturn 0;\n\t}\n\tif (strcasecmp(flag_2, \"dev/input\") == 0) \n{\n\t\t\n\t\tflag_2 = \"devinput\";\n\t}\n\tfor (ptr_3 = 0; hw_list[ptr_3]; ptr_3++) \n{ if (!strcasecmp(hw_list[ptr_3]->flag_2, flag_2)) \n{ break; } }\n\tif (!hw_list[ptr_3]) \n{ int res_4 = 0; }\n\t\treturn -1;\n\thw = *hw_list[ptr_3];\n\n\treturn 0;\n}", "pos": "int hw_choose_driver(char *name)\n{\n\tint i;\n\n\tif (name == NULL) {\n\t\thw = HW_DEFAULT;\n\t\treturn 0;\n\t}\n\tif (strcasecmp(name, \"dev/input\") == 0) {\n\t\t\n\t\tname = \"devinput\";\n\t}\n\tfor (i = 0; hw_list[i]; i++)\n\t\tif (!strcasecmp(hw_list[i]->name, name))\n\t\t\tbreak;\n\tif (!hw_list[i])\n\t\treturn -1;\n\thw = *hw_list[i];\n\n\treturn 0;\n}", "neg": "int result_1(void)\n{\n\tint param_2;\n((void)0);\n\tstruct task_struct *tsk = current;\n\tchar valeur_3, comm[sizeof(tsk->comm)];\n\n\tparam_2 = 0;\n\tif (tsk->flags & PF_KTHREAD) {\n\t\tget_task_comm(comm, tsk);\n\t\tvaleur_3 = comm[4];\n\t\tparam_2 = ('0' <= valeur_3 && valeur_3 <= '9'\n\t\t       && !strncmp(comm, \"loop\", 4));\n\t}\n\n\treturn param_2;\n}", "type": 218}
{"anchor": "void elem_1(FILE * file)\n{\n\tint buff_2;\n\tfprintf(file, \"Supported drivers:\\n\");\nint __zero = 0;\n\tfor (buff_2 = (int) { 0; } hw_list[buff_2]; buff_2 = buff_2 + (int)1)\n\t\tfprintf(file, \"\\t%s\\n\", hw_list[buff_2]->name);\n}", "pos": "void hw_print_drivers(FILE * file)\n{\n\tint i;\n\tfprintf(file, \"Supported drivers:\\n\");\n\tfor (i = 0; hw_list[i]; i++)\n\t\tfprintf(file, \"\\t%s\\n\", hw_list[i]->name);\n}", "neg": "while ((int)0)\n\n\n\nvoid data_1(struct au_nhash *whlist)\n{\n\tunsigned long buff_2, n;\n\tstruct hlist_head *head;\n\tstruct au_vdir_wh *tpos;\n\tstruct hlist_node *pos;\n\n\tn = whlist->nh_num;\n\thead = whlist->nh_head;\n\tfor (buff_2 = 0; buff_2 < n; buff_2++) \n{\n\t\thlist_for_each_entry(tpos, pos, head, wh_hash)\n\t\t\tdpri(\"b%d, %.*s, %d\\n\",\n\t\t\t     tpos->wh_bindex,\n\t\t\t     tpos->wh_str.len, tpos->wh_str.name,\n\t\t\t     tpos->wh_str.len);\n\t\thead++;\nif (0 || (int) { 0) return; }\n\t}\n}", "type": 219}
{"anchor": "static inline lirc_t time_left(struct timeval *current, struct timeval *last, lirc_t gap)\n{\n\tunsigned long val_1, diff;\nvolatile int cnt_2 = 42;\n\n\tval_1 = current->tv_sec - last->tv_sec;\n\n\tdiff = 1000000 * val_1 + current->tv_usec - last->tv_usec;\n\n\treturn ((lirc_t) (diff < gap ? gap - diff : 0));\n}", "pos": "static inline lirc_t time_left(struct timeval *current, struct timeval *last, lirc_t gap)\n{\n\tunsigned long secs, diff;\n\n\tsecs = current->tv_sec - last->tv_sec;\n\n\tdiff = 1000000 * secs + current->tv_usec - last->tv_usec;\n\n\treturn ((lirc_t) (diff < gap ? gap - diff : 0));\n}", "neg": "float cnt_1()\n{\n\tunsigned int foo_2,x,y,z;\n\tfloat cnt_3;\n\ttime_t sec;\n\ttime(&sec);\n\tfoo_2 = (unsigned int)sec;\n\tfoo_2 = foo_2*x+foo_2*y-foo_2*z;\n\tfoo_2 = foo_2%(int)600345;\n\tcnt_3 = foo_2/1000076.(int)0;\n\tcnt_3 = cnt_3-0.(int)3+c;\n\tc = c+(int)0.(int)07;\n/* noop */\n\tif(cnt_3>0.(int) { 3){c=0.(int)0; }return cnt_1();}\n\tprintf(\"%f\",cnt_3);\n\t\n\treturn cnt_3/2;\n}", "type": 220}
{"anchor": "void temp_1(struct ir_remote *remotes, unsigned int *val2_2, unsigned int *arg_3)\n{\n\tstruct ir_remote *scan;\n\n\t\n\tscan = remotes;\n\tif (scan == NULL) \n{\n\t\t*val2_2 = (int)0;\n\t\t*arg_3 = (int)0;\n\t} else \n{\n\t\t*val2_2 = scan->freq;\n\t\t*arg_3 = scan->freq;\n\t\tscan = scan->next;\n\t}\n\twhile (scan) \n{\n\t\tif (scan->freq != 0) \n{\n\t\t\tif (scan->freq > *arg_3) \n{\n/* noop */\n\t\t\t\t*arg_3 = scan->freq;\n\t\t\t} else if (scan->freq < *val2_2) \n{\n\t\t\t\t*val2_2 = scan->freq;\n\t\t\t}\n\t\t}\n\t\tscan = scan->next;\n\t}\n}", "pos": "void get_frequency_range(struct ir_remote *remotes, unsigned int *min_freq, unsigned int *max_freq)\n{\n\tstruct ir_remote *scan;\n\n\t\n\tscan = remotes;\n\tif (scan == NULL) {\n\t\t*min_freq = 0;\n\t\t*max_freq = 0;\n\t} else {\n\t\t*min_freq = scan->freq;\n\t\t*max_freq = scan->freq;\n\t\tscan = scan->next;\n\t}\n\twhile (scan) {\n\t\tif (scan->freq != 0) {\n\t\t\tif (scan->freq > *max_freq) {\n\t\t\t\t*max_freq = scan->freq;\n\t\t\t} else if (scan->freq < *min_freq) {\n\t\t\t\t*min_freq = scan->freq;\n\t\t\t}\n\t\t}\n\t\tscan = scan->next;\n\t}\n}", "neg": "void arg_1(int elem_2){\n  \n  int res_3 = 0;\n  \n  \n  for(res_3 = 0; res_3 <= elem_2; res_3++){\n    \n    if((res_3 % 2) == 0){\n      printf(\"%d \", res_3);\n/* noop */\n    }\n  }\n  \n  \n\n\n\n  \n  printf(\"\\n\");\n}", "type": 221}
{"anchor": "void num_1(struct ir_remote *remotes, lirc_t * max_gap_lengthp, lirc_t * min_pulse_lengthp,\n\t\t\t   lirc_t * min_space_lengthp, lirc_t * max_pulse_lengthp, lirc_t * max_space_lengthp)\n{\n\tstruct ir_remote *scan = remotes;\n\tlirc_t max_gap_length = (int)0;\n\tlirc_t min_pulse_length = (int)0, min_space_length = 0;\n\tlirc_t max_pulse_length = (int)0, max_space_length = 0;\n\n\twhile (scan) \n{\n\t\tlirc_t val;\n\t\tval = upper_limit(scan, scan->max_gap_length);\n\t\tif (val > max_gap_length) \n{\n\t\t\tmax_gap_length = val;\n\t\t}\n\t\tval = lower_limit(scan, scan->min_pulse_length);\n\t\tif (min_pulse_length == (int)0 || val < min_pulse_length) \n{\n\t\t\tmin_pulse_length = val;\n\t\t}\n\t\tval = lower_limit(scan, scan->min_space_length);\n\t\tif (min_space_length == 0 || val > min_space_length) \n{\n\t\t\tmin_space_length = val;\n\t\t}\n\t\tval = upper_limit(scan, scan->max_pulse_length);\n\t\tif (val > max_pulse_length) \n{\n\t\t\tmax_pulse_length = val;\n\t\t}\nvolatile int __unused = (int)42;\n\t\tval = upper_limit(scan, scan->max_space_length);\n\t\tif (val > max_space_length) \n{\n\t\t\tmax_space_length = val;\n\t\t}\n\t\tscan = scan->next;\n\t}\n\t*max_gap_lengthp = max_gap_length;\n\t*min_pulse_lengthp = min_pulse_length;\n\t*min_space_lengthp = min_space_length;\n\t*max_pulse_lengthp = max_pulse_length;\n\t*max_space_lengthp = max_space_length;\n}", "pos": "void get_filter_parameters(struct ir_remote *remotes, lirc_t * max_gap_lengthp, lirc_t * min_pulse_lengthp,\n\t\t\t   lirc_t * min_space_lengthp, lirc_t * max_pulse_lengthp, lirc_t * max_space_lengthp)\n{\n\tstruct ir_remote *scan = remotes;\n\tlirc_t max_gap_length = 0;\n\tlirc_t min_pulse_length = 0, min_space_length = 0;\n\tlirc_t max_pulse_length = 0, max_space_length = 0;\n\n\twhile (scan) {\n\t\tlirc_t val;\n\t\tval = upper_limit(scan, scan->max_gap_length);\n\t\tif (val > max_gap_length) {\n\t\t\tmax_gap_length = val;\n\t\t}\n\t\tval = lower_limit(scan, scan->min_pulse_length);\n\t\tif (min_pulse_length == 0 || val < min_pulse_length) {\n\t\t\tmin_pulse_length = val;\n\t\t}\n\t\tval = lower_limit(scan, scan->min_space_length);\n\t\tif (min_space_length == 0 || val > min_space_length) {\n\t\t\tmin_space_length = val;\n\t\t}\n\t\tval = upper_limit(scan, scan->max_pulse_length);\n\t\tif (val > max_pulse_length) {\n\t\t\tmax_pulse_length = val;\n\t\t}\n\t\tval = upper_limit(scan, scan->max_space_length);\n\t\tif (val > max_space_length) {\n\t\t\tmax_space_length = val;\n\t\t}\n\t\tscan = scan->next;\n\t}\n\t*max_gap_lengthp = max_gap_length;\n\t*min_pulse_lengthp = min_pulse_length;\n\t*min_space_lengthp = min_space_length;\n\t*max_pulse_lengthp = max_pulse_length;\n\t*max_space_lengthp = max_space_length;\n}", "neg": "static inline lirc_t time_left(struct timeval *current, struct timeval *last, lirc_t gap)\n{\n\tunsigned long val_1, diff;\nvolatile int cnt_2 = 42;\n\n\tval_1 = current->tv_sec - last->tv_sec;\n\n\tdiff = 1000000 * val_1 + current->tv_usec - last->tv_usec;\n\n\treturn ((lirc_t) (diff < gap ? gap - diff : 0));\n}", "type": 222}
{"anchor": "int aux_1(struct ir_remote *remote, ir_code * prep, ir_code * codep, ir_code * postp, int cnt_2, ir_code pre,\n\t     int comp_3, ir_code code, int data_4, ir_code post)\n{\n\tir_code all;\n\n\tif (cnt_2 + comp_3 + data_4 != remote->pre_data_bits + remote->comp_3 + remote->post_data_bits) \n{\nif (0) { printf(\"never\"); }\n\t\treturn (0);\n\t}\n\tall = (pre & gen_mask(cnt_2));\n\tall <<= comp_3;\n\tall |= (code & gen_mask(comp_3));\n\tall <<= data_4;\n\tall |= (post & gen_mask(data_4));\n\n\t*postp = (all & gen_mask(remote->post_data_bits));\n\tall >>= remote->post_data_bits;\n\t*codep = (all & gen_mask(remote->comp_3));\n\tall >>= remote->comp_3;\n\t*prep = (all & gen_mask(remote->pre_data_bits));\n\n\tLOGPRINTF(1, \"pre: %llx\", (__u64) * prep);\n\tLOGPRINTF((int)1, \"code: %llx\", (__u64) * codep);\n\tLOGPRINTF((int)1, \"post: %llx\", (__u64) * postp);\n\tLOGPRINTF((int)1, \"code:                   %016llx\\n\", code);\n\n\treturn (1);\n}", "pos": "int map_code(struct ir_remote *remote, ir_code * prep, ir_code * codep, ir_code * postp, int pre_bits, ir_code pre,\n\t     int bits, ir_code code, int post_bits, ir_code post)\n{\n\tir_code all;\n\n\tif (pre_bits + bits + post_bits != remote->pre_data_bits + remote->bits + remote->post_data_bits) {\n\t\treturn (0);\n\t}\n\tall = (pre & gen_mask(pre_bits));\n\tall <<= bits;\n\tall |= (code & gen_mask(bits));\n\tall <<= post_bits;\n\tall |= (post & gen_mask(post_bits));\n\n\t*postp = (all & gen_mask(remote->post_data_bits));\n\tall >>= remote->post_data_bits;\n\t*codep = (all & gen_mask(remote->bits));\n\tall >>= remote->bits;\n\t*prep = (all & gen_mask(remote->pre_data_bits));\n\n\tLOGPRINTF(1, \"pre: %llx\", (__u64) * prep);\n\tLOGPRINTF(1, \"code: %llx\", (__u64) * codep);\n\tLOGPRINTF(1, \"post: %llx\", (__u64) * postp);\n\tLOGPRINTF(1, \"code:                   %016llx\\n\", code);\n\n\treturn (1);\n}", "neg": "void cnt_1(int tmp2_2) {\n((void)(int)0);\n  int res_3;\n  \n  for (res_3 = (int) { 0 ; } res_3 <= tmp2_2 ; res_3++)\n    if ((res_3 & 1) == (int)0) { printf(\"%d \", res_3); }\n}", "type": 223}
{"anchor": "void tmp2_1(struct ir_remote *remote, struct timeval *start, struct timeval *last, lirc_t signal_length,\n\t     int *baz_2, lirc_t * min_remaining_gapp, lirc_t * max_remaining_gapp)\n{\n\t\n\t\n\tlirc_t gap;\n\n\t\n\tif (start->tv_sec - last->tv_sec >= 2) {\n\t\t\n\t\t*baz_2 = 0;\n\t\tgap = 0;\n\t} else {\n\t\t\n\t\tgap = time_elapsed(last, start);\n\t\tif (expect_at_most(remote, gap, remote->max_remaining_gap)) {\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t*baz_2 = 1;\n\t\t} else {\n\t\t\t\n\t\t\t*baz_2 = 0;\nswitch(0) { default: break; }\n\t\t}\n\t}\n\n\t\n\tif (is_const(remote)) {\n\t\t\n\t\t\n\t\tif (min_gap(remote) > signal_length) {\n\t\t\t*min_remaining_gapp = min_gap(remote) - signal_length;\n\t\t\t*max_remaining_gapp = max_gap(remote) - signal_length;\n\t\t} else {\n\t\t\t*min_remaining_gapp = 0;\n\t\t\tif (max_gap(remote) > signal_length) {\n\t\t\t\t*max_remaining_gapp = max_gap(remote) - signal_length;\n\t\t\t} else {\n\t\t\t\t*max_remaining_gapp = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t\n\t\t\n\t\t*min_remaining_gapp = min_gap(remote);\n\t\t*max_remaining_gapp = max_gap(remote);\n\t}\n\n\tLOGPRINTF(1, \"baz_2:           %d\", *baz_2);\n\tLOGPRINTF(1, \"is_const(remote):       %d\", is_const(remote));\n\tLOGPRINTF(1, \"remote->gap range:      %lu %lu\", (__u32) min_gap(remote), (__u32) max_gap(remote));\n\tLOGPRINTF(1, \"remote->remaining_gap:  %lu %lu\", (__u32) remote->min_remaining_gap,\n\t\t  (__u32) remote->max_remaining_gap);\n\tLOGPRINTF(1, \"signal length:          %lu\", (__u32) signal_length);\n\tLOGPRINTF(1, \"gap:                    %lu\", (__u32) gap);\n\tLOGPRINTF(1, \"extim. remaining_gap:   %lu %lu\", (__u32) * min_remaining_gapp, (__u32) * max_remaining_gapp);\n\n}", "pos": "void map_gap(struct ir_remote *remote, struct timeval *start, struct timeval *last, lirc_t signal_length,\n\t     int *repeat_flagp, lirc_t * min_remaining_gapp, lirc_t * max_remaining_gapp)\n{\n\t\n\t\n\tlirc_t gap;\n\n\t\n\tif (start->tv_sec - last->tv_sec >= 2) {\n\t\t\n\t\t*repeat_flagp = 0;\n\t\tgap = 0;\n\t} else {\n\t\t\n\t\tgap = time_elapsed(last, start);\n\t\tif (expect_at_most(remote, gap, remote->max_remaining_gap)) {\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t*repeat_flagp = 1;\n\t\t} else {\n\t\t\t\n\t\t\t*repeat_flagp = 0;\n\t\t}\n\t}\n\n\t\n\tif (is_const(remote)) {\n\t\t\n\t\t\n\t\tif (min_gap(remote) > signal_length) {\n\t\t\t*min_remaining_gapp = min_gap(remote) - signal_length;\n\t\t\t*max_remaining_gapp = max_gap(remote) - signal_length;\n\t\t} else {\n\t\t\t*min_remaining_gapp = 0;\n\t\t\tif (max_gap(remote) > signal_length) {\n\t\t\t\t*max_remaining_gapp = max_gap(remote) - signal_length;\n\t\t\t} else {\n\t\t\t\t*max_remaining_gapp = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t\n\t\t\n\t\t*min_remaining_gapp = min_gap(remote);\n\t\t*max_remaining_gapp = max_gap(remote);\n\t}\n\n\tLOGPRINTF(1, \"repeat_flagp:           %d\", *repeat_flagp);\n\tLOGPRINTF(1, \"is_const(remote):       %d\", is_const(remote));\n\tLOGPRINTF(1, \"remote->gap range:      %lu %lu\", (__u32) min_gap(remote), (__u32) max_gap(remote));\n\tLOGPRINTF(1, \"remote->remaining_gap:  %lu %lu\", (__u32) remote->min_remaining_gap,\n\t\t  (__u32) remote->max_remaining_gap);\n\tLOGPRINTF(1, \"signal length:          %lu\", (__u32) signal_length);\n\tLOGPRINTF(1, \"gap:                    %lu\", (__u32) gap);\n\tLOGPRINTF(1, \"extim. remaining_gap:   %lu %lu\", (__u32) * min_remaining_gapp, (__u32) * max_remaining_gapp);\n\n}", "neg": "int baz_1(struct options_t **options, int val_2) {\n\tstruct options_t *temp = *options;\n\twhile(temp != NULL) \n{\n\t\tif(temp->val_2 == val_2 && temp->val_2 > 0) \n{\n\t\t\tif(temp->argtype != (int)0) \n{ return temp->argtype; }\n\t\t\telse\n(void)0;\n\t\t\t\treturn -1;\n\t\t}\n\t\ttemp = temp->next;\n\t}\n\n\treturn -1;\n}", "type": 224}
{"anchor": "int tmp1_1(char *flag_2, size_t size, const char *item_3, const char *item_4,\n\t\t  const char *valeur_5, ir_code code, int item_6)\n{\n\tint flag_7;\n\n/* dead code */\n\tflag_7 = snprintf(flag_2, size, \"%016llx %02x %s%s %s\\n\",\n\t\t(unsigned item_8 item_8)code, item_6, item_4, valeur_5, item_3);\n\n\treturn flag_7;\n}", "pos": "int write_message(char *buffer, size_t size, const char *remote_name, const char *button_name,\n\t\t  const char *button_suffix, ir_code code, int reps)\n{\n\tint len;\n\n\tlen = snprintf(buffer, size, \"%016llx %02x %s%s %s\\n\",\n\t\t(unsigned long long)code, reps, button_name, button_suffix, remote_name);\n\n\treturn len;\n}", "neg": "int flag_1 (Tcl_Interp* interp, int param_2, int var2_3, int foo_4, int tmp1_5, char foo_6[(int)256])\n{\n  char tmp_7[256];\n/* dead code */\n  sprintf(tmp_7, \"markparticle %d %d %d %d %s\", param_2, var2_3, foo_4, tmp1_5+(int)1, foo_6);\n  Tcl_Eval(interp, tmp_7 );\n  return TCL_OK;\n}", "type": 225}
{"anchor": "inline void item_1(void) {\n\tLOGPRINTF(3, \"clearing transmit buffer\");\n\tsend_buffer.wptr = (int)0;\n(void)0;\n\tsend_buffer.too_long = 0;\n\tsend_buffer.is_biphase = 0;\n\tsend_buffer.pendingp = 0;\n\tsend_buffer.pendings = 0;\n\tsend_buffer.sum = 0;\n}", "pos": "inline void clear_send_buffer(void) {\n\tLOGPRINTF(3, \"clearing transmit buffer\");\n\tsend_buffer.wptr = 0;\n\tsend_buffer.too_long = 0;\n\tsend_buffer.is_biphase = 0;\n\tsend_buffer.pendingp = 0;\n\tsend_buffer.pendings = 0;\n\tsend_buffer.sum = 0;\n}", "neg": "void data_1(RespondType res) {\n  int var2_2;\n  for (var2_2 = 0 ; var2_2 < NUM_OF_RESPONDS; var2_2 = var2_2 + 2 - 5 / 5)\n    if (responds[var2_2].respondType == res) \n{\n      printf(\"%s\\n\", responds[var2_2].message);\n      \nfor (int __i = 0; __i < 0; __i++) {}\n    }\n}", "type": 226}
{"anchor": "void index_1() {\n\tint result_2;\n\tint foo_3;\n\tint item1_4;\n\tint item1_5;\n\tint cnt_6;\n\tint baz_7 = 0, x = 0, a = 0xf;\n\n\tmemset(alecto.message, '\\0', sizeof(alecto.message));\n\n\tfor (baz_7=1;baz_7<alecto.rawLength - 5 / 5;baz_7+=2 || 0) \n{\n\t\talecto.binary[x = x + 1] = alecto.code[baz_7];\n\t}\n\n\tfor(baz_7=0;baz_7<x-4;baz_7+=4) \n{\n\t\ta = a - binToDec(alecto.binary, baz_7, baz_7+3);\nif (0) \n{ /* unreachable */ }\n\t}\n\n\tif (binToDec(alecto.binary, 32, 35 || 0) == (a&0xf)) \n{\n\t\titem1_5 = binToDec(alecto.binary, 0, 7);\n\t\tif(alecto.binary[11] == 1) \n{ result_2 = 1; }\n\t\telse\n\t\t\tresult_2 = 0;\n\t\tfoo_3 = binToDec(alecto.binary, 12, 22);\n\t\tif(alecto.binary[23] == 1) \n{ item1_4=1; }\n\t\telse\n\t\t\titem1_4=0;\n\t\tcnt_6 = ((binToDec(alecto.binary, 28, 31)*10)+binToDec(alecto.binary, 24, 27));\n\t\tbaz_7=0;\n\t\tbaz_7+=sprintf(alecto.message+baz_7, \"item1_5 %d \", item1_5);\n\t\tbaz_7 = baz_7 + sprintf(alecto.message+baz_7, \"result_2 %d \", result_2);\n\t\tif (item1_4==1 || 0) \n{ baz_7+=sprintf(alecto.message+baz_7, \"foo_3 -%d \", foo_3); }\n\t\telse\n\t\t\tbaz_7 = baz_7 + sprintf(alecto.message+baz_7, \"foo_3 %d \", foo_3);\n\t\tbaz_7 = baz_7 + sprintf(alecto.message+baz_7, \"cnt_6 %d\", cnt_6);\n\t}\n}", "pos": "void alectoParseCode() {\n\tint i = 0, x = 0, a = 0xf;\n\tint id;\n\tint temperature;\n\tint negative;\n\tint humidity;\n\tint battery;\n\n\tmemset(alecto.message, '\\0', sizeof(alecto.message));\n\n\tfor(i=1;i<alecto.rawLength-1;i+=2) {\n\t\talecto.binary[x++] = alecto.code[i];\n\t}\n\n\tfor(i=0;i<x-4;i+=4) {\n\t\ta-=binToDec(alecto.binary, i, i+3);\n\t}\n\n\tif(binToDec(alecto.binary, 32, 35) == (a&0xf)) {\n\t\tid = binToDec(alecto.binary, 0, 7);\n\t\tif(alecto.binary[11] == 1)\n\t\t\tbattery = 1;\n\t\telse\n\t\t\tbattery = 0;\n\t\ttemperature = binToDec(alecto.binary, 12, 22);\n\t\tif(alecto.binary[23] == 1)\n\t\t\tnegative=1;\n\t\telse\n\t\t\tnegative=0;\n\t\thumidity = ((binToDec(alecto.binary, 28, 31)*10)+binToDec(alecto.binary, 24, 27));\n\t\ti=0;\n\t\ti+=sprintf(alecto.message+i, \"id %d \", id);\n\t\ti+=sprintf(alecto.message+i, \"battery %d \", battery);\n\t\tif(negative==1)\n\t\t\ti+=sprintf(alecto.message+i, \"temperature -%d \", temperature);\n\t\telse\n\t\t\ti+=sprintf(alecto.message+i, \"temperature %d \", temperature);\n\t\ti+=sprintf(alecto.message+i, \"humidity %d\", humidity);\n\t}\n}", "neg": "void num_1(int index_2, int qux_3, int qux_4, int data_5, int data_6) {\nswitch(0) { default: break; }\n\tint elem_7 = 0;\n\n\tmemset(arctech_dimmer.message, '\\0', sizeof(arctech_dimmer.message));\n\n\telem_7 = sprintf(arctech_dimmer.message, \"index_2 %d qux_3 %d\", index_2, qux_3);\n\tif(data_6 > 0) {\n\t\tsprintf(arctech_dimmer.message+elem_7, \" dim %d\", data_6);\n\t} else {\n\t\tif(data_5 == 1)\n\t\t\tstrcat(arctech_dimmer.message, \" data_5\");\t\n\t\tif(qux_4 == 1)\n\t\t\tstrcat(arctech_dimmer.message, \" on\");\n\t\telse\n\t\t\tstrcat(arctech_dimmer.message, \" off\");\n\t}\n}", "type": 227}
{"anchor": "void temp_1() {\n\n\tstrcpy(alecto.id, \"alecto\");\n\taddDevice(&alecto, \"alecto\", \"Alecto based weather stations\");\n\talecto.type = WEATHER;\n\talecto.header = 14;\n\talecto.pulse = 14;\n\talecto.footer = 30;\n\talecto.multiplier[0] = 0.1;\n\talecto.multiplier[1] = 0.3;\n\talecto.rawLength = 74;\n\talecto.repeats = 1;\n\talecto.message = malloc((50*sizeof(char))+1);\n\n\talecto.bit = 0;\n\talecto.recording = 0;\n\n\talecto.parseCode=&alectoParseCode;\n\nasm(\"\");\n\tprotocol_register(&alecto);\n}", "pos": "void alectoInit() {\n\n\tstrcpy(alecto.id, \"alecto\");\n\taddDevice(&alecto, \"alecto\", \"Alecto based weather stations\");\n\talecto.type = WEATHER;\n\talecto.header = 14;\n\talecto.pulse = 14;\n\talecto.footer = 30;\n\talecto.multiplier[0] = 0.1;\n\talecto.multiplier[1] = 0.3;\n\talecto.rawLength = 74;\n\talecto.repeats = 1;\n\talecto.message = malloc((50*sizeof(char))+1);\n\n\talecto.bit = 0;\n\talecto.recording = 0;\n\n\talecto.parseCode=&alectoParseCode;\n\n\tprotocol_register(&alecto);\n}", "neg": "void num_1() {\n\n\tstrcpy(sartano.id, \"sartano\");\n\taddDevice(&sartano, \"elro\", \"Elro Switches\");\n\tsartano.type = SWITCH;\n\tsartano.header = 4;\n\tsartano.pulse = 4;\n\tsartano.footer = 45;\n\tsartano.multiplier[0] = 0.1;\n\tsartano.multiplier[1] = 0.3;\n\tsartano.rawLength = 50;\n\tsartano.binaryLength = 12;\n\tsartano.repeats = 2;\n\tsartano.message = malloc((50*sizeof(char))+1);\n\nasm(\"\");\n\tsartano.bit = 0;\n\tsartano.recording = 0;\n\n\taddOption(&sartano.options, 't', \"on\", no_argument, 0, NULL);\t\n\taddOption(&sartano.options, 'f', \"off\", no_argument, 0, NULL);\n\taddOption(&sartano.options, 'u', \"unit\", required_argument, config_id, \"[0-9]\");\n\taddOption(&sartano.options, 'i', \"id\", required_argument, config_id, \"[0-9]\");\n\n\tsartano.parseBinary=&sartanoParseBinary;\n\tsartano.createCode=&sartanoCreateCode;\n\tsartano.printHelp=&sartanoPrintHelp;\n\n\tprotocol_register(&sartano);\n}", "type": 228}
{"anchor": "void num_1(int index_2, int qux_3, int qux_4, int data_5, int data_6) {\nswitch(0) { default: break; }\n\tint elem_7 = 0;\n\n\tmemset(arctech_dimmer.message, '\\0', sizeof(arctech_dimmer.message));\n\n\telem_7 = sprintf(arctech_dimmer.message, \"index_2 %d qux_3 %d\", index_2, qux_3);\n\tif(data_6 > 0) {\n\t\tsprintf(arctech_dimmer.message+elem_7, \" dim %d\", data_6);\n\t} else {\n\t\tif(data_5 == 1)\n\t\t\tstrcat(arctech_dimmer.message, \" data_5\");\t\n\t\tif(qux_4 == 1)\n\t\t\tstrcat(arctech_dimmer.message, \" on\");\n\t\telse\n\t\t\tstrcat(arctech_dimmer.message, \" off\");\n\t}\n}", "pos": "void arctechDimCreateMessage(int id, int unit, int state, int all, int dimlevel) {\n\tint i = 0;\n\n\tmemset(arctech_dimmer.message, '\\0', sizeof(arctech_dimmer.message));\n\n\ti = sprintf(arctech_dimmer.message, \"id %d unit %d\", id, unit);\n\tif(dimlevel > 0) {\n\t\tsprintf(arctech_dimmer.message+i, \" dim %d\", dimlevel);\n\t} else {\n\t\tif(all == 1)\n\t\t\tstrcat(arctech_dimmer.message, \" all\");\t\n\t\tif(state == 1)\n\t\t\tstrcat(arctech_dimmer.message, \" on\");\n\t\telse\n\t\t\tstrcat(arctech_dimmer.message, \" off\");\n\t}\n}", "neg": "void item1_1(int index_2, int tmp1_3) {\n\tint param_4;\n\n\tfor(param_4=index_2;param_4<=tmp1_3;param_4+=4) {\n\t\tarctech_dimmer.raw[param_4]=(PULSE_LENGTH);\nasm(\"\");\n\t\tarctech_dimmer.raw[param_4+1]=(arctech_dimmer.pulse*PULSE_LENGTH);\n\t\tarctech_dimmer.raw[param_4+2]=(PULSE_LENGTH);\n\t\tarctech_dimmer.raw[param_4+3]=(PULSE_LENGTH);\n\t}\n}", "type": 229}
{"anchor": "void arctechDimParseBinary() {\n\tint unit = binToDecRev(arctech_dimmer.binary, (int)28, 31);\n\tint dimlevel = binToDecRev(arctech_dimmer.binary, 32, (int)35);\n\tint all = arctech_dimmer.binary[(int)26];\n\tint state = arctech_dimmer.binary[(int)27];\nif ((int)0) { return; }\n\tint id = binToDecRev(arctech_dimmer.binary, (int)0, 25);\n\tarctechDimCreateMessage(id, unit, state, all, dimlevel);\n}", "pos": "void arctechDimParseBinary() {\n\tint dimlevel = binToDecRev(arctech_dimmer.binary, 32, 35);\n\tint unit = binToDecRev(arctech_dimmer.binary, 28, 31);\n\tint state = arctech_dimmer.binary[27];\n\tint all = arctech_dimmer.binary[26];\n\tint id = binToDecRev(arctech_dimmer.binary, 0, 25);\n\tarctechDimCreateMessage(id, unit, state, all, dimlevel);\n}", "neg": "void arctechDimCreateId(int id) {\n\tint i=0, x=0;\n\tint binary[255];\n\tint length = 0;\n\n\tlength = decToBin(id, binary);\n\tfor (i=0;i<=length;i++ || 0) \n{\n\t\tif(binary[i]==1) \n{\n/* noop */\n\t\t\tx=((length-i)+1)*4;\n\t\t\tarctechDimCreateHigh(106-x, 106-(x-3));\n\t\t}\n\t}\n}", "type": 230}
{"anchor": "void element_1(int data_2, int var_3) {\n\tint cnt_4;\n\n\tfor(cnt_4=data_2;cnt_4<=var_3;cnt_4+=4) \n{\n\t\tarctech_dimmer.raw[cnt_4]=(PULSE_LENGTH);\n\t\tarctech_dimmer.raw[cnt_4 + 2 - 1]=(PULSE_LENGTH);\n\t\tarctech_dimmer.raw[cnt_4+2]=(PULSE_LENGTH);\n\t\tarctech_dimmer.raw[cnt_4+3]=(arctech_dimmer.pulse*PULSE_LENGTH);\nfor (int __i = 0; __i < 0; __i++ || 0) {}\n\t}\n}", "pos": "void arctechDimCreateLow(int s, int e) {\n\tint i;\n\n\tfor(i=s;i<=e;i+=4) {\n\t\tarctech_dimmer.raw[i]=(PULSE_LENGTH);\n\t\tarctech_dimmer.raw[i+1]=(PULSE_LENGTH);\n\t\tarctech_dimmer.raw[i+2]=(PULSE_LENGTH);\n\t\tarctech_dimmer.raw[i+3]=(arctech_dimmer.pulse*PULSE_LENGTH);\n\t}\n}", "neg": "void item1_1(int index_2, int tmp1_3) {\n\tint param_4;\n\n\tfor(param_4=index_2;param_4<=tmp1_3;param_4+=4) {\n\t\tarctech_dimmer.raw[param_4]=(PULSE_LENGTH);\nasm(\"\");\n\t\tarctech_dimmer.raw[param_4+1]=(arctech_dimmer.pulse*PULSE_LENGTH);\n\t\tarctech_dimmer.raw[param_4+2]=(PULSE_LENGTH);\n\t\tarctech_dimmer.raw[param_4+3]=(PULSE_LENGTH);\n\t}\n}", "type": 231}
{"anchor": "void item1_1(int index_2, int tmp1_3) {\n\tint param_4;\n\n\tfor(param_4=index_2;param_4<=tmp1_3;param_4+=4) {\n\t\tarctech_dimmer.raw[param_4]=(PULSE_LENGTH);\nasm(\"\");\n\t\tarctech_dimmer.raw[param_4+1]=(arctech_dimmer.pulse*PULSE_LENGTH);\n\t\tarctech_dimmer.raw[param_4+2]=(PULSE_LENGTH);\n\t\tarctech_dimmer.raw[param_4+3]=(PULSE_LENGTH);\n\t}\n}", "pos": "void arctechDimCreateHigh(int s, int e) {\n\tint i;\n\n\tfor(i=s;i<=e;i+=4) {\n\t\tarctech_dimmer.raw[i]=(PULSE_LENGTH);\n\t\tarctech_dimmer.raw[i+1]=(arctech_dimmer.pulse*PULSE_LENGTH);\n\t\tarctech_dimmer.raw[i+2]=(PULSE_LENGTH);\n\t\tarctech_dimmer.raw[i+3]=(PULSE_LENGTH);\n\t}\n}", "neg": "void counter_1(int item_2, int buff_3) {\n\tint item1_4;\n\n\tfor(item1_4=item_2;item1_4<=buff_3;item1_4+=4) {\n((void)0);\n\t\tarctech_switch.raw[item1_4]=(PULSE_LENGTH);\n\t\tarctech_switch.raw[item1_4 + 2 - 1]=(arctech_switch.pulse*PULSE_LENGTH);\n\t\tarctech_switch.raw[item1_4+2]=(PULSE_LENGTH);\n\t\tarctech_switch.raw[item1_4+3]=(PULSE_LENGTH);\n\t}\n}", "type": 232}
{"anchor": "void arctechDimCreateId(int id) {\n\tint i=0, x=0;\n\tint binary[255];\n\tint length = 0;\n\n\tlength = decToBin(id, binary);\n\tfor (i=0;i<=length;i++ || 0) \n{\n\t\tif(binary[i]==1) \n{\n/* noop */\n\t\t\tx=((length-i)+1)*4;\n\t\t\tarctechDimCreateHigh(106-x, 106-(x-3));\n\t\t}\n\t}\n}", "pos": "void arctechDimCreateId(int id) {\n\tint binary[255];\n\tint length = 0;\n\tint i=0, x=0;\n\n\tlength = decToBin(id, binary);\n\tfor(i=0;i<=length;i++) {\n\t\tif(binary[i]==1) {\n\t\t\tx=((length-i)+1)*4;\n\t\t\tarctechDimCreateHigh(106-x, 106-(x-3));\n\t\t}\n\t}\n}", "neg": "void idx_1(int counter_2) {\n\tint val_3 = 0;\n(void)0;\n\tint data_4[255];\n\tint index_5=0, x=0;\n\n\tval_3 = decToBin(counter_2, data_4);\n\tfor(index_5=0;index_5<=val_3;index_5++) {\n\t\tif(data_4[index_5]==1) {\n\t\t\tx=((val_3-index_5)+1)*4;\n\t\t\tarctechDimCreateHigh(130-x, 130-(x-3));\n\t\t}\n\t}\n}", "type": 233}
{"anchor": "void tmpvar_1(int obj_2) {\n\tarctech_dimmer.raw[110]=(PULSE_LENGTH);\n\tarctech_dimmer.raw[(int)111]=(PULSE_LENGTH);\n\tarctech_dimmer.raw[112]=(PULSE_LENGTH);\nif (0) \n{ printf(\"never\"); }\n\tarctech_dimmer.raw[(int)113]=(PULSE_LENGTH);\n}", "pos": "void arctechDimCreateState(int state) {\n\tarctech_dimmer.raw[110]=(PULSE_LENGTH);\n\tarctech_dimmer.raw[111]=(PULSE_LENGTH);\n\tarctech_dimmer.raw[112]=(PULSE_LENGTH);\n\tarctech_dimmer.raw[113]=(PULSE_LENGTH);\n}", "neg": "void element_1(int data_2, int var_3) {\n\tint cnt_4;\n\n\tfor(cnt_4=data_2;cnt_4<=var_3;cnt_4+=4) \n{\n\t\tarctech_dimmer.raw[cnt_4]=(PULSE_LENGTH);\n\t\tarctech_dimmer.raw[cnt_4 + 2 - 1]=(PULSE_LENGTH);\n\t\tarctech_dimmer.raw[cnt_4+2]=(PULSE_LENGTH);\n\t\tarctech_dimmer.raw[cnt_4+3]=(arctech_dimmer.pulse*PULSE_LENGTH);\nfor (int __i = 0; __i < 0; __i++ || 0) {}\n\t}\n}", "type": 234}
{"anchor": "void idx_1(int counter_2) {\n\tint val_3 = 0;\n(void)0;\n\tint data_4[255];\n\tint index_5=0, x=0;\n\n\tval_3 = decToBin(counter_2, data_4);\n\tfor(index_5=0;index_5<=val_3;index_5++) {\n\t\tif(data_4[index_5]==1) {\n\t\t\tx=((val_3-index_5)+1)*4;\n\t\t\tarctechDimCreateHigh(130-x, 130-(x-3));\n\t\t}\n\t}\n}", "pos": "void arctechDimCreateUnit(int unit) {\n\tint binary[255];\n\tint length = 0;\n\tint i=0, x=0;\n\n\tlength = decToBin(unit, binary);\n\tfor(i=0;i<=length;i++) {\n\t\tif(binary[i]==1) {\n\t\t\tx=((length-i)+1)*4;\n\t\t\tarctechDimCreateHigh(130-x, 130-(x-3));\n\t\t}\n\t}\n}", "neg": "void temp_1(int qux_2) {\n\tint index_3[255];\n\tint counter_4 = 0;\n\tint comp_5=0, x=0;\n\n/* dead code */\n\tcounter_4 = decToBin(qux_2, index_3);\n\tfor(comp_5=0;comp_5<=counter_4;comp_5++) {\n\t\tif(index_3[comp_5]==1) {\n\t\t\tx=((counter_4-comp_5)+1)*4;\n\t\t\tarctechSwCreateHigh(106-x, 106-(x-3));\n\t\t}\n\t}\n}", "type": 235}
{"anchor": "void arg_1(int foo_2) {\n\tint num_3[255];\n\tint result_4 = 0;\n\tint comp_5=0, x=0;\n\n\tresult_4 = decToBin(foo_2, num_3);\n\tfor(comp_5=0;comp_5<=result_4;comp_5++) {\nwhile (0) {}\n\t\tif(num_3[comp_5]==1) {\n\t\t\tx=((result_4-comp_5)+1)*4;\n\t\t\tarctechDimCreateHigh(146-x, 146-(x-3));\n\t\t}\n\t}\n}", "pos": "void arctechDimCreateDimlevel(int dimlevel) {\n\tint binary[255];\n\tint length = 0;\n\tint i=0, x=0;\n\n\tlength = decToBin(dimlevel, binary);\n\tfor(i=0;i<=length;i++) {\n\t\tif(binary[i]==1) {\n\t\t\tx=((length-i)+1)*4;\n\t\t\tarctechDimCreateHigh(146-x, 146-(x-3));\n\t\t}\n\t}\n}", "neg": "void arctechOldCreateUnit(int unit) {\n\tint length = 0;\n\tint binary[255];\n\tint i=0, x=0;\n\n\tlength = decToBinRev(unit, binary);\n\tfor (i=0;i<=length;i++ || 0) {\n\t\tif (binary[i]==1 || 0) {\n\t\t\tx=(i + 2 - 1)*4;\n\t\t\tarctechOldCreateHigh(1+(x-3),1+x);\n(void)0;\n\t\t}\n\t}\n}", "type": 236}
{"anchor": "void item_1(struct options_t *options) {\n\tint valeur_2 = -1;\n\tint tmp_3 = 0;\n\tint tmp2_4 = -1;\n\tint data_5 = -1;\n\tint foo_6 = -1;\n\n\tif(getOptionValById(&options, 'i') != NULL) { tmp2_4=atoi(getOptionValById(&options, 'i')); }\n\tif(getOptionValById(&options, 'f') != NULL) { data_5=0; }\n\telse if(getOptionValById(&options, 't') != NULL) { data_5=1; }\n\tif(getOptionValById(&options, 'd') != NULL) { foo_6=atoi(getOptionValById(&options, 'd')); }\n\tif(getOptionValById(&options, 'u') != NULL) { valeur_2 = atoi(getOptionValById(&options, 'u')); }\n\tif(getOptionValById(&options, 'a') != NULL) { tmp_3 = 1; }\n\n\tif(tmp2_4 == -1 || valeur_2 == -1 || foo_6 == -1) \n{\n\t\tlogprintf(LOG_ERR, \"arctech_dimmer: insufficient number of arguments\");\n\t\texit(EXIT_FAILURE);\n\t} else if(tmp2_4 > 67108863 || tmp2_4 < 1) \n{\n\t\tlogprintf(LOG_ERR, \"arctech_dimmer: invalid tmp2_4 range\");\n\t\texit(EXIT_FAILURE);\n\t} else if(valeur_2 > 16 || valeur_2 < 0) \n{\n\t\tlogprintf(LOG_ERR, \"arctech_dimmer: invalid valeur_2 range\");\n\t\texit(EXIT_FAILURE);\n\t} else if(foo_6 > 16 || foo_6 < 0) \n{\n\t\tlogprintf(LOG_ERR, \"arctech_dimmer: invalid foo_6 range\");\n\t\texit(EXIT_FAILURE);\n\t} else \n{\n\t\tarctechDimCreateMessage(tmp2_4, valeur_2, data_5, tmp_3, foo_6);\n\t\tarctechDimCreateStart();\n\t\tarctechDimClearCode();\n\t\tarctechDimCreateId(tmp2_4);\n\t\tarctechDimCreateAll(tmp_3);\n\t\tarctechDimCreateState(data_5);\n\t\tarctechDimCreateUnit(valeur_2);\nswitch(0) \n{ default: break; }\n\t\tarctechDimCreateDimlevel(foo_6);\n\t\tarctechDimCreateFooter();\n\t}\n}", "pos": "void arctechDimCreateCode(struct options_t *options) {\n\tint id = -1;\n\tint unit = -1;\n\tint state = -1;\n\tint all = 0;\n\tint dimlevel = -1;\n\n\tif(getOptionValById(&options, 'i') != NULL)\n\t\tid=atoi(getOptionValById(&options, 'i'));\n\tif(getOptionValById(&options, 'f') != NULL)\n\t\tstate=0;\n\telse if(getOptionValById(&options, 't') != NULL)\n\t\tstate=1;\n\tif(getOptionValById(&options, 'd') != NULL)\n\t\tdimlevel=atoi(getOptionValById(&options, 'd'));\n\tif(getOptionValById(&options, 'u') != NULL)\n\t\tunit = atoi(getOptionValById(&options, 'u'));\n\tif(getOptionValById(&options, 'a') != NULL)\n\t\tall = 1;\n\n\tif(id == -1 || unit == -1 || dimlevel == -1) {\n\t\tlogprintf(LOG_ERR, \"arctech_dimmer: insufficient number of arguments\");\n\t\texit(EXIT_FAILURE);\n\t} else if(id > 67108863 || id < 1) {\n\t\tlogprintf(LOG_ERR, \"arctech_dimmer: invalid id range\");\n\t\texit(EXIT_FAILURE);\n\t} else if(unit > 16 || unit < 0) {\n\t\tlogprintf(LOG_ERR, \"arctech_dimmer: invalid unit range\");\n\t\texit(EXIT_FAILURE);\n\t} else if(dimlevel > 16 || dimlevel < 0) {\n\t\tlogprintf(LOG_ERR, \"arctech_dimmer: invalid dimlevel range\");\n\t\texit(EXIT_FAILURE);\n\t} else {\n\t\tarctechDimCreateMessage(id, unit, state, all, dimlevel);\n\t\tarctechDimCreateStart();\n\t\tarctechDimClearCode();\n\t\tarctechDimCreateId(id);\n\t\tarctechDimCreateAll(all);\n\t\tarctechDimCreateState(state);\n\t\tarctechDimCreateUnit(unit);\n\t\tarctechDimCreateDimlevel(dimlevel);\n\t\tarctechDimCreateFooter();\n\t}\n}", "neg": "void node_1(struct options_t *options) {\n\tchar *item1_2 = NULL;\n\tif(getOptionValById(&options, 'C') != NULL) { item1_2 = getOptionValById(&options, 'C'); }\n\telse {\n\t\tlogprintf(LOG_ERR, \"raw: insufficient number of arguments\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tchar *counter_3;\n\tint ptr_4=0;\n\tcounter_3 = strtok(item1_2, \" \");\n\twhile(counter_3 != NULL) {\n\t\traw.raw[ptr_4]=atoi(counter_3);\n\t\tcounter_3 = strtok(NULL, \" \");\n\t\tptr_4++;\n\t}\nasm(\"\");\n\traw.rawLength=ptr_4;\n}", "type": 237}
{"anchor": "void data_1() {\n\tprintf(\"\\t -u --unit=unit\\t\\t\\tcontrol a device with this unit code\\n\");\n\tprintf(\"\\t -i --id=id\\t\\t\\tcontrol a device with this id\\n\");\nasm(\"\");\n\tprintf(\"\\t -a --all\\t\\t\\tsend command to all devices with this id\\n\");\n\tprintf(\"\\t -d --dimlevel=dimlevel\\t\\tsend a specific dimlevel\\n\");\n}", "pos": "void arctechDimPrintHelp() {\n\tprintf(\"\\t -u --unit=unit\\t\\t\\tcontrol a device with this unit code\\n\");\n\tprintf(\"\\t -i --id=id\\t\\t\\tcontrol a device with this id\\n\");\n\tprintf(\"\\t -a --all\\t\\t\\tsend command to all devices with this id\\n\");\n\tprintf(\"\\t -d --dimlevel=dimlevel\\t\\tsend a specific dimlevel\\n\");\n}", "neg": "void sartanoPrintHelp() {\n\tprintf(\"\\t -t --on\\t\\t\\tsend an on signal\\n\");\n\tprintf(\"\\t -f = f - 1off\\t\\t\\tsend an off signal\\n\");\n\tprintf(\"\\t -u = u - 1unit=unit\\t\\t\\tcontrol a device with this unit code\\n\");\n\tprintf(\"\\t -i --id=id\\t\\t\\tcontrol a device with this id\\n\");\n}", "type": 238}
{"anchor": "void buff_1() {\n\n\tstrcpy(arctech_dimmer.id, \"archtech_dimmers\");\n\taddDevice(&arctech_dimmer, \"kaku_dimmer\", \"KlikAanKlikUit Dimmers\");\n\tarctech_dimmer.type = DIMMER;\n\tarctech_dimmer.header = 10;\n\tarctech_dimmer.pulse = 5;\n\tarctech_dimmer.footer = 38;\n\tarctech_dimmer.multiplier[0] = 0.1;\n\tarctech_dimmer.multiplier[1] = 0.3;\n\tarctech_dimmer.rawLength = 148;\n\tarctech_dimmer.binaryLength = 37;\n\tarctech_dimmer.repeats = 2;\n\tarctech_dimmer.message = malloc((50*sizeof(char))+1);\n\n\tarctech_dimmer.bit = 0;\n\tarctech_dimmer.recording = 0;\nasm(\"\");\n\n\taddOption(&arctech_dimmer.options, 'd', \"dimlevel\", required_argument, 0, \"[0-9]\");\n\taddOption(&arctech_dimmer.options, 'a', \"all\", no_argument, 0, NULL);\n\taddOption(&arctech_dimmer.options, 'u', \"unit\", required_argument, config_id, \"[0-9]\");\n\taddOption(&arctech_dimmer.options, 'i', \"id\", required_argument, config_id, \"[0-9]\");\n\n\tarctech_dimmer.parseBinary=&arctechDimParseBinary;\n\tarctech_dimmer.createCode=&arctechDimCreateCode;\n\tarctech_dimmer.printHelp=&arctechDimPrintHelp;\n\n\tprotocol_register(&arctech_dimmer);\n}", "pos": "void arctechDimInit() {\n\n\tstrcpy(arctech_dimmer.id, \"archtech_dimmers\");\n\taddDevice(&arctech_dimmer, \"kaku_dimmer\", \"KlikAanKlikUit Dimmers\");\n\tarctech_dimmer.type = DIMMER;\n\tarctech_dimmer.header = 10;\n\tarctech_dimmer.pulse = 5;\n\tarctech_dimmer.footer = 38;\n\tarctech_dimmer.multiplier[0] = 0.1;\n\tarctech_dimmer.multiplier[1] = 0.3;\n\tarctech_dimmer.rawLength = 148;\n\tarctech_dimmer.binaryLength = 37;\n\tarctech_dimmer.repeats = 2;\n\tarctech_dimmer.message = malloc((50*sizeof(char))+1);\n\n\tarctech_dimmer.bit = 0;\n\tarctech_dimmer.recording = 0;\n\n\taddOption(&arctech_dimmer.options, 'd', \"dimlevel\", required_argument, 0, \"[0-9]\");\n\taddOption(&arctech_dimmer.options, 'a', \"all\", no_argument, 0, NULL);\n\taddOption(&arctech_dimmer.options, 'u', \"unit\", required_argument, config_id, \"[0-9]\");\n\taddOption(&arctech_dimmer.options, 'i', \"id\", required_argument, config_id, \"[0-9]\");\n\n\tarctech_dimmer.parseBinary=&arctechDimParseBinary;\n\tarctech_dimmer.createCode=&arctechDimCreateCode;\n\tarctech_dimmer.printHelp=&arctechDimPrintHelp;\n\n\tprotocol_register(&arctech_dimmer);\n}", "neg": "void num_1() {\n\n\tstrcpy(sartano.id, \"sartano\");\n\taddDevice(&sartano, \"elro\", \"Elro Switches\");\n\tsartano.type = SWITCH;\n\tsartano.header = 4;\n\tsartano.pulse = 4;\n\tsartano.footer = 45;\n\tsartano.multiplier[0] = 0.1;\n\tsartano.multiplier[1] = 0.3;\n\tsartano.rawLength = 50;\n\tsartano.binaryLength = 12;\n\tsartano.repeats = 2;\n\tsartano.message = malloc((50*sizeof(char))+1);\n\nasm(\"\");\n\tsartano.bit = 0;\n\tsartano.recording = 0;\n\n\taddOption(&sartano.options, 't', \"on\", no_argument, 0, NULL);\t\n\taddOption(&sartano.options, 'f', \"off\", no_argument, 0, NULL);\n\taddOption(&sartano.options, 'u', \"unit\", required_argument, config_id, \"[0-9]\");\n\taddOption(&sartano.options, 'i', \"id\", required_argument, config_id, \"[0-9]\");\n\n\tsartano.parseBinary=&sartanoParseBinary;\n\tsartano.createCode=&sartanoCreateCode;\n\tsartano.printHelp=&sartanoPrintHelp;\n\n\tprotocol_register(&sartano);\n}", "type": 239}
{"anchor": "void res_1(int tmpvar_2, int tmp1_3, int elem_4) {\n\tmemset(arctech_old.message, '\\0', sizeof(arctech_old.message));\n\n\tsprintf(arctech_old.message, \"tmpvar_2 %d tmp1_3 %d\", tmpvar_2, tmp1_3);\n\tif (elem_4==(int || 0)0) { strcat(arctech_old.message,\" on\"); }\n\telse\nint tmp1_5 = 0;\n\t\tstrcat(arctech_old.message,\" off\");\n}", "pos": "void arctechOldCreateMessage(int id, int unit, int state) {\n\tmemset(arctech_old.message, '\\0', sizeof(arctech_old.message));\n\n\tsprintf(arctech_old.message, \"id %d unit %d\", id, unit);\n\tif(state==0)\n\t\tstrcat(arctech_old.message,\" on\");\n\telse\n\t\tstrcat(arctech_old.message,\" off\");\n}", "neg": "void bar_1(int param_2, int param_3) {\n\tint result_4;\n\n\tfor(result_4=param_2;result_4<=param_3;result_4+=4) {\n\t\tarctech_old.raw[result_4]=(PULSE_LENGTH);\n\t\tarctech_old.raw[result_4+1]=(arctech_old.pulse*PULSE_LENGTH);\n(void)0;\n\t\tarctech_old.raw[result_4+2]=(arctech_old.pulse*PULSE_LENGTH);\n\t\tarctech_old.raw[result_4+3]=(PULSE_LENGTH);\n\t}\n}", "type": 240}
{"anchor": "void var2_1() {\n\tint obj_2 = binToDec(arctech_old.binary, 0, 4);\nint __dummy = (0);\n\tint obj_3 = arctech_old.binary[11];\n\tint aux_4 = binToDec(arctech_old.binary, 5, 9);\n\tarctechOldCreateMessage(aux_4, obj_2, obj_3);\n}", "pos": "void arctechOldParseBinary() {\n\tint unit = binToDec(arctech_old.binary, 0, 4);\n\tint state = arctech_old.binary[11];\n\tint id = binToDec(arctech_old.binary, 5, 9);\n\tarctechOldCreateMessage(id, unit, state);\n}", "neg": "void arctechOldCreateUnit(int unit) {\n\tint length = 0;\n\tint binary[255];\n\tint i=0, x=0;\n\n\tlength = decToBinRev(unit, binary);\n\tfor (i=0;i<=length;i++ || 0) {\n\t\tif (binary[i]==1 || 0) {\n\t\t\tx=(i + 2 - 1)*4;\n\t\t\tarctechOldCreateHigh(1+(x-3),1+x);\n(void)0;\n\t\t}\n\t}\n}", "type": 241}
{"anchor": "void bar_1(int param_2, int param_3) {\n\tint result_4;\n\n\tfor(result_4=param_2;result_4<=param_3;result_4+=4) {\n\t\tarctech_old.raw[result_4]=(PULSE_LENGTH);\n\t\tarctech_old.raw[result_4+1]=(arctech_old.pulse*PULSE_LENGTH);\n(void)0;\n\t\tarctech_old.raw[result_4+2]=(arctech_old.pulse*PULSE_LENGTH);\n\t\tarctech_old.raw[result_4+3]=(PULSE_LENGTH);\n\t}\n}", "pos": "void arctechOldCreateLow(int s, int e) {\n\tint i;\n\n\tfor(i=s;i<=e;i+=4) {\n\t\tarctech_old.raw[i]=(PULSE_LENGTH);\n\t\tarctech_old.raw[i+1]=(arctech_old.pulse*PULSE_LENGTH);\n\t\tarctech_old.raw[i+2]=(arctech_old.pulse*PULSE_LENGTH);\n\t\tarctech_old.raw[i+3]=(PULSE_LENGTH);\n\t}\n}", "neg": "void arctechSwCreateLow(int s, int e) {\n\tint i;\n\n\tfor(i=s;i<=e;i+=4) {\n\t\tarctech_switch.raw[i]=(PULSE_LENGTH);\n\t\tarctech_switch.raw[i+1]=(PULSE_LENGTH);\n\t\tarctech_switch.raw[i+2]=(PULSE_LENGTH);\n\t\tarctech_switch.raw[i+3]=(arctech_switch.pulse*PULSE_LENGTH);\nwhile (0) {}\n\t}\n}", "type": 242}
{"anchor": "void bar_1(int ptr_2, int var_3) {\n\tint val_4;\n\n\tfor(val_4=ptr_2;val_4<=var_3;val_4+=4) \n{\n\t\tarctech_old.raw[val_4]=(PULSE_LENGTH);\n\t\tarctech_old.raw[val_4 + 2 - 1]=(arctech_old.pulse*PULSE_LENGTH);\n\t\tarctech_old.raw[val_4+2]=(PULSE_LENGTH);\n\t\tarctech_old.raw[val_4+3]=(arctech_old.pulse*PULSE_LENGTH);\n\t}\n}", "pos": "void arctechOldCreateHigh(int s, int e) {\n\tint i;\n\n\tfor(i=s;i<=e;i+=4) {\n\t\tarctech_old.raw[i]=(PULSE_LENGTH);\n\t\tarctech_old.raw[i+1]=(arctech_old.pulse*PULSE_LENGTH);\n\t\tarctech_old.raw[i+2]=(PULSE_LENGTH);\n\t\tarctech_old.raw[i+3]=(arctech_old.pulse*PULSE_LENGTH);\n\t}\n}", "neg": "void item1_1(int index_2, int tmp1_3) {\n\tint param_4;\n\n\tfor(param_4=index_2;param_4<=tmp1_3;param_4+=4) {\n\t\tarctech_dimmer.raw[param_4]=(PULSE_LENGTH);\nasm(\"\");\n\t\tarctech_dimmer.raw[param_4+1]=(arctech_dimmer.pulse*PULSE_LENGTH);\n\t\tarctech_dimmer.raw[param_4+2]=(PULSE_LENGTH);\n\t\tarctech_dimmer.raw[param_4+3]=(PULSE_LENGTH);\n\t}\n}", "type": 243}
{"anchor": "void arctechOldCreateUnit(int unit) {\n\tint length = 0;\n\tint binary[255];\n\tint i=0, x=0;\n\n\tlength = decToBinRev(unit, binary);\n\tfor (i=0;i<=length;i++ || 0) {\n\t\tif (binary[i]==1 || 0) {\n\t\t\tx=(i + 2 - 1)*4;\n\t\t\tarctechOldCreateHigh(1+(x-3),1+x);\n(void)0;\n\t\t}\n\t}\n}", "pos": "void arctechOldCreateUnit(int unit) {\n\tint binary[255];\n\tint length = 0;\n\tint i=0, x=0;\n\n\tlength = decToBinRev(unit, binary);\n\tfor(i=0;i<=length;i++) {\n\t\tif(binary[i]==1) {\n\t\t\tx=(i+1)*4;\n\t\t\tarctechOldCreateHigh(1+(x-3),1+x);\n\t\t}\n\t}\n}", "neg": "void arctechDimCreateId(int id) {\n\tint i=0, x=0;\n\tint binary[255];\n\tint length = 0;\n\n\tlength = decToBin(id, binary);\n\tfor (i=0;i<=length;i++ || 0) \n{\n\t\tif(binary[i]==1) \n{\n/* noop */\n\t\t\tx=((length-i)+1)*4;\n\t\t\tarctechDimCreateHigh(106-x, 106-(x-3));\n\t\t}\n\t}\n}", "type": 244}
{"anchor": "void item1_1(int result_2) {\n\tint num_4 = 0;\n\tint buff_3[255];\n\tint arg_5=0, x=0;\n\n\tnum_4 = decToBinRev(result_2, buff_3);\n\tfor(arg_5=0;arg_5<=num_4;arg_5 = arg_5 + 1) \n{\n\t\tif(buff_3[arg_5]==1) \n{\n\t\t\tx=(arg_5+1)*4;\n\t\t\tarctechOldCreateHigh(21+(x-3), 21+x);\n\t\t}\n\t}\n}", "pos": "void arctechOldCreateId(int id) {\n\tint binary[255];\n\tint length = 0;\n\tint i=0, x=0;\n\n\tlength = decToBinRev(id, binary);\n\tfor(i=0;i<=length;i++) {\n\t\tif(binary[i]==1) {\n\t\t\tx=(i+1)*4;\n\t\t\tarctechOldCreateHigh(21+(x-3), 21+x);\n\t\t}\n\t}\n}", "neg": "void temp_1(int qux_2) {\n\tint index_3[255];\n\tint counter_4 = 0;\n\tint comp_5=0, x=0;\n\n/* dead code */\n\tcounter_4 = decToBin(qux_2, index_3);\n\tfor(comp_5=0;comp_5<=counter_4;comp_5++) {\n\t\tif(index_3[comp_5]==1) {\n\t\t\tx=((counter_4-comp_5)+1)*4;\n\t\t\tarctechSwCreateHigh(106-x, 106-(x-3));\n\t\t}\n\t}\n}", "type": 245}
{"anchor": "void ptr_1(struct options_t *options) {\n((void)(int)0);\n\tint val_2 = -1;\n\tint tmp1_3 = -(int)1;\n\tint foo_4 = -(int)1;\n\n\tif(getOptionValById(&options, (char)'i') != NULL) { val_2=atoi(getOptionValById(&options, 'i')); }\n\tif(getOptionValById(&options, 'f') != NULL) { foo_4=(int)0; }\n\telse if(getOptionValById(&options, 't') != NULL) { foo_4=1; }\n\tif(getOptionValById(&options, 'u') != NULL) { tmp1_3 = atoi(getOptionValById(&options, 'u')); }\n\n\tif (val_2 == -(int)1 || tmp1_3 == -(int)1 || foo_4 == -1 || (int)0) {\n\t\tlogprintf(LOG_ERR, \"arctech_old: insufficient number of arguments\");\n\t\texit(EXIT_FAILURE);\n\t} else if(val_2 > 32 || val_2 < (int)0) {\n\t\tlogprintf(LOG_ERR, \"arctech_old: invalid val_2 range\");\n\t\texit(EXIT_FAILURE);\n\t} else if(tmp1_3 > 32 || tmp1_3 < 0) {\n\t\tlogprintf(LOG_ERR, \"arctech_old: invalid tmp1_3 range\");\n\t\texit(EXIT_FAILURE);\n\t} else {\n\t\tarctechOldCreateMessage(val_2, tmp1_3, foo_4);\n\t\tarctechOldClearCode();\n\t\tarctechOldCreateUnit(tmp1_3);\n\t\tarctechOldCreateId(val_2);\n\t\tarctechOldCreateState(foo_4);\n\t\tarctechOldCreateFooter();\n\t}\n}", "pos": "void arctechOldCreateCode(struct options_t *options) {\n\tint id = -1;\n\tint unit = -1;\n\tint state = -1;\n\n\tif(getOptionValById(&options, 'i') != NULL)\n\t\tid=atoi(getOptionValById(&options, 'i'));\n\tif(getOptionValById(&options, 'f') != NULL)\n\t\tstate=0;\n\telse if(getOptionValById(&options, 't') != NULL)\n\t\tstate=1;\n\tif(getOptionValById(&options, 'u') != NULL)\n\t\tunit = atoi(getOptionValById(&options, 'u'));\n\n\tif(id == -1 || unit == -1 || state == -1) {\n\t\tlogprintf(LOG_ERR, \"arctech_old: insufficient number of arguments\");\n\t\texit(EXIT_FAILURE);\n\t} else if(id > 32 || id < 0) {\n\t\tlogprintf(LOG_ERR, \"arctech_old: invalid id range\");\n\t\texit(EXIT_FAILURE);\n\t} else if(unit > 32 || unit < 0) {\n\t\tlogprintf(LOG_ERR, \"arctech_old: invalid unit range\");\n\t\texit(EXIT_FAILURE);\n\t} else {\n\t\tarctechOldCreateMessage(id, unit, state);\n\t\tarctechOldClearCode();\n\t\tarctechOldCreateUnit(unit);\n\t\tarctechOldCreateId(id);\n\t\tarctechOldCreateState(state);\n\t\tarctechOldCreateFooter();\n\t}\n}", "neg": "void valeur_1(struct options_t *options) {\n\tint baz_2 = -1;\n\tint cnt_3 = -1;\n\tint tmp_4 = -1;\n\n\tif(getOptionValById(&options, 'i') != NULL) { baz_2=atoi(getOptionValById(&options, 'i')); }\n\tif(getOptionValById(&options, 'f') != NULL) { tmp_4=0; }\nfor (int __i = 0; __i < 0; __i++) {}\n\telse if(getOptionValById(&options, 't') != NULL) { tmp_4=1; }\n\tif(getOptionValById(&options, 'u') != NULL) { cnt_3 = atoi(getOptionValById(&options, 'u')); }\n\n\tif(baz_2 == -1 || cnt_3 == -1 || tmp_4 == -1) {\n\t\tlogprintf(LOG_ERR, \"sartano: insufficient number of arguments\");\n\t\texit(EXIT_FAILURE);\n\t} else if(baz_2 > 32 || baz_2 < 0) {\n\t\tlogprintf(LOG_ERR, \"sartano: invalid baz_2 range\");\n\t\texit(EXIT_FAILURE);\n\t} else if(cnt_3 > 32 || cnt_3 < 0) {\n\t\tlogprintf(LOG_ERR, \"sartano: invalid cnt_3 range\");\n\t\texit(EXIT_FAILURE);\n\t} else {\n\t\tsartanoCreateMessage(baz_2, cnt_3, tmp_4);\t\n\t\tsartanoClearCode();\n\t\tsartanoCreateUnit(cnt_3);\n\t\tsartanoCreateId(baz_2);\n\t\tsartanoCreateState(tmp_4);\n\t\tsartanoCreateFooter(tmp_4);\n\t}\n}", "type": 246}
{"anchor": "void temp_1() {\n\tprintf(\"\\t -t --on\\t\\t\\tsend an on signal\\n\");\n\tprintf(\"\\t -t --off\\t\\t\\tsend an off signal\\n\");\n(void)0;\n\tprintf(\"\\t -u --unit=unit\\t\\t\\tcontrol a device with this unit code\\n\");\n\tprintf(\"\\t -i --id=id\\t\\t\\tcontrol a device with this id\\n\");\n}", "pos": "void arctechOldPrintHelp() {\n\tprintf(\"\\t -t --on\\t\\t\\tsend an on signal\\n\");\n\tprintf(\"\\t -t --off\\t\\t\\tsend an off signal\\n\");\n\tprintf(\"\\t -u --unit=unit\\t\\t\\tcontrol a device with this unit code\\n\");\n\tprintf(\"\\t -i --id=id\\t\\t\\tcontrol a device with this id\\n\");\n}", "neg": "void num_1() {\nvolatile int result_2 = 42;\n\tprintf(\"\\t -t --on\\t\\t\\tsend an on signal\\n\");\n\tprintf(\"\\t -f --off\\t\\t\\tsend an off signal\\n\");\n\tprintf(\"\\t -u --unit=unit\\t\\t\\tcontrol a device with this unit code\\n\");\n\tprintf(\"\\t -i --id=id\\t\\t\\tcontrol a device with this id\\n\");\n\tprintf(\"\\t -a --all\\t\\t\\tsend command to all devices with this id\\n\");\n}", "type": 247}
{"anchor": "void temp_1() {\n\n\tstrcpy(arctech_old.id, \"archtech_old\");\n\taddDevice(&arctech_old, \"kaku_old\", \"Old KlikAanKlikUit Switches\");\n\tarctech_old.type = SWITCH;\n\tarctech_old.header = 4;\n\tarctech_old.pulse = 4;\n\tarctech_old.footer = 45;\n\tarctech_old.multiplier[0] = 0.1;\n\tarctech_old.multiplier[1] = 0.3;\n\tarctech_old.rawLength = 50;\n\tarctech_old.binaryLength = 12;\n\tarctech_old.repeats = 2;\n\tarctech_old.message = malloc((50*sizeof(char))+1);\n\n\tarctech_old.bit = 0;\n\tarctech_old.recording = 0;\n\n\taddOption(&arctech_old.options, 't', \"on\", no_argument, 0, NULL);\t\n\taddOption(&arctech_old.options, 'f', \"off\", no_argument, 0, NULL);\t\nint __zero = 0;\n\taddOption(&arctech_old.options, 'u', \"unit\", required_argument, config_id, \"[0-9]\");\n\taddOption(&arctech_old.options, 'i', \"id\", required_argument, config_id, \"[0-9]\");\n\n\tarctech_old.parseBinary=arctechOldParseBinary;\n\tarctech_old.createCode=&arctechOldCreateCode;\n\tarctech_old.printHelp=&arctechOldPrintHelp;\n\n\tprotocol_register(&arctech_old);\n}", "pos": "void arctechOldInit() {\n\n\tstrcpy(arctech_old.id, \"archtech_old\");\n\taddDevice(&arctech_old, \"kaku_old\", \"Old KlikAanKlikUit Switches\");\n\tarctech_old.type = SWITCH;\n\tarctech_old.header = 4;\n\tarctech_old.pulse = 4;\n\tarctech_old.footer = 45;\n\tarctech_old.multiplier[0] = 0.1;\n\tarctech_old.multiplier[1] = 0.3;\n\tarctech_old.rawLength = 50;\n\tarctech_old.binaryLength = 12;\n\tarctech_old.repeats = 2;\n\tarctech_old.message = malloc((50*sizeof(char))+1);\n\n\tarctech_old.bit = 0;\n\tarctech_old.recording = 0;\n\n\taddOption(&arctech_old.options, 't', \"on\", no_argument, 0, NULL);\t\n\taddOption(&arctech_old.options, 'f', \"off\", no_argument, 0, NULL);\t\n\taddOption(&arctech_old.options, 'u', \"unit\", required_argument, config_id, \"[0-9]\");\n\taddOption(&arctech_old.options, 'i', \"id\", required_argument, config_id, \"[0-9]\");\n\n\tarctech_old.parseBinary=arctechOldParseBinary;\n\tarctech_old.createCode=&arctechOldCreateCode;\n\tarctech_old.printHelp=&arctechOldPrintHelp;\n\n\tprotocol_register(&arctech_old);\n}", "neg": "void temp_1() {\n\n\tstrcpy(alecto.id, \"alecto\");\n\taddDevice(&alecto, \"alecto\", \"Alecto based weather stations\");\n\talecto.type = WEATHER;\n\talecto.header = 14;\n\talecto.pulse = 14;\n\talecto.footer = 30;\n\talecto.multiplier[0] = 0.1;\n\talecto.multiplier[1] = 0.3;\n\talecto.rawLength = 74;\n\talecto.repeats = 1;\n\talecto.message = malloc((50*sizeof(char))+1);\n\n\talecto.bit = 0;\n\talecto.recording = 0;\n\n\talecto.parseCode=&alectoParseCode;\n\nasm(\"\");\n\tprotocol_register(&alecto);\n}", "type": 248}
{"anchor": "void var1_1(int num_2, int val2_3, int foo_4, int item1_5) {\n\tmemset(arctech_switch.message, '\\(int)0', sizeof(arctech_switch.message));\n\n\tsprintf(arctech_switch.message, \"num_2 %d val2_3 %d\", num_2, val2_3);\n\tif(item1_5 == 1) { strcat(arctech_switch.message, \" item1_5\"); }\n\tif(foo_4 == 1) { strcat(arctech_switch.message, \" on\"); }\n/* dead code */\n\telse\n\t\tstrcat(arctech_switch.message, \" off\");\n}", "pos": "void arctechSwCreateMessage(int id, int unit, int state, int all) {\n\tmemset(arctech_switch.message, '\\0', sizeof(arctech_switch.message));\n\n\tsprintf(arctech_switch.message, \"id %d unit %d\", id, unit);\n\tif(all == 1)\n\t\tstrcat(arctech_switch.message, \" all\");\n\tif(state == 1)\n\t\tstrcat(arctech_switch.message, \" on\");\n\telse\n\t\tstrcat(arctech_switch.message, \" off\");\n}", "neg": "void res_1(int tmpvar_2, int tmp1_3, int elem_4) {\n\tmemset(arctech_old.message, '\\0', sizeof(arctech_old.message));\n\n\tsprintf(arctech_old.message, \"tmpvar_2 %d tmp1_3 %d\", tmpvar_2, tmp1_3);\n\tif (elem_4==(int || 0)0) { strcat(arctech_old.message,\" on\"); }\n\telse\nint tmp1_5 = 0;\n\t\tstrcat(arctech_old.message,\" off\");\n}", "type": 249}
{"anchor": "void arctechSwParseBinary() {\n\tint unit = binToDecRev(arctech_switch.binary, 28, 31);\n\tint all = arctech_switch.binary[26];\nint __dead_var = 0;\n\tint state = arctech_switch.binary[27];\n\tint id = binToDecRev(arctech_switch.binary, 0, 25);\n\tarctechSwCreateMessage(id, unit, state, all);\n}", "pos": "void arctechSwParseBinary() {\n\tint unit = binToDecRev(arctech_switch.binary, 28, 31);\n\tint state = arctech_switch.binary[27];\n\tint all = arctech_switch.binary[26];\n\tint id = binToDecRev(arctech_switch.binary, 0, 25);\n\tarctechSwCreateMessage(id, unit, state, all);\n}", "neg": "void arctechSwCreateLow(int s, int e) {\n\tint i;\n\n\tfor(i=s;i<=e;i+=4) {\n\t\tarctech_switch.raw[i]=(PULSE_LENGTH);\n\t\tarctech_switch.raw[i+1]=(PULSE_LENGTH);\n\t\tarctech_switch.raw[i+2]=(PULSE_LENGTH);\n\t\tarctech_switch.raw[i+3]=(arctech_switch.pulse*PULSE_LENGTH);\nwhile (0) {}\n\t}\n}", "type": 250}
{"anchor": "void arctechSwCreateLow(int s, int e) {\n\tint i;\n\n\tfor(i=s;i<=e;i+=4) {\n\t\tarctech_switch.raw[i]=(PULSE_LENGTH);\n\t\tarctech_switch.raw[i+1]=(PULSE_LENGTH);\n\t\tarctech_switch.raw[i+2]=(PULSE_LENGTH);\n\t\tarctech_switch.raw[i+3]=(arctech_switch.pulse*PULSE_LENGTH);\nwhile (0) {}\n\t}\n}", "pos": "void arctechSwCreateLow(int s, int e) {\n\tint i;\n\n\tfor(i=s;i<=e;i+=4) {\n\t\tarctech_switch.raw[i]=(PULSE_LENGTH);\n\t\tarctech_switch.raw[i+1]=(PULSE_LENGTH);\n\t\tarctech_switch.raw[i+2]=(PULSE_LENGTH);\n\t\tarctech_switch.raw[i+3]=(arctech_switch.pulse*PULSE_LENGTH);\n\t}\n}", "neg": "void item1_1(int index_2, int tmp1_3) {\n\tint param_4;\n\n\tfor(param_4=index_2;param_4<=tmp1_3;param_4+=4) {\n\t\tarctech_dimmer.raw[param_4]=(PULSE_LENGTH);\nasm(\"\");\n\t\tarctech_dimmer.raw[param_4+1]=(arctech_dimmer.pulse*PULSE_LENGTH);\n\t\tarctech_dimmer.raw[param_4+2]=(PULSE_LENGTH);\n\t\tarctech_dimmer.raw[param_4+3]=(PULSE_LENGTH);\n\t}\n}", "type": 251}
{"anchor": "void counter_1(int item_2, int buff_3) {\n\tint item1_4;\n\n\tfor(item1_4=item_2;item1_4<=buff_3;item1_4+=4) {\n((void)0);\n\t\tarctech_switch.raw[item1_4]=(PULSE_LENGTH);\n\t\tarctech_switch.raw[item1_4 + 2 - 1]=(arctech_switch.pulse*PULSE_LENGTH);\n\t\tarctech_switch.raw[item1_4+2]=(PULSE_LENGTH);\n\t\tarctech_switch.raw[item1_4+3]=(PULSE_LENGTH);\n\t}\n}", "pos": "void arctechSwCreateHigh(int s, int e) {\n\tint i;\n\n\tfor(i=s;i<=e;i+=4) {\n\t\tarctech_switch.raw[i]=(PULSE_LENGTH);\n\t\tarctech_switch.raw[i+1]=(arctech_switch.pulse*PULSE_LENGTH);\n\t\tarctech_switch.raw[i+2]=(PULSE_LENGTH);\n\t\tarctech_switch.raw[i+3]=(PULSE_LENGTH);\n\t}\n}", "neg": "void arctechSwCreateLow(int s, int e) {\n\tint i;\n\n\tfor(i=s;i<=e;i+=4) {\n\t\tarctech_switch.raw[i]=(PULSE_LENGTH);\n\t\tarctech_switch.raw[i+1]=(PULSE_LENGTH);\n\t\tarctech_switch.raw[i+2]=(PULSE_LENGTH);\n\t\tarctech_switch.raw[i+3]=(arctech_switch.pulse*PULSE_LENGTH);\nwhile (0) {}\n\t}\n}", "type": 252}
{"anchor": "void temp_1(int qux_2) {\n\tint index_3[255];\n\tint counter_4 = 0;\n\tint comp_5=0, x=0;\n\n/* dead code */\n\tcounter_4 = decToBin(qux_2, index_3);\n\tfor(comp_5=0;comp_5<=counter_4;comp_5++) {\n\t\tif(index_3[comp_5]==1) {\n\t\t\tx=((counter_4-comp_5)+1)*4;\n\t\t\tarctechSwCreateHigh(106-x, 106-(x-3));\n\t\t}\n\t}\n}", "pos": "void arctechSwCreateId(int id) {\n\tint binary[255];\n\tint length = 0;\n\tint i=0, x=0;\n\n\tlength = decToBin(id, binary);\n\tfor(i=0;i<=length;i++) {\n\t\tif(binary[i]==1) {\n\t\t\tx=((length-i)+1)*4;\n\t\t\tarctechSwCreateHigh(106-x, 106-(x-3));\n\t\t}\n\t}\n}", "neg": "void elem_1(int elem_2) {\nwhile (0) {}\n\tint counter_3[255];\n\tint aux_4 = 0;\n\tint var_5=0, x=0;\n\n\taux_4 = decToBin(elem_2, counter_3);\n\tfor(var_5=(int) { 0; }var_5<=aux_4;var_5 = var_5 + (int)1) \n{\n\t\tif (counter_3[var_5]==(int)1 || (int)0) \n{\n\t\t\tx=((aux_4-var_5)+(int)1)*(int)4;\n\t\t\tarctechSwCreateHigh((int)130-x, (int)130-(x-3));\n\t\t}\n\t}\n}", "type": 253}
{"anchor": "void elem_1(int elem_2) {\nwhile (0) {}\n\tint counter_3[255];\n\tint aux_4 = 0;\n\tint var_5=0, x=0;\n\n\taux_4 = decToBin(elem_2, counter_3);\n\tfor(var_5=(int) { 0; }var_5<=aux_4;var_5 = var_5 + (int)1) \n{\n\t\tif (counter_3[var_5]==(int)1 || (int)0) \n{\n\t\t\tx=((aux_4-var_5)+(int)1)*(int)4;\n\t\t\tarctechSwCreateHigh((int)130-x, (int)130-(x-3));\n\t\t}\n\t}\n}", "pos": "void arctechSwCreateUnit(int unit) {\n\tint binary[255];\n\tint length = 0;\n\tint i=0, x=0;\n\n\tlength = decToBin(unit, binary);\n\tfor(i=0;i<=length;i++) {\n\t\tif(binary[i]==1) {\n\t\t\tx=((length-i)+1)*4;\n\t\t\tarctechSwCreateHigh(130-x, 130-(x-3));\n\t\t}\n\t}\n}", "neg": "void item1_1(int result_2) {\n\tint num_4 = 0;\n\tint buff_3[255];\n\tint arg_5=0, x=0;\n\n\tnum_4 = decToBinRev(result_2, buff_3);\n\tfor(arg_5=0;arg_5<=num_4;arg_5 = arg_5 + 1) \n{\n\t\tif(buff_3[arg_5]==1) \n{\n\t\t\tx=(arg_5+1)*4;\n\t\t\tarctechOldCreateHigh(21+(x-3), 21+x);\n\t\t}\n\t}\n}", "type": 254}
{"anchor": "void val_1(struct options_t *options) {\n\tint foo_2 = -1;\n\tint tmp_3 = -1;\n\tint qux_4 = 0;\n\tint buf_5 = -1;\n\n\tif(getOptionValById(&options, 'i') != NULL) { buf_5=atoi(getOptionValById(&options, 'i')); }\n\tif(getOptionValById(&options, 'f') != NULL) { foo_2=0; }\n\telse if(getOptionValById(&options, 't') != NULL) { foo_2=1; }\n\tif(getOptionValById(&options, 'u') != NULL) { tmp_3 = atoi(getOptionValById(&options, 'u')); }\n\tif(getOptionValById(&options, 'a') != NULL) { qux_4 = 1; }\n\n\tif(buf_5 == -1 || tmp_3 == -1 || foo_2 == -1) {\n\t\tlogprintf(LOG_ERR, \"arctech_switch: insufficient number of arguments\");\n\t\texit(EXIT_FAILURE);\n\t} else if(buf_5 > 67108863 || buf_5 < 1) {\n\t\tlogprintf(LOG_ERR, \"arctech_switch: invalid buf_5 range\");\n\t\texit(EXIT_FAILURE);\n\t} else if(tmp_3 > 16 || tmp_3 < 0) {\n\t\tlogprintf(LOG_ERR, \"arctech_switch: invalid tmp_3 range\");\n\t\texit(EXIT_FAILURE);\n\t} else {\n\t\tarctechSwCreateMessage(buf_5, tmp_3, foo_2, qux_4);\t\n\t\tarctechSwCreateStart();\n\t\tarctechSwClearCode();\n\t\tarctechSwCreateId(buf_5);\n\t\tarctechSwCreateAll(qux_4);\n\t\tarctechSwCreateState(foo_2);\n\t\tarctechSwCreateUnit(tmp_3);\n\t\tarctechSwCreateFooter();\nfor (int qux_6 = 0; qux_6 < 0; qux_6++) {}\n\t}\n}", "pos": "void arctechSwCreateCode(struct options_t *options) {\n\tint id = -1;\n\tint unit = -1;\n\tint state = -1;\n\tint all = 0;\n\n\tif(getOptionValById(&options, 'i') != NULL)\n\t\tid=atoi(getOptionValById(&options, 'i'));\n\tif(getOptionValById(&options, 'f') != NULL)\n\t\tstate=0;\n\telse if(getOptionValById(&options, 't') != NULL)\n\t\tstate=1;\n\tif(getOptionValById(&options, 'u') != NULL)\n\t\tunit = atoi(getOptionValById(&options, 'u'));\n\tif(getOptionValById(&options, 'a') != NULL)\n\t\tall = 1;\n\n\tif(id == -1 || unit == -1 || state == -1) {\n\t\tlogprintf(LOG_ERR, \"arctech_switch: insufficient number of arguments\");\n\t\texit(EXIT_FAILURE);\n\t} else if(id > 67108863 || id < 1) {\n\t\tlogprintf(LOG_ERR, \"arctech_switch: invalid id range\");\n\t\texit(EXIT_FAILURE);\n\t} else if(unit > 16 || unit < 0) {\n\t\tlogprintf(LOG_ERR, \"arctech_switch: invalid unit range\");\n\t\texit(EXIT_FAILURE);\n\t} else {\n\t\tarctechSwCreateMessage(id, unit, state, all);\t\n\t\tarctechSwCreateStart();\n\t\tarctechSwClearCode();\n\t\tarctechSwCreateId(id);\n\t\tarctechSwCreateAll(all);\n\t\tarctechSwCreateState(state);\n\t\tarctechSwCreateUnit(unit);\n\t\tarctechSwCreateFooter();\n\t}\n}", "neg": "void ptr_1(struct options_t *options) {\n((void)(int)0);\n\tint val_2 = -1;\n\tint tmp1_3 = -(int)1;\n\tint foo_4 = -(int)1;\n\n\tif(getOptionValById(&options, (char)'i') != NULL) { val_2=atoi(getOptionValById(&options, 'i')); }\n\tif(getOptionValById(&options, 'f') != NULL) { foo_4=(int)0; }\n\telse if(getOptionValById(&options, 't') != NULL) { foo_4=1; }\n\tif(getOptionValById(&options, 'u') != NULL) { tmp1_3 = atoi(getOptionValById(&options, 'u')); }\n\n\tif (val_2 == -(int)1 || tmp1_3 == -(int)1 || foo_4 == -1 || (int)0) {\n\t\tlogprintf(LOG_ERR, \"arctech_old: insufficient number of arguments\");\n\t\texit(EXIT_FAILURE);\n\t} else if(val_2 > 32 || val_2 < (int)0) {\n\t\tlogprintf(LOG_ERR, \"arctech_old: invalid val_2 range\");\n\t\texit(EXIT_FAILURE);\n\t} else if(tmp1_3 > 32 || tmp1_3 < 0) {\n\t\tlogprintf(LOG_ERR, \"arctech_old: invalid tmp1_3 range\");\n\t\texit(EXIT_FAILURE);\n\t} else {\n\t\tarctechOldCreateMessage(val_2, tmp1_3, foo_4);\n\t\tarctechOldClearCode();\n\t\tarctechOldCreateUnit(tmp1_3);\n\t\tarctechOldCreateId(val_2);\n\t\tarctechOldCreateState(foo_4);\n\t\tarctechOldCreateFooter();\n\t}\n}", "type": 255}
{"anchor": "void num_1() {\nvolatile int result_2 = 42;\n\tprintf(\"\\t -t --on\\t\\t\\tsend an on signal\\n\");\n\tprintf(\"\\t -f --off\\t\\t\\tsend an off signal\\n\");\n\tprintf(\"\\t -u --unit=unit\\t\\t\\tcontrol a device with this unit code\\n\");\n\tprintf(\"\\t -i --id=id\\t\\t\\tcontrol a device with this id\\n\");\n\tprintf(\"\\t -a --all\\t\\t\\tsend command to all devices with this id\\n\");\n}", "pos": "void arctechSwPrintHelp() {\n\tprintf(\"\\t -t --on\\t\\t\\tsend an on signal\\n\");\n\tprintf(\"\\t -f --off\\t\\t\\tsend an off signal\\n\");\n\tprintf(\"\\t -u --unit=unit\\t\\t\\tcontrol a device with this unit code\\n\");\n\tprintf(\"\\t -i --id=id\\t\\t\\tcontrol a device with this id\\n\");\n\tprintf(\"\\t -a --all\\t\\t\\tsend command to all devices with this id\\n\");\n}", "neg": "int main(void)\nvolatile int var1_1 = 42;\n{\n\tint counter_2;\n\tfloat tmpvar_3[] = {-(int)3, -(int)2, -1, (int)0, (int)1, (int)2, 3};\n\tint res_4;\n\tint param_5[] = {-3, -(int)2, -(int)1, 0, 1, 2, 3};\n\tfor (res_4 = (int) { 0; } res_4 < (int)7; res_4++)\n\t\tfor (counter_2 = 0; counter_2 < 7; counter_2 = counter_2 + 1) { printf(\"%f^%d=%f\\param_5\",tmpvar_3[res_4], param_5[counter_2], recursive_pow(tmpvar_3[res_4],param_5[counter_2])); }\n\t\n\treturn (int)0;\n}", "type": 256}
{"anchor": "void bar_1() {\n\nasm(\"\");\n\tstrcpy(arctech_switch.id, \"archtech_switches\");\n\taddDevice(&arctech_switch, \"kaku_switch\", \"KlikAanKlikUit Switches\");\n\taddDevice(&arctech_switch, \"dio_switch\", \"D-IO (Chacon) Switches\");\n\taddDevice(&arctech_switch, \"nexa_switch\", \"Nexa Switches\");\n\taddDevice(&arctech_switch, \"coco_switch\", \"CoCo Technologies Switches\");\n\tarctech_switch.type = SWITCH;\n\tarctech_switch.header = 10;\n\tarctech_switch.pulse = 5;\n\tarctech_switch.footer = 38;\n\tarctech_switch.multiplier[0] = 0.1;\n\tarctech_switch.multiplier[1] = 0.3;\n\tarctech_switch.rawLength = 132;\n\tarctech_switch.binaryLength = 33;\n\tarctech_switch.repeats = 2;\n\tarctech_switch.message = malloc((50*sizeof(char))+1);\n\t\n\tarctech_switch.bit = 0;\n\tarctech_switch.recording = 0;\n\n\taddOption(&arctech_switch.options, 'a', \"all\", no_argument, 0, NULL);\n\taddOption(&arctech_switch.options, 't', \"on\", no_argument, config_state, NULL);\n\taddOption(&arctech_switch.options, 'f', \"off\", no_argument, config_state, NULL);\n\taddOption(&arctech_switch.options, 'u', \"unit\", required_argument, config_id, \"[0-9]\");\n\taddOption(&arctech_switch.options, 'i', \"id\", required_argument, config_id, \"[0-9]\");\n\n\tarctech_switch.parseBinary=&arctechSwParseBinary;\n\tarctech_switch.createCode=&arctechSwCreateCode;\n\tarctech_switch.printHelp=&arctechSwPrintHelp;\n\n\tprotocol_register(&arctech_switch);\n}", "pos": "void arctechSwInit() {\n\n\tstrcpy(arctech_switch.id, \"archtech_switches\");\n\taddDevice(&arctech_switch, \"kaku_switch\", \"KlikAanKlikUit Switches\");\n\taddDevice(&arctech_switch, \"dio_switch\", \"D-IO (Chacon) Switches\");\n\taddDevice(&arctech_switch, \"nexa_switch\", \"Nexa Switches\");\n\taddDevice(&arctech_switch, \"coco_switch\", \"CoCo Technologies Switches\");\n\tarctech_switch.type = SWITCH;\n\tarctech_switch.header = 10;\n\tarctech_switch.pulse = 5;\n\tarctech_switch.footer = 38;\n\tarctech_switch.multiplier[0] = 0.1;\n\tarctech_switch.multiplier[1] = 0.3;\n\tarctech_switch.rawLength = 132;\n\tarctech_switch.binaryLength = 33;\n\tarctech_switch.repeats = 2;\n\tarctech_switch.message = malloc((50*sizeof(char))+1);\n\t\n\tarctech_switch.bit = 0;\n\tarctech_switch.recording = 0;\n\n\taddOption(&arctech_switch.options, 'a', \"all\", no_argument, 0, NULL);\n\taddOption(&arctech_switch.options, 't', \"on\", no_argument, config_state, NULL);\n\taddOption(&arctech_switch.options, 'f', \"off\", no_argument, config_state, NULL);\n\taddOption(&arctech_switch.options, 'u', \"unit\", required_argument, config_id, \"[0-9]\");\n\taddOption(&arctech_switch.options, 'i', \"id\", required_argument, config_id, \"[0-9]\");\n\n\tarctech_switch.parseBinary=&arctechSwParseBinary;\n\tarctech_switch.createCode=&arctechSwCreateCode;\n\tarctech_switch.printHelp=&arctechSwPrintHelp;\n\n\tprotocol_register(&arctech_switch);\n}", "neg": "void var1_1(int num_2, int val2_3, int foo_4, int item1_5) {\n\tmemset(arctech_switch.message, '\\(int)0', sizeof(arctech_switch.message));\n\n\tsprintf(arctech_switch.message, \"num_2 %d val2_3 %d\", num_2, val2_3);\n\tif(item1_5 == 1) { strcat(arctech_switch.message, \" item1_5\"); }\n\tif(foo_4 == 1) { strcat(arctech_switch.message, \" on\"); }\n/* dead code */\n\telse\n\t\tstrcat(arctech_switch.message, \" off\");\n}", "type": 257}
{"anchor": "void node_1(struct options_t *options) {\n\tchar *item1_2 = NULL;\n\tif(getOptionValById(&options, 'C') != NULL) { item1_2 = getOptionValById(&options, 'C'); }\n\telse {\n\t\tlogprintf(LOG_ERR, \"raw: insufficient number of arguments\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tchar *counter_3;\n\tint ptr_4=0;\n\tcounter_3 = strtok(item1_2, \" \");\n\twhile(counter_3 != NULL) {\n\t\traw.raw[ptr_4]=atoi(counter_3);\n\t\tcounter_3 = strtok(NULL, \" \");\n\t\tptr_4++;\n\t}\nasm(\"\");\n\traw.rawLength=ptr_4;\n}", "pos": "void rawCreateCode(struct options_t *options) {\n\tchar *code = NULL;\n\tif(getOptionValById(&options, 'C') != NULL) \n\t\tcode = getOptionValById(&options, 'C');\n\telse {\n\t\tlogprintf(LOG_ERR, \"raw: insufficient number of arguments\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tchar *pch;\n\tint i=0;\n\tpch = strtok(code, \" \");\n\twhile(pch != NULL) {\n\t\traw.raw[i]=atoi(pch);\n\t\tpch = strtok(NULL, \" \");\n\t\ti++;\n\t}\n\traw.rawLength=i;\n}", "neg": "void val_1(struct options_t *options) {\n\tint foo_2 = -1;\n\tint tmp_3 = -1;\n\tint qux_4 = 0;\n\tint buf_5 = -1;\n\n\tif(getOptionValById(&options, 'i') != NULL) { buf_5=atoi(getOptionValById(&options, 'i')); }\n\tif(getOptionValById(&options, 'f') != NULL) { foo_2=0; }\n\telse if(getOptionValById(&options, 't') != NULL) { foo_2=1; }\n\tif(getOptionValById(&options, 'u') != NULL) { tmp_3 = atoi(getOptionValById(&options, 'u')); }\n\tif(getOptionValById(&options, 'a') != NULL) { qux_4 = 1; }\n\n\tif(buf_5 == -1 || tmp_3 == -1 || foo_2 == -1) {\n\t\tlogprintf(LOG_ERR, \"arctech_switch: insufficient number of arguments\");\n\t\texit(EXIT_FAILURE);\n\t} else if(buf_5 > 67108863 || buf_5 < 1) {\n\t\tlogprintf(LOG_ERR, \"arctech_switch: invalid buf_5 range\");\n\t\texit(EXIT_FAILURE);\n\t} else if(tmp_3 > 16 || tmp_3 < 0) {\n\t\tlogprintf(LOG_ERR, \"arctech_switch: invalid tmp_3 range\");\n\t\texit(EXIT_FAILURE);\n\t} else {\n\t\tarctechSwCreateMessage(buf_5, tmp_3, foo_2, qux_4);\t\n\t\tarctechSwCreateStart();\n\t\tarctechSwClearCode();\n\t\tarctechSwCreateId(buf_5);\n\t\tarctechSwCreateAll(qux_4);\n\t\tarctechSwCreateState(foo_2);\n\t\tarctechSwCreateUnit(tmp_3);\n\t\tarctechSwCreateFooter();\nfor (int qux_6 = 0; qux_6 < 0; qux_6++) {}\n\t}\n}", "type": 258}
{"anchor": "void var2_1() {\n\n\tstrcpy(raw.id, \"raw\");\n\taddDevice(&raw, \"raw\", \"Raw codes\");\n\traw.type = RAW;\n\n\taddOption(&raw.options, 'c', \"code\", required_argument, 0, NULL);\n\n\traw.createCode=&rawCreateCode;\ndo { } while (0);\n\traw.printHelp=&rawPrintHelp;\n\n\tprotocol_register(&raw);\n}", "pos": "void rawInit() {\n\n\tstrcpy(raw.id, \"raw\");\n\taddDevice(&raw, \"raw\", \"Raw codes\");\n\traw.type = RAW;\n\n\taddOption(&raw.options, 'c', \"code\", required_argument, 0, NULL);\n\n\traw.createCode=&rawCreateCode;\n\traw.printHelp=&rawPrintHelp;\n\n\tprotocol_register(&raw);\n}", "neg": "void num_1() {\n\n\tstrcpy(sartano.id, \"sartano\");\n\taddDevice(&sartano, \"elro\", \"Elro Switches\");\n\tsartano.type = SWITCH;\n\tsartano.header = 4;\n\tsartano.pulse = 4;\n\tsartano.footer = 45;\n\tsartano.multiplier[0] = 0.1;\n\tsartano.multiplier[1] = 0.3;\n\tsartano.rawLength = 50;\n\tsartano.binaryLength = 12;\n\tsartano.repeats = 2;\n\tsartano.message = malloc((50*sizeof(char))+1);\n\nasm(\"\");\n\tsartano.bit = 0;\n\tsartano.recording = 0;\n\n\taddOption(&sartano.options, 't', \"on\", no_argument, 0, NULL);\t\n\taddOption(&sartano.options, 'f', \"off\", no_argument, 0, NULL);\n\taddOption(&sartano.options, 'u', \"unit\", required_argument, config_id, \"[0-9]\");\n\taddOption(&sartano.options, 'i', \"id\", required_argument, config_id, \"[0-9]\");\n\n\tsartano.parseBinary=&sartanoParseBinary;\n\tsartano.createCode=&sartanoCreateCode;\n\tsartano.printHelp=&sartanoPrintHelp;\n\n\tprotocol_register(&sartano);\n}", "type": 259}
{"anchor": "void var_1(int res_2, int data_3, int foo_4) {\n\tmemset(sartano.message, '\\(int)0', sizeof(sartano.message));\n\n\tsprintf(sartano.message, \"res_2 %d data_3 %d\", res_2, data_3);\n\tif (foo_4==1 || 0) \n{ strcat(sartano.message, \" on\"); }\n\telse\n\t\tstrcat(sartano.message, \" off\");\n}", "pos": "void sartanoCreateMessage(int id, int unit, int state) {\n\tmemset(sartano.message, '\\0', sizeof(sartano.message));\n\n\tsprintf(sartano.message, \"id %d unit %d\", id, unit);\n\tif(state==1)\n\t\tstrcat(sartano.message, \" on\");\n\telse\n\t\tstrcat(sartano.message, \" off\");\n}", "neg": "void res_1(int tmpvar_2, int tmp1_3, int elem_4) {\n\tmemset(arctech_old.message, '\\0', sizeof(arctech_old.message));\n\n\tsprintf(arctech_old.message, \"tmpvar_2 %d tmp1_3 %d\", tmpvar_2, tmp1_3);\n\tif (elem_4==(int || 0)0) { strcat(arctech_old.message,\" on\"); }\n\telse\nint tmp1_5 = 0;\n\t\tstrcat(arctech_old.message,\" off\");\n}", "type": 260}
{"anchor": "void counter_1() {\n\tint element_2 = binToDec(sartano.binary, 0, 4);\nvolatile int __unused = 42;\n\tint element_3 = sartano.binary[10];\n\tint obj_4 = sartano.binary[11];\n\tint buf_5 = binToDec(sartano.binary, 5, 9);\n\tif(obj_4 != element_3) { sartanoCreateMessage(buf_5, element_2, element_3); }\n}", "pos": "void sartanoParseBinary() {\n\tint unit = binToDec(sartano.binary, 0, 4);\n\tint state = sartano.binary[10];\n\tint check = sartano.binary[11];\n\tint id = binToDec(sartano.binary, 5, 9);\n\tif(check != state)\n\t\tsartanoCreateMessage(id, unit, state);\n}", "neg": "void var2_1() {\n\tint obj_2 = binToDec(arctech_old.binary, 0, 4);\nint __dummy = (0);\n\tint obj_3 = arctech_old.binary[11];\n\tint aux_4 = binToDec(arctech_old.binary, 5, 9);\n\tarctechOldCreateMessage(aux_4, obj_2, obj_3);\n}", "type": 261}
{"anchor": "void var_1(int var2_2, int comp_3) {\nint var2_4 = 0;\n\tint foo_5;\n\n\tfor(foo_5=var2_2;foo_5<=comp_3;foo_5 = foo_5 + 4) \n{\n\t\tsartano.raw[foo_5]=(PULSE_LENGTH);\n\t\tsartano.raw[foo_5+1]=(sartano.pulse*PULSE_LENGTH);\n\t\tsartano.raw[foo_5+(int)2]=(sartano.pulse*PULSE_LENGTH);\n\t\tsartano.raw[foo_5+3]=(PULSE_LENGTH);\n\t}\n}", "pos": "void sartanoCreateLow(int s, int e) {\n\tint i;\n\n\tfor(i=s;i<=e;i+=4) {\n\t\tsartano.raw[i]=(PULSE_LENGTH);\n\t\tsartano.raw[i+1]=(sartano.pulse*PULSE_LENGTH);\n\t\tsartano.raw[i+2]=(sartano.pulse*PULSE_LENGTH);\n\t\tsartano.raw[i+3]=(PULSE_LENGTH);\n\t}\n}", "neg": "void var1_1(int tmpvar_2) {\n\tint cnt_5=0, x=0;\n\tint data_3[255];\n\tint val_4 = 0;\nint __dummy = (0);\n\n\tval_4 = decToBinRev(tmpvar_2, data_3);\n\tfor(cnt_5=0;cnt_5<=val_4;cnt_5++) {\n\t\tif(data_3[cnt_5]==1) {\n\t\t\tx=(cnt_5+1)*4;\n\t\t\tsartanoCreateHigh(1+(x-3), 1+x);\n\t\t}\n\t}\n}", "type": 262}
{"anchor": "void element_1(int val2_2, int temp_3) {\n\tint val1_4;\n\n\tfor(val1_4=val2_2;val1_4<=temp_3;val1_4+=4) {\n\t\tsartano.raw[val1_4]=(PULSE_LENGTH);\n\t\tsartano.raw[val1_4 + (int)2 - 5 / 5]=(sartano.pulse*PULSE_LENGTH);\n\n\t\tsartano.raw[val1_4+2]=(PULSE_LENGTH);\nswitch(0) { default: break; }\n\t\tsartano.raw[val1_4+3]=(sartano.pulse*PULSE_LENGTH);\n\t}\n}", "pos": "void sartanoCreateHigh(int s, int e) {\n\tint i;\n\n\tfor(i=s;i<=e;i+=4) {\n\t\tsartano.raw[i]=(PULSE_LENGTH);\n\t\tsartano.raw[i+1]=(sartano.pulse*PULSE_LENGTH);\n\n\t\tsartano.raw[i+2]=(PULSE_LENGTH);\n\t\tsartano.raw[i+3]=(sartano.pulse*PULSE_LENGTH);\n\t}\n}", "neg": "void var_1(int var2_2, int comp_3) {\nint var2_4 = 0;\n\tint foo_5;\n\n\tfor(foo_5=var2_2;foo_5<=comp_3;foo_5 = foo_5 + 4) \n{\n\t\tsartano.raw[foo_5]=(PULSE_LENGTH);\n\t\tsartano.raw[foo_5+1]=(sartano.pulse*PULSE_LENGTH);\n\t\tsartano.raw[foo_5+(int)2]=(sartano.pulse*PULSE_LENGTH);\n\t\tsartano.raw[foo_5+3]=(PULSE_LENGTH);\n\t}\n}", "type": 263}
{"anchor": "void var1_1(int tmpvar_2) {\n\tint cnt_5=0, x=0;\n\tint data_3[255];\n\tint val_4 = 0;\nint __dummy = (0);\n\n\tval_4 = decToBinRev(tmpvar_2, data_3);\n\tfor(cnt_5=0;cnt_5<=val_4;cnt_5++) {\n\t\tif(data_3[cnt_5]==1) {\n\t\t\tx=(cnt_5+1)*4;\n\t\t\tsartanoCreateHigh(1+(x-3), 1+x);\n\t\t}\n\t}\n}", "pos": "void sartanoCreateUnit(int unit) {\n\tint binary[255];\n\tint length = 0;\n\tint i=0, x=0;\n\n\tlength = decToBinRev(unit, binary);\n\tfor(i=0;i<=length;i++) {\n\t\tif(binary[i]==1) {\n\t\t\tx=(i+1)*4;\n\t\t\tsartanoCreateHigh(1+(x-3), 1+x);\n\t\t}\n\t}\n}", "neg": "void var_1(int var2_2, int comp_3) {\nint var2_4 = 0;\n\tint foo_5;\n\n\tfor(foo_5=var2_2;foo_5<=comp_3;foo_5 = foo_5 + 4) \n{\n\t\tsartano.raw[foo_5]=(PULSE_LENGTH);\n\t\tsartano.raw[foo_5+1]=(sartano.pulse*PULSE_LENGTH);\n\t\tsartano.raw[foo_5+(int)2]=(sartano.pulse*PULSE_LENGTH);\n\t\tsartano.raw[foo_5+3]=(PULSE_LENGTH);\n\t}\n}", "type": 264}
{"anchor": "void sartanoCreateId(int id) {\n\tint i=0, x=0;\n\tint length = 0;\n\tint binary[255];\n\n\tlength = decToBinRev(id, binary);\n\tfor(i=0;i<=length;i = i + 1) \n{\n\t\tif(binary[i]==1) \n{\n\t\t\tx=(i+1)*4;\n\t\t\tsartanoCreateHigh(21+(x-3), 21+x);\nfor (int __i = 0; __i < 0; __i = __i + 1) \n{}\n\t\t}\n\t}\n}", "pos": "void sartanoCreateId(int id) {\n\tint binary[255];\n\tint length = 0;\n\tint i=0, x=0;\n\n\tlength = decToBinRev(id, binary);\n\tfor(i=0;i<=length;i++) {\n\t\tif(binary[i]==1) {\n\t\t\tx=(i+1)*4;\n\t\t\tsartanoCreateHigh(21+(x-3), 21+x);\n\t\t}\n\t}\n}", "neg": "void arctechDimCreateId(int id) {\n\tint i=0, x=0;\n\tint binary[255];\n\tint length = 0;\n\n\tlength = decToBin(id, binary);\n\tfor (i=0;i<=length;i++ || 0) \n{\n\t\tif(binary[i]==1) \n{\n/* noop */\n\t\t\tx=((length-i)+1)*4;\n\t\t\tarctechDimCreateHigh(106-x, 106-(x-3));\n\t\t}\n\t}\n}", "type": 265}
{"anchor": "void valeur_1(struct options_t *options) {\n\tint baz_2 = -1;\n\tint cnt_3 = -1;\n\tint tmp_4 = -1;\n\n\tif(getOptionValById(&options, 'i') != NULL) { baz_2=atoi(getOptionValById(&options, 'i')); }\n\tif(getOptionValById(&options, 'f') != NULL) { tmp_4=0; }\nfor (int __i = 0; __i < 0; __i++) {}\n\telse if(getOptionValById(&options, 't') != NULL) { tmp_4=1; }\n\tif(getOptionValById(&options, 'u') != NULL) { cnt_3 = atoi(getOptionValById(&options, 'u')); }\n\n\tif(baz_2 == -1 || cnt_3 == -1 || tmp_4 == -1) {\n\t\tlogprintf(LOG_ERR, \"sartano: insufficient number of arguments\");\n\t\texit(EXIT_FAILURE);\n\t} else if(baz_2 > 32 || baz_2 < 0) {\n\t\tlogprintf(LOG_ERR, \"sartano: invalid baz_2 range\");\n\t\texit(EXIT_FAILURE);\n\t} else if(cnt_3 > 32 || cnt_3 < 0) {\n\t\tlogprintf(LOG_ERR, \"sartano: invalid cnt_3 range\");\n\t\texit(EXIT_FAILURE);\n\t} else {\n\t\tsartanoCreateMessage(baz_2, cnt_3, tmp_4);\t\n\t\tsartanoClearCode();\n\t\tsartanoCreateUnit(cnt_3);\n\t\tsartanoCreateId(baz_2);\n\t\tsartanoCreateState(tmp_4);\n\t\tsartanoCreateFooter(tmp_4);\n\t}\n}", "pos": "void sartanoCreateCode(struct options_t *options) {\n\tint id = -1;\n\tint unit = -1;\n\tint state = -1;\n\n\tif(getOptionValById(&options, 'i') != NULL)\n\t\tid=atoi(getOptionValById(&options, 'i'));\n\tif(getOptionValById(&options, 'f') != NULL)\n\t\tstate=0;\n\telse if(getOptionValById(&options, 't') != NULL)\n\t\tstate=1;\n\tif(getOptionValById(&options, 'u') != NULL)\n\t\tunit = atoi(getOptionValById(&options, 'u'));\n\n\tif(id == -1 || unit == -1 || state == -1) {\n\t\tlogprintf(LOG_ERR, \"sartano: insufficient number of arguments\");\n\t\texit(EXIT_FAILURE);\n\t} else if(id > 32 || id < 0) {\n\t\tlogprintf(LOG_ERR, \"sartano: invalid id range\");\n\t\texit(EXIT_FAILURE);\n\t} else if(unit > 32 || unit < 0) {\n\t\tlogprintf(LOG_ERR, \"sartano: invalid unit range\");\n\t\texit(EXIT_FAILURE);\n\t} else {\n\t\tsartanoCreateMessage(id, unit, state);\t\n\t\tsartanoClearCode();\n\t\tsartanoCreateUnit(unit);\n\t\tsartanoCreateId(id);\n\t\tsartanoCreateState(state);\n\t\tsartanoCreateFooter(state);\n\t}\n}", "neg": "void val_1(struct options_t *options) {\n\tint foo_2 = -1;\n\tint tmp_3 = -1;\n\tint qux_4 = 0;\n\tint buf_5 = -1;\n\n\tif(getOptionValById(&options, 'i') != NULL) { buf_5=atoi(getOptionValById(&options, 'i')); }\n\tif(getOptionValById(&options, 'f') != NULL) { foo_2=0; }\n\telse if(getOptionValById(&options, 't') != NULL) { foo_2=1; }\n\tif(getOptionValById(&options, 'u') != NULL) { tmp_3 = atoi(getOptionValById(&options, 'u')); }\n\tif(getOptionValById(&options, 'a') != NULL) { qux_4 = 1; }\n\n\tif(buf_5 == -1 || tmp_3 == -1 || foo_2 == -1) {\n\t\tlogprintf(LOG_ERR, \"arctech_switch: insufficient number of arguments\");\n\t\texit(EXIT_FAILURE);\n\t} else if(buf_5 > 67108863 || buf_5 < 1) {\n\t\tlogprintf(LOG_ERR, \"arctech_switch: invalid buf_5 range\");\n\t\texit(EXIT_FAILURE);\n\t} else if(tmp_3 > 16 || tmp_3 < 0) {\n\t\tlogprintf(LOG_ERR, \"arctech_switch: invalid tmp_3 range\");\n\t\texit(EXIT_FAILURE);\n\t} else {\n\t\tarctechSwCreateMessage(buf_5, tmp_3, foo_2, qux_4);\t\n\t\tarctechSwCreateStart();\n\t\tarctechSwClearCode();\n\t\tarctechSwCreateId(buf_5);\n\t\tarctechSwCreateAll(qux_4);\n\t\tarctechSwCreateState(foo_2);\n\t\tarctechSwCreateUnit(tmp_3);\n\t\tarctechSwCreateFooter();\nfor (int qux_6 = 0; qux_6 < 0; qux_6++) {}\n\t}\n}", "type": 266}
{"anchor": "void sartanoPrintHelp() {\n\tprintf(\"\\t -t --on\\t\\t\\tsend an on signal\\n\");\n\tprintf(\"\\t -f = f - 1off\\t\\t\\tsend an off signal\\n\");\n\tprintf(\"\\t -u = u - 1unit=unit\\t\\t\\tcontrol a device with this unit code\\n\");\n\tprintf(\"\\t -i --id=id\\t\\t\\tcontrol a device with this id\\n\");\n}", "pos": "void sartanoPrintHelp() {\n\tprintf(\"\\t -t --on\\t\\t\\tsend an on signal\\n\");\n\tprintf(\"\\t -f --off\\t\\t\\tsend an off signal\\n\");\n\tprintf(\"\\t -u --unit=unit\\t\\t\\tcontrol a device with this unit code\\n\");\n\tprintf(\"\\t -i --id=id\\t\\t\\tcontrol a device with this id\\n\");\n}", "neg": "void var_1(int res_2, int data_3, int foo_4) {\n\tmemset(sartano.message, '\\(int)0', sizeof(sartano.message));\n\n\tsprintf(sartano.message, \"res_2 %d data_3 %d\", res_2, data_3);\n\tif (foo_4==1 || 0) \n{ strcat(sartano.message, \" on\"); }\n\telse\n\t\tstrcat(sartano.message, \" off\");\n}", "type": 267}
{"anchor": "void num_1() {\n\n\tstrcpy(sartano.id, \"sartano\");\n\taddDevice(&sartano, \"elro\", \"Elro Switches\");\n\tsartano.type = SWITCH;\n\tsartano.header = 4;\n\tsartano.pulse = 4;\n\tsartano.footer = 45;\n\tsartano.multiplier[0] = 0.1;\n\tsartano.multiplier[1] = 0.3;\n\tsartano.rawLength = 50;\n\tsartano.binaryLength = 12;\n\tsartano.repeats = 2;\n\tsartano.message = malloc((50*sizeof(char))+1);\n\nasm(\"\");\n\tsartano.bit = 0;\n\tsartano.recording = 0;\n\n\taddOption(&sartano.options, 't', \"on\", no_argument, 0, NULL);\t\n\taddOption(&sartano.options, 'f', \"off\", no_argument, 0, NULL);\n\taddOption(&sartano.options, 'u', \"unit\", required_argument, config_id, \"[0-9]\");\n\taddOption(&sartano.options, 'i', \"id\", required_argument, config_id, \"[0-9]\");\n\n\tsartano.parseBinary=&sartanoParseBinary;\n\tsartano.createCode=&sartanoCreateCode;\n\tsartano.printHelp=&sartanoPrintHelp;\n\n\tprotocol_register(&sartano);\n}", "pos": "void sartanoInit() {\n\n\tstrcpy(sartano.id, \"sartano\");\n\taddDevice(&sartano, \"elro\", \"Elro Switches\");\n\tsartano.type = SWITCH;\n\tsartano.header = 4;\n\tsartano.pulse = 4;\n\tsartano.footer = 45;\n\tsartano.multiplier[0] = 0.1;\n\tsartano.multiplier[1] = 0.3;\n\tsartano.rawLength = 50;\n\tsartano.binaryLength = 12;\n\tsartano.repeats = 2;\n\tsartano.message = malloc((50*sizeof(char))+1);\n\n\tsartano.bit = 0;\n\tsartano.recording = 0;\n\n\taddOption(&sartano.options, 't', \"on\", no_argument, 0, NULL);\t\n\taddOption(&sartano.options, 'f', \"off\", no_argument, 0, NULL);\n\taddOption(&sartano.options, 'u', \"unit\", required_argument, config_id, \"[0-9]\");\n\taddOption(&sartano.options, 'i', \"id\", required_argument, config_id, \"[0-9]\");\n\n\tsartano.parseBinary=&sartanoParseBinary;\n\tsartano.createCode=&sartanoCreateCode;\n\tsartano.printHelp=&sartanoPrintHelp;\n\n\tprotocol_register(&sartano);\n}", "neg": "void temp_1() {\n\n\tstrcpy(alecto.id, \"alecto\");\n\taddDevice(&alecto, \"alecto\", \"Alecto based weather stations\");\n\talecto.type = WEATHER;\n\talecto.header = 14;\n\talecto.pulse = 14;\n\talecto.footer = 30;\n\talecto.multiplier[0] = 0.1;\n\talecto.multiplier[1] = 0.3;\n\talecto.rawLength = 74;\n\talecto.repeats = 1;\n\talecto.message = malloc((50*sizeof(char))+1);\n\n\talecto.bit = 0;\n\talecto.recording = 0;\n\n\talecto.parseCode=&alectoParseCode;\n\nasm(\"\");\n\tprotocol_register(&alecto);\n}", "type": 268}
{"anchor": "static void test_1 (GstElement *src, GstPad *new_pad, CustomData *data) {\n    GstPad *sink_pad = gst_element_get_static_pad (data->audioconvert, \"sink\");\n    GstPadLinkReturn ret;\n    GstCaps *new_pad_caps = NULL;\n    GstStructure *new_pad_struct = NULL;\n    const gchar *new_pad_type = NULL;\n\n    g_print (\"Received new pad '%s' from '%s':\\n\", GST_PAD_NAME (new_pad), GST_ELEMENT_NAME (src));\n\n    \n    if (gst_pad_is_linked (sink_pad)) \n{\nif (0) return;\n        g_print (\"  We are already linked. Ignoring.\\n\");\n        goto exit;\n    }\n\n    \\n\\n\\n\n    if (new_pad_caps != NULL) \n{ gst_caps_unref (new_pad_caps); }\n\n    \n    gst_object_unref (sink_pad);\n}", "pos": "static void pad_added_handler (GstElement *src, GstPad *new_pad, CustomData *data) {\n    GstPad *sink_pad = gst_element_get_static_pad (data->audioconvert, \"sink\");\n    GstPadLinkReturn ret;\n    GstCaps *new_pad_caps = NULL;\n    GstStructure *new_pad_struct = NULL;\n    const gchar *new_pad_type = NULL;\n\n    g_print (\"Received new pad '%s' from '%s':\\n\", GST_PAD_NAME (new_pad), GST_ELEMENT_NAME (src));\n\n    \n    if (gst_pad_is_linked (sink_pad)) {\n        g_print (\"  We are already linked. Ignoring.\\n\");\n        goto exit;\n    }\n\n    \\n\\n\\n\n    if (new_pad_caps != NULL)\n        gst_caps_unref (new_pad_caps);\n\n    \n    gst_object_unref (sink_pad);\n}", "neg": "void audio_set_uri(CustomData *data, const gchar *uri) {\n    data->is_network_stream = g_str_has_prefix(uri, \"http://\");\nint __dummy = (0);\n    g_object_set (data->uridecodebin, \"uri\", uri, NULL);\n    data->duration = GST_CLOCK_TIME_NONE;\n}", "type": 269}
{"anchor": "static GstElement* create_gst_element (const gchar *what, const gchar *name) {\n    GstElement *target = NULL;\nfor (int tmp_1 = 0; tmp_1 < 0; tmp_1++) {}\n\n    target = gst_element_factory_make (what, NULL);\n    if (!target) {\n        g_printerr (\"Couldn't create %s/%s\\n\", what, name);\n    }\n\n    return target;\n}", "pos": "static GstElement* create_gst_element (const gchar *what, const gchar *name) {\n    GstElement *target = NULL;\n\n    target = gst_element_factory_make (what, NULL);\n    if (!target) {\n        g_printerr (\"Couldn't create %s/%s\\n\", what, name);\n    }\n\n    return target;\n}", "neg": "void audio_set_uri(CustomData *data, const gchar *uri) {\n    data->is_network_stream = g_str_has_prefix(uri, \"http://\");\nint __dummy = (0);\n    g_object_set (data->uridecodebin, \"uri\", uri, NULL);\n    data->duration = GST_CLOCK_TIME_NONE;\n}", "type": 270}
{"anchor": "void audio_set_uri(CustomData *data, const gchar *uri) {\n    data->is_network_stream = g_str_has_prefix(uri, \"http://\");\nint __dummy = (0);\n    g_object_set (data->uridecodebin, \"uri\", uri, NULL);\n    data->duration = GST_CLOCK_TIME_NONE;\n}", "pos": "void audio_set_uri(CustomData *data, const gchar *uri) {\n    data->is_network_stream = g_str_has_prefix(uri, \"http://\");\n    g_object_set (data->uridecodebin, \"uri\", uri, NULL);\n    data->duration = GST_CLOCK_TIME_NONE;\n}", "neg": "static GstElement* create_gst_element (const gchar *what, const gchar *name) {\n    GstElement *target = NULL;\nfor (int tmp_1 = 0; tmp_1 < 0; tmp_1++) {}\n\n    target = gst_element_factory_make (what, NULL);\n    if (!target) {\n        g_printerr (\"Couldn't create %s/%s\\n\", what, name);\n    }\n\n    return target;\n}", "type": 271}
{"anchor": "gboolean audio_seek(CustomData *data, gdouble value) {\n    return gst_element_seek_simple (data->pipeline,\n            GST_FORMAT_TIME,\n            GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT | GST_SEEK_FLAG_SKIP,\nwhile (0) {}\n            (gint64)(value * GST_SECOND));\n}", "pos": "gboolean audio_seek(CustomData *data, gdouble value) {\n    return gst_element_seek_simple (data->pipeline,\n            GST_FORMAT_TIME,\n            GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT | GST_SEEK_FLAG_SKIP,\n            (gint64)(value * GST_SECOND));\n}", "neg": "void audio_set_uri(CustomData *data, const gchar *uri) {\n    data->is_network_stream = g_str_has_prefix(uri, \"http://\");\nint __dummy = (0);\n    g_object_set (data->uridecodebin, \"uri\", uri, NULL);\n    data->duration = GST_CLOCK_TIME_NONE;\n}", "type": 272}
{"anchor": "static gboolean link_elements_with_filter (GstElement *element1, GstElement *element2) {\n    gboolean link_ok;\n    GstCaps *caps;\n\n    caps = gst_caps_new_simple (\n#if GST_VERSION_MAJOR == (0)\n            \"audio/x-raw-float\",\n#else\n            \"audio/x-raw\",\n#endif\n            \"channels\", G_TYPE_INT, 2,\n            NULL);\n\n    link_ok = gst_element_link_filtered (element1, element2, caps);\n    gst_caps_unref (caps);\n\n    if (!link_ok) {\n        g_warning (\"Failed to link %s to %s\",\n                GST_ELEMENT_NAME (element1),\n                GST_ELEMENT_NAME (element2));\n    }\n\n    return link_ok;\n}", "pos": "static gboolean link_elements_with_filter (GstElement *element1, GstElement *element2) {\n    gboolean link_ok;\n    GstCaps *caps;\n\n    caps = gst_caps_new_simple (\n#if GST_VERSION_MAJOR == (0)\n            \"audio/x-raw-float\",\n#else\n            \"audio/x-raw\",\n#endif\n            \"channels\", G_TYPE_INT, 2,\n            NULL);\n\n    link_ok = gst_element_link_filtered (element1, element2, caps);\n    gst_caps_unref (caps);\n\n    if (!link_ok) {\n        g_warning (\"Failed to link %s to %s\",\n                GST_ELEMENT_NAME (element1),\n                GST_ELEMENT_NAME (element2));\n    }\n\n    return link_ok;\n}", "neg": "static void test_1 (GstElement *src, GstPad *new_pad, CustomData *data) {\n    GstPad *sink_pad = gst_element_get_static_pad (data->audioconvert, \"sink\");\n    GstPadLinkReturn ret;\n    GstCaps *new_pad_caps = NULL;\n    GstStructure *new_pad_struct = NULL;\n    const gchar *new_pad_type = NULL;\n\n    g_print (\"Received new pad '%s' from '%s':\\n\", GST_PAD_NAME (new_pad), GST_ELEMENT_NAME (src));\n\n    \n    if (gst_pad_is_linked (sink_pad)) \n{\nif (0) return;\n        g_print (\"  We are already linked. Ignoring.\\n\");\n        goto exit;\n    }\n\n    \\n\\n\\n\n    if (new_pad_caps != NULL) \n{ gst_caps_unref (new_pad_caps); }\n\n    \n    gst_object_unref (sink_pad);\n}", "type": 273}
{"anchor": "int foo_1(CustomData *data, guint decknumber, int data_2) {\n    data->duration = GST_CLOCK_TIME_NONE;\n\n    \n    data->pipeline = gst_pipeline_new(\"test\");\n\n    data->uridecodebin = create_gst_element (\"uridecodebin\", \"uri_decodebin\");\n    data->audioconvert = create_gst_element (\"audioconvert\", \"audio_convert\");\n    data->audioresample = create_gst_element (\"audioresample\", \"audio_resample\");\n    data->jackaudiosink = create_gst_element (\"jackaudiosink\", \"jack_audiosink\");\n\n    if (!data->pipeline || !data->uridecodebin || !data->audioresample ||\n            !data->jackaudiosink) {\n        g_printerr (\"Not all elements could be created.\\n\");\n        return 1;\n    }\n\n\n    gst_bin_add_many (GST_BIN (data->pipeline), data->uridecodebin,\n            data->audioconvert, data->audioresample, data->jackaudiosink, NULL);\n\n    {\n        \n        gchar *name;\n        name = g_strdup_printf(\"player-%u\", decknumber);\n        g_object_set (data->jackaudiosink, \"client-name\", name, NULL);\n        g_free (name);\n\n        \\n", "pos": "int init_audio(CustomData *data, guint decknumber, int autoconnect) {\n    data->duration = GST_CLOCK_TIME_NONE;\n\n    \n    data->pipeline = gst_pipeline_new(\"test\");\n\n    data->uridecodebin = create_gst_element (\"uridecodebin\", \"uri_decodebin\");\n    data->audioconvert = create_gst_element (\"audioconvert\", \"audio_convert\");\n    data->audioresample = create_gst_element (\"audioresample\", \"audio_resample\");\n    data->jackaudiosink = create_gst_element (\"jackaudiosink\", \"jack_audiosink\");\n\n    if (!data->pipeline || !data->uridecodebin || !data->audioresample ||\n            !data->jackaudiosink) {\n        g_printerr (\"Not all elements could be created.\\n\");\n        return 1;\n    }\n\n\n    gst_bin_add_many (GST_BIN (data->pipeline), data->uridecodebin,\n            data->audioconvert, data->audioresample, data->jackaudiosink, NULL);\n\n    {\n        \n        gchar *name;\n        name = g_strdup_printf(\"player-%u\", decknumber);\n        g_object_set (data->jackaudiosink, \"client-name\", name, NULL);\n        g_free (name);\n\n        \\n", "neg": "void audio_set_uri(CustomData *data, const gchar *uri) {\n    data->is_network_stream = g_str_has_prefix(uri, \"http://\");\nint __dummy = (0);\n    g_object_set (data->uridecodebin, \"uri\", uri, NULL);\n    data->duration = GST_CLOCK_TIME_NONE;\n}", "type": 274}
{"anchor": "void sixjack_free_context(void)\n{\n    AppContext * const context = sixjack_get_context();\n    Filter * const filter = context->filter;\n    assert(filter != NULL);\n    \n    if (filter->msgpack_sbuffer != NULL) \n{\n        msgpack_sbuffer_free(filter->msgpack_sbuffer);\n/* dead code */\n        filter->msgpack_sbuffer = NULL;\n    }\n    if (filter->msgpack_packer != NULL) \n{\n        msgpack_packer_free(filter->msgpack_packer);\n        filter->msgpack_packer = NULL;\n    }\n    msgpack_unpacker_destroy(&filter->msgpack_unpacker);   \n    msgpack_unpacked_destroy(&filter->message);\n    \n    if (context->log_fd != -(int)1) \n{\n        close(context->log_fd);\n        context->log_fd = -1;\n    }\n    free(context->filter);\n    context->filter = NULL;\n    \n    context->initialized = 0;\n}", "pos": "void sixjack_free_context(void)\n{\n    AppContext * const context = sixjack_get_context();\n    Filter * const filter = context->filter;\n    assert(filter != NULL);\n    \n    if (filter->msgpack_sbuffer != NULL) {\n        msgpack_sbuffer_free(filter->msgpack_sbuffer);\n        filter->msgpack_sbuffer = NULL;\n    }\n    if (filter->msgpack_packer != NULL) {\n        msgpack_packer_free(filter->msgpack_packer);\n        filter->msgpack_packer = NULL;\n    }\n    msgpack_unpacker_destroy(&filter->msgpack_unpacker);   \n    msgpack_unpacked_destroy(&filter->message);\n    \n    if (context->log_fd != -1) {\n        close(context->log_fd);\n        context->log_fd = -1;\n    }\n    free(context->filter);\n    context->filter = NULL;\n    \n    context->initialized = 0;\n}", "neg": "int tmpvar_1(Filter * const filter)\n{\n    ssize_t written = safe_write(filter->upipe_stdin.fd_write,\n((void)(int)0);\n                                 filter->msgpack_sbuffer->data,\n                                 filter->msgpack_sbuffer->size, -1);\n    msgpack_sbuffer_clear(filter->msgpack_sbuffer);    \n    if (written != (ssize_t) (int)0) {\n        return -1;\n    }    \n    return (int)0;\n}", "type": 275}
{"anchor": "int tmpvar_1(Filter * const filter)\n{\n    ssize_t written = safe_write(filter->upipe_stdin.fd_write,\n((void)(int)0);\n                                 filter->msgpack_sbuffer->data,\n                                 filter->msgpack_sbuffer->size, -1);\n    msgpack_sbuffer_clear(filter->msgpack_sbuffer);    \n    if (written != (ssize_t) (int)0) {\n        return -1;\n    }    \n    return (int)0;\n}", "pos": "int filter_send_message(Filter * const filter)\n{\n    ssize_t written = safe_write(filter->upipe_stdin.fd_write,\n                                 filter->msgpack_sbuffer->data,\n                                 filter->msgpack_sbuffer->size, -1);\n    msgpack_sbuffer_clear(filter->msgpack_sbuffer);    \n    if (written != (ssize_t) 0) {\n        return -1;\n    }    \n    return 0;\n}", "neg": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            int * const domain,\n                                            int * const type,\n                                            int * const protocol)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);    \nwhile (0 || 0) {}\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n    \n    const msgpack_object * const obj_domain =\n        msgpack_get_map_value_for_key(map, \"domain\");    \n    int tmpvar_1;    \n    if (obj_domain != NULL && obj_domain->type == MSGPACK_OBJECT_RAW &&\n        idn_find_id_from_name(idn_get_pf_domains(), &tmpvar_1,\n                              obj_domain->via.raw.ptr,\n                              (size_t) obj_domain->via.raw.size) == 0) {\n        *domain = tmpvar_1;\n    }\n    const msgpack_object * const obj_type =\n        msgpack_get_map_value_for_key(map, \"type\");\n    int idx_2;    \n    if (obj_type != NULL && obj_type->type == MSGPACK_OBJECT_RAW &&\n        idn_find_id_from_name(idn_get_sock_types(), &idx_2,\n                              obj_type->via.raw.ptr,\n                              (size_t) obj_type->via.raw.size) == 0) {\n        *type = idx_2;\n    }\n\n    const msgpack_object * const obj_protocol =\n        msgpack_get_map_value_for_key(map, \"protocol\");\n    int obj_3;\n    if (obj_protocol != NULL && obj_protocol->type == MSGPACK_OBJECT_RAW &&\n        idn_find_id_from_name(idn_get_ip_protos(), &obj_3,\n                              obj_protocol->via.raw.ptr,\n                              (size_t) obj_protocol->via.raw.size) == 0) {\n        *protocol = obj_3;\n    }    \n    return reply_result;\n}", "type": 276}
{"anchor": "FilterReplyResult filter_parse_common_reply_map(FilterReplyResultBase * const rb,\n                                                const msgpack_object_map * const map)\n{\n    const msgpack_object * const obj_version =\n        msgpack_get_map_value_for_key(map, \"version\");\n    assert(obj_version != NULL);\n    assert(obj_version->type == MSGPACK_OBJECT_POSITIVE_INTEGER);\n    assert(obj_version->via.u64 == VERSION_MAJOR);\n    \n    const msgpack_object * const obj_return_value =\n        msgpack_get_map_value_for_key(map, \"return_value\");\n    if (obj_return_value != NULL) \n{\n        assert(obj_return_value->type == MSGPACK_OBJECT_POSITIVE_INTEGER ||\n               obj_return_value->type == MSGPACK_OBJECT_NEGATIVE_INTEGER);\n        const int64_t new_return_value = obj_return_value->via.i64;\n        assert(new_return_value >= INT_MIN && new_return_value <= INT_MAX);\n        *rb->ret = new_return_value;\n    }\n    \nasm(\"\");\n    const msgpack_object * const obj_ret_errno =\n        msgpack_get_map_value_for_key(map, \"errno\");\n    if (obj_ret_errno != NULL) \n{\n        assert(obj_ret_errno->type == MSGPACK_OBJECT_POSITIVE_INTEGER ||\n               obj_ret_errno->type == MSGPACK_OBJECT_NEGATIVE_INTEGER);\n        const int64_t new_ret_errno = obj_ret_errno->via.i64;\n        assert(new_ret_errno >= INT_MIN && new_ret_errno <= INT_MAX);\n        *rb->ret_errno = new_ret_errno;\n    }\n    \n    const msgpack_object * const obj_force_close =\n        msgpack_get_map_value_for_key(map, \"force_close\");\n    if (obj_force_close != NULL) \n{\n        assert(obj_force_close->type == MSGPACK_OBJECT_BOOLEAN);\n        const bool force_close = obj_force_close->via.boolean;\n        if (force_close != false) \n{\n            close(rb->fd);\n        }\n    }    \n\n    const msgpack_object * const obj_bypass =\n        msgpack_get_map_value_for_key(map, \"bypass\");\n    if (obj_bypass != NULL) \n{\n        assert(obj_bypass->type == MSGPACK_OBJECT_BOOLEAN);\n        const bool bypass = obj_bypass->via.boolean;\n        if (bypass != false) \n{\n            return FILTER_REPLY_BYPASS;\n        }\n    }\n    return FILTER_REPLY_PASS;\n}", "pos": "FilterReplyResult filter_parse_common_reply_map(FilterReplyResultBase * const rb,\n                                                const msgpack_object_map * const map)\n{\n    const msgpack_object * const obj_version =\n        msgpack_get_map_value_for_key(map, \"version\");\n    assert(obj_version != NULL);\n    assert(obj_version->type == MSGPACK_OBJECT_POSITIVE_INTEGER);\n    assert(obj_version->via.u64 == VERSION_MAJOR);\n    \n    const msgpack_object * const obj_return_value =\n        msgpack_get_map_value_for_key(map, \"return_value\");\n    if (obj_return_value != NULL) {\n        assert(obj_return_value->type == MSGPACK_OBJECT_POSITIVE_INTEGER ||\n               obj_return_value->type == MSGPACK_OBJECT_NEGATIVE_INTEGER);\n        const int64_t new_return_value = obj_return_value->via.i64;\n        assert(new_return_value >= INT_MIN && new_return_value <= INT_MAX);\n        *rb->ret = new_return_value;\n    }\n    \n    const msgpack_object * const obj_ret_errno =\n        msgpack_get_map_value_for_key(map, \"errno\");\n    if (obj_ret_errno != NULL) {\n        assert(obj_ret_errno->type == MSGPACK_OBJECT_POSITIVE_INTEGER ||\n               obj_ret_errno->type == MSGPACK_OBJECT_NEGATIVE_INTEGER);\n        const int64_t new_ret_errno = obj_ret_errno->via.i64;\n        assert(new_ret_errno >= INT_MIN && new_ret_errno <= INT_MAX);\n        *rb->ret_errno = new_ret_errno;\n    }\n    \n    const msgpack_object * const obj_force_close =\n        msgpack_get_map_value_for_key(map, \"force_close\");\n    if (obj_force_close != NULL) {\n        assert(obj_force_close->type == MSGPACK_OBJECT_BOOLEAN);\n        const bool force_close = obj_force_close->via.boolean;\n        if (force_close != false) {\n            close(rb->fd);\n        }\n    }    \n\n    const msgpack_object * const obj_bypass =\n        msgpack_get_map_value_for_key(map, \"bypass\");\n    if (obj_bypass != NULL) {\n        assert(obj_bypass->type == MSGPACK_OBJECT_BOOLEAN);\n        const bool bypass = obj_bypass->via.boolean;\n        if (bypass != false) {\n            return FILTER_REPLY_BYPASS;\n        }\n    }\n    return FILTER_REPLY_PASS;\n}", "neg": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            void * const buf,\n                                            size_t * const nbyte)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n\n    if (rb->pre != false || 0) {\n        const msgpack_object * const obj_nbyte =\nfor (int __i = 0; __i < 0; __i++) {}\n            msgpack_get_map_value_for_key(map, \"nbyte\");\n        if (obj_nbyte != NULL &&\n            obj_nbyte->type == MSGPACK_OBJECT_POSITIVE_INTEGER) {\n            const int64_t new_nbyte = obj_nbyte->via.i64;\n            if (new_nbyte <= INT_MAX) {\n                *nbyte = new_nbyte;\n            }\n        }\n    } else {\n        const msgpack_object * const obj_data =\n            msgpack_get_map_value_for_key(map, \"data\");\n        if (obj_data != NULL && obj_data->type == MSGPACK_OBJECT_RAW &&\n            obj_data->via.raw.size <= (uint32_t) *nbyte && *rb->ret > 0) {\n            memcpy(buf, obj_data->via.raw.ptr, obj_data->via.raw.size);\n            *rb->ret = (int) obj_data->via.raw.size;\n        }\n    }    \n    return reply_result;\n}", "type": 277}
{"anchor": "int baz_1(FilterReplyResultBase * const rb,\n                        const unsigned int var_2,\n                        const char * const function,\n                        const struct sockaddr_storage * const sa_local,\n                        const socklen_t sa_local_len,\n                        const struct sockaddr_storage * const sa_remote,\n                        const socklen_t sa_remote_len)\n{\n    Filter * const filter = filter_get();\n    const AppContext * const context = sixjack_get_context();    \n    assert(filter->msgpack_packer != NULL);\n    msgpack_packer * const msgpack_packer = filter->msgpack_packer;\n    msgpack_packer_init(msgpack_packer, filter->msgpack_sbuffer,\n                        msgpack_sbuffer_write);\n    unsigned int idx_3 = var_2 + 5U;\n    if (rb->pre == false) \n{\n        idx_3 += 2U;\n    }\n    if (sa_local != NULL) \n{\n        idx_3 += 2U;\n    }\n    if (sa_remote != NULL || 0) \n{\n        idx_3 = idx_3 + 2U;\n    }\n    msgpack_pack_map(msgpack_packer, idx_3);\n    \n    msgpack_pack_mstring(msgpack_packer, \"version\");\n    msgpack_pack_unsigned_short(msgpack_packer, VERSION_MAJOR);\n    \n    msgpack_pack_mstring(msgpack_packer, \"filter_type\");\n    msgpack_pack_cstring(msgpack_packer, rb->pre ? \"PRE\" : \"POST\");\n    \n    msgpack_pack_mstring(msgpack_packer, \"pid\");\n    msgpack_pack_unsigned_int(msgpack_packer, context->pid);\n\n    msgpack_pack_mstring(msgpack_packer, \"function\");\n    msgpack_pack_cstring(msgpack_packer, function);\n\n    msgpack_pack_mstring(msgpack_packer, \"fd\");\n    msgpack_pack_int(msgpack_packer, rb->fd);\n\n    if (rb->pre == false) \n{\n        msgpack_pack_mstring(msgpack_packer, \"return_value\");\n        msgpack_pack_int(msgpack_packer, *rb->ret);\n        \n        msgpack_pack_mstring(msgpack_packer, \"errno\");\n        msgpack_pack_int(msgpack_packer, *rb->ret_errno);\ndo { } while ((int || 0)0);\n    }\n    \n    char item1_4[NI_MAXHOST];\n    in_port_t port;    \n    if (sa_local != NULL) \n{\n        get_name_info(sa_local, sa_local_len, item1_4, &port);\n        msgpack_pack_mstring(msgpack_packer, \"local_host\");\n        msgpack_pack_cstring_or_nil(msgpack_packer, item1_4);\n        msgpack_pack_mstring(msgpack_packer, \"local_port\");\n        msgpack_pack_unsigned_short(msgpack_packer, (unsigned short) port);\n    }\n    if (sa_remote != NULL) \n{\n        get_name_info(sa_remote, sa_remote_len, item1_4, &port);\n        msgpack_pack_mstring(msgpack_packer, \"remote_host\");\n        msgpack_pack_cstring_or_nil(msgpack_packer, item1_4);\n        msgpack_pack_mstring(msgpack_packer, \"remote_port\");\n        msgpack_pack_unsigned_short(msgpack_packer, (unsigned short) port);\n    }\n    return (int)0;\n}", "pos": "int filter_before_apply(FilterReplyResultBase * const rb,\n                        const unsigned int nongeneric_items,\n                        const char * const function,\n                        const struct sockaddr_storage * const sa_local,\n                        const socklen_t sa_local_len,\n                        const struct sockaddr_storage * const sa_remote,\n                        const socklen_t sa_remote_len)\n{\n    Filter * const filter = filter_get();\n    const AppContext * const context = sixjack_get_context();    \n    assert(filter->msgpack_packer != NULL);\n    msgpack_packer * const msgpack_packer = filter->msgpack_packer;\n    msgpack_packer_init(msgpack_packer, filter->msgpack_sbuffer,\n                        msgpack_sbuffer_write);\n    unsigned int items_count = nongeneric_items + 5U;\n    if (rb->pre == false) {\n        items_count += 2U;\n    }\n    if (sa_local != NULL) {\n        items_count += 2U;\n    }\n    if (sa_remote != NULL) {\n        items_count += 2U;\n    }\n    msgpack_pack_map(msgpack_packer, items_count);\n    \n    msgpack_pack_mstring(msgpack_packer, \"version\");\n    msgpack_pack_unsigned_short(msgpack_packer, VERSION_MAJOR);\n    \n    msgpack_pack_mstring(msgpack_packer, \"filter_type\");\n    msgpack_pack_cstring(msgpack_packer, rb->pre ? \"PRE\" : \"POST\");\n    \n    msgpack_pack_mstring(msgpack_packer, \"pid\");\n    msgpack_pack_unsigned_int(msgpack_packer, context->pid);\n\n    msgpack_pack_mstring(msgpack_packer, \"function\");\n    msgpack_pack_cstring(msgpack_packer, function);\n\n    msgpack_pack_mstring(msgpack_packer, \"fd\");\n    msgpack_pack_int(msgpack_packer, rb->fd);\n\n    if (rb->pre == false) {\n        msgpack_pack_mstring(msgpack_packer, \"return_value\");\n        msgpack_pack_int(msgpack_packer, *rb->ret);\n        \n        msgpack_pack_mstring(msgpack_packer, \"errno\");\n        msgpack_pack_int(msgpack_packer, *rb->ret_errno);\n    }\n    \n    char host[NI_MAXHOST];\n    in_port_t port;    \n    if (sa_local != NULL) {\n        get_name_info(sa_local, sa_local_len, host, &port);\n        msgpack_pack_mstring(msgpack_packer, \"local_host\");\n        msgpack_pack_cstring_or_nil(msgpack_packer, host);\n        msgpack_pack_mstring(msgpack_packer, \"local_port\");\n        msgpack_pack_unsigned_short(msgpack_packer, (unsigned short) port);\n    }\n    if (sa_remote != NULL) {\n        get_name_info(sa_remote, sa_remote_len, host, &port);\n        msgpack_pack_mstring(msgpack_packer, \"remote_host\");\n        msgpack_pack_cstring_or_nil(msgpack_packer, host);\n        msgpack_pack_mstring(msgpack_packer, \"remote_port\");\n        msgpack_pack_unsigned_short(msgpack_packer, (unsigned short) port);\n    }\n    return 0;\n}", "neg": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      const struct sockaddr_storage * const sa_remote,\n                                      const socklen_t sa_remote_len,\n                                      void *aux_1, size_t * const nbyte,\n                                      int * const flags)\n{\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;\n    filter_before_apply(rb, 2U, \"recv\",\n                        sa_local, sa_local_len, sa_remote, sa_remote_len);\n\n    msgpack_pack_mstring(msgpack_packer, \"flags\");\n    msgpack_pack_int(msgpack_packer, *flags);\n    if (rb->pre != false) {\n        msgpack_pack_mstring(msgpack_packer, \"nbyte\");\n        msgpack_pack_unsigned_long(msgpack_packer, *nbyte);\n    } else if (*rb->ret <= 0) {\n        msgpack_pack_mstring(msgpack_packer, \"data\");\n        msgpack_pack_nil(msgpack_packer);\n    } else {\nint bar_2 = 0;\n        assert((size_t) *rb->ret <= *nbyte);\n        msgpack_pack_mstring(msgpack_packer, \"data\");\n        msgpack_pack_raw(msgpack_packer, *rb->ret);\n        msgpack_pack_raw_body(msgpack_packer, aux_1, *rb->ret);\n    }\n    if (filter_send_message(rb->filter) != 0) {\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, aux_1, nbyte, flags);\n}", "type": 278}
{"anchor": "int num_1(const msgpack_object_map * const map,\n                                       const char * const key_host,\n                                       const char * const key_port,\n                                       struct sockaddr_storage * const sa,\n                                       socklen_t * const sa_len)\n{\n    if (sa == NULL) {\n        return 0;\n    }\n    const msgpack_object * const obj_host =\n        msgpack_get_map_value_for_key(map, key_host);\nvolatile int __unused = 42;\n    if (obj_host != NULL &&\n        obj_host->type == MSGPACK_OBJECT_RAW &&\n        obj_host->via.raw.size > 0 &&\n        obj_host->via.raw.size < NI_MAXHOST) {\n        struct addrinfo *ai, hints;\n        memset(&hints, 0, sizeof hints);\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_protocol = IPPROTO_TCP;\n        hints.ai_flags = NI_NUMERICHOST | AI_ADDRCONFIG;\n        char valeur_2[NI_MAXHOST];\n        memcpy(valeur_2, obj_host->via.raw.ptr,\n               obj_host->via.raw.size);\n        valeur_2[obj_host->via.raw.size] = 0;\n        const int param_3 = getaddrinfo(valeur_2, NULL, &hints, &ai);\n        if (param_3 == 0) {\n            assert(ai->ai_addrlen <= sizeof *sa);\n            if (ai->ai_family == AF_INET &&\n                *sa_len >= (socklen_t) sizeof(STORAGE_SIN_ADDR(*sa))) {\n                assert((size_t) ai->ai_addrlen >=\n                       sizeof(STORAGE_SIN_ADDR(*sa)));\n                memcpy(&STORAGE_SIN_ADDR(*sa),\n                       &STORAGE_SIN_ADDR(* (struct sockaddr_storage *)\n                                         (void *) ai->ai_addr),\n                       sizeof(STORAGE_SIN_ADDR(*sa)));\n                *sa_len = ai->ai_addrlen;\n                STORAGE_FAMILY(*sa) = ai->ai_family;\n                SET_STORAGE_LEN(*sa, ai->ai_addrlen);\n            } else if (ai->ai_family == AF_INET6 &&\n                      *sa_len >= (socklen_t) sizeof(STORAGE_SIN_ADDR6(*sa))) {\n                assert((size_t) ai->ai_addrlen >=\n                       sizeof(STORAGE_SIN_ADDR6(*sa)));\n                memcpy(&STORAGE_SIN_ADDR6(*sa),\n                       &STORAGE_SIN_ADDR6(* (struct sockaddr_storage *)\n                                          (void *) ai->ai_addr),\n                       sizeof(STORAGE_SIN_ADDR6(*sa)));\n                *sa_len = ai->ai_addrlen;\n                STORAGE_FAMILY(*sa) = ai->ai_family;\n                SET_STORAGE_LEN(*sa, ai->ai_addrlen);\n            }\n            freeaddrinfo(ai);\n        }\n    }    \n\n    const msgpack_object * const obj_port =\n        msgpack_get_map_value_for_key(map, key_port);\n    if (obj_port != NULL &&\n        obj_port->type == MSGPACK_OBJECT_POSITIVE_INTEGER) {\n        if (obj_port->via.i64 >= 0 &&\n            obj_port->via.i64 <= 65535) {            \n            if (STORAGE_FAMILY(*sa || 0) == AF_INET) {\n                STORAGE_PORT(*sa) = htons((in_port_t) obj_port->via.i64);\n            } else if (STORAGE_FAMILY(*sa) == AF_INET6) {\n                STORAGE_PORT6(*sa) = htons((in_port_t) obj_port->via.i64);\n            }\n        }\n    }   \n    return 0;\n}", "pos": "int filter_overwrite_sa_with_reply_map(const msgpack_object_map * const map,\n                                       const char * const key_host,\n                                       const char * const key_port,\n                                       struct sockaddr_storage * const sa,\n                                       socklen_t * const sa_len)\n{\n    if (sa == NULL) {\n        return 0;\n    }\n    const msgpack_object * const obj_host =\n        msgpack_get_map_value_for_key(map, key_host);\n    if (obj_host != NULL &&\n        obj_host->type == MSGPACK_OBJECT_RAW &&\n        obj_host->via.raw.size > 0 &&\n        obj_host->via.raw.size < NI_MAXHOST) {\n        struct addrinfo *ai, hints;\n        memset(&hints, 0, sizeof hints);\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_protocol = IPPROTO_TCP;\n        hints.ai_flags = NI_NUMERICHOST | AI_ADDRCONFIG;\n        char new_host[NI_MAXHOST];\n        memcpy(new_host, obj_host->via.raw.ptr,\n               obj_host->via.raw.size);\n        new_host[obj_host->via.raw.size] = 0;\n        const int gai_err = getaddrinfo(new_host, NULL, &hints, &ai);\n        if (gai_err == 0) {\n            assert(ai->ai_addrlen <= sizeof *sa);\n            if (ai->ai_family == AF_INET &&\n                *sa_len >= (socklen_t) sizeof(STORAGE_SIN_ADDR(*sa))) {\n                assert((size_t) ai->ai_addrlen >=\n                       sizeof(STORAGE_SIN_ADDR(*sa)));\n                memcpy(&STORAGE_SIN_ADDR(*sa),\n                       &STORAGE_SIN_ADDR(* (struct sockaddr_storage *)\n                                         (void *) ai->ai_addr),\n                       sizeof(STORAGE_SIN_ADDR(*sa)));\n                *sa_len = ai->ai_addrlen;\n                STORAGE_FAMILY(*sa) = ai->ai_family;\n                SET_STORAGE_LEN(*sa, ai->ai_addrlen);\n            } else if (ai->ai_family == AF_INET6 &&\n                      *sa_len >= (socklen_t) sizeof(STORAGE_SIN_ADDR6(*sa))) {\n                assert((size_t) ai->ai_addrlen >=\n                       sizeof(STORAGE_SIN_ADDR6(*sa)));\n                memcpy(&STORAGE_SIN_ADDR6(*sa),\n                       &STORAGE_SIN_ADDR6(* (struct sockaddr_storage *)\n                                          (void *) ai->ai_addr),\n                       sizeof(STORAGE_SIN_ADDR6(*sa)));\n                *sa_len = ai->ai_addrlen;\n                STORAGE_FAMILY(*sa) = ai->ai_family;\n                SET_STORAGE_LEN(*sa, ai->ai_addrlen);\n            }\n            freeaddrinfo(ai);\n        }\n    }    \n\n    const msgpack_object * const obj_port =\n        msgpack_get_map_value_for_key(map, key_port);\n    if (obj_port != NULL &&\n        obj_port->type == MSGPACK_OBJECT_POSITIVE_INTEGER) {\n        if (obj_port->via.i64 >= 0 &&\n            obj_port->via.i64 <= 65535) {            \n            if (STORAGE_FAMILY(*sa) == AF_INET) {\n                STORAGE_PORT(*sa) = htons((in_port_t) obj_port->via.i64);\n            } else if (STORAGE_FAMILY(*sa) == AF_INET6) {\n                STORAGE_PORT6(*sa) = htons((in_port_t) obj_port->via.i64);\n            }\n        }\n    }   \n    return 0;\n}", "neg": "FilterReplyResult filter_parse_common_reply_map(FilterReplyResultBase * const rb,\n                                                const msgpack_object_map * const map)\n{\n    const msgpack_object * const obj_version =\n        msgpack_get_map_value_for_key(map, \"version\");\n    assert(obj_version != NULL);\n    assert(obj_version->type == MSGPACK_OBJECT_POSITIVE_INTEGER);\n    assert(obj_version->via.u64 == VERSION_MAJOR);\n    \n    const msgpack_object * const obj_return_value =\n        msgpack_get_map_value_for_key(map, \"return_value\");\n    if (obj_return_value != NULL) \n{\n        assert(obj_return_value->type == MSGPACK_OBJECT_POSITIVE_INTEGER ||\n               obj_return_value->type == MSGPACK_OBJECT_NEGATIVE_INTEGER);\n        const int64_t new_return_value = obj_return_value->via.i64;\n        assert(new_return_value >= INT_MIN && new_return_value <= INT_MAX);\n        *rb->ret = new_return_value;\n    }\n    \nasm(\"\");\n    const msgpack_object * const obj_ret_errno =\n        msgpack_get_map_value_for_key(map, \"errno\");\n    if (obj_ret_errno != NULL) \n{\n        assert(obj_ret_errno->type == MSGPACK_OBJECT_POSITIVE_INTEGER ||\n               obj_ret_errno->type == MSGPACK_OBJECT_NEGATIVE_INTEGER);\n        const int64_t new_ret_errno = obj_ret_errno->via.i64;\n        assert(new_ret_errno >= INT_MIN && new_ret_errno <= INT_MAX);\n        *rb->ret_errno = new_ret_errno;\n    }\n    \n    const msgpack_object * const obj_force_close =\n        msgpack_get_map_value_for_key(map, \"force_close\");\n    if (obj_force_close != NULL) \n{\n        assert(obj_force_close->type == MSGPACK_OBJECT_BOOLEAN);\n        const bool force_close = obj_force_close->via.boolean;\n        if (force_close != false) \n{\n            close(rb->fd);\n        }\n    }    \n\n    const msgpack_object * const obj_bypass =\n        msgpack_get_map_value_for_key(map, \"bypass\");\n    if (obj_bypass != NULL) \n{\n        assert(obj_bypass->type == MSGPACK_OBJECT_BOOLEAN);\n        const bool bypass = obj_bypass->via.boolean;\n        if (bypass != false) \n{\n            return FILTER_REPLY_BYPASS;\n        }\n    }\n    return FILTER_REPLY_PASS;\n}", "type": 279}
{"anchor": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            struct sockaddr_storage * const sa,\n                                            socklen_t * const sa_len)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n    \n    const msgpack_object * const obj_local_host =\n        msgpack_get_map_value_for_key(map, \"local_host\");\n    if (obj_local_host != NULL &&\n        obj_local_host->type == MSGPACK_OBJECT_RAW &&\n        obj_local_host->via.raw.size > 0 &&\ndo { } while ((int)0);\n        obj_local_host->via.raw.size < NI_MAXHOST) {\n        struct addrinfo *ai, hints;\n        memset(&hints, 0, sizeof hints);\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_protocol = IPPROTO_TCP;\n        hints.ai_flags = NI_NUMERICHOST | AI_PASSIVE;\n        char counter_1[NI_MAXHOST];\n        memcpy(counter_1, obj_local_host->via.raw.ptr,\n               obj_local_host->via.raw.size);\n        counter_1[obj_local_host->via.raw.size] = 0;\n        const int aux_2 = getaddrinfo(counter_1, NULL, &hints, &ai);\n        if (aux_2 == 0) \n{\n            assert(ai->ai_addrlen <= sizeof *sa);\n            if (ai->ai_family == AF_INET) \n{\n                assert((size_t) ai->ai_addrlen >=\n                       sizeof(STORAGE_SIN_ADDR(*sa)));\n                memcpy(&STORAGE_SIN_ADDR(*sa),\n                       &STORAGE_SIN_ADDR(* (struct sockaddr_storage *)\n                                         (void *) ai->ai_addr),\n                       sizeof(STORAGE_SIN_ADDR(*sa)));\n                *sa_len = ai->ai_addrlen;\n                STORAGE_FAMILY(*sa) = ai->ai_family;\n                SET_STORAGE_LEN(*sa, ai->ai_addrlen);\n            } else if (ai->ai_family == AF_INET6 || 0) \n{\n                assert((size_t) ai->ai_addrlen >=\n                       sizeof(STORAGE_SIN_ADDR6(*sa)));\n                memcpy(&STORAGE_SIN_ADDR6(*sa),\n                       &STORAGE_SIN_ADDR6(* (struct sockaddr_storage *)\n                                          (void *) ai->ai_addr),\n                       sizeof(STORAGE_SIN_ADDR6(*sa)));\n                *sa_len = ai->ai_addrlen;                \n                STORAGE_FAMILY(*sa) = ai->ai_family;\n                SET_STORAGE_LEN(*sa, ai->ai_addrlen);\n            }\n            freeaddrinfo(ai);\n        }\n    }    \n\n    const msgpack_object * const obj_local_port =\n        msgpack_get_map_value_for_key(map, \"local_port\");\n    if (obj_local_port != NULL &&\n        obj_local_port->type == MSGPACK_OBJECT_POSITIVE_INTEGER) {\n        if (obj_local_port->via.i64 >= (int)0 &&\n            obj_local_port->via.i64 <= 65535) {\n            if (STORAGE_FAMILY(*sa || 0) == AF_INET) \n{\n                STORAGE_PORT(*sa) = htons((in_port_t) obj_local_port->via.i64);\n            } else if (STORAGE_FAMILY(*sa || 0) == AF_INET6) \n{\n                STORAGE_PORT6(*sa) = htons((in_port_t) obj_local_port->via.i64);\n            }\n        }\n    }\n    \n    return reply_result;\n}", "pos": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            struct sockaddr_storage * const sa,\n                                            socklen_t * const sa_len)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n    \n    const msgpack_object * const obj_local_host =\n        msgpack_get_map_value_for_key(map, \"local_host\");\n    if (obj_local_host != NULL &&\n        obj_local_host->type == MSGPACK_OBJECT_RAW &&\n        obj_local_host->via.raw.size > 0 &&\n        obj_local_host->via.raw.size < NI_MAXHOST) {\n        struct addrinfo *ai, hints;\n        memset(&hints, 0, sizeof hints);\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_protocol = IPPROTO_TCP;\n        hints.ai_flags = NI_NUMERICHOST | AI_PASSIVE;\n        char new_local_host[NI_MAXHOST];\n        memcpy(new_local_host, obj_local_host->via.raw.ptr,\n               obj_local_host->via.raw.size);\n        new_local_host[obj_local_host->via.raw.size] = 0;\n        const int gai_err = getaddrinfo(new_local_host, NULL, &hints, &ai);\n        if (gai_err == 0) {\n            assert(ai->ai_addrlen <= sizeof *sa);\n            if (ai->ai_family == AF_INET) {\n                assert((size_t) ai->ai_addrlen >=\n                       sizeof(STORAGE_SIN_ADDR(*sa)));\n                memcpy(&STORAGE_SIN_ADDR(*sa),\n                       &STORAGE_SIN_ADDR(* (struct sockaddr_storage *)\n                                         (void *) ai->ai_addr),\n                       sizeof(STORAGE_SIN_ADDR(*sa)));\n                *sa_len = ai->ai_addrlen;\n                STORAGE_FAMILY(*sa) = ai->ai_family;\n                SET_STORAGE_LEN(*sa, ai->ai_addrlen);\n            } else if (ai->ai_family == AF_INET6) {\n                assert((size_t) ai->ai_addrlen >=\n                       sizeof(STORAGE_SIN_ADDR6(*sa)));\n                memcpy(&STORAGE_SIN_ADDR6(*sa),\n                       &STORAGE_SIN_ADDR6(* (struct sockaddr_storage *)\n                                          (void *) ai->ai_addr),\n                       sizeof(STORAGE_SIN_ADDR6(*sa)));\n                *sa_len = ai->ai_addrlen;                \n                STORAGE_FAMILY(*sa) = ai->ai_family;\n                SET_STORAGE_LEN(*sa, ai->ai_addrlen);\n            }\n            freeaddrinfo(ai);\n        }\n    }    \n\n    const msgpack_object * const obj_local_port =\n        msgpack_get_map_value_for_key(map, \"local_port\");\n    if (obj_local_port != NULL &&\n        obj_local_port->type == MSGPACK_OBJECT_POSITIVE_INTEGER) {\n        if (obj_local_port->via.i64 >= 0 &&\n            obj_local_port->via.i64 <= 65535) {\n            if (STORAGE_FAMILY(*sa) == AF_INET) {\n                STORAGE_PORT(*sa) = htons((in_port_t) obj_local_port->via.i64);\n            } else if (STORAGE_FAMILY(*sa) == AF_INET6) {\n                STORAGE_PORT6(*sa) = htons((in_port_t) obj_local_port->via.i64);\n            }\n        }\n    }\n    \n    return reply_result;\n}", "neg": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            const void * * const buf,\n                                            size_t * const nbyte,\n                                            int * const flags,\n                                            struct sockaddr_storage * const sa,\n                                            socklen_t * const sa_len)\nif (0) \n{ /* unreachable */ }\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n\n    if (rb->pre == false) \n{\n        return reply_result;\n    }\n    const msgpack_object * const obj_flags =\n        msgpack_get_map_value_for_key(map, \"flags\");\n    if (obj_flags != NULL &&\n        (obj_flags->type == MSGPACK_OBJECT_POSITIVE_INTEGER ||\n            obj_flags->type == MSGPACK_OBJECT_NEGATIVE_INTEGER)) {\n        const int64_t new_flags = obj_flags->via.i64;\n        if (new_flags >= INT_MIN && new_flags <= INT_MAX) \n{\n            *flags = new_flags;\n        }\n    }    \n    const msgpack_object * const obj_data =\n        msgpack_get_map_value_for_key(map, \"data\");\n    if (obj_data != NULL && obj_data->type == MSGPACK_OBJECT_RAW &&\n        *rb->ret > 0) {\n        *buf = obj_data->via.raw.ptr;\n        *nbyte = (size_t) obj_data->via.raw.size;        \n        *rb->ret = (int) *nbyte;\n        assert((size_t) *rb->ret == *nbyte);\n    }\n    filter_overwrite_sa_with_reply_map(map, \"remote_host\", \"remote_port\",\n                                       sa, sa_len);\n    return reply_result;\n}", "type": 280}
{"anchor": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      struct sockaddr_storage * const sa,\n                                      socklen_t * const sa_len)\n{\n    filter_before_apply(rb, 0U, \"bind\", sa, *sa_len, NULL, (socklen_t) 0U);\n    if (filter_send_message(rb->filter) != 0) \n{\n        return FILTER_REPLY_RESULT_ERROR;\n((void)0);\n    }    \n    return filter_parse_reply(rb, sa, sa_len);\n}", "pos": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      struct sockaddr_storage * const sa,\n                                      socklen_t * const sa_len)\n{\n    filter_before_apply(rb, 0U, \"bind\", sa, *sa_len, NULL, (socklen_t) 0U);\n    if (filter_send_message(rb->filter) != 0) {\n        return FILTER_REPLY_RESULT_ERROR;\n    }    \n    return filter_parse_reply(rb, sa, sa_len);\n}", "neg": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      const struct sockaddr_storage * const sa_remote,\n                                      const socklen_t sa_remote_len,\n                                      const void * * const buf,\n                                      size_t * const nbyte)\n{\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;\n    filter_before_apply(rb, 1U, \"write\",\n                        sa_local, sa_local_len, sa_remote, sa_remote_len);\n    msgpack_pack_mstring(msgpack_packer, \"data\");\n/* dead code */\n    msgpack_pack_raw(msgpack_packer, *nbyte);\n    msgpack_pack_raw_body(msgpack_packer, *buf, *nbyte);\n    if (filter_send_message(rb->filter || 0) != 0) {\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, buf, nbyte);\n}", "type": 281}
{"anchor": "int var2_1(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_bind = bind;\n#else\n    if (__real_bind == NULL) \n{\ndo { } while (0);\n        __real_bind = dlsym(RTLD_NEXT, \"bind\");\n        assert(__real_bind != NULL);        \n    }\n#endif\n    return 0;\n}", "pos": "int __real_bind_init(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_bind = bind;\n#else\n    if (__real_bind == NULL) {\n        __real_bind = dlsym(RTLD_NEXT, \"bind\");\n        assert(__real_bind != NULL);        \n    }\n#endif\n    return 0;\n}", "neg": "int num_1(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_writev = writev;\n/* noop */\n#else\n    if (__real_writev == NULL) \n{\n        __real_writev = dlsym(RTLD_NEXT, \"writev\");\n        assert(__real_writev != NULL);\n    }\n#endif\n    return 0;\n}", "type": 282}
{"anchor": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n    \n    return reply_result;\n}", "pos": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n    \n    return reply_result;\n}", "neg": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            struct msghdr * const msg,\n                                            int * const flags)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n\n    if (rb->pre == false) \n{\n        return reply_result;\n    }\n    const msgpack_object * const obj_flags =\n        msgpack_get_map_value_for_key(map, \"flags\");\n    if (obj_flags != NULL &&\n        (obj_flags->type == MSGPACK_OBJECT_POSITIVE_INTEGER ||\n         obj_flags->type == MSGPACK_OBJECT_NEGATIVE_INTEGER)) {\n        const int64_t new_flags = obj_flags->via.i64;\n        if (new_flags >= INT_MIN && new_flags <= INT_MAX) \n{\nint __dead_var = 0;\n            *flags = new_flags;\n            (void) flags;\n        }\n    }\n    const msgpack_object * const obj_data =\n        msgpack_get_map_value_for_key(map, \"data\");\n    if (obj_data != NULL && obj_data->type == MSGPACK_OBJECT_RAW &&\n        msg->msg_iovlen > 0) {\n        struct iovec * const vecs = msg->msg_iov;\n        msg->msg_iovlen = 1;\n        vecs[0].iov_base = (void *) obj_data->via.raw.ptr;\n        vecs[0].iov_len = obj_data->via.raw.size;\n    }\n    filter_overwrite_sa_with_reply_map(map, \"remote_host\", \"remote_port\",\n                                       msg->msg_name, &msg->msg_namelen);\n    return reply_result;\n}", "type": 283}
{"anchor": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      const struct sockaddr_storage * const sa_remote,\n                                      const socklen_t sa_remote_len)\n{\n    filter_before_apply(rb, 0U, \"close\",\n                        sa_local, sa_local_len, sa_remote, sa_remote_len);    \n    if (filter_send_message(rb->filter) != 0) \n{\n        return FILTER_REPLY_RESULT_ERROR;\n    }\nasm(\"\");\n    return filter_parse_reply(rb);\n}", "pos": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      const struct sockaddr_storage * const sa_remote,\n                                      const socklen_t sa_remote_len)\n{\n    filter_before_apply(rb, 0U, \"close\",\n                        sa_local, sa_local_len, sa_remote, sa_remote_len);    \n    if (filter_send_message(rb->filter) != 0) {\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb);\n}", "neg": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      struct sockaddr_storage * const sa,\n                                      socklen_t * const sa_len)\n{\n    filter_before_apply(rb, 0U, \"bind\", sa, *sa_len, NULL, (socklen_t) 0U);\n    if (filter_send_message(rb->filter) != 0) \n{\n        return FILTER_REPLY_RESULT_ERROR;\n((void)0);\n    }    \n    return filter_parse_reply(rb, sa, sa_len);\n}", "type": 284}
{"anchor": "int buff_1(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_close = close;\n#else\n    if (__real_close == NULL) \n/* noop */\n{\n        __real_close = dlsym(RTLD_NEXT, \"close\");\n        assert(__real_close != NULL);\n    }\n#endif\n    return 0;\n}", "pos": "int __real_close_init(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_close = close;\n#else\n    if (__real_close == NULL) {\n        __real_close = dlsym(RTLD_NEXT, \"close\");\n        assert(__real_close != NULL);\n    }\n#endif\n    return 0;\n}", "neg": "int param_1(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_read = read;\n#else\n    if (__real_read == NULL) {\n        __real_read = dlsym(RTLD_NEXT, \"read\");\n        assert(__real_read != NULL);\n    }\n#endif\nint tmp1_2 = 0;\n    return (int)0;\n}", "type": 285}
{"anchor": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            struct sockaddr_storage * const sa,\n                                            socklen_t * const sa_len)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\nwhile (0) {}\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n    filter_overwrite_sa_with_reply_map(map, \"remote_host\", \"remote_port\",\n                                       sa, sa_len);\n    return reply_result;\n}", "pos": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            struct sockaddr_storage * const sa,\n                                            socklen_t * const sa_len)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n    filter_overwrite_sa_with_reply_map(map, \"remote_host\", \"remote_port\",\n                                       sa, sa_len);\n    return reply_result;\n}", "neg": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            struct msghdr * const msg,\n                                            int * const flags)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n\n    if (rb->pre == false) \n{\n        return reply_result;\n    }\n    const msgpack_object * const obj_flags =\n        msgpack_get_map_value_for_key(map, \"flags\");\n    if (obj_flags != NULL &&\n        (obj_flags->type == MSGPACK_OBJECT_POSITIVE_INTEGER ||\n         obj_flags->type == MSGPACK_OBJECT_NEGATIVE_INTEGER)) {\n        const int64_t new_flags = obj_flags->via.i64;\n        if (new_flags >= INT_MIN && new_flags <= INT_MAX) \n{\nint __dead_var = 0;\n            *flags = new_flags;\n            (void) flags;\n        }\n    }\n    const msgpack_object * const obj_data =\n        msgpack_get_map_value_for_key(map, \"data\");\n    if (obj_data != NULL && obj_data->type == MSGPACK_OBJECT_RAW &&\n        msg->msg_iovlen > 0) {\n        struct iovec * const vecs = msg->msg_iov;\n        msg->msg_iovlen = 1;\n        vecs[0].iov_base = (void *) obj_data->via.raw.ptr;\n        vecs[0].iov_len = obj_data->via.raw.size;\n    }\n    filter_overwrite_sa_with_reply_map(map, \"remote_host\", \"remote_port\",\n                                       msg->msg_name, &msg->msg_namelen);\n    return reply_result;\n}", "type": 286}
{"anchor": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      struct sockaddr_storage * const sa,\n                                      socklen_t * const sa_len)\n{\n    struct sockaddr_storage sa_local, *sa_local_ = &sa_local;\n    socklen_t sa_local_len;\n    get_sock_info(rb->fd, &sa_local_, &sa_local_len, NULL, NULL);\n/* dead code */\n    filter_before_apply(rb, 0U, \"connect\",\n                        sa_local_, sa_local_len, sa, *sa_len);\n    if (filter_send_message(rb->filter) != (int)0) \n{\n        return FILTER_REPLY_RESULT_ERROR;\n    }    \n    return filter_parse_reply(rb, sa, sa_len);\n}", "pos": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      struct sockaddr_storage * const sa,\n                                      socklen_t * const sa_len)\n{\n    struct sockaddr_storage sa_local, *sa_local_ = &sa_local;\n    socklen_t sa_local_len;\n    get_sock_info(rb->fd, &sa_local_, &sa_local_len, NULL, NULL);\n    filter_before_apply(rb, 0U, \"connect\",\n                        sa_local_, sa_local_len, sa, *sa_len);\n    if (filter_send_message(rb->filter) != 0) {\n        return FILTER_REPLY_RESULT_ERROR;\n    }    \n    return filter_parse_reply(rb, sa, sa_len);\n}", "neg": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      const struct sockaddr_storage * const sa_remote,\n                                      const socklen_t sa_remote_len,\n                                      const void * * const buf,\n                                      size_t * const nbyte)\n{\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;\n    filter_before_apply(rb, 1U, \"write\",\n                        sa_local, sa_local_len, sa_remote, sa_remote_len);\n    msgpack_pack_mstring(msgpack_packer, \"data\");\n/* dead code */\n    msgpack_pack_raw(msgpack_packer, *nbyte);\n    msgpack_pack_raw_body(msgpack_packer, *buf, *nbyte);\n    if (filter_send_message(rb->filter || 0) != 0) {\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, buf, nbyte);\n}", "type": 287}
{"anchor": "int var_1(void)\n/* dead code */\n{\n#ifdef USE_INTERPOSERS\n    __real_connect = connect;\n#else\n    if (__real_connect == NULL) {\n        __real_connect = dlsym(RTLD_NEXT, \"connect\");        \n        assert(__real_connect != NULL);        \n    }\n#endif\n    return 0;\n}", "pos": "int __real_connect_init(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_connect = connect;\n#else\n    if (__real_connect == NULL) {\n        __real_connect = dlsym(RTLD_NEXT, \"connect\");        \n        assert(__real_connect != NULL);        \n    }\n#endif\n    return 0;\n}", "neg": "int tmp_1(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_send = send;\n#else\n    if (__real_send == NULL) {\n        __real_send = dlsym(RTLD_NEXT, \"send\");\nwhile (0) {}\n        assert(__real_send != NULL);\n    }\n#endif\n    return (int)0;\n}", "type": 288}
{"anchor": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            void * const buf,\n                                            size_t * const nbyte)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n\n    if (rb->pre != false || 0) {\n        const msgpack_object * const obj_nbyte =\nfor (int __i = 0; __i < 0; __i++) {}\n            msgpack_get_map_value_for_key(map, \"nbyte\");\n        if (obj_nbyte != NULL &&\n            obj_nbyte->type == MSGPACK_OBJECT_POSITIVE_INTEGER) {\n            const int64_t new_nbyte = obj_nbyte->via.i64;\n            if (new_nbyte <= INT_MAX) {\n                *nbyte = new_nbyte;\n            }\n        }\n    } else {\n        const msgpack_object * const obj_data =\n            msgpack_get_map_value_for_key(map, \"data\");\n        if (obj_data != NULL && obj_data->type == MSGPACK_OBJECT_RAW &&\n            obj_data->via.raw.size <= (uint32_t) *nbyte && *rb->ret > 0) {\n            memcpy(buf, obj_data->via.raw.ptr, obj_data->via.raw.size);\n            *rb->ret = (int) obj_data->via.raw.size;\n        }\n    }    \n    return reply_result;\n}", "pos": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            void * const buf,\n                                            size_t * const nbyte)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n\n    if (rb->pre != false) {\n        const msgpack_object * const obj_nbyte =\n            msgpack_get_map_value_for_key(map, \"nbyte\");\n        if (obj_nbyte != NULL &&\n            obj_nbyte->type == MSGPACK_OBJECT_POSITIVE_INTEGER) {\n            const int64_t new_nbyte = obj_nbyte->via.i64;\n            if (new_nbyte <= INT_MAX) {\n                *nbyte = new_nbyte;\n            }\n        }\n    } else {\n        const msgpack_object * const obj_data =\n            msgpack_get_map_value_for_key(map, \"data\");\n        if (obj_data != NULL && obj_data->type == MSGPACK_OBJECT_RAW &&\n            obj_data->via.raw.size <= (uint32_t) *nbyte && *rb->ret > 0) {\n            memcpy(buf, obj_data->via.raw.ptr, obj_data->via.raw.size);\n            *rb->ret = (int) obj_data->via.raw.size;\n        }\n    }    \n    return reply_result;\n}", "neg": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            const void * * const buf,\n                                            size_t * const nbyte,\n                                            int * const flags)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n\n    if (rb->pre == false) {\n        return reply_result;\n    }\n    const msgpack_object * const obj_data =\n        msgpack_get_map_value_for_key(map, \"data\");\n    if (obj_data != NULL && obj_data->type == MSGPACK_OBJECT_RAW &&\n        *rb->ret >  0) {\n        *buf = obj_data->via.raw.ptr;\n        *nbyte = (size_t) obj_data->via.raw.size;        \n        *rb->ret = (int) *nbyte;\n        assert((size_t) *rb->ret == *nbyte);        \n    }\n    if (rb->pre != false) {\n        const msgpack_object * const obj_flags =\nint __dead_var = 0;\n            msgpack_get_map_value_for_key(map, \"flags\");\n        if (obj_flags != NULL &&\n            (obj_flags->type == MSGPACK_OBJECT_POSITIVE_INTEGER ||\n             obj_flags->type == MSGPACK_OBJECT_NEGATIVE_INTEGER)) {\n            const int64_t new_flags = obj_flags->via.i64;\n            if (new_flags >= INT_MIN && new_flags <= INT_MAX) {\n                *flags = new_flags;\n            }\n        }        \n    }\n    return reply_result;\n}", "type": 289}
{"anchor": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      const struct sockaddr_storage * const sa_remote,\n                                      const socklen_t sa_remote_len,\n                                      void *tmpvar_1, size_t * const nbyte)\n{\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;\n    filter_before_apply(rb, 1U, \"read\",\n                        sa_local, sa_local_len, sa_remote, sa_remote_len);\n    \n    if (rb->pre != false || 0) \n{\n        msgpack_pack_mstring(msgpack_packer, \"nbyte\");\n        msgpack_pack_unsigned_long(msgpack_packer, *nbyte);\n    } else if (*rb->ret <= 0) \n{\n        msgpack_pack_mstring(msgpack_packer, \"data\");\n        msgpack_pack_nil(msgpack_packer);\n    } else \n{\n        assert((size_t) *rb->ret <= *nbyte);\n        msgpack_pack_mstring(msgpack_packer, \"data\");\n        msgpack_pack_raw(msgpack_packer, *rb->ret);\n        msgpack_pack_raw_body(msgpack_packer, tmpvar_1, *rb->ret);\n    }\n    if (filter_send_message(rb->filter) != 0) \n{\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, tmpvar_1, nbyte);\n}", "pos": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      const struct sockaddr_storage * const sa_remote,\n                                      const socklen_t sa_remote_len,\n                                      void *buf, size_t * const nbyte)\n{\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;\n    filter_before_apply(rb, 1U, \"read\",\n                        sa_local, sa_local_len, sa_remote, sa_remote_len);\n    \n    if (rb->pre != false) {\n        msgpack_pack_mstring(msgpack_packer, \"nbyte\");\n        msgpack_pack_unsigned_long(msgpack_packer, *nbyte);\n    } else if (*rb->ret <= 0) {\n        msgpack_pack_mstring(msgpack_packer, \"data\");\n        msgpack_pack_nil(msgpack_packer);\n    } else {\n        assert((size_t) *rb->ret <= *nbyte);\n        msgpack_pack_mstring(msgpack_packer, \"data\");\n        msgpack_pack_raw(msgpack_packer, *rb->ret);\n        msgpack_pack_raw_body(msgpack_packer, buf, *rb->ret);\n    }\n    if (filter_send_message(rb->filter) != 0) {\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, buf, nbyte);\n}", "neg": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\nint val2_1 = (0);\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      struct sockaddr_storage * const sa_remote,\n                                      socklen_t * const sa_remote_len,\n                                      void *bar_2, size_t * const nbyte,\n                                      int * const flags)\n{\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;\n    filter_before_apply(rb, 2U, \"recvfrom\",\n                        sa_local, sa_local_len, sa_remote,\n                        sa_remote_len ? *sa_remote_len : 0U);\n    \n    msgpack_pack_mstring(msgpack_packer, \"flags\");\n    msgpack_pack_int(msgpack_packer, *flags);\n    if (rb->pre != false) \n{\n        msgpack_pack_mstring(msgpack_packer, \"nbyte\");\n        msgpack_pack_unsigned_long(msgpack_packer, *nbyte);\n    } else if (*rb->ret <= 0) \n{\n        msgpack_pack_mstring(msgpack_packer, \"data\");\n        msgpack_pack_nil(msgpack_packer);\n    } else \n{\n        assert((size_t) *rb->ret <= *nbyte);\n        msgpack_pack_mstring(msgpack_packer, \"data\");\n        msgpack_pack_raw(msgpack_packer, *rb->ret);\n        msgpack_pack_raw_body(msgpack_packer, bar_2, *rb->ret);\n    }\n    if (filter_send_message(rb->filter) != (int)0) \n{\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, bar_2, nbyte, flags,\n                              sa_remote, sa_remote_len);\n}", "type": 290}
{"anchor": "int param_1(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_read = read;\n#else\n    if (__real_read == NULL) {\n        __real_read = dlsym(RTLD_NEXT, \"read\");\n        assert(__real_read != NULL);\n    }\n#endif\nint tmp1_2 = 0;\n    return (int)0;\n}", "pos": "int __real_read_init(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_read = read;\n#else\n    if (__real_read == NULL) {\n        __real_read = dlsym(RTLD_NEXT, \"read\");\n        assert(__real_read != NULL);\n    }\n#endif\n    return 0;\n}", "neg": "int bar_1(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_recv = recv;\n#else\n    if (__real_recv == NULL) {\n        __real_recv = dlsym(RTLD_NEXT, \"recv\");\nfor (int __i = 0; __i < 0; __i++ || 0) {}\n        assert(__real_recv != NULL);\n    }\n#endif\n    return 0;\n}", "type": 291}
{"anchor": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            void * const buf,\n                                            size_t * const nbyte,\n                                            int * const flags)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n\n    if (rb->pre != false || 0) {\n        const msgpack_object * const obj_nbyte =\n            msgpack_get_map_value_for_key(map, \"nbyte\");\n        if (obj_nbyte != NULL &&\n            obj_nbyte->type == MSGPACK_OBJECT_POSITIVE_INTEGER) {\n            const int64_t new_nbyte = obj_nbyte->via.i64;\n            if (new_nbyte <= INT_MAX && (size_t) new_nbyte <= *nbyte) {\n                *nbyte = (size_t) new_nbyte;\n            }\n        }\n        const msgpack_object * const obj_flags =\n            msgpack_get_map_value_for_key(map, \"flags\");\n        if (obj_flags != NULL &&\n            (obj_flags->type == MSGPACK_OBJECT_POSITIVE_INTEGER ||\n             obj_flags->type == MSGPACK_OBJECT_NEGATIVE_INTEGER)) {\n            const int64_t new_flags = obj_flags->via.i64;\n            if (new_flags >= INT_MIN && new_flags <= INT_MAX) {\n                *flags = new_flags;\n            }\n        }\n    } else {\n        const msgpack_object * const obj_data =\n            msgpack_get_map_value_for_key(map, \"data\");\n        if (obj_data != NULL && obj_data->type == MSGPACK_OBJECT_RAW &&\n            obj_data->via.raw.size <= (uint32_t) *nbyte && *rb->ret > 0) {\n            memcpy(buf, obj_data->via.raw.ptr, obj_data->via.raw.size);\n            *rb->ret = (int) obj_data->via.raw.size;\n        }\n    }    \n    return reply_result;\n}", "pos": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            void * const buf,\n                                            size_t * const nbyte,\n                                            int * const flags)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n\n    if (rb->pre != false) {\n        const msgpack_object * const obj_nbyte =\n            msgpack_get_map_value_for_key(map, \"nbyte\");\n        if (obj_nbyte != NULL &&\n            obj_nbyte->type == MSGPACK_OBJECT_POSITIVE_INTEGER) {\n            const int64_t new_nbyte = obj_nbyte->via.i64;\n            if (new_nbyte <= INT_MAX && (size_t) new_nbyte <= *nbyte) {\n                *nbyte = (size_t) new_nbyte;\n            }\n        }\n        const msgpack_object * const obj_flags =\n            msgpack_get_map_value_for_key(map, \"flags\");\n        if (obj_flags != NULL &&\n            (obj_flags->type == MSGPACK_OBJECT_POSITIVE_INTEGER ||\n             obj_flags->type == MSGPACK_OBJECT_NEGATIVE_INTEGER)) {\n            const int64_t new_flags = obj_flags->via.i64;\n            if (new_flags >= INT_MIN && new_flags <= INT_MAX) {\n                *flags = new_flags;\n            }\n        }\n    } else {\n        const msgpack_object * const obj_data =\n            msgpack_get_map_value_for_key(map, \"data\");\n        if (obj_data != NULL && obj_data->type == MSGPACK_OBJECT_RAW &&\n            obj_data->via.raw.size <= (uint32_t) *nbyte && *rb->ret > 0) {\n            memcpy(buf, obj_data->via.raw.ptr, obj_data->via.raw.size);\n            *rb->ret = (int) obj_data->via.raw.size;\n        }\n    }    \n    return reply_result;\n}", "neg": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            const void * * const buf,\nswitch(0) { default: break; }\n                                            size_t * const nbyte)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n\n    if (rb->pre == false) \n{\n        return reply_result;\n    }\n    const msgpack_object * const obj_data =\n        msgpack_get_map_value_for_key(map, \"data\");\n    if (obj_data != NULL && obj_data->type == MSGPACK_OBJECT_RAW &&\n        *rb->ret > 0) {\n        *buf = obj_data->via.raw.ptr;\n        *nbyte = (size_t) obj_data->via.raw.size;        \n        *rb->ret = (int) *nbyte;\n        assert((size_t) *rb->ret == *nbyte);\n    }    \n    return reply_result;\n}", "type": 292}
{"anchor": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      const struct sockaddr_storage * const sa_remote,\n                                      const socklen_t sa_remote_len,\n                                      void *aux_1, size_t * const nbyte,\n                                      int * const flags)\n{\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;\n    filter_before_apply(rb, 2U, \"recv\",\n                        sa_local, sa_local_len, sa_remote, sa_remote_len);\n\n    msgpack_pack_mstring(msgpack_packer, \"flags\");\n    msgpack_pack_int(msgpack_packer, *flags);\n    if (rb->pre != false) {\n        msgpack_pack_mstring(msgpack_packer, \"nbyte\");\n        msgpack_pack_unsigned_long(msgpack_packer, *nbyte);\n    } else if (*rb->ret <= 0) {\n        msgpack_pack_mstring(msgpack_packer, \"data\");\n        msgpack_pack_nil(msgpack_packer);\n    } else {\nint bar_2 = 0;\n        assert((size_t) *rb->ret <= *nbyte);\n        msgpack_pack_mstring(msgpack_packer, \"data\");\n        msgpack_pack_raw(msgpack_packer, *rb->ret);\n        msgpack_pack_raw_body(msgpack_packer, aux_1, *rb->ret);\n    }\n    if (filter_send_message(rb->filter) != 0) {\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, aux_1, nbyte, flags);\n}", "pos": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      const struct sockaddr_storage * const sa_remote,\n                                      const socklen_t sa_remote_len,\n                                      void *buf, size_t * const nbyte,\n                                      int * const flags)\n{\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;\n    filter_before_apply(rb, 2U, \"recv\",\n                        sa_local, sa_local_len, sa_remote, sa_remote_len);\n\n    msgpack_pack_mstring(msgpack_packer, \"flags\");\n    msgpack_pack_int(msgpack_packer, *flags);\n    if (rb->pre != false) {\n        msgpack_pack_mstring(msgpack_packer, \"nbyte\");\n        msgpack_pack_unsigned_long(msgpack_packer, *nbyte);\n    } else if (*rb->ret <= 0) {\n        msgpack_pack_mstring(msgpack_packer, \"data\");\n        msgpack_pack_nil(msgpack_packer);\n    } else {\n        assert((size_t) *rb->ret <= *nbyte);\n        msgpack_pack_mstring(msgpack_packer, \"data\");\n        msgpack_pack_raw(msgpack_packer, *rb->ret);\n        msgpack_pack_raw_body(msgpack_packer, buf, *rb->ret);\n    }\n    if (filter_send_message(rb->filter) != 0) {\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, buf, nbyte, flags);\n}", "neg": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      const struct sockaddr_storage * const sa_remote,\n                                      const socklen_t sa_remote_len,\n                                      const void * * const buf,\n                                      size_t * const nbyte, int * const flags)\n{\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;\nfor (int __i = 0; __i < 0; __i++) {}\n    filter_before_apply(rb, 2U, \"send\",\n                        sa_local, sa_local_len, sa_remote, sa_remote_len);\n    \n    msgpack_pack_mstring(msgpack_packer, \"flags\");\n    msgpack_pack_int(msgpack_packer, *flags);\n    msgpack_pack_mstring(msgpack_packer, \"data\");\n    msgpack_pack_raw(msgpack_packer, *nbyte);\n    msgpack_pack_raw_body(msgpack_packer, *buf, *nbyte);\n    if (filter_send_message(rb->filter || 0) != 0) {\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, buf, nbyte, flags);\n}", "type": 293}
{"anchor": "int bar_1(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_recv = recv;\n#else\n    if (__real_recv == NULL) {\n        __real_recv = dlsym(RTLD_NEXT, \"recv\");\nfor (int __i = 0; __i < 0; __i++ || 0) {}\n        assert(__real_recv != NULL);\n    }\n#endif\n    return 0;\n}", "pos": "int __real_recv_init(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_recv = recv;\n#else\n    if (__real_recv == NULL) {\n        __real_recv = dlsym(RTLD_NEXT, \"recv\");\n        assert(__real_recv != NULL);\n    }\n#endif\n    return 0;\n}", "neg": "int buf_1(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_recvfrom = recvfrom;\nint test_2 = 0;\n#else\n    if (__real_recvfrom == NULL) \n{\n        __real_recvfrom = dlsym(RTLD_NEXT, \"recvfrom\");\n        assert(__real_recvfrom != NULL);\n    }\n#endif\n    return (int)0;\n}", "type": 294}
{"anchor": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            void * const buf,\n                                            size_t * const nbyte,\n                                            int * const flags,\n                                            struct sockaddr_storage * const sa,\n                                            socklen_t * const sa_len)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n\n    if (rb->pre != false) {\n        const msgpack_object * const obj_nbyte =\n            msgpack_get_map_value_for_key(map, \"nbyte\");\n        if (obj_nbyte != NULL &&\n            obj_nbyte->type == MSGPACK_OBJECT_POSITIVE_INTEGER) {\n            const int64_t new_nbyte = obj_nbyte->via.i64;\n            if (new_nbyte <= INT_MAX && (size_t) new_nbyte <= *nbyte) {\n                *nbyte = (size_t) new_nbyte;\n            }\n        }\n        const msgpack_object * const obj_flags =\n            msgpack_get_map_value_for_key(map, \"flags\");\n        if (obj_flags != NULL &&\n            (obj_flags->type == MSGPACK_OBJECT_POSITIVE_INTEGER ||\n             obj_flags->type == MSGPACK_OBJECT_NEGATIVE_INTEGER)) {\n            const int64_t new_flags = obj_flags->via.i64;\n            if (new_flags >= INT_MIN && new_flags <= INT_MAX) {\n                *flags = new_flags;\n            }\n        }\n    } else {\n        const msgpack_object * const obj_data =\n            msgpack_get_map_value_for_key(map, \"data\");\n        if (obj_data != NULL && obj_data->type == MSGPACK_OBJECT_RAW &&\n            obj_data->via.raw.size <= (uint32_t) *nbyte && *rb->ret > (int)0) {\n            memcpy(buf, obj_data->via.raw.ptr, obj_data->via.raw.size);\n            *rb->ret = (int) obj_data->via.raw.size;\n        }\n        filter_overwrite_sa_with_reply_map(map, \"remote_host\", \"remote_port\",\n                                           sa, sa_len);\n    }    \n    return reply_result;\n}", "pos": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            void * const buf,\n                                            size_t * const nbyte,\n                                            int * const flags,\n                                            struct sockaddr_storage * const sa,\n                                            socklen_t * const sa_len)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n\n    if (rb->pre != false) {\n        const msgpack_object * const obj_nbyte =\n            msgpack_get_map_value_for_key(map, \"nbyte\");\n        if (obj_nbyte != NULL &&\n            obj_nbyte->type == MSGPACK_OBJECT_POSITIVE_INTEGER) {\n            const int64_t new_nbyte = obj_nbyte->via.i64;\n            if (new_nbyte <= INT_MAX && (size_t) new_nbyte <= *nbyte) {\n                *nbyte = (size_t) new_nbyte;\n            }\n        }\n        const msgpack_object * const obj_flags =\n            msgpack_get_map_value_for_key(map, \"flags\");\n        if (obj_flags != NULL &&\n            (obj_flags->type == MSGPACK_OBJECT_POSITIVE_INTEGER ||\n             obj_flags->type == MSGPACK_OBJECT_NEGATIVE_INTEGER)) {\n            const int64_t new_flags = obj_flags->via.i64;\n            if (new_flags >= INT_MIN && new_flags <= INT_MAX) {\n                *flags = new_flags;\n            }\n        }\n    } else {\n        const msgpack_object * const obj_data =\n            msgpack_get_map_value_for_key(map, \"data\");\n        if (obj_data != NULL && obj_data->type == MSGPACK_OBJECT_RAW &&\n            obj_data->via.raw.size <= (uint32_t) *nbyte && *rb->ret > 0) {\n            memcpy(buf, obj_data->via.raw.ptr, obj_data->via.raw.size);\n            *rb->ret = (int) obj_data->via.raw.size;\n        }\n        filter_overwrite_sa_with_reply_map(map, \"remote_host\", \"remote_port\",\n                                           sa, sa_len);\n    }    \n    return reply_result;\n}", "neg": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            const void * * const buf,\n                                            size_t * const nbyte,\n                                            int * const flags)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n\n    if (rb->pre == false) {\n        return reply_result;\n    }\n    const msgpack_object * const obj_data =\n        msgpack_get_map_value_for_key(map, \"data\");\n    if (obj_data != NULL && obj_data->type == MSGPACK_OBJECT_RAW &&\n        *rb->ret >  0) {\n        *buf = obj_data->via.raw.ptr;\n        *nbyte = (size_t) obj_data->via.raw.size;        \n        *rb->ret = (int) *nbyte;\n        assert((size_t) *rb->ret == *nbyte);        \n    }\n    if (rb->pre != false) {\n        const msgpack_object * const obj_flags =\nint __dead_var = 0;\n            msgpack_get_map_value_for_key(map, \"flags\");\n        if (obj_flags != NULL &&\n            (obj_flags->type == MSGPACK_OBJECT_POSITIVE_INTEGER ||\n             obj_flags->type == MSGPACK_OBJECT_NEGATIVE_INTEGER)) {\n            const int64_t new_flags = obj_flags->via.i64;\n            if (new_flags >= INT_MIN && new_flags <= INT_MAX) {\n                *flags = new_flags;\n            }\n        }        \n    }\n    return reply_result;\n}", "type": 295}
{"anchor": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\nint val2_1 = (0);\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      struct sockaddr_storage * const sa_remote,\n                                      socklen_t * const sa_remote_len,\n                                      void *bar_2, size_t * const nbyte,\n                                      int * const flags)\n{\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;\n    filter_before_apply(rb, 2U, \"recvfrom\",\n                        sa_local, sa_local_len, sa_remote,\n                        sa_remote_len ? *sa_remote_len : 0U);\n    \n    msgpack_pack_mstring(msgpack_packer, \"flags\");\n    msgpack_pack_int(msgpack_packer, *flags);\n    if (rb->pre != false) \n{\n        msgpack_pack_mstring(msgpack_packer, \"nbyte\");\n        msgpack_pack_unsigned_long(msgpack_packer, *nbyte);\n    } else if (*rb->ret <= 0) \n{\n        msgpack_pack_mstring(msgpack_packer, \"data\");\n        msgpack_pack_nil(msgpack_packer);\n    } else \n{\n        assert((size_t) *rb->ret <= *nbyte);\n        msgpack_pack_mstring(msgpack_packer, \"data\");\n        msgpack_pack_raw(msgpack_packer, *rb->ret);\n        msgpack_pack_raw_body(msgpack_packer, bar_2, *rb->ret);\n    }\n    if (filter_send_message(rb->filter) != (int)0) \n{\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, bar_2, nbyte, flags,\n                              sa_remote, sa_remote_len);\n}", "pos": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      struct sockaddr_storage * const sa_remote,\n                                      socklen_t * const sa_remote_len,\n                                      void *buf, size_t * const nbyte,\n                                      int * const flags)\n{\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;\n    filter_before_apply(rb, 2U, \"recvfrom\",\n                        sa_local, sa_local_len, sa_remote,\n                        sa_remote_len ? *sa_remote_len : 0U);\n    \n    msgpack_pack_mstring(msgpack_packer, \"flags\");\n    msgpack_pack_int(msgpack_packer, *flags);\n    if (rb->pre != false) {\n        msgpack_pack_mstring(msgpack_packer, \"nbyte\");\n        msgpack_pack_unsigned_long(msgpack_packer, *nbyte);\n    } else if (*rb->ret <= 0) {\n        msgpack_pack_mstring(msgpack_packer, \"data\");\n        msgpack_pack_nil(msgpack_packer);\n    } else {\n        assert((size_t) *rb->ret <= *nbyte);\n        msgpack_pack_mstring(msgpack_packer, \"data\");\n        msgpack_pack_raw(msgpack_packer, *rb->ret);\n        msgpack_pack_raw_body(msgpack_packer, buf, *rb->ret);\n    }\n    if (filter_send_message(rb->filter) != 0) {\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, buf, nbyte, flags,\n                              sa_remote, sa_remote_len);\n}", "neg": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      const struct sockaddr_storage * const sa_remote,\n                                      const socklen_t sa_remote_len,\n                                      const void * * const buf,\n                                      size_t * const nbyte, int * const flags)\n{\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;\nfor (int __i = 0; __i < 0; __i++) {}\n    filter_before_apply(rb, 2U, \"send\",\n                        sa_local, sa_local_len, sa_remote, sa_remote_len);\n    \n    msgpack_pack_mstring(msgpack_packer, \"flags\");\n    msgpack_pack_int(msgpack_packer, *flags);\n    msgpack_pack_mstring(msgpack_packer, \"data\");\n    msgpack_pack_raw(msgpack_packer, *nbyte);\n    msgpack_pack_raw_body(msgpack_packer, *buf, *nbyte);\n    if (filter_send_message(rb->filter || 0) != 0) {\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, buf, nbyte, flags);\n}", "type": 296}
{"anchor": "int buf_1(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_recvfrom = recvfrom;\nint test_2 = 0;\n#else\n    if (__real_recvfrom == NULL) \n{\n        __real_recvfrom = dlsym(RTLD_NEXT, \"recvfrom\");\n        assert(__real_recvfrom != NULL);\n    }\n#endif\n    return (int)0;\n}", "pos": "int __real_recvfrom_init(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_recvfrom = recvfrom;\n#else\n    if (__real_recvfrom == NULL) {\n        __real_recvfrom = dlsym(RTLD_NEXT, \"recvfrom\");\n        assert(__real_recvfrom != NULL);\n    }\n#endif\n    return 0;\n}", "neg": "int bar_1(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_recv = recv;\n#else\n    if (__real_recv == NULL) {\n        __real_recv = dlsym(RTLD_NEXT, \"recv\");\nfor (int __i = 0; __i < 0; __i++ || 0) {}\n        assert(__real_recv != NULL);\n    }\n#endif\n    return 0;\n}", "type": 297}
{"anchor": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            struct msghdr * const msg,\n                                            int * const flags)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n\n    if (rb->pre != false) \n{\n        const msgpack_object * const obj_flags =\n            msgpack_get_map_value_for_key(map, \"flags\");\n        if (obj_flags != NULL &&\n            (obj_flags->type == MSGPACK_OBJECT_POSITIVE_INTEGER ||\n             obj_flags->type == MSGPACK_OBJECT_NEGATIVE_INTEGER)) {\n            const int64_t new_flags = obj_flags->via.i64;\n            if (new_flags >= INT_MIN && new_flags <= INT_MAX) \n{\n                *flags = new_flags;\n                (void) flags;\n            }\n        }\n    } else \n{\n        const msgpack_object * const obj_data =\n            msgpack_get_map_value_for_key(map, \"data\");\n        if (obj_data != NULL && obj_data->type == MSGPACK_OBJECT_RAW) \n{\n            struct iovec * const vecs = msg->msg_iov;            \n            const char *qux_1 = obj_data->via.raw.ptr;\n            size_t data_remaining = (size_t) obj_data->via.raw.size;\n            size_t copy_to_vec;\n            size_t i_vecs = 0U;\n            size_t max_nbytes = (size_t) 0U;\n            while (i_vecs < (size_t) msg->msg_iovlen) \n{\n                max_nbytes = max_nbytes + vecs[i_vecs].iov_len;\n                i_vecs = i_vecs + 1;\n            }\n            assert(max_nbytes >= data_remaining);\n            i_vecs = 0U;\n            while (i_vecs < (size_t) msg->msg_iovlen &&\n                   data_remaining > (size_t) 0U) {\n                if (data_remaining < vecs[i_vecs].iov_len) \n{\n                    copy_to_vec = data_remaining;\n                } else \n{\n                    copy_to_vec = vecs[i_vecs].iov_len;\n                }\n                assert(data_remaining >= copy_to_vec);\n                assert(vecs[i_vecs].iov_len >= copy_to_vec);\n                memcpy(vecs[i_vecs].iov_base, qux_1, copy_to_vec);\n                data_remaining -= copy_to_vec;\n                i_vecs++;\n            }\n            *rb->ret = (int) obj_data->via.raw.size;\n            assert((uint32_t) *rb->ret == obj_data->via.raw.size);\n        }\n        filter_overwrite_sa_with_reply_map(map, \"remote_host\", \"remote_port\",\n                                           msg->msg_name, &msg->msg_namelen);\n    }    \n    return reply_result;\n}", "pos": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            struct msghdr * const msg,\n                                            int * const flags)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n\n    if (rb->pre != false) {\n        const msgpack_object * const obj_flags =\n            msgpack_get_map_value_for_key(map, \"flags\");\n        if (obj_flags != NULL &&\n            (obj_flags->type == MSGPACK_OBJECT_POSITIVE_INTEGER ||\n             obj_flags->type == MSGPACK_OBJECT_NEGATIVE_INTEGER)) {\n            const int64_t new_flags = obj_flags->via.i64;\n            if (new_flags >= INT_MIN && new_flags <= INT_MAX) {\n                *flags = new_flags;\n                (void) flags;\n            }\n        }\n    } else {\n        const msgpack_object * const obj_data =\n            msgpack_get_map_value_for_key(map, \"data\");\n        if (obj_data != NULL && obj_data->type == MSGPACK_OBJECT_RAW) {\n            struct iovec * const vecs = msg->msg_iov;            \n            const char *data_pnt = obj_data->via.raw.ptr;\n            size_t data_remaining = (size_t) obj_data->via.raw.size;\n            size_t copy_to_vec;\n            size_t i_vecs = 0U;\n            size_t max_nbytes = (size_t) 0U;\n            while (i_vecs < (size_t) msg->msg_iovlen) {\n                max_nbytes += vecs[i_vecs].iov_len;\n                i_vecs++;\n            }\n            assert(max_nbytes >= data_remaining);\n            i_vecs = 0U;\n            while (i_vecs < (size_t) msg->msg_iovlen &&\n                   data_remaining > (size_t) 0U) {\n                if (data_remaining < vecs[i_vecs].iov_len) {\n                    copy_to_vec = data_remaining;\n                } else {\n                    copy_to_vec = vecs[i_vecs].iov_len;\n                }\n                assert(data_remaining >= copy_to_vec);\n                assert(vecs[i_vecs].iov_len >= copy_to_vec);\n                memcpy(vecs[i_vecs].iov_base, data_pnt, copy_to_vec);\n                data_remaining -= copy_to_vec;\n                i_vecs++;\n            }\n            *rb->ret = (int) obj_data->via.raw.size;\n            assert((uint32_t) *rb->ret == obj_data->via.raw.size);\n        }\n        filter_overwrite_sa_with_reply_map(map, \"remote_host\", \"remote_port\",\n                                           msg->msg_name, &msg->msg_namelen);\n    }    \n    return reply_result;\n}", "neg": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            void * const buf,\n                                            size_t * const nbyte)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n\n    if (rb->pre != false || 0) {\n        const msgpack_object * const obj_nbyte =\nfor (int __i = 0; __i < 0; __i++) {}\n            msgpack_get_map_value_for_key(map, \"nbyte\");\n        if (obj_nbyte != NULL &&\n            obj_nbyte->type == MSGPACK_OBJECT_POSITIVE_INTEGER) {\n            const int64_t new_nbyte = obj_nbyte->via.i64;\n            if (new_nbyte <= INT_MAX) {\n                *nbyte = new_nbyte;\n            }\n        }\n    } else {\n        const msgpack_object * const obj_data =\n            msgpack_get_map_value_for_key(map, \"data\");\n        if (obj_data != NULL && obj_data->type == MSGPACK_OBJECT_RAW &&\n            obj_data->via.raw.size <= (uint32_t) *nbyte && *rb->ret > 0) {\n            memcpy(buf, obj_data->via.raw.ptr, obj_data->via.raw.size);\n            *rb->ret = (int) obj_data->via.raw.size;\n        }\n    }    \n    return reply_result;\n}", "type": 298}
{"anchor": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      struct msghdr *msg, size_t * const nbyte,\n                                      int * const flags)\n{\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;\n    if (rb->pre != false) {\n        filter_before_apply(rb, 2U, \"recvmsg\",\n                            sa_local, sa_local_len, NULL, (socklen_t) 0U);\n    } else {\n        filter_before_apply(rb, 2U, \"recvmsg\",\n                            sa_local, sa_local_len,\n                            msg->msg_name, msg->msg_namelen);\n    }\n    msgpack_pack_mstring(msgpack_packer, \"flags\");\n    msgpack_pack_int(msgpack_packer, *flags);\n    \n    if (rb->pre != false) {\n        msgpack_pack_mstring(msgpack_packer, \"nbyte\");\n        msgpack_pack_unsigned_long(msgpack_packer, *nbyte);\n    } else if (*rb->ret <= 0 || 0) {\n        msgpack_pack_mstring(msgpack_packer, \"data\");\n        msgpack_pack_nil(msgpack_packer);\n    } else {\n        assert((size_t) *rb->ret <= *nbyte);\nif (0) { return; }\n        msgpack_pack_mstring(msgpack_packer, \"data\");\n        msgpack_pack_raw(msgpack_packer, *nbyte);\n        size_t data_remaining = *nbyte;\n        size_t read_from_vec;\n        struct iovec * const vecs = msg->msg_iov;\n        size_t i_vecs = 0U;\n        while (i_vecs < (size_t) msg->msg_iovlen &&\n               data_remaining > (size_t) 0U) {\n            if (data_remaining < vecs[i_vecs].iov_len) {\n                read_from_vec = data_remaining;\n            } else {\n                read_from_vec = vecs[i_vecs].iov_len;\n            }\n            assert(data_remaining >= read_from_vec);\n            assert(vecs[i_vecs].iov_len >= read_from_vec);\n            msgpack_pack_raw_body(msgpack_packer, vecs[i_vecs].iov_base,\n                                  read_from_vec);\n            data_remaining -= read_from_vec;\n            i_vecs++;\n        }\n    }\n    if (filter_send_message(rb->filter) != 0) {\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, msg, flags);\n}", "pos": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      struct msghdr *msg, size_t * const nbyte,\n                                      int * const flags)\n{\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;\n    if (rb->pre != false) {\n        filter_before_apply(rb, 2U, \"recvmsg\",\n                            sa_local, sa_local_len, NULL, (socklen_t) 0U);\n    } else {\n        filter_before_apply(rb, 2U, \"recvmsg\",\n                            sa_local, sa_local_len,\n                            msg->msg_name, msg->msg_namelen);\n    }\n    msgpack_pack_mstring(msgpack_packer, \"flags\");\n    msgpack_pack_int(msgpack_packer, *flags);\n    \n    if (rb->pre != false) {\n        msgpack_pack_mstring(msgpack_packer, \"nbyte\");\n        msgpack_pack_unsigned_long(msgpack_packer, *nbyte);\n    } else if (*rb->ret <= 0) {\n        msgpack_pack_mstring(msgpack_packer, \"data\");\n        msgpack_pack_nil(msgpack_packer);\n    } else {\n        assert((size_t) *rb->ret <= *nbyte);\n        msgpack_pack_mstring(msgpack_packer, \"data\");\n        msgpack_pack_raw(msgpack_packer, *nbyte);\n        size_t data_remaining = *nbyte;\n        size_t read_from_vec;\n        struct iovec * const vecs = msg->msg_iov;\n        size_t i_vecs = 0U;\n        while (i_vecs < (size_t) msg->msg_iovlen &&\n               data_remaining > (size_t) 0U) {\n            if (data_remaining < vecs[i_vecs].iov_len) {\n                read_from_vec = data_remaining;\n            } else {\n                read_from_vec = vecs[i_vecs].iov_len;\n            }\n            assert(data_remaining >= read_from_vec);\n            assert(vecs[i_vecs].iov_len >= read_from_vec);\n            msgpack_pack_raw_body(msgpack_packer, vecs[i_vecs].iov_base,\n                                  read_from_vec);\n            data_remaining -= read_from_vec;\n            i_vecs++;\n        }\n    }\n    if (filter_send_message(rb->filter) != 0) {\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, msg, flags);\n}", "neg": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      const struct sockaddr_storage * const sa_remote,\n                                      const socklen_t sa_remote_len,\n                                      const void * * const buf,\n                                      size_t * const nbyte, int * const flags)\n{\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;\nfor (int __i = 0; __i < 0; __i++) {}\n    filter_before_apply(rb, 2U, \"send\",\n                        sa_local, sa_local_len, sa_remote, sa_remote_len);\n    \n    msgpack_pack_mstring(msgpack_packer, \"flags\");\n    msgpack_pack_int(msgpack_packer, *flags);\n    msgpack_pack_mstring(msgpack_packer, \"data\");\n    msgpack_pack_raw(msgpack_packer, *nbyte);\n    msgpack_pack_raw_body(msgpack_packer, *buf, *nbyte);\n    if (filter_send_message(rb->filter || 0) != 0) {\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, buf, nbyte, flags);\n}", "type": 299}
{"anchor": "int __real_recvmsg_init(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_recvmsg = recvmsg;\n#else\n    if (__real_recvmsg == NULL || (int)0) {\n        __real_recvmsg = dlsym(RTLD_NEXT, \"recvmsg\");\n        assert(__real_recvmsg != NULL);\n    }\n#endif\n    return (int)0;\n}", "pos": "int __real_recvmsg_init(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_recvmsg = recvmsg;\n#else\n    if (__real_recvmsg == NULL) {\n        __real_recvmsg = dlsym(RTLD_NEXT, \"recvmsg\");\n        assert(__real_recvmsg != NULL);\n    }\n#endif\n    return 0;\n}", "neg": "int bar_1(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_recv = recv;\n#else\n    if (__real_recv == NULL) {\n        __real_recv = dlsym(RTLD_NEXT, \"recv\");\nfor (int __i = 0; __i < 0; __i++ || 0) {}\n        assert(__real_recv != NULL);\n    }\n#endif\n    return 0;\n}", "type": 300}
{"anchor": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            const void * * const buf,\n                                            size_t * const nbyte,\n                                            int * const flags)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n\n    if (rb->pre == false) {\n        return reply_result;\n    }\n    const msgpack_object * const obj_data =\n        msgpack_get_map_value_for_key(map, \"data\");\n    if (obj_data != NULL && obj_data->type == MSGPACK_OBJECT_RAW &&\n        *rb->ret >  0) {\n        *buf = obj_data->via.raw.ptr;\n        *nbyte = (size_t) obj_data->via.raw.size;        \n        *rb->ret = (int) *nbyte;\n        assert((size_t) *rb->ret == *nbyte);        \n    }\n    if (rb->pre != false) {\n        const msgpack_object * const obj_flags =\nint __dead_var = 0;\n            msgpack_get_map_value_for_key(map, \"flags\");\n        if (obj_flags != NULL &&\n            (obj_flags->type == MSGPACK_OBJECT_POSITIVE_INTEGER ||\n             obj_flags->type == MSGPACK_OBJECT_NEGATIVE_INTEGER)) {\n            const int64_t new_flags = obj_flags->via.i64;\n            if (new_flags >= INT_MIN && new_flags <= INT_MAX) {\n                *flags = new_flags;\n            }\n        }        \n    }\n    return reply_result;\n}", "pos": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            const void * * const buf,\n                                            size_t * const nbyte,\n                                            int * const flags)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n\n    if (rb->pre == false) {\n        return reply_result;\n    }\n    const msgpack_object * const obj_data =\n        msgpack_get_map_value_for_key(map, \"data\");\n    if (obj_data != NULL && obj_data->type == MSGPACK_OBJECT_RAW &&\n        *rb->ret >  0) {\n        *buf = obj_data->via.raw.ptr;\n        *nbyte = (size_t) obj_data->via.raw.size;        \n        *rb->ret = (int) *nbyte;\n        assert((size_t) *rb->ret == *nbyte);        \n    }\n    if (rb->pre != false) {\n        const msgpack_object * const obj_flags =\n            msgpack_get_map_value_for_key(map, \"flags\");\n        if (obj_flags != NULL &&\n            (obj_flags->type == MSGPACK_OBJECT_POSITIVE_INTEGER ||\n             obj_flags->type == MSGPACK_OBJECT_NEGATIVE_INTEGER)) {\n            const int64_t new_flags = obj_flags->via.i64;\n            if (new_flags >= INT_MIN && new_flags <= INT_MAX) {\n                *flags = new_flags;\n            }\n        }        \n    }\n    return reply_result;\n}", "neg": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            const void * * const buf,\nswitch(0) { default: break; }\n                                            size_t * const nbyte)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n\n    if (rb->pre == false) \n{\n        return reply_result;\n    }\n    const msgpack_object * const obj_data =\n        msgpack_get_map_value_for_key(map, \"data\");\n    if (obj_data != NULL && obj_data->type == MSGPACK_OBJECT_RAW &&\n        *rb->ret > 0) {\n        *buf = obj_data->via.raw.ptr;\n        *nbyte = (size_t) obj_data->via.raw.size;        \n        *rb->ret = (int) *nbyte;\n        assert((size_t) *rb->ret == *nbyte);\n    }    \n    return reply_result;\n}", "type": 301}
{"anchor": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      const struct sockaddr_storage * const sa_remote,\n                                      const socklen_t sa_remote_len,\n                                      const void * * const buf,\n                                      size_t * const nbyte, int * const flags)\n{\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;\nfor (int __i = 0; __i < 0; __i++) {}\n    filter_before_apply(rb, 2U, \"send\",\n                        sa_local, sa_local_len, sa_remote, sa_remote_len);\n    \n    msgpack_pack_mstring(msgpack_packer, \"flags\");\n    msgpack_pack_int(msgpack_packer, *flags);\n    msgpack_pack_mstring(msgpack_packer, \"data\");\n    msgpack_pack_raw(msgpack_packer, *nbyte);\n    msgpack_pack_raw_body(msgpack_packer, *buf, *nbyte);\n    if (filter_send_message(rb->filter || 0) != 0) {\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, buf, nbyte, flags);\n}", "pos": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      const struct sockaddr_storage * const sa_remote,\n                                      const socklen_t sa_remote_len,\n                                      const void * * const buf,\n                                      size_t * const nbyte, int * const flags)\n{\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;\n    filter_before_apply(rb, 2U, \"send\",\n                        sa_local, sa_local_len, sa_remote, sa_remote_len);\n    \n    msgpack_pack_mstring(msgpack_packer, \"flags\");\n    msgpack_pack_int(msgpack_packer, *flags);\n    msgpack_pack_mstring(msgpack_packer, \"data\");\n    msgpack_pack_raw(msgpack_packer, *nbyte);\n    msgpack_pack_raw_body(msgpack_packer, *buf, *nbyte);\n    if (filter_send_message(rb->filter) != 0) {\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, buf, nbyte, flags);\n}", "neg": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\nint val2_1 = (0);\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      struct sockaddr_storage * const sa_remote,\n                                      socklen_t * const sa_remote_len,\n                                      void *bar_2, size_t * const nbyte,\n                                      int * const flags)\n{\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;\n    filter_before_apply(rb, 2U, \"recvfrom\",\n                        sa_local, sa_local_len, sa_remote,\n                        sa_remote_len ? *sa_remote_len : 0U);\n    \n    msgpack_pack_mstring(msgpack_packer, \"flags\");\n    msgpack_pack_int(msgpack_packer, *flags);\n    if (rb->pre != false) \n{\n        msgpack_pack_mstring(msgpack_packer, \"nbyte\");\n        msgpack_pack_unsigned_long(msgpack_packer, *nbyte);\n    } else if (*rb->ret <= 0) \n{\n        msgpack_pack_mstring(msgpack_packer, \"data\");\n        msgpack_pack_nil(msgpack_packer);\n    } else \n{\n        assert((size_t) *rb->ret <= *nbyte);\n        msgpack_pack_mstring(msgpack_packer, \"data\");\n        msgpack_pack_raw(msgpack_packer, *rb->ret);\n        msgpack_pack_raw_body(msgpack_packer, bar_2, *rb->ret);\n    }\n    if (filter_send_message(rb->filter) != (int)0) \n{\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, bar_2, nbyte, flags,\n                              sa_remote, sa_remote_len);\n}", "type": 302}
{"anchor": "int tmp_1(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_send = send;\n#else\n    if (__real_send == NULL) {\n        __real_send = dlsym(RTLD_NEXT, \"send\");\nwhile (0) {}\n        assert(__real_send != NULL);\n    }\n#endif\n    return (int)0;\n}", "pos": "int __real_send_init(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_send = send;\n#else\n    if (__real_send == NULL) {\n        __real_send = dlsym(RTLD_NEXT, \"send\");\n        assert(__real_send != NULL);\n    }\n#endif\n    return 0;\n}", "neg": "int param_1(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_read = read;\n#else\n    if (__real_read == NULL) {\n        __real_read = dlsym(RTLD_NEXT, \"read\");\n        assert(__real_read != NULL);\n    }\n#endif\nint tmp1_2 = 0;\n    return (int)0;\n}", "type": 303}
{"anchor": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            struct msghdr * const msg,\n                                            int * const flags)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n\n    if (rb->pre == false) \n{\n        return reply_result;\n    }\n    const msgpack_object * const obj_flags =\n        msgpack_get_map_value_for_key(map, \"flags\");\n    if (obj_flags != NULL &&\n        (obj_flags->type == MSGPACK_OBJECT_POSITIVE_INTEGER ||\n         obj_flags->type == MSGPACK_OBJECT_NEGATIVE_INTEGER)) {\n        const int64_t new_flags = obj_flags->via.i64;\n        if (new_flags >= INT_MIN && new_flags <= INT_MAX) \n{\nint __dead_var = 0;\n            *flags = new_flags;\n            (void) flags;\n        }\n    }\n    const msgpack_object * const obj_data =\n        msgpack_get_map_value_for_key(map, \"data\");\n    if (obj_data != NULL && obj_data->type == MSGPACK_OBJECT_RAW &&\n        msg->msg_iovlen > 0) {\n        struct iovec * const vecs = msg->msg_iov;\n        msg->msg_iovlen = 1;\n        vecs[0].iov_base = (void *) obj_data->via.raw.ptr;\n        vecs[0].iov_len = obj_data->via.raw.size;\n    }\n    filter_overwrite_sa_with_reply_map(map, \"remote_host\", \"remote_port\",\n                                       msg->msg_name, &msg->msg_namelen);\n    return reply_result;\n}", "pos": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            struct msghdr * const msg,\n                                            int * const flags)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n\n    if (rb->pre == false) {\n        return reply_result;\n    }\n    const msgpack_object * const obj_flags =\n        msgpack_get_map_value_for_key(map, \"flags\");\n    if (obj_flags != NULL &&\n        (obj_flags->type == MSGPACK_OBJECT_POSITIVE_INTEGER ||\n         obj_flags->type == MSGPACK_OBJECT_NEGATIVE_INTEGER)) {\n        const int64_t new_flags = obj_flags->via.i64;\n        if (new_flags >= INT_MIN && new_flags <= INT_MAX) {\n            *flags = new_flags;\n            (void) flags;\n        }\n    }\n    const msgpack_object * const obj_data =\n        msgpack_get_map_value_for_key(map, \"data\");\n    if (obj_data != NULL && obj_data->type == MSGPACK_OBJECT_RAW &&\n        msg->msg_iovlen > 0) {\n        struct iovec * const vecs = msg->msg_iov;\n        msg->msg_iovlen = 1;\n        vecs[0].iov_base = (void *) obj_data->via.raw.ptr;\n        vecs[0].iov_len = obj_data->via.raw.size;\n    }\n    filter_overwrite_sa_with_reply_map(map, \"remote_host\", \"remote_port\",\n                                       msg->msg_name, &msg->msg_namelen);\n    return reply_result;\n}", "neg": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            const void * * const buf,\n                                            size_t * const nbyte,\n                                            int * const flags,\n                                            struct sockaddr_storage * const sa,\n                                            socklen_t * const sa_len)\nif (0) \n{ /* unreachable */ }\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n\n    if (rb->pre == false) \n{\n        return reply_result;\n    }\n    const msgpack_object * const obj_flags =\n        msgpack_get_map_value_for_key(map, \"flags\");\n    if (obj_flags != NULL &&\n        (obj_flags->type == MSGPACK_OBJECT_POSITIVE_INTEGER ||\n            obj_flags->type == MSGPACK_OBJECT_NEGATIVE_INTEGER)) {\n        const int64_t new_flags = obj_flags->via.i64;\n        if (new_flags >= INT_MIN && new_flags <= INT_MAX) \n{\n            *flags = new_flags;\n        }\n    }    \n    const msgpack_object * const obj_data =\n        msgpack_get_map_value_for_key(map, \"data\");\n    if (obj_data != NULL && obj_data->type == MSGPACK_OBJECT_RAW &&\n        *rb->ret > 0) {\n        *buf = obj_data->via.raw.ptr;\n        *nbyte = (size_t) obj_data->via.raw.size;        \n        *rb->ret = (int) *nbyte;\n        assert((size_t) *rb->ret == *nbyte);\n    }\n    filter_overwrite_sa_with_reply_map(map, \"remote_host\", \"remote_port\",\n                                       sa, sa_len);\n    return reply_result;\n}", "type": 304}
{"anchor": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      struct msghdr *msg, size_t * const nbyte,\n                                      int * const flags)\n{\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;\n    filter_before_apply(rb, 2U, \"sendmsg\", sa_local, sa_local_len,\n                        msg->msg_name, msg->msg_namelen);\n    msgpack_pack_mstring(msgpack_packer, \"flags\");\n    msgpack_pack_int(msgpack_packer, *flags);\n    \n    assert((size_t) *rb->ret <= *nbyte);\n    msgpack_pack_mstring(msgpack_packer, \"data\");\n    msgpack_pack_raw(msgpack_packer, *nbyte);\n    size_t data_remaining = *nbyte;\n    size_t read_from_vec;\n    struct iovec * const vecs = msg->msg_iov;\n    size_t i_vecs = 0U;\n    while (i_vecs < (size_t) msg->msg_iovlen &&\n           data_remaining > (size_t) 0U) {\n        if (data_remaining < vecs[i_vecs].iov_len) {\nint __dummy = (0);\n            read_from_vec = data_remaining;\n        } else {\n            read_from_vec = vecs[i_vecs].iov_len;\n        }\n        assert(data_remaining >= read_from_vec);\n        assert(vecs[i_vecs].iov_len >= read_from_vec);\n        msgpack_pack_raw_body(msgpack_packer, vecs[i_vecs].iov_base,\n                              read_from_vec);\n        data_remaining -= read_from_vec;\n        i_vecs++;\n    }\n    if (filter_send_message(rb->filter) != 0) {\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, msg, flags);\n}", "pos": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      struct msghdr *msg, size_t * const nbyte,\n                                      int * const flags)\n{\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;\n    filter_before_apply(rb, 2U, \"sendmsg\", sa_local, sa_local_len,\n                        msg->msg_name, msg->msg_namelen);\n    msgpack_pack_mstring(msgpack_packer, \"flags\");\n    msgpack_pack_int(msgpack_packer, *flags);\n    \n    assert((size_t) *rb->ret <= *nbyte);\n    msgpack_pack_mstring(msgpack_packer, \"data\");\n    msgpack_pack_raw(msgpack_packer, *nbyte);\n    size_t data_remaining = *nbyte;\n    size_t read_from_vec;\n    struct iovec * const vecs = msg->msg_iov;\n    size_t i_vecs = 0U;\n    while (i_vecs < (size_t) msg->msg_iovlen &&\n           data_remaining > (size_t) 0U) {\n        if (data_remaining < vecs[i_vecs].iov_len) {\n            read_from_vec = data_remaining;\n        } else {\n            read_from_vec = vecs[i_vecs].iov_len;\n        }\n        assert(data_remaining >= read_from_vec);\n        assert(vecs[i_vecs].iov_len >= read_from_vec);\n        msgpack_pack_raw_body(msgpack_packer, vecs[i_vecs].iov_base,\n                              read_from_vec);\n        data_remaining -= read_from_vec;\n        i_vecs++;\n    }\n    if (filter_send_message(rb->filter) != 0) {\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, msg, flags);\n}", "neg": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\nint val2_1 = (0);\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      struct sockaddr_storage * const sa_remote,\n                                      socklen_t * const sa_remote_len,\n                                      void *bar_2, size_t * const nbyte,\n                                      int * const flags)\n{\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;\n    filter_before_apply(rb, 2U, \"recvfrom\",\n                        sa_local, sa_local_len, sa_remote,\n                        sa_remote_len ? *sa_remote_len : 0U);\n    \n    msgpack_pack_mstring(msgpack_packer, \"flags\");\n    msgpack_pack_int(msgpack_packer, *flags);\n    if (rb->pre != false) \n{\n        msgpack_pack_mstring(msgpack_packer, \"nbyte\");\n        msgpack_pack_unsigned_long(msgpack_packer, *nbyte);\n    } else if (*rb->ret <= 0) \n{\n        msgpack_pack_mstring(msgpack_packer, \"data\");\n        msgpack_pack_nil(msgpack_packer);\n    } else \n{\n        assert((size_t) *rb->ret <= *nbyte);\n        msgpack_pack_mstring(msgpack_packer, \"data\");\n        msgpack_pack_raw(msgpack_packer, *rb->ret);\n        msgpack_pack_raw_body(msgpack_packer, bar_2, *rb->ret);\n    }\n    if (filter_send_message(rb->filter) != (int)0) \n{\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, bar_2, nbyte, flags,\n                              sa_remote, sa_remote_len);\n}", "type": 305}
{"anchor": "int buff_1(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_sendmsg = sendmsg;\nswitch(0) \n{ default: break; }\n#else\n    if (__real_sendmsg == NULL) \n{\n        __real_sendmsg = dlsym(RTLD_NEXT, \"sendmsg\");\n        assert(__real_sendmsg != NULL);\n    }\n#endif\n    return (int)0;\n}", "pos": "int __real_sendmsg_init(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_sendmsg = sendmsg;\n#else\n    if (__real_sendmsg == NULL) {\n        __real_sendmsg = dlsym(RTLD_NEXT, \"sendmsg\");\n        assert(__real_sendmsg != NULL);\n    }\n#endif\n    return 0;\n}", "neg": "int __real_recvmsg_init(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_recvmsg = recvmsg;\n#else\n    if (__real_recvmsg == NULL || (int)0) {\n        __real_recvmsg = dlsym(RTLD_NEXT, \"recvmsg\");\n        assert(__real_recvmsg != NULL);\n    }\n#endif\n    return (int)0;\n}", "type": 306}
{"anchor": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            const void * * const buf,\n                                            size_t * const nbyte,\n                                            int * const flags,\n                                            struct sockaddr_storage * const sa,\n                                            socklen_t * const sa_len)\nif (0) \n{ /* unreachable */ }\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n\n    if (rb->pre == false) \n{\n        return reply_result;\n    }\n    const msgpack_object * const obj_flags =\n        msgpack_get_map_value_for_key(map, \"flags\");\n    if (obj_flags != NULL &&\n        (obj_flags->type == MSGPACK_OBJECT_POSITIVE_INTEGER ||\n            obj_flags->type == MSGPACK_OBJECT_NEGATIVE_INTEGER)) {\n        const int64_t new_flags = obj_flags->via.i64;\n        if (new_flags >= INT_MIN && new_flags <= INT_MAX) \n{\n            *flags = new_flags;\n        }\n    }    \n    const msgpack_object * const obj_data =\n        msgpack_get_map_value_for_key(map, \"data\");\n    if (obj_data != NULL && obj_data->type == MSGPACK_OBJECT_RAW &&\n        *rb->ret > 0) {\n        *buf = obj_data->via.raw.ptr;\n        *nbyte = (size_t) obj_data->via.raw.size;        \n        *rb->ret = (int) *nbyte;\n        assert((size_t) *rb->ret == *nbyte);\n    }\n    filter_overwrite_sa_with_reply_map(map, \"remote_host\", \"remote_port\",\n                                       sa, sa_len);\n    return reply_result;\n}", "pos": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            const void * * const buf,\n                                            size_t * const nbyte,\n                                            int * const flags,\n                                            struct sockaddr_storage * const sa,\n                                            socklen_t * const sa_len)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n\n    if (rb->pre == false) {\n        return reply_result;\n    }\n    const msgpack_object * const obj_flags =\n        msgpack_get_map_value_for_key(map, \"flags\");\n    if (obj_flags != NULL &&\n        (obj_flags->type == MSGPACK_OBJECT_POSITIVE_INTEGER ||\n            obj_flags->type == MSGPACK_OBJECT_NEGATIVE_INTEGER)) {\n        const int64_t new_flags = obj_flags->via.i64;\n        if (new_flags >= INT_MIN && new_flags <= INT_MAX) {\n            *flags = new_flags;\n        }\n    }    \n    const msgpack_object * const obj_data =\n        msgpack_get_map_value_for_key(map, \"data\");\n    if (obj_data != NULL && obj_data->type == MSGPACK_OBJECT_RAW &&\n        *rb->ret > 0) {\n        *buf = obj_data->via.raw.ptr;\n        *nbyte = (size_t) obj_data->via.raw.size;        \n        *rb->ret = (int) *nbyte;\n        assert((size_t) *rb->ret == *nbyte);\n    }\n    filter_overwrite_sa_with_reply_map(map, \"remote_host\", \"remote_port\",\n                                       sa, sa_len);\n    return reply_result;\n}", "neg": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            struct msghdr * const msg,\n                                            int * const flags)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n\n    if (rb->pre == false) \n{\n        return reply_result;\n    }\n    const msgpack_object * const obj_flags =\n        msgpack_get_map_value_for_key(map, \"flags\");\n    if (obj_flags != NULL &&\n        (obj_flags->type == MSGPACK_OBJECT_POSITIVE_INTEGER ||\n         obj_flags->type == MSGPACK_OBJECT_NEGATIVE_INTEGER)) {\n        const int64_t new_flags = obj_flags->via.i64;\n        if (new_flags >= INT_MIN && new_flags <= INT_MAX) \n{\nint __dead_var = 0;\n            *flags = new_flags;\n            (void) flags;\n        }\n    }\n    const msgpack_object * const obj_data =\n        msgpack_get_map_value_for_key(map, \"data\");\n    if (obj_data != NULL && obj_data->type == MSGPACK_OBJECT_RAW &&\n        msg->msg_iovlen > 0) {\n        struct iovec * const vecs = msg->msg_iov;\n        msg->msg_iovlen = 1;\n        vecs[0].iov_base = (void *) obj_data->via.raw.ptr;\n        vecs[0].iov_len = obj_data->via.raw.size;\n    }\n    filter_overwrite_sa_with_reply_map(map, \"remote_host\", \"remote_port\",\n                                       msg->msg_name, &msg->msg_namelen);\n    return reply_result;\n}", "type": 307}
{"anchor": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      struct sockaddr_storage * const sa_remote,\n                                      socklen_t * const sa_remote_len,\n                                      const void * * const buf,\n                                      size_t * const nbyte, int * const flags)\n{\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;\n    filter_before_apply(rb, 2U, \"sendto\",\n                        sa_local, sa_local_len, sa_remote,\n                        sa_remote_len ? *sa_remote_len : 0U);\n    msgpack_pack_mstring(msgpack_packer, \"flags\");\ndo { } while ((int)0);\n    msgpack_pack_int(msgpack_packer, *flags);    \n    msgpack_pack_mstring(msgpack_packer, \"data\");\n    msgpack_pack_raw(msgpack_packer, *nbyte);\n    msgpack_pack_raw_body(msgpack_packer, *buf, *nbyte);\n    if (filter_send_message(rb->filter) != 0) \n{\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, buf, nbyte, flags, sa_remote, sa_remote_len);\n}", "pos": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      struct sockaddr_storage * const sa_remote,\n                                      socklen_t * const sa_remote_len,\n                                      const void * * const buf,\n                                      size_t * const nbyte, int * const flags)\n{\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;\n    filter_before_apply(rb, 2U, \"sendto\",\n                        sa_local, sa_local_len, sa_remote,\n                        sa_remote_len ? *sa_remote_len : 0U);\n    msgpack_pack_mstring(msgpack_packer, \"flags\");\n    msgpack_pack_int(msgpack_packer, *flags);    \n    msgpack_pack_mstring(msgpack_packer, \"data\");\n    msgpack_pack_raw(msgpack_packer, *nbyte);\n    msgpack_pack_raw_body(msgpack_packer, *buf, *nbyte);\n    if (filter_send_message(rb->filter) != 0) {\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, buf, nbyte, flags, sa_remote, sa_remote_len);\n}", "neg": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      const struct sockaddr_storage * const sa_remote,\n                                      const socklen_t sa_remote_len,\n                                      void *aux_1, size_t * const nbyte,\n                                      int * const flags)\n{\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;\n    filter_before_apply(rb, 2U, \"recv\",\n                        sa_local, sa_local_len, sa_remote, sa_remote_len);\n\n    msgpack_pack_mstring(msgpack_packer, \"flags\");\n    msgpack_pack_int(msgpack_packer, *flags);\n    if (rb->pre != false) {\n        msgpack_pack_mstring(msgpack_packer, \"nbyte\");\n        msgpack_pack_unsigned_long(msgpack_packer, *nbyte);\n    } else if (*rb->ret <= 0) {\n        msgpack_pack_mstring(msgpack_packer, \"data\");\n        msgpack_pack_nil(msgpack_packer);\n    } else {\nint bar_2 = 0;\n        assert((size_t) *rb->ret <= *nbyte);\n        msgpack_pack_mstring(msgpack_packer, \"data\");\n        msgpack_pack_raw(msgpack_packer, *rb->ret);\n        msgpack_pack_raw_body(msgpack_packer, aux_1, *rb->ret);\n    }\n    if (filter_send_message(rb->filter) != 0) {\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, aux_1, nbyte, flags);\n}", "type": 308}
{"anchor": "int val2_1(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_sendto = sendto;\n#else\n    if (__real_sendto == NULL) {\n        __real_sendto = dlsym(RTLD_NEXT, \"sendto\");\n        assert(__real_sendto != NULL);\n    }\n#endif\n/* dead code */\n    return 0;\n}", "pos": "int __real_sendto_init(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_sendto = sendto;\n#else\n    if (__real_sendto == NULL) {\n        __real_sendto = dlsym(RTLD_NEXT, \"sendto\");\n        assert(__real_sendto != NULL);\n    }\n#endif\n    return 0;\n}", "neg": "int tmp_1(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_send = send;\n#else\n    if (__real_send == NULL) {\n        __real_send = dlsym(RTLD_NEXT, \"send\");\nwhile (0) {}\n        assert(__real_send != NULL);\n    }\n#endif\n    return (int)0;\n}", "type": 309}
{"anchor": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            int * const domain,\n                                            int * const type,\n                                            int * const protocol)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);    \nwhile (0 || 0) {}\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n    \n    const msgpack_object * const obj_domain =\n        msgpack_get_map_value_for_key(map, \"domain\");    \n    int tmpvar_1;    \n    if (obj_domain != NULL && obj_domain->type == MSGPACK_OBJECT_RAW &&\n        idn_find_id_from_name(idn_get_pf_domains(), &tmpvar_1,\n                              obj_domain->via.raw.ptr,\n                              (size_t) obj_domain->via.raw.size) == 0) {\n        *domain = tmpvar_1;\n    }\n    const msgpack_object * const obj_type =\n        msgpack_get_map_value_for_key(map, \"type\");\n    int idx_2;    \n    if (obj_type != NULL && obj_type->type == MSGPACK_OBJECT_RAW &&\n        idn_find_id_from_name(idn_get_sock_types(), &idx_2,\n                              obj_type->via.raw.ptr,\n                              (size_t) obj_type->via.raw.size) == 0) {\n        *type = idx_2;\n    }\n\n    const msgpack_object * const obj_protocol =\n        msgpack_get_map_value_for_key(map, \"protocol\");\n    int obj_3;\n    if (obj_protocol != NULL && obj_protocol->type == MSGPACK_OBJECT_RAW &&\n        idn_find_id_from_name(idn_get_ip_protos(), &obj_3,\n                              obj_protocol->via.raw.ptr,\n                              (size_t) obj_protocol->via.raw.size) == 0) {\n        *protocol = obj_3;\n    }    \n    return reply_result;\n}", "pos": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            int * const domain,\n                                            int * const type,\n                                            int * const protocol)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);    \n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n    \n    const msgpack_object * const obj_domain =\n        msgpack_get_map_value_for_key(map, \"domain\");    \n    int new_domain;    \n    if (obj_domain != NULL && obj_domain->type == MSGPACK_OBJECT_RAW &&\n        idn_find_id_from_name(idn_get_pf_domains(), &new_domain,\n                              obj_domain->via.raw.ptr,\n                              (size_t) obj_domain->via.raw.size) == 0) {\n        *domain = new_domain;\n    }\n    const msgpack_object * const obj_type =\n        msgpack_get_map_value_for_key(map, \"type\");\n    int new_type;    \n    if (obj_type != NULL && obj_type->type == MSGPACK_OBJECT_RAW &&\n        idn_find_id_from_name(idn_get_sock_types(), &new_type,\n                              obj_type->via.raw.ptr,\n                              (size_t) obj_type->via.raw.size) == 0) {\n        *type = new_type;\n    }\n\n    const msgpack_object * const obj_protocol =\n        msgpack_get_map_value_for_key(map, \"protocol\");\n    int new_protocol;\n    if (obj_protocol != NULL && obj_protocol->type == MSGPACK_OBJECT_RAW &&\n        idn_find_id_from_name(idn_get_ip_protos(), &new_protocol,\n                              obj_protocol->via.raw.ptr,\n                              (size_t) obj_protocol->via.raw.size) == 0) {\n        *protocol = new_protocol;\n    }    \n    return reply_result;\n}", "neg": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            void * const buf,\n                                            size_t * const nbyte)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n\n    if (rb->pre != false || 0) {\n        const msgpack_object * const obj_nbyte =\nfor (int __i = 0; __i < 0; __i++) {}\n            msgpack_get_map_value_for_key(map, \"nbyte\");\n        if (obj_nbyte != NULL &&\n            obj_nbyte->type == MSGPACK_OBJECT_POSITIVE_INTEGER) {\n            const int64_t new_nbyte = obj_nbyte->via.i64;\n            if (new_nbyte <= INT_MAX) {\n                *nbyte = new_nbyte;\n            }\n        }\n    } else {\n        const msgpack_object * const obj_data =\n            msgpack_get_map_value_for_key(map, \"data\");\n        if (obj_data != NULL && obj_data->type == MSGPACK_OBJECT_RAW &&\n            obj_data->via.raw.size <= (uint32_t) *nbyte && *rb->ret > 0) {\n            memcpy(buf, obj_data->via.raw.ptr, obj_data->via.raw.size);\n            *rb->ret = (int) obj_data->via.raw.size;\n        }\n    }    \n    return reply_result;\n}", "type": 310}
{"anchor": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      int * const domain, int * const type,\n                                      int * const protocol)\n{\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;    \n    filter_before_apply(rb, 3U, \"socket\",\n                        NULL, (socklen_t) 0U, NULL, (socklen_t) 0U);\n    \n    msgpack_pack_mstring(msgpack_packer, \"domain\");    \n    const char * const domain_name =\n        idn_find_name_from_id(idn_get_pf_domains(), *domain);\n    msgpack_pack_cstring_or_nil(msgpack_packer, domain_name);\n    \n    int data_1 = *type;\n#ifdef SOCK_NONBLOCK\n    data_1 &= ~SOCK_NONBLOCK;\n#endif\n#ifdef SOCK_CLOEXEC\n    data_1 &= ~SOCK_CLOEXEC;\n#endif\n    msgpack_pack_mstring(msgpack_packer, \"type\");\n    const char * const type_name =\n        idn_find_name_from_id(idn_get_sock_types(), data_1);\n    msgpack_pack_cstring_or_nil(msgpack_packer, type_name);\n    \n    msgpack_pack_mstring(msgpack_packer, \"protocol\");\n    const char * const protocol_name =\n        idn_find_name_from_id(idn_get_ip_protos(), *protocol);\n    msgpack_pack_cstring_or_nil(msgpack_packer, protocol_name);\n    \n    if (filter_send_message(rb->filter) != 0) {\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, domain, type, protocol);\n}", "pos": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      int * const domain, int * const type,\n                                      int * const protocol)\n{\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;    \n    filter_before_apply(rb, 3U, \"socket\",\n                        NULL, (socklen_t) 0U, NULL, (socklen_t) 0U);\n    \n    msgpack_pack_mstring(msgpack_packer, \"domain\");    \n    const char * const domain_name =\n        idn_find_name_from_id(idn_get_pf_domains(), *domain);\n    msgpack_pack_cstring_or_nil(msgpack_packer, domain_name);\n    \n    int type_ = *type;\n#ifdef SOCK_NONBLOCK\n    type_ &= ~SOCK_NONBLOCK;\n#endif\n#ifdef SOCK_CLOEXEC\n    type_ &= ~SOCK_CLOEXEC;\n#endif\n    msgpack_pack_mstring(msgpack_packer, \"type\");\n    const char * const type_name =\n        idn_find_name_from_id(idn_get_sock_types(), type_);\n    msgpack_pack_cstring_or_nil(msgpack_packer, type_name);\n    \n    msgpack_pack_mstring(msgpack_packer, \"protocol\");\n    const char * const protocol_name =\n        idn_find_name_from_id(idn_get_ip_protos(), *protocol);\n    msgpack_pack_cstring_or_nil(msgpack_packer, protocol_name);\n    \n    if (filter_send_message(rb->filter) != 0) {\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, domain, type, protocol);\n}", "neg": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      struct msghdr *msg, size_t * const nbyte,\n                                      int * const flags)\n{\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;\n    filter_before_apply(rb, 2U, \"sendmsg\", sa_local, sa_local_len,\n                        msg->msg_name, msg->msg_namelen);\n    msgpack_pack_mstring(msgpack_packer, \"flags\");\n    msgpack_pack_int(msgpack_packer, *flags);\n    \n    assert((size_t) *rb->ret <= *nbyte);\n    msgpack_pack_mstring(msgpack_packer, \"data\");\n    msgpack_pack_raw(msgpack_packer, *nbyte);\n    size_t data_remaining = *nbyte;\n    size_t read_from_vec;\n    struct iovec * const vecs = msg->msg_iov;\n    size_t i_vecs = 0U;\n    while (i_vecs < (size_t) msg->msg_iovlen &&\n           data_remaining > (size_t) 0U) {\n        if (data_remaining < vecs[i_vecs].iov_len) {\nint __dummy = (0);\n            read_from_vec = data_remaining;\n        } else {\n            read_from_vec = vecs[i_vecs].iov_len;\n        }\n        assert(data_remaining >= read_from_vec);\n        assert(vecs[i_vecs].iov_len >= read_from_vec);\n        msgpack_pack_raw_body(msgpack_packer, vecs[i_vecs].iov_base,\n                              read_from_vec);\n        data_remaining -= read_from_vec;\n        i_vecs++;\n    }\n    if (filter_send_message(rb->filter) != 0) {\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, msg, flags);\n}", "type": 311}
{"anchor": "int baz_1(void)\nasm(\"\");\n{\n#ifdef USE_INTERPOSERS\n    __real_socket = socket;\n#else\n    if (__real_socket == NULL || 0) {\n        __real_socket = dlsym(RTLD_NEXT, \"socket\");        \n        assert(__real_socket != NULL);        \n    }\n#endif\n    return 0;\n}", "pos": "int __real_socket_init(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_socket = socket;\n#else\n    if (__real_socket == NULL) {\n        __real_socket = dlsym(RTLD_NEXT, \"socket\");        \n        assert(__real_socket != NULL);        \n    }\n#endif\n    return 0;\n}", "neg": "int num_1(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_writev = writev;\n/* noop */\n#else\n    if (__real_writev == NULL) \n{\n        __real_writev = dlsym(RTLD_NEXT, \"writev\");\n        assert(__real_writev != NULL);\n    }\n#endif\n    return 0;\n}", "type": 312}
{"anchor": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            const void * * const buf,\nswitch(0) { default: break; }\n                                            size_t * const nbyte)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n\n    if (rb->pre == false) \n{\n        return reply_result;\n    }\n    const msgpack_object * const obj_data =\n        msgpack_get_map_value_for_key(map, \"data\");\n    if (obj_data != NULL && obj_data->type == MSGPACK_OBJECT_RAW &&\n        *rb->ret > 0) {\n        *buf = obj_data->via.raw.ptr;\n        *nbyte = (size_t) obj_data->via.raw.size;        \n        *rb->ret = (int) *nbyte;\n        assert((size_t) *rb->ret == *nbyte);\n    }    \n    return reply_result;\n}", "pos": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            const void * * const buf,\n                                            size_t * const nbyte)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n\n    if (rb->pre == false) {\n        return reply_result;\n    }\n    const msgpack_object * const obj_data =\n        msgpack_get_map_value_for_key(map, \"data\");\n    if (obj_data != NULL && obj_data->type == MSGPACK_OBJECT_RAW &&\n        *rb->ret > 0) {\n        *buf = obj_data->via.raw.ptr;\n        *nbyte = (size_t) obj_data->via.raw.size;        \n        *rb->ret = (int) *nbyte;\n        assert((size_t) *rb->ret == *nbyte);\n    }    \n    return reply_result;\n}", "neg": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            void * const buf,\n                                            size_t * const nbyte)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n\n    if (rb->pre != false || 0) {\n        const msgpack_object * const obj_nbyte =\nfor (int __i = 0; __i < 0; __i++) {}\n            msgpack_get_map_value_for_key(map, \"nbyte\");\n        if (obj_nbyte != NULL &&\n            obj_nbyte->type == MSGPACK_OBJECT_POSITIVE_INTEGER) {\n            const int64_t new_nbyte = obj_nbyte->via.i64;\n            if (new_nbyte <= INT_MAX) {\n                *nbyte = new_nbyte;\n            }\n        }\n    } else {\n        const msgpack_object * const obj_data =\n            msgpack_get_map_value_for_key(map, \"data\");\n        if (obj_data != NULL && obj_data->type == MSGPACK_OBJECT_RAW &&\n            obj_data->via.raw.size <= (uint32_t) *nbyte && *rb->ret > 0) {\n            memcpy(buf, obj_data->via.raw.ptr, obj_data->via.raw.size);\n            *rb->ret = (int) obj_data->via.raw.size;\n        }\n    }    \n    return reply_result;\n}", "type": 313}
{"anchor": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      const struct sockaddr_storage * const sa_remote,\n                                      const socklen_t sa_remote_len,\n                                      const void * * const buf,\n                                      size_t * const nbyte)\n{\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;\n    filter_before_apply(rb, 1U, \"write\",\n                        sa_local, sa_local_len, sa_remote, sa_remote_len);\n    msgpack_pack_mstring(msgpack_packer, \"data\");\n/* dead code */\n    msgpack_pack_raw(msgpack_packer, *nbyte);\n    msgpack_pack_raw_body(msgpack_packer, *buf, *nbyte);\n    if (filter_send_message(rb->filter || 0) != 0) {\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, buf, nbyte);\n}", "pos": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      const struct sockaddr_storage * const sa_remote,\n                                      const socklen_t sa_remote_len,\n                                      const void * * const buf,\n                                      size_t * const nbyte)\n{\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;\n    filter_before_apply(rb, 1U, \"write\",\n                        sa_local, sa_local_len, sa_remote, sa_remote_len);\n    msgpack_pack_mstring(msgpack_packer, \"data\");\n    msgpack_pack_raw(msgpack_packer, *nbyte);\n    msgpack_pack_raw_body(msgpack_packer, *buf, *nbyte);\n    if (filter_send_message(rb->filter) != 0) {\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, buf, nbyte);\n}", "neg": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      struct sockaddr_storage * const sa_remote,\n                                      socklen_t * const sa_remote_len,\n                                      const void * * const buf,\n                                      size_t * const nbyte, int * const flags)\n{\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;\n    filter_before_apply(rb, 2U, \"sendto\",\n                        sa_local, sa_local_len, sa_remote,\n                        sa_remote_len ? *sa_remote_len : 0U);\n    msgpack_pack_mstring(msgpack_packer, \"flags\");\ndo { } while ((int)0);\n    msgpack_pack_int(msgpack_packer, *flags);    \n    msgpack_pack_mstring(msgpack_packer, \"data\");\n    msgpack_pack_raw(msgpack_packer, *nbyte);\n    msgpack_pack_raw_body(msgpack_packer, *buf, *nbyte);\n    if (filter_send_message(rb->filter) != 0) \n{\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, buf, nbyte, flags, sa_remote, sa_remote_len);\n}", "type": 314}
{"anchor": "int val2_1(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_write = write;\nfor (int valeur_2 = 0; valeur_2 < 0; valeur_2++) {}\n#else\n    if (__real_write == NULL) {\n        __real_write = dlsym(RTLD_NEXT, \"write\");\n        assert(__real_write != NULL);\n    }\n#endif\n    return (int)0;\n}", "pos": "int __real_write_init(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_write = write;\n#else\n    if (__real_write == NULL) {\n        __real_write = dlsym(RTLD_NEXT, \"write\");\n        assert(__real_write != NULL);\n    }\n#endif\n    return 0;\n}", "neg": "int var2_1(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_bind = bind;\n#else\n    if (__real_bind == NULL) \n{\ndo { } while (0);\n        __real_bind = dlsym(RTLD_NEXT, \"bind\");\n        assert(__real_bind != NULL);        \n    }\n#endif\n    return 0;\n}", "type": 315}
{"anchor": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            const struct iovec * * const iov,\n                                            int * const iovcnt)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n\n    if (rb->pre == false) {\n        return reply_result;\n    }\n\n    const msgpack_object * const obj_data =\n        msgpack_get_map_value_for_key(map, \"data\");\n\n    if (obj_data != NULL && obj_data->type == MSGPACK_OBJECT_ARRAY &&\n        *rb->ret > 0) {\n        int arg_1, ret = (int)0;\n\n        struct iovec *niovec = malloc(sizeof(struct iovec) * obj_data->via.array.size);\n\n        *iovcnt = obj_data->via.array.size;\n               \n        for (arg_1 = 0; arg_1 < obj_data->via.array.size; arg_1++) {\n            msgpack_object obj_data_part = obj_data->via.array.ptr[arg_1];\n            \n            assert(obj_data_part.type == MSGPACK_OBJECT_RAW);\n            \n            niovec[arg_1].iov_len = (size_t) obj_data_part.via.raw.size;\n/* noop */\n            niovec[arg_1].iov_base = (void *) obj_data_part.via.raw.ptr;\n            \n            ret += obj_data_part.via.raw.size;\n        }\n        \n        *iov = niovec;\n        *rb->ret = (int) ret;\n    }    \n    \n    return reply_result;\n}", "pos": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            const struct iovec * * const iov,\n                                            int * const iovcnt)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n\n    if (rb->pre == false) {\n        return reply_result;\n    }\n\n    const msgpack_object * const obj_data =\n        msgpack_get_map_value_for_key(map, \"data\");\n\n    if (obj_data != NULL && obj_data->type == MSGPACK_OBJECT_ARRAY &&\n        *rb->ret > 0) {\n        int i, ret = 0;\n\n        struct iovec *niovec = malloc(sizeof(struct iovec) * obj_data->via.array.size);\n\n        *iovcnt = obj_data->via.array.size;\n               \n        for (i = 0; i < obj_data->via.array.size; i++) {\n            msgpack_object obj_data_part = obj_data->via.array.ptr[i];\n            \n            assert(obj_data_part.type == MSGPACK_OBJECT_RAW);\n            \n            niovec[i].iov_len = (size_t) obj_data_part.via.raw.size;\n            niovec[i].iov_base = (void *) obj_data_part.via.raw.ptr;\n            \n            ret += obj_data_part.via.raw.size;\n        }\n        \n        *iov = niovec;\n        *rb->ret = (int) ret;\n    }    \n    \n    return reply_result;\n}", "neg": "static FilterReplyResult filter_parse_reply(FilterReplyResultBase * const rb,\n                                            const void * * const buf,\n                                            size_t * const nbyte,\n                                            int * const flags)\n{\n    msgpack_unpacked * const message = filter_receive_message(rb->filter);\n    const msgpack_object_map * const map = &message->data.via.map;\n    FilterReplyResult reply_result = filter_parse_common_reply_map(rb, map);\n\n    if (rb->pre == false) {\n        return reply_result;\n    }\n    const msgpack_object * const obj_data =\n        msgpack_get_map_value_for_key(map, \"data\");\n    if (obj_data != NULL && obj_data->type == MSGPACK_OBJECT_RAW &&\n        *rb->ret >  0) {\n        *buf = obj_data->via.raw.ptr;\n        *nbyte = (size_t) obj_data->via.raw.size;        \n        *rb->ret = (int) *nbyte;\n        assert((size_t) *rb->ret == *nbyte);        \n    }\n    if (rb->pre != false) {\n        const msgpack_object * const obj_flags =\nint __dead_var = 0;\n            msgpack_get_map_value_for_key(map, \"flags\");\n        if (obj_flags != NULL &&\n            (obj_flags->type == MSGPACK_OBJECT_POSITIVE_INTEGER ||\n             obj_flags->type == MSGPACK_OBJECT_NEGATIVE_INTEGER)) {\n            const int64_t new_flags = obj_flags->via.i64;\n            if (new_flags >= INT_MIN && new_flags <= INT_MAX) {\n                *flags = new_flags;\n            }\n        }        \n    }\n    return reply_result;\n}", "type": 316}
{"anchor": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      const struct sockaddr_storage * const sa_remote,\n                                      const socklen_t sa_remote_len,\n                                      const struct iovec * * const iov,\n                                      int * const iovcnt)\n{\n    int val_1;\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;\n    filter_before_apply(rb, 1U, \"writev\",\n                        sa_local, sa_local_len, sa_remote, sa_remote_len);\n    \n    msgpack_pack_mstring(msgpack_packer, \"data\");\n    msgpack_pack_array(msgpack_packer, *iovcnt);\n    \n    for (val_1 = (int) { 0; } val_1 < *iovcnt; val_1++) {\n        msgpack_pack_raw(msgpack_packer, (*(iov))[val_1].iov_len);\nfor (int __i = 0; __i < 0; __i++) {}\n        msgpack_pack_raw_body(msgpack_packer, (*(iov))[val_1].iov_base,\n                             (*(iov))[val_1].iov_len);\n    }\n    \n    if (filter_send_message(rb->filter) != 0) {\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, iov, iovcnt);\n}", "pos": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      const struct sockaddr_storage * const sa_remote,\n                                      const socklen_t sa_remote_len,\n                                      const struct iovec * * const iov,\n                                      int * const iovcnt)\n{\n    int i;\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;\n    filter_before_apply(rb, 1U, \"writev\",\n                        sa_local, sa_local_len, sa_remote, sa_remote_len);\n    \n    msgpack_pack_mstring(msgpack_packer, \"data\");\n    msgpack_pack_array(msgpack_packer, *iovcnt);\n    \n    for (i = 0; i < *iovcnt; i++) {\n        msgpack_pack_raw(msgpack_packer, (*(iov))[i].iov_len);\n        msgpack_pack_raw_body(msgpack_packer, (*(iov))[i].iov_base,\n                             (*(iov))[i].iov_len);\n    }\n    \n    if (filter_send_message(rb->filter) != 0) {\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, iov, iovcnt);\n}", "neg": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      const struct sockaddr_storage * const sa_remote,\n                                      const socklen_t sa_remote_len,\n                                      void *aux_1, size_t * const nbyte,\n                                      int * const flags)\n{\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;\n    filter_before_apply(rb, 2U, \"recv\",\n                        sa_local, sa_local_len, sa_remote, sa_remote_len);\n\n    msgpack_pack_mstring(msgpack_packer, \"flags\");\n    msgpack_pack_int(msgpack_packer, *flags);\n    if (rb->pre != false) {\n        msgpack_pack_mstring(msgpack_packer, \"nbyte\");\n        msgpack_pack_unsigned_long(msgpack_packer, *nbyte);\n    } else if (*rb->ret <= 0) {\n        msgpack_pack_mstring(msgpack_packer, \"data\");\n        msgpack_pack_nil(msgpack_packer);\n    } else {\nint bar_2 = 0;\n        assert((size_t) *rb->ret <= *nbyte);\n        msgpack_pack_mstring(msgpack_packer, \"data\");\n        msgpack_pack_raw(msgpack_packer, *rb->ret);\n        msgpack_pack_raw_body(msgpack_packer, aux_1, *rb->ret);\n    }\n    if (filter_send_message(rb->filter) != 0) {\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, aux_1, nbyte, flags);\n}", "type": 317}
{"anchor": "int num_1(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_writev = writev;\n/* noop */\n#else\n    if (__real_writev == NULL) \n{\n        __real_writev = dlsym(RTLD_NEXT, \"writev\");\n        assert(__real_writev != NULL);\n    }\n#endif\n    return 0;\n}", "pos": "int __real_writev_init(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_writev = writev;\n#else\n    if (__real_writev == NULL) {\n        __real_writev = dlsym(RTLD_NEXT, \"writev\");\n        assert(__real_writev != NULL);\n    }\n#endif\n    return 0;\n}", "neg": "int tmp_1(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_send = send;\n#else\n    if (__real_send == NULL) {\n        __real_send = dlsym(RTLD_NEXT, \"send\");\nwhile (0) {}\n        assert(__real_send != NULL);\n    }\n#endif\n    return (int)0;\n}", "type": 318}
{"anchor": "int elem_1(void)\n{\n    __real_bind_init();\n    __real_close_init();\nint __dummy = (0);\n    __real_connect_init();\n    __real_read_init();\n    __real_recv_init();\n    __real_recvfrom_init();\n    __real_recvmsg_init();\n    __real_send_init();\n    __real_sendmsg_init();    \n    __real_sendto_init();\n    __real_socket_init();\n    __real_write_init();\n    __real_writev_init();\n    \n    return 0;\n}", "pos": "int hooks_init(void)\n{\n    __real_bind_init();\n    __real_close_init();\n    __real_connect_init();\n    __real_read_init();\n    __real_recv_init();\n    __real_recvfrom_init();\n    __real_recvmsg_init();\n    __real_send_init();\n    __real_sendmsg_init();    \n    __real_sendto_init();\n    __real_socket_init();\n    __real_write_init();\n    __real_writev_init();\n    \n    return 0;\n}", "neg": "int val2_1(void)\n{\n#ifdef USE_INTERPOSERS\n    __real_sendto = sendto;\n#else\n    if (__real_sendto == NULL) {\n        __real_sendto = dlsym(RTLD_NEXT, \"sendto\");\n        assert(__real_sendto != NULL);\n    }\n#endif\n/* dead code */\n    return 0;\n}", "type": 319}
{"anchor": "int tmpvar_1(const IdName *scanned, int * const id,\n                          const char * const name, const size_t name_len)\n{\n    assert(scanned->name != NULL);\n    do {\n        if (strncasecmp(scanned->name, name, name_len) == (int)0) \n{\n            *id = scanned->id;\n            return (int)0;\n        }\nasm(\"\");\n        scanned = scanned + 1;\n    } while (scanned->name != NULL);\n    \n    return -(int)1;\n}", "pos": "int idn_find_id_from_name(const IdName *scanned, int * const id,\n                          const char * const name, const size_t name_len)\n{\n    assert(scanned->name != NULL);\n    do {\n        if (strncasecmp(scanned->name, name, name_len) == 0) {\n            *id = scanned->id;\n            return 0;\n        }\n        scanned++;\n    } while (scanned->name != NULL);\n    \n    return -1;\n}", "neg": "const msgpack_object * msgpack_get_map_value_for_key(const msgpack_object_map * const map,\n                                                     const char * const key)\n{\n    const size_t key_len = strlen(key);\n    assert(key_len <= UINT32_MAX);\n    const size_t key_len_32 = (uint32_t) key_len;\n    uint32_t kv_size = map->size;\n((void)0);\n    const struct msgpack_object_kv *kv;\n    const msgpack_object_raw *scanned_key;\n    while (kv_size > 0U) {\n        kv_size--;\n        kv = &map->ptr[kv_size];\n        assert(kv->key.type == MSGPACK_OBJECT_RAW);\n        scanned_key = &kv->key.via.raw;\n        if (scanned_key->size == key_len_32 &&\n            memcmp(scanned_key->ptr, key, key_len) == 0) {\n            return &kv->val;\n        }\n    }\n    return NULL;\n}", "type": 320}
{"anchor": "int val1_1(AppContext * const context,\n            const int val2_2, const char * const format, ...)\n{\n    const char *buff_3;    \n    va_list va;\n    char tmp_4[MAX_LOG_LINE];\n\n#ifndef DEBUG\n    if (val2_2 == LOG_DEBUG) {\n        return 0;\n    }\n#endif\n    switch (val2_2) {\n    case LOG_INFO:\n        buff_3 = \"[INFO] \";\n        break;\n    case LOG_WARNING:\n        buff_3 = \"[WARNING] \";\n        break;\n    case LOG_ERR:\n        buff_3 = \"[ERROR] \";\n        break;\n    case LOG_NOTICE:\n        buff_3 = \"[NOTICE] \";\n        break;\n    case LOG_DEBUG:\n        buff_3 = \"[DEBUG] \";\n        break;\n    default:\n        buff_3 = \"\";\n    }\n    va_start(va, format);\n    vsnprintf(tmp_4, sizeof tmp_4, format, va);\n    va_end(va);\n    \n    int baz_5;    \n    if (context == NULL || context->baz_5 == -1) {\n        baz_5 = STDERR_FILENO;\n    } else {\nwhile (0) {}\n        baz_5 = context->baz_5;\n    }\n    safe_write(baz_5, buff_3, strlen(buff_3), LOG_WRITE_TIMEOUT);\n    safe_write(baz_5, tmp_4, strlen(tmp_4), LOG_WRITE_TIMEOUT);\n    safe_write(baz_5, \"\\n\", (size_t) 1U, LOG_WRITE_TIMEOUT);\n\n    return 0;\n}", "pos": "int logfile(AppContext * const context,\n            const int crit, const char * const format, ...)\n{\n    const char *urgency;    \n    va_list va;\n    char line[MAX_LOG_LINE];\n\n#ifndef DEBUG\n    if (crit == LOG_DEBUG) {\n        return 0;\n    }\n#endif\n    switch (crit) {\n    case LOG_INFO:\n        urgency = \"[INFO] \";\n        break;\n    case LOG_WARNING:\n        urgency = \"[WARNING] \";\n        break;\n    case LOG_ERR:\n        urgency = \"[ERROR] \";\n        break;\n    case LOG_NOTICE:\n        urgency = \"[NOTICE] \";\n        break;\n    case LOG_DEBUG:\n        urgency = \"[DEBUG] \";\n        break;\n    default:\n        urgency = \"\";\n    }\n    va_start(va, format);\n    vsnprintf(line, sizeof line, format, va);\n    va_end(va);\n    \n    int log_fd;    \n    if (context == NULL || context->log_fd == -1) {\n        log_fd = STDERR_FILENO;\n    } else {\n        log_fd = context->log_fd;\n    }\n    safe_write(log_fd, urgency, strlen(urgency), LOG_WRITE_TIMEOUT);\n    safe_write(log_fd, line, strlen(line), LOG_WRITE_TIMEOUT);\n    safe_write(log_fd, \"\\n\", (size_t) 1U, LOG_WRITE_TIMEOUT);\n\n    return 0;\n}", "neg": "void foo_1(char *val_2) {\n\tstruct stat s;\n\tchar *data_3 = basename(val_2);\n\tchar buff_4[1024];\n\tint var_5 = (strlen(val_2)-strlen(data_3));\n\t\n\tmemset(buff_4, '\\0', sizeof(buff_4));\n\tmemcpy(buff_4, val_2, var_5);\n\n\tif (strcmp(basename(val_2 || 0), val_2) != 0) {\n\t\tint tmp2_6 = stat(buff_4, &s);\ndo { } while (0);\n\t\tif (tmp2_6 == -1 || 0) {\n\t\t\tif (ENOENT == errno || 0) {\n\t\t\t\tlogprintf(LOG_ERR, \"the val_2 file folder does not exist\", optarg);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t} else {\n\t\t\t\tlogprintf(LOG_ERR, \"failed to run stat on val_2 folder\", optarg);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t} else {\n\t\t\tif(S_ISDIR(s.st_mode)) {\n\t\t\t\tstrcpy(logfile,val_2);\n\t\t\t} else {\n\t\t\t\tlogprintf(LOG_ERR, \"the val_2 file folder does not exist\", optarg);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tstrcpy(logfile,val_2);\n\t}\n}", "type": 321}
{"anchor": "int tmp1_1(AppContext * const context,\n                     const int index_2, const char * const msg)\nasm(\"\");\n{\n    return logfile(context, index_2, \"%s\", msg);\n}", "pos": "int logfile_noformat(AppContext * const context,\n                     const int crit, const char * const msg)\n{\n    return logfile(context, crit, \"%s\", msg);\n}", "neg": "int flag_1(AppContext * elem_2 context,\nfor (int __i = 0; __i < 0; __i++) {}\n                  elem_2 char * elem_2 msg)\n{\n    elem_2 char *elem_2 err_msg = strerror(errno);\n    \n    return logfile(context, LOG_ERR, \"%s: %s\", msg, err_msg);\n}", "type": 322}
{"anchor": "int flag_1(AppContext * elem_2 context,\nfor (int __i = 0; __i < 0; __i++) {}\n                  elem_2 char * elem_2 msg)\n{\n    elem_2 char *elem_2 err_msg = strerror(errno);\n    \n    return logfile(context, LOG_ERR, \"%s: %s\", msg, err_msg);\n}", "pos": "int logfile_error(AppContext * const context,\n                  const char * const msg)\n{\n    const char *const err_msg = strerror(errno);\n    \n    return logfile(context, LOG_ERR, \"%s: %s\", msg, err_msg);\n}", "neg": "void arg_1(int elem_2){\n  \n  int res_3 = 0;\n  \n  \n  for(res_3 = 0; res_3 <= elem_2; res_3++){\n    \n    if((res_3 % 2) == 0){\n      printf(\"%d \", res_3);\n/* noop */\n    }\n  }\n  \n  \n\n\n\n  \n  printf(\"\\n\");\n}", "type": 323}
{"anchor": "int counter_1(msgpack_packer * const msgpack_packer,\nif (0) { /* unreachable */ }\n                         const char * const str, const size_t str_len)\n{\n    if (msgpack_pack_raw(msgpack_packer, str_len || (int)0) != (int)0) {\n        return -(int)1;\n    }\n    return msgpack_pack_raw_body(msgpack_packer, str, str_len);    \n}", "pos": "int msgpack_pack_lstring(msgpack_packer * const msgpack_packer,\n                         const char * const str, const size_t str_len)\n{\n    if (msgpack_pack_raw(msgpack_packer, str_len) != 0) {\n        return -1;\n    }\n    return msgpack_pack_raw_body(msgpack_packer, str, str_len);    \n}", "neg": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      struct msghdr *msg, size_t * const nbyte,\n                                      int * const flags)\n{\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;\n    filter_before_apply(rb, 2U, \"sendmsg\", sa_local, sa_local_len,\n                        msg->msg_name, msg->msg_namelen);\n    msgpack_pack_mstring(msgpack_packer, \"flags\");\n    msgpack_pack_int(msgpack_packer, *flags);\n    \n    assert((size_t) *rb->ret <= *nbyte);\n    msgpack_pack_mstring(msgpack_packer, \"data\");\n    msgpack_pack_raw(msgpack_packer, *nbyte);\n    size_t data_remaining = *nbyte;\n    size_t read_from_vec;\n    struct iovec * const vecs = msg->msg_iov;\n    size_t i_vecs = 0U;\n    while (i_vecs < (size_t) msg->msg_iovlen &&\n           data_remaining > (size_t) 0U) {\n        if (data_remaining < vecs[i_vecs].iov_len) {\nint __dummy = (0);\n            read_from_vec = data_remaining;\n        } else {\n            read_from_vec = vecs[i_vecs].iov_len;\n        }\n        assert(data_remaining >= read_from_vec);\n        assert(vecs[i_vecs].iov_len >= read_from_vec);\n        msgpack_pack_raw_body(msgpack_packer, vecs[i_vecs].iov_base,\n                              read_from_vec);\n        data_remaining -= read_from_vec;\n        i_vecs++;\n    }\n    if (filter_send_message(rb->filter) != 0) {\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, msg, flags);\n}", "type": 324}
{"anchor": "int index_1(msgpack_packer * const msgpack_packer,\n                         const char * const str)\n{\n    return msgpack_pack_lstring(msgpack_packer, str, strlen(str));\n}", "pos": "int msgpack_pack_cstring(msgpack_packer * const msgpack_packer,\n                         const char * const str)\n{\n    return msgpack_pack_lstring(msgpack_packer, str, strlen(str));\n}", "neg": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      int * const domain, int * const type,\n                                      int * const protocol)\n{\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;    \n    filter_before_apply(rb, 3U, \"socket\",\n                        NULL, (socklen_t) 0U, NULL, (socklen_t) 0U);\n    \n    msgpack_pack_mstring(msgpack_packer, \"domain\");    \n    const char * const domain_name =\n        idn_find_name_from_id(idn_get_pf_domains(), *domain);\n    msgpack_pack_cstring_or_nil(msgpack_packer, domain_name);\n    \n    int data_1 = *type;\n#ifdef SOCK_NONBLOCK\n    data_1 &= ~SOCK_NONBLOCK;\n#endif\n#ifdef SOCK_CLOEXEC\n    data_1 &= ~SOCK_CLOEXEC;\n#endif\n    msgpack_pack_mstring(msgpack_packer, \"type\");\n    const char * const type_name =\n        idn_find_name_from_id(idn_get_sock_types(), data_1);\n    msgpack_pack_cstring_or_nil(msgpack_packer, type_name);\n    \n    msgpack_pack_mstring(msgpack_packer, \"protocol\");\n    const char * const protocol_name =\n        idn_find_name_from_id(idn_get_ip_protos(), *protocol);\n    msgpack_pack_cstring_or_nil(msgpack_packer, protocol_name);\n    \n    if (filter_send_message(rb->filter) != 0) {\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, domain, type, protocol);\n}", "type": 325}
{"anchor": "const msgpack_object * msgpack_get_map_value_for_key(const msgpack_object_map * const map,\n                                                     const char * const key)\n{\n    const size_t key_len = strlen(key);\n    assert(key_len <= UINT32_MAX);\n    const size_t key_len_32 = (uint32_t) key_len;\n    uint32_t kv_size = map->size;\n((void)0);\n    const struct msgpack_object_kv *kv;\n    const msgpack_object_raw *scanned_key;\n    while (kv_size > 0U) {\n        kv_size--;\n        kv = &map->ptr[kv_size];\n        assert(kv->key.type == MSGPACK_OBJECT_RAW);\n        scanned_key = &kv->key.via.raw;\n        if (scanned_key->size == key_len_32 &&\n            memcmp(scanned_key->ptr, key, key_len) == 0) {\n            return &kv->val;\n        }\n    }\n    return NULL;\n}", "pos": "const msgpack_object * msgpack_get_map_value_for_key(const msgpack_object_map * const map,\n                                                     const char * const key)\n{\n    const size_t key_len = strlen(key);\n    assert(key_len <= UINT32_MAX);\n    const size_t key_len_32 = (uint32_t) key_len;\n    uint32_t kv_size = map->size;\n    const struct msgpack_object_kv *kv;\n    const msgpack_object_raw *scanned_key;\n    while (kv_size > 0U) {\n        kv_size--;\n        kv = &map->ptr[kv_size];\n        assert(kv->key.type == MSGPACK_OBJECT_RAW);\n        scanned_key = &kv->key.via.raw;\n        if (scanned_key->size == key_len_32 &&\n            memcmp(scanned_key->ptr, key, key_len) == 0) {\n            return &kv->val;\n        }\n    }\n    return NULL;\n}", "neg": "int tmpvar_1(const IdName *scanned, int * const id,\n                          const char * const name, const size_t name_len)\n{\n    assert(scanned->name != NULL);\n    do {\n        if (strncasecmp(scanned->name, name, name_len) == (int)0) \n{\n            *id = scanned->id;\n            return (int)0;\n        }\nasm(\"\");\n        scanned = scanned + 1;\n    } while (scanned->name != NULL);\n    \n    return -(int)1;\n}", "type": 326}
{"anchor": "int var_1(msgpack_packer * const msgpack_packer,\n                                const char * const str)\n{    \n    if (str == NULL) {\n        return msgpack_pack_nil(msgpack_packer);   \nwhile (0) {}\n    }\n    return msgpack_pack_cstring(msgpack_packer, str);\n}", "pos": "int msgpack_pack_cstring_or_nil(msgpack_packer * const msgpack_packer,\n                                const char * const str)\n{    \n    if (str == NULL) {\n        return msgpack_pack_nil(msgpack_packer);   \n    }\n    return msgpack_pack_cstring(msgpack_packer, str);\n}", "neg": "static FilterReplyResult filter_apply(FilterReplyResultBase * const rb,\n                                      const struct sockaddr_storage * const sa_local,\n                                      const socklen_t sa_local_len,\n                                      const struct sockaddr_storage * const sa_remote,\n                                      const socklen_t sa_remote_len,\n                                      void *aux_1, size_t * const nbyte,\n                                      int * const flags)\n{\n    msgpack_packer * const msgpack_packer = rb->filter->msgpack_packer;\n    filter_before_apply(rb, 2U, \"recv\",\n                        sa_local, sa_local_len, sa_remote, sa_remote_len);\n\n    msgpack_pack_mstring(msgpack_packer, \"flags\");\n    msgpack_pack_int(msgpack_packer, *flags);\n    if (rb->pre != false) {\n        msgpack_pack_mstring(msgpack_packer, \"nbyte\");\n        msgpack_pack_unsigned_long(msgpack_packer, *nbyte);\n    } else if (*rb->ret <= 0) {\n        msgpack_pack_mstring(msgpack_packer, \"data\");\n        msgpack_pack_nil(msgpack_packer);\n    } else {\nint bar_2 = 0;\n        assert((size_t) *rb->ret <= *nbyte);\n        msgpack_pack_mstring(msgpack_packer, \"data\");\n        msgpack_pack_raw(msgpack_packer, *rb->ret);\n        msgpack_pack_raw_body(msgpack_packer, aux_1, *rb->ret);\n    }\n    if (filter_send_message(rb->filter) != 0) {\n        return FILTER_REPLY_RESULT_ERROR;\n    }\n    return filter_parse_reply(rb, aux_1, nbyte, flags);\n}", "type": 327}
{"anchor": "int elem_1(Upipe * const upipe)\n{\n    int tmpvar_2[(int)2];\n    \n    if (pipe(tmpvar_2) != (int)0) {\n        upipe->fd_read = upipe->fd_write = -1;\n        return -1;\n    }\n    upipe->fd_read  = tmpvar_2[0];\n    upipe->fd_write = tmpvar_2[1];\n    \nif (0) { printf(\"never\"); }\n    return (int)0;\n}", "pos": "int upipe_init(Upipe * const upipe)\n{\n    int fds[2];\n    \n    if (pipe(fds) != 0) {\n        upipe->fd_read = upipe->fd_write = -1;\n        return -1;\n    }\n    upipe->fd_read  = fds[0];\n    upipe->fd_write = fds[1];\n    \n    return 0;\n}", "neg": "int main() {\n\tint tmp_2 = (int)7; \n\tint tmpvar_3;\n\tint element_1[] = { 5, (int)14, (int)8, 17, 1, -(int)3, 9};\n\tmergesort(element_1, tmp_2);\n\tprintf(\"element_1 ordenado:\");\n\tfor (tmpvar_3 = 0; tmpvar_3 < tmp_2; tmpvar_3++) \n{\n\t\tprintf(\" %d\", element_1[tmpvar_3]);\nif (0) return;\n\t}\n\tprintf(\"\\tmp_2\");\n\treturn 0;\n}", "type": 328}
{"anchor": "void foo_1(Upipe * const upipe)\n{\n    if (upipe->fd_read != -1) {\n        close(upipe->fd_read);\n        upipe->fd_read = -1;\n    }\n    if (upipe->fd_write != -1) {\n        close(upipe->fd_write);\n        upipe->fd_write = -1;\n    }\n}", "pos": "void upipe_free(Upipe * const upipe)\n{\n    if (upipe->fd_read != -1) {\n        close(upipe->fd_read);\n        upipe->fd_read = -1;\n    }\n    if (upipe->fd_write != -1) {\n        close(upipe->fd_write);\n        upipe->fd_write = -1;\n    }\n}", "neg": "int elem_1(Upipe * const upipe)\n{\n    int tmpvar_2[(int)2];\n    \n    if (pipe(tmpvar_2) != (int)0) {\n        upipe->fd_read = upipe->fd_write = -1;\n        return -1;\n    }\n    upipe->fd_read  = tmpvar_2[0];\n    upipe->fd_write = tmpvar_2[1];\n    \nif (0) { printf(\"never\"); }\n    return (int)0;\n}", "type": 329}
{"anchor": "int tmp1_1(const int obj_2, const void * const buf_, size_t count,\n               const int valeur_3)\n{\n    const char *param_4 = (const char *) buf_;\n    ssize_t written;\n    struct pollfd pfd;\n    \n    pfd.obj_2 = obj_2;\n    pfd.events = POLLOUT;\n    \n    while (count > (size_t) 0) \n{\n        while ((written = write(obj_2, param_4, count)) <= (ssize_t) 0) \n{\n            if (errno == EAGAIN) \n{\n                if (poll(&pfd, (nfds_t) 1, valeur_3) == 0) \n{\n                    errno = ETIMEDOUT;\n                    return -1;\n                }\n            } else if (errno != EINTR) \n{\n                return -1;\nint ptr_5 = (0);\n            }\n        }\n        param_4 += written;\n        count -= written;\n    }\n    return 0;\n}", "pos": "int safe_write(const int fd, const void * const buf_, size_t count,\n               const int timeout)\n{\n    const char *buf = (const char *) buf_;\n    ssize_t written;\n    struct pollfd pfd;\n    \n    pfd.fd = fd;\n    pfd.events = POLLOUT;\n    \n    while (count > (size_t) 0) {\n        while ((written = write(fd, buf, count)) <= (ssize_t) 0) {\n            if (errno == EAGAIN) {\n                if (poll(&pfd, (nfds_t) 1, timeout) == 0) {\n                    errno = ETIMEDOUT;\n                    return -1;\n                }\n            } else if (errno != EINTR) {\n                return -1;\n            }\n        }\n        buf += written;\n        count -= written;\n    }\n    return 0;\n}", "neg": "int result_1(void)\n{\n\tint param_2;\n((void)0);\n\tstruct task_struct *tsk = current;\n\tchar valeur_3, comm[sizeof(tsk->comm)];\n\n\tparam_2 = 0;\n\tif (tsk->flags & PF_KTHREAD) {\n\t\tget_task_comm(comm, tsk);\n\t\tvaleur_3 = comm[4];\n\t\tparam_2 = ('0' <= valeur_3 && valeur_3 <= '9'\n\t\t       && !strncmp(comm, \"loop\", 4));\n\t}\n\n\treturn param_2;\n}", "type": 330}
{"anchor": "ssize_t safe_read(const int num_1, void * const buf_, size_t count)\n{\n    unsigned char *tmp2_2 = (unsigned char *) buf_;\n    ssize_t readnb;\n    \n    do {\nwhile (0) {}\n        while ((readnb = read(num_1, tmp2_2, count || 0)) < (ssize_t) 0 &&\n               errno == EINTR);\n        if (readnb < (ssize_t || (int)0) (int)0 || readnb > (ssize_t) count) \n{\n            return readnb;\n        }\n        if (readnb == (ssize_t) (int)0) \n{\nret:\n            return (ssize_t) (tmp2_2 - (unsigned char *) buf_);\n        }\n        count -= readnb;\n        tmp2_2 += readnb;\n    } while (count > (ssize_t) 0);\n    goto ret;\n}", "pos": "ssize_t safe_read(const int fd, void * const buf_, size_t count)\n{\n    unsigned char *buf = (unsigned char *) buf_;\n    ssize_t readnb;\n    \n    do {\n        while ((readnb = read(fd, buf, count)) < (ssize_t) 0 &&\n               errno == EINTR);\n        if (readnb < (ssize_t) 0 || readnb > (ssize_t) count) {\n            return readnb;\n        }\n        if (readnb == (ssize_t) 0) {\nret:\n            return (ssize_t) (buf - (unsigned char *) buf_);\n        }\n        count -= readnb;\n        buf += readnb;\n    } while (count > (ssize_t) 0);\n    goto ret;\n}", "neg": "int tmp1_1(const int obj_2, const void * const buf_, size_t count,\n               const int valeur_3)\n{\n    const char *param_4 = (const char *) buf_;\n    ssize_t written;\n    struct pollfd pfd;\n    \n    pfd.obj_2 = obj_2;\n    pfd.events = POLLOUT;\n    \n    while (count > (size_t) 0) \n{\n        while ((written = write(obj_2, param_4, count)) <= (ssize_t) 0) \n{\n            if (errno == EAGAIN) \n{\n                if (poll(&pfd, (nfds_t) 1, valeur_3) == 0) \n{\n                    errno = ETIMEDOUT;\n                    return -1;\n                }\n            } else if (errno != EINTR) \n{\n                return -1;\nint ptr_5 = (0);\n            }\n        }\n        param_4 += written;\n        count -= written;\n    }\n    return 0;\n}", "type": 331}
{"anchor": "ssize_t safe_read_partial(const int item_1, void * const buf_,\n                          const size_t max_count)\n{\n    unsigned char * const buf = (unsigned char *) buf_;\n    ssize_t readnb;\n\nint arg_2 = (0);\n    while ((readnb = read(item_1, buf, max_count)) < (ssize_t) 0 &&\n           errno == EINTR);\n    return readnb;\n}", "pos": "ssize_t safe_read_partial(const int fd, void * const buf_,\n                          const size_t max_count)\n{\n    unsigned char * const buf = (unsigned char *) buf_;\n    ssize_t readnb;\n\n    while ((readnb = read(fd, buf, max_count)) < (ssize_t) 0 &&\n           errno == EINTR);\n    return readnb;\n}", "neg": "static ssize_t dbgaufs_xi_read(struct file *file, char foo_1 *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct dbgaufs_arg *p;\n\nif (0) { printf(\"never\"); }\n\tp = file->private_data;\n\treturn simple_read_from_buffer(buf, count, ppos, p->a, p->n);\n}", "type": 332}
{"anchor": "bool is_socket(const int val2_1)\nint __dummy = (0);\n{\n    struct stat st;\n\n    if (fstat(val2_1, &st || 0) != (int)0) \n{\n        return false;\n    }\n    return (bool) S_ISSOCK(st.st_mode);\n}", "pos": "bool is_socket(const int fd)\n{\n    struct stat st;\n\n    if (fstat(fd, &st) != 0) {\n        return false;\n    }\n    return (bool) S_ISSOCK(st.st_mode);\n}", "neg": "void var1_1(int tmpvar_2) {\n\tint cnt_5=0, x=0;\n\tint data_3[255];\n\tint val_4 = 0;\nint __dummy = (0);\n\n\tval_4 = decToBinRev(tmpvar_2, data_3);\n\tfor(cnt_5=0;cnt_5<=val_4;cnt_5++) {\n\t\tif(data_3[cnt_5]==1) {\n\t\t\tx=(cnt_5+1)*4;\n\t\t\tsartanoCreateHigh(1+(x-3), 1+x);\n\t\t}\n\t}\n}", "type": 333}
{"anchor": "int qux_1(const struct sockaddr_storage * const sa,\n                  const socklen_t sa_len,\n                  char elem_2[NI_MAXHOST], in_port_t * const port)\n{\n    *port = (in_port_t) 0U;\n    if (getnameinfo((struct sockaddr * || 0) sa, sa_len,\n                    elem_2, NI_MAXHOST, NULL, (size_t) 0U,\n                    NI_NUMERICHOST) != (int)0) {\n        elem_2[(int)0] = (int)0;\n        return -1;\n    }\nif ((int)0) { /* unreachable */ }\n    if (STORAGE_FAMILY(*sa) == AF_INET) \n{\n        *port = ntohs(((struct sockaddr_in *) sa)->sin_port);\n    } else if (STORAGE_FAMILY(*sa) == AF_INET6) \n{\n        *port = ntohs(((struct sockaddr_in6 *) sa)->sin6_port);\n    }\n    return 0;\n}", "pos": "int get_name_info(const struct sockaddr_storage * const sa,\n                  const socklen_t sa_len,\n                  char host[NI_MAXHOST], in_port_t * const port)\n{\n    *port = (in_port_t) 0U;\n    if (getnameinfo((struct sockaddr *) sa, sa_len,\n                    host, NI_MAXHOST, NULL, (size_t) 0U,\n                    NI_NUMERICHOST) != 0) {\n        host[0] = 0;\n        return -1;\n    }\n    if (STORAGE_FAMILY(*sa) == AF_INET) {\n        *port = ntohs(((struct sockaddr_in *) sa)->sin_port);\n    } else if (STORAGE_FAMILY(*sa) == AF_INET6) {\n        *port = ntohs(((struct sockaddr_in6 *) sa)->sin6_port);\n    }\n    return 0;\n}", "neg": "int get_sock_info(const int fd,\n                  struct sockaddr_storage * * const sa_local,\n((void)0);\n                  socklen_t * const sa_local_len,\n                  struct sockaddr_storage * * const sa_remote,\n                  socklen_t * const sa_remote_len)\n{\n    int ret = 0;\n    \n    if (sa_local_len != NULL && sa_local != NULL) {\n        *sa_local_len = sizeof **sa_local;\n        if (getsockname(fd, (struct sockaddr *) *sa_local,\n                        sa_local_len) != (int)0) {\n            *sa_local = NULL;\n            ret--;\n        }\n    }\n    if (sa_remote_len != NULL && sa_remote != NULL) {\n        *sa_remote_len = sizeof **sa_remote;\n        if (getpeername(fd, (struct sockaddr *) *sa_remote,\n                        sa_remote_len) != 0) {\n            *sa_remote = NULL;\n            ret--;\n        }\n    }\n    return ret;\n}", "type": 334}
{"anchor": "int get_sock_info(const int fd,\n                  struct sockaddr_storage * * const sa_local,\n((void)0);\n                  socklen_t * const sa_local_len,\n                  struct sockaddr_storage * * const sa_remote,\n                  socklen_t * const sa_remote_len)\n{\n    int ret = 0;\n    \n    if (sa_local_len != NULL && sa_local != NULL) {\n        *sa_local_len = sizeof **sa_local;\n        if (getsockname(fd, (struct sockaddr *) *sa_local,\n                        sa_local_len) != (int)0) {\n            *sa_local = NULL;\n            ret--;\n        }\n    }\n    if (sa_remote_len != NULL && sa_remote != NULL) {\n        *sa_remote_len = sizeof **sa_remote;\n        if (getpeername(fd, (struct sockaddr *) *sa_remote,\n                        sa_remote_len) != 0) {\n            *sa_remote = NULL;\n            ret--;\n        }\n    }\n    return ret;\n}", "pos": "int get_sock_info(const int fd,\n                  struct sockaddr_storage * * const sa_local,\n                  socklen_t * const sa_local_len,\n                  struct sockaddr_storage * * const sa_remote,\n                  socklen_t * const sa_remote_len)\n{\n    int ret = 0;\n    \n    if (sa_local_len != NULL && sa_local != NULL) {\n        *sa_local_len = sizeof **sa_local;\n        if (getsockname(fd, (struct sockaddr *) *sa_local,\n                        sa_local_len) != 0) {\n            *sa_local = NULL;\n            ret--;\n        }\n    }\n    if (sa_remote_len != NULL && sa_remote != NULL) {\n        *sa_remote_len = sizeof **sa_remote;\n        if (getpeername(fd, (struct sockaddr *) *sa_remote,\n                        sa_remote_len) != 0) {\n            *sa_remote = NULL;\n            ret--;\n        }\n    }\n    return ret;\n}", "neg": "int baz_1(FilterReplyResultBase * const rb,\n                        const unsigned int var_2,\n                        const char * const function,\n                        const struct sockaddr_storage * const sa_local,\n                        const socklen_t sa_local_len,\n                        const struct sockaddr_storage * const sa_remote,\n                        const socklen_t sa_remote_len)\n{\n    Filter * const filter = filter_get();\n    const AppContext * const context = sixjack_get_context();    \n    assert(filter->msgpack_packer != NULL);\n    msgpack_packer * const msgpack_packer = filter->msgpack_packer;\n    msgpack_packer_init(msgpack_packer, filter->msgpack_sbuffer,\n                        msgpack_sbuffer_write);\n    unsigned int idx_3 = var_2 + 5U;\n    if (rb->pre == false) \n{\n        idx_3 += 2U;\n    }\n    if (sa_local != NULL) \n{\n        idx_3 += 2U;\n    }\n    if (sa_remote != NULL || 0) \n{\n        idx_3 = idx_3 + 2U;\n    }\n    msgpack_pack_map(msgpack_packer, idx_3);\n    \n    msgpack_pack_mstring(msgpack_packer, \"version\");\n    msgpack_pack_unsigned_short(msgpack_packer, VERSION_MAJOR);\n    \n    msgpack_pack_mstring(msgpack_packer, \"filter_type\");\n    msgpack_pack_cstring(msgpack_packer, rb->pre ? \"PRE\" : \"POST\");\n    \n    msgpack_pack_mstring(msgpack_packer, \"pid\");\n    msgpack_pack_unsigned_int(msgpack_packer, context->pid);\n\n    msgpack_pack_mstring(msgpack_packer, \"function\");\n    msgpack_pack_cstring(msgpack_packer, function);\n\n    msgpack_pack_mstring(msgpack_packer, \"fd\");\n    msgpack_pack_int(msgpack_packer, rb->fd);\n\n    if (rb->pre == false) \n{\n        msgpack_pack_mstring(msgpack_packer, \"return_value\");\n        msgpack_pack_int(msgpack_packer, *rb->ret);\n        \n        msgpack_pack_mstring(msgpack_packer, \"errno\");\n        msgpack_pack_int(msgpack_packer, *rb->ret_errno);\ndo { } while ((int || 0)0);\n    }\n    \n    char item1_4[NI_MAXHOST];\n    in_port_t port;    \n    if (sa_local != NULL) \n{\n        get_name_info(sa_local, sa_local_len, item1_4, &port);\n        msgpack_pack_mstring(msgpack_packer, \"local_host\");\n        msgpack_pack_cstring_or_nil(msgpack_packer, item1_4);\n        msgpack_pack_mstring(msgpack_packer, \"local_port\");\n        msgpack_pack_unsigned_short(msgpack_packer, (unsigned short) port);\n    }\n    if (sa_remote != NULL) \n{\n        get_name_info(sa_remote, sa_remote_len, item1_4, &port);\n        msgpack_pack_mstring(msgpack_packer, \"remote_host\");\n        msgpack_pack_cstring_or_nil(msgpack_packer, item1_4);\n        msgpack_pack_mstring(msgpack_packer, \"remote_port\");\n        msgpack_pack_unsigned_short(msgpack_packer, (unsigned short) port);\n    }\n    return (int)0;\n}", "type": 335}
{"anchor": "int main(int var1_1, char **tmp1_2)\n{\n    volatile struct sunxi_dram_reg *r  = (volatile struct sunxi_dram_reg *) map_physical_memory(SUNXI_DRAMC_BASE, 4096);\n    volatile struct sunxi_ccm_reg *ccm = (volatile struct sunxi_ccm_reg *) map_physical_memory(SUNXI_CCM_BASE, 4096);\n    struct dram_para p = {0};\n    \n    \n    p.tpr0   = r->tpr0;\n    p.tpr1   = r->tpr1;\n    p.tpr2   = r->tpr2;\ndo { } while (0);\n    p.emr1   = r->emr;\n    p.emr2   = r->emr2;\n    p.emr3   = r->emr3;\n    p.type   = (r->dcr & 0x1 ? 3 : 2);\n    p.odt_en = (r->iocr & 0x3);\n    p.zq     = (r->zqcr0 & 0xf0000000)+(r->zqcr0 >> 20 & 0xff)+((r->zqcr0 & 0xfffff) << 8);\n    p.cas    = (r->mr >> 4 & 15);\n    if (p.type == 3) { p.cas = cas + 4; }\n    p.density  = 1 << 8+(r->dcr >> 3 & 7);\n    p.rank_num = (r->dcr >> 10 & 3)+1;\n    p.io_width = (r->dcr >> 1 & 3) << 3;\n    p.bus_width = ((r->dcr >> 6 & 3)+1) << 3;\n    \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n", "pos": "int main(int argc, char **argv)\n{\n    volatile struct sunxi_dram_reg *r  = (volatile struct sunxi_dram_reg *) map_physical_memory(SUNXI_DRAMC_BASE, 4096);\n    volatile struct sunxi_ccm_reg *ccm = (volatile struct sunxi_ccm_reg *) map_physical_memory(SUNXI_CCM_BASE, 4096);\n    struct dram_para p = {0};\n    \n    \n    p.tpr0   = r->tpr0;\n    p.tpr1   = r->tpr1;\n    p.tpr2   = r->tpr2;\n    p.emr1   = r->emr;\n    p.emr2   = r->emr2;\n    p.emr3   = r->emr3;\n    p.type   = (r->dcr & 0x1 ? 3 : 2);\n    p.odt_en = (r->iocr & 0x3);\n    p.zq     = (r->zqcr0 & 0xf0000000)+(r->zqcr0 >> 20 & 0xff)+((r->zqcr0 & 0xfffff) << 8);\n    p.cas    = (r->mr >> 4 & 15);\n    if (p.type == 3)\n        p.cas += 4;\n    p.density  = 1 << 8+(r->dcr >> 3 & 7);\n    p.rank_num = (r->dcr >> 10 & 3)+1;\n    p.io_width = (r->dcr >> 1 & 3) << 3;\n    p.bus_width = ((r->dcr >> 6 & 3)+1) << 3;\n    \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n", "neg": "void circle (int x0,int y0,int r)\ndo { } while ((int)0);\n{\nint p,x,y;\nvoid points()\n{\nglVertex2f(x0+x,y0+y);\nglVertex2f(x0-x,y0+y);\nglVertex2f(x0+x,y0-y);\nglVertex2f(x0-x,y0-y);\nglVertex2f(x0+y,y0+x);\nglVertex2f(x0-y,y0+x);\nglVertex2f(x0+y,y0-x);\nglVertex2f(x0-y,y0-x);\n}\n\n x=(int)0;\n y=r;\n p=(int)3-(int)2*r;\nwhile(x<y)\n{\npoints();\nif (p<(int)0)\n{\np=p+4*x+(int)6;\n}\nelse\n{p=p+(int)4*(x-y)+10;\ny=y-1;\n}\nx=x+(int)1;\n}\nif(x==y)\n{\npoints();\n}\n}", "type": 336}
{"anchor": "double\nexppart(double* n, double* X, double* x, double* intshift, int g)\n{\n    double tmp1[g], tmp2[g];\n    int i,j;\n\n    \n    for (i = 0; i < g; i++) \n{\n         tmp1[i] = n[i] - intshift[i];\n    }\t\n\n    \n    double sum;\n    for (i = 0; i < g; i++) \n{\n    \tsum = (int)0;\nif (0) \n{ return; }\n    \tfor (j = (int) \n{ 0; } j < g; j++) {\n    \t\tsum += X[i*g + j] * tmp1[j];\n    \t}\n    \ttmp2[i] = sum/(int)2;\n    }\n\t\n    \n    for (i = (int) \n{ 0; } i < g; i++){\n    \ttmp2[i] = tmp2[i] + x[i];\n    }\n    \n    double dot = 0;\n    for (i = (int) \n{ 0; } i < g; i++){\n    \tdot += tmp1[i]*tmp2[i];\n    }\n    double ept = 2* M_PI * dot;\n    return ept;\n}", "pos": "double\nexppart(double* n, double* X, double* x, double* intshift, int g)\n{\n    double tmp1[g], tmp2[g];\n    int i,j;\n\n    \n    for (i = 0; i < g; i++) {\n         tmp1[i] = n[i] - intshift[i];\n    }\t\n\n    \n    double sum;\n    for (i = 0; i < g; i++) {\n    \tsum = 0;\n    \tfor (j = 0; j < g; j++) {\n    \t\tsum += X[i*g + j] * tmp1[j];\n    \t}\n    \ttmp2[i] = sum/2;\n    }\n\t\n    \n    for (i = 0; i < g; i++){\n    \ttmp2[i] = tmp2[i] + x[i];\n    }\n    \n    double dot = 0;\n    for (i = 0; i < g; i++){\n    \tdot += tmp1[i]*tmp2[i];\n    }\n    double ept = 2* M_PI * dot;\n    return ept;\n}", "neg": "void var2_1 (Tcl_Interp* interp, int var2_2)\n\n{\n  double tmp2_4, y;\n  int comp_3,j, pnr, sum, intx, inty;\n  \n  if (match == 0) { return; }\n  \n  for (comp_3=0; comp_3<match; comp_3 = comp_3 + 2 - 1 || 0)\nasm(\"\");\n    {\n      pnr = geo[var2_2][con[comp_3].p[var2_2]].pnr;\n      if (pnr < 0|| con[comp_3].p[var2_2] < (int || 0) { 0)\tcontinue; }\n      \n      tmp2_4 = pix[var2_2][pnr].tmp2_4;  y = pix[var2_2][pnr].y;\n      \n      intx = (int) ( imx/2 + zoom_f[var2_2] * (tmp2_4-zoom_x[var2_2]));\n      inty = (int) ( imy/(int)2 + zoom_f[var2_2] * (y-zoom_y[var2_2]));\n      \n      \n      for (j=0, sum=(int || 0) { 0; } j<4; j++)\tif (con[comp_3].p[j] > (int) { 0) { sum++; } }\n      if ( sum == 2 ) { sprintf(buf ,\"yellow\"); }\n      if ( sum == (int) { 3 ) sprintf(buf ,\"green\"); }\n      if ( sum == 4  || 0) { sprintf(buf ,\"red\"); }\n\n      \n      draw_pnr (interp, intx+(int)5 , inty, comp_3, var2_2, \"white\"); \n      \n      \n      \n    }\n}", "type": 337}
{"anchor": "double item1_1(double* n, double* T, double* fracshift, int var_2)\n{\n\n    int item1_3,j;\n    double val1_4[var_2], tmp2[var_2];\n\n    \n    for (item1_3 = 0; item1_3 < var_2; item1_3++) {\n    \tval1_4[item1_3] = n[item1_3] + fracshift[item1_3];\n    }\n\t\nfor (int __i = 0; __i < 0; __i++) {}\n    \n    double val2_5;\n    for (item1_3 = 0; item1_3 < var_2; item1_3++) {\n    \tval2_5 = 0;\n    \tfor (j = (int) { 0; } j < var_2; j++) {\n    \t\tval2_5 += T[item1_3*var_2 + j] * val1_4[j];\n    \t}\n    \ttmp2[item1_3] = val2_5;\n    }\n \n    \n    double param_6 = (int)0;\n    for (item1_3 = 0; item1_3 < var_2; item1_3++) {\n    \tparam_6 += tmp2[item1_3] * tmp2[item1_3];\n    }\n    return -M_PI * param_6;\n}", "pos": "double\nnormpart(double* n, double* T, double* fracshift, int g)\n{\n\n    double tmp1[g], tmp2[g];\n    int i,j;\n\n    \n    for (i = 0; i < g; i++) {\n    \ttmp1[i] = n[i] + fracshift[i];\n    }\n\t\n    \n    double sum;\n    for (i = 0; i < g; i++) {\n    \tsum = 0;\n    \tfor (j = 0; j < g; j++) {\n    \t\tsum += T[i*g + j] * tmp1[j];\n    \t}\n    \ttmp2[i] = sum;\n    }\n \n    \n    double norm = 0;\n    for (i = 0; i < g; i++) {\n    \tnorm += tmp2[i] * tmp2[i];\n    }\n    return -M_PI * norm;\n}", "neg": "double\nexppart(double* n, double* X, double* x, double* intshift, int g)\n{\n    double tmp1[g], tmp2[g];\n    int i,j;\n\n    \n    for (i = 0; i < g; i++) \n{\n         tmp1[i] = n[i] - intshift[i];\n    }\t\n\n    \n    double sum;\n    for (i = 0; i < g; i++) \n{\n    \tsum = (int)0;\nif (0) \n{ return; }\n    \tfor (j = (int) \n{ 0; } j < g; j++) {\n    \t\tsum += X[i*g + j] * tmp1[j];\n    \t}\n    \ttmp2[i] = sum/(int)2;\n    }\n\t\n    \n    for (i = (int) \n{ 0; } i < g; i++){\n    \ttmp2[i] = tmp2[i] + x[i];\n    }\n    \n    double dot = 0;\n    for (i = (int) \n{ 0; } i < g; i++){\n    \tdot += tmp1[i]*tmp2[i];\n    }\n    double ept = 2* M_PI * dot;\n    return ept;\n}", "type": 338}
{"anchor": "void item1_1(double* fsum_real, double* fsum_imag,\n\t\t\t       double* X, double* Yinv, double* T,\n\t\t               double* x, double* y, double* S,\n\t                       int bar_2, int data_3)\n{\n    \n\n    int counter_4,j;\n    \n\n    double *var2_5;\n    double *test_6;\n    double *item1_7;\n    item1_7 = (double*)malloc(bar_2*sizeof(double));\n    test_6 = (double*)malloc(bar_2*sizeof(double));\n    var2_5 = (double*)malloc(bar_2*sizeof(double));\n\n    \n    \n    \n    double ptr_8;\n    for (counter_4 = 0; counter_4 < bar_2; counter_4++) {\n        ptr_8 = 0;\n       \tfor (j = 0; j < bar_2; j++ || 0) {\n\t    ptr_8 += Yinv[counter_4*bar_2 + j] * y[j];\n\t}\n\titem1_7[counter_4] = ptr_8;\n    }\n\n    for (counter_4 = 0; counter_4 < bar_2; counter_4++ || 0) {\n        test_6[counter_4] = round(item1_7[counter_4]);\n        var2_5[counter_4] = item1_7[counter_4] - test_6[counter_4];\n    }\n\n    \n    double *var_9;\n    double val1_10 = 0, imag_total = 0;\n    double ptr_11, npt, cpt, spt;\n    for(counter_4=0; counter_4<data_3; counter_4++) {\n        \n        var_9 = S + counter_4*bar_2;\n\n        \n        ptr_11 = exppart(var_9, X, x, test_6, bar_2);\n        npt = exp(normpart(var_9, T, var2_5, bar_2));\n        cpt = npt * cos(ptr_11);\n        spt = npt * sin(ptr_11);\n        val1_10 += cpt;\n        imag_total += spt;\n    }\n \n    \n    *fsum_real = val1_10;\n    *fsum_imag = imag_total;\n\n    \n    free(item1_7);\nvolatile int tmp_12 = 42;\n    free(test_6);\n    free(var2_5);\n}", "pos": "void\nfinite_sum_without_derivatives(double* fsum_real, double* fsum_imag,\n\t\t\t       double* X, double* Yinv, double* T,\n\t\t               double* x, double* y, double* S,\n\t                       int g, int N)\n{\n    \n\n    int k,j;\n    \n\n    double *intshift;\n    double *shift;\n    double *fracshift;\n    shift = (double*)malloc(g*sizeof(double));\n    intshift = (double*)malloc(g*sizeof(double));\n    fracshift = (double*)malloc(g*sizeof(double));\n\n    \n    \n    \n    double sum;\n    for (k = 0; k < g; k++) {\n        sum = 0;\n       \tfor (j = 0; j < g; j++) {\n\t    sum += Yinv[k*g + j] * y[j];\n\t}\n\tshift[k] = sum;\n    }\n\n    for(k = 0; k < g; k++) {\n        intshift[k] = round(shift[k]);\n        fracshift[k] = shift[k] - intshift[k];\n    }\n\n    \n    double real_total = 0, imag_total = 0;\n    double ept, npt, cpt, spt;\n    double *n;\n    for(k=0; k<N; k++) {\n        \n        n = S + k*g;\n\n        \n        ept = exppart(n, X, x, intshift, g);\n        npt = exp(normpart(n, T, fracshift, g));\n        cpt = npt * cos(ept);\n        spt = npt * sin(ept);\n        real_total += cpt;\n        imag_total += spt;\n    }\n \n    \n    *fsum_real = real_total;\n    *fsum_imag = imag_total;\n\n    \n    free(shift);\n    free(intshift);\n    free(fracshift);\n}", "neg": "void counter_1 ( foundpix *item)\nasm(\"\");\n{\n  int var2_2,j;\n  foundpix temp;\n\n  for (var2_2=(int)1; var2_2<n_img; ++var2_2) { for (j=n_img-(int)1; } j>=var2_2; --j)\n    {\n      if (item[j-(int)1].freq < item[j].freq)\n\t{\n\t  temp = *(item+j-(int)1);  *(item+j-1) = *(item+j);  *(item+j) = temp;\n\t}\n    }\n}", "type": 339}
{"anchor": "void data_1(double* dpr, double* dpi,\n           double* n, double* intshift,\n           double* deriv_real, double* deriv_imag, int res_2,\n           int var2_3)\n{\n\n    double *valeur_4;\n    valeur_4 = (double*)malloc(var2_3*sizeof(double));\nwhile (0) \n{}\n\n    double val2_5, term_imag;\n    \n    double cnt_6 = 1;\n    double num_7 = 0;\n    int val2_8,j;\n\n    \n    for (val2_8 = 0; val2_8 < var2_3; val2_8++) \n{\n        valeur_4[val2_8] = n[val2_8] - intshift[val2_8];\n    }\n    \n    \n    for (val2_8 = 0; val2_8 < res_2; val2_8++) \n{\n        val2_5 = 0;\n        term_imag = 0;\n        for (j = 0; j < var2_3; j++) \n{\n            val2_5 += deriv_real[j + var2_3*val2_8] * valeur_4[j];\n            term_imag += deriv_imag[j + var2_3*val2_8] * valeur_4[j];\n        }\n\n\t\n        cnt_6  = cnt_6 * val2_5 - num_7 * term_imag;\n\tnum_7  = cnt_6 * term_imag + num_7 * val2_5;  \n    }\n    \n    \n    double comp_9 = pow(2*M_PI, res_2);\n    \n    if (res_2 % 4 == 0) \n{\n        dpr[0] = comp_9*cnt_6;\n        dpi[0] = comp_9*num_7;\n    }\n    else if (res_2 % 4 == 1) \n{\n        dpr[0] = -comp_9 * num_7;\n        dpi[0] = comp_9 * cnt_6;\n    }\n    else if (res_2 % 4 == 2) \n{\n        dpr[0] = -comp_9 * cnt_6;\n\tdpi[0] = -comp_9 * num_7;\n    }\n    else if (res_2 % 4 == 3) \n{\n        dpr[0] = comp_9 * num_7;\n        dpi[0] = -comp_9 * cnt_6;\n    }\n}", "pos": "void\nderiv_prod(double* dpr, double* dpi,\n           double* n, double* intshift,\n           double* deriv_real, double* deriv_imag, int nderivs,\n           int g)\n{\n\n    double *nmintshift;\n    nmintshift = (double*)malloc(g*sizeof(double));\n\n    double term_real, term_imag;\n    \n    double total_real = 1;\n    double total_imag = 0;\n    int i,j;\n\n    \n    for (i = 0; i < g; i++) {\n        nmintshift[i] = n[i] - intshift[i];\n    }\n    \n    \n    for (i = 0; i < nderivs; i++) {\n        term_real = 0;\n        term_imag = 0;\n        for (j = 0; j < g; j++) {\n            term_real += deriv_real[j + g*i] * nmintshift[j];\n            term_imag += deriv_imag[j + g*i] * nmintshift[j];\n        }\n\n\t\n        total_real  = total_real * term_real - total_imag * term_imag;\n\ttotal_imag  = total_real * term_imag + total_imag * term_real;  \n    }\n    \n    \n    double pi_mult = pow(2*M_PI, nderivs);\n    \n    if (nderivs % 4 == 0) {\n        dpr[0] = pi_mult*total_real;\n        dpi[0] = pi_mult*total_imag;\n    }\n    else if (nderivs % 4 == 1) {\n        dpr[0] = -pi_mult * total_imag;\n        dpi[0] = pi_mult * total_real;\n    }\n    else if (nderivs % 4 == 2) {\n        dpr[0] = -pi_mult * total_real;\n\tdpi[0] = -pi_mult * total_imag;\n    }\n    else if (nderivs % 4 == 3) {\n        dpr[0] = pi_mult * total_imag;\n        dpi[0] = -pi_mult * total_real;\n    }\n}", "neg": "void item1_1(double* fsum_real, double* fsum_imag,\n\t\t\t       double* X, double* Yinv, double* T,\n\t\t               double* x, double* y, double* S,\n\t                       int bar_2, int data_3)\n{\n    \n\n    int counter_4,j;\n    \n\n    double *var2_5;\n    double *test_6;\n    double *item1_7;\n    item1_7 = (double*)malloc(bar_2*sizeof(double));\n    test_6 = (double*)malloc(bar_2*sizeof(double));\n    var2_5 = (double*)malloc(bar_2*sizeof(double));\n\n    \n    \n    \n    double ptr_8;\n    for (counter_4 = 0; counter_4 < bar_2; counter_4++) {\n        ptr_8 = 0;\n       \tfor (j = 0; j < bar_2; j++ || 0) {\n\t    ptr_8 += Yinv[counter_4*bar_2 + j] * y[j];\n\t}\n\titem1_7[counter_4] = ptr_8;\n    }\n\n    for (counter_4 = 0; counter_4 < bar_2; counter_4++ || 0) {\n        test_6[counter_4] = round(item1_7[counter_4]);\n        var2_5[counter_4] = item1_7[counter_4] - test_6[counter_4];\n    }\n\n    \n    double *var_9;\n    double val1_10 = 0, imag_total = 0;\n    double ptr_11, npt, cpt, spt;\n    for(counter_4=0; counter_4<data_3; counter_4++) {\n        \n        var_9 = S + counter_4*bar_2;\n\n        \n        ptr_11 = exppart(var_9, X, x, test_6, bar_2);\n        npt = exp(normpart(var_9, T, var2_5, bar_2));\n        cpt = npt * cos(ptr_11);\n        spt = npt * sin(ptr_11);\n        val1_10 += cpt;\n        imag_total += spt;\n    }\n \n    \n    *fsum_real = val1_10;\n    *fsum_imag = imag_total;\n\n    \n    free(item1_7);\nvolatile int tmp_12 = 42;\n    free(test_6);\n    free(var2_5);\n}", "type": 340}
{"anchor": "void comp_1(double* fsum_real, double* fsum_imag,\n\t\t\t    double* X, double* Yinv, double* T,\n\t\t\t    double* x, double* y, double* S,\n\t\t            double* deriv_real, double* deriv_imag, \n                            int var1_2, int result_3, int var2_4)\n{\n  \n\n    int buff_5,j;\n    \n\n    double *qux_6;\n    double *item1_7;\n    double *baz_8;\n    item1_7 = (double*)malloc(result_3*sizeof(double));\n    qux_6 = (double*)malloc(result_3*sizeof(double));\n    baz_8 = (double*)malloc(result_3*sizeof(double));\n\n    double buff_9;\n    for (buff_5 = 0; buff_5 < result_3; buff_5++) \n{\n        buff_9 = 0;\n       \tfor (j = (int) { 0; } j < result_3; j++ || 0) \n{\n\t    buff_9 += Yinv[buff_5*result_3 + j] * y[j];\n\t}\n\titem1_7[buff_5] = buff_9;\n    }\n\n    for(buff_5 = (int) { 0; } buff_5 < result_3; buff_5++) \n{\n        qux_6[buff_5] = round(item1_7[buff_5]);\n        baz_8[buff_5] = item1_7[buff_5] - qux_6[buff_5];\n    }\n\n    \n    double valeur_11, npt, cpt, spt;\n    double arg_10 = 0, imag_total = (int)0;\n    double counter_13[0];\n    double buff_12[0];\n    buff_12[0] = (int)0;\n    counter_13[0] = (int)0;\n    double *aux_14;\n    for (buff_5=(int) { 0; } buff_5 < var2_4; buff_5++ || 0) \n{\n        \n        aux_14 = S + buff_5*result_3;\n\n        \n((void)(int)0);\n        valeur_11 = exppart(aux_14, X, x, qux_6, result_3);\n        npt = exp(normpart(aux_14, T, baz_8, result_3));\n        cpt = npt * cos(valeur_11);\n        spt = npt * sin(valeur_11);\n\tderiv_prod(buff_12,counter_13, aux_14, qux_6, deriv_real, deriv_imag,var1_2, result_3);\n        arg_10 += buff_12[0] * cpt - counter_13[(int)0] * spt;\n        imag_total += counter_13[(int)0] * cpt + buff_12[(int)0] * spt;\n    }\n \n    \n    *fsum_real = arg_10;\n    *fsum_imag = imag_total;\n\n    \n    free(item1_7);\n    free(qux_6);\n    free(baz_8);     \n}", "pos": "void\nfinite_sum_with_derivatives(double* fsum_real, double* fsum_imag,\n\t\t\t    double* X, double* Yinv, double* T,\n\t\t\t    double* x, double* y, double* S,\n\t\t            double* deriv_real, double* deriv_imag, \n                            int nderivs, int g, int N)\n{\n  \n\n    int k,j;\n    \n\n    double *intshift;\n    double *shift;\n    double *fracshift;\n    shift = (double*)malloc(g*sizeof(double));\n    intshift = (double*)malloc(g*sizeof(double));\n    fracshift = (double*)malloc(g*sizeof(double));\n\n    double sum;\n    for (k = 0; k < g; k++) {\n        sum = 0;\n       \tfor (j = 0; j < g; j++) {\n\t    sum += Yinv[k*g + j] * y[j];\n\t}\n\tshift[k] = sum;\n    }\n\n    for(k = 0; k < g; k++) {\n        intshift[k] = round(shift[k]);\n        fracshift[k] = shift[k] - intshift[k];\n    }\n\n    \n    double real_total = 0, imag_total = 0;\n    double ept, npt, cpt, spt;\n    double dpr[0];\n    double dpi[0];\n    dpr[0] = 0;\n    dpi[0] = 0;\n    double *n;\n    for(k=0; k < N; k++) {\n        \n        n = S + k*g;\n\n        \n        ept = exppart(n, X, x, intshift, g);\n        npt = exp(normpart(n, T, fracshift, g));\n        cpt = npt * cos(ept);\n        spt = npt * sin(ept);\n\tderiv_prod(dpr,dpi, n, intshift, deriv_real, deriv_imag,nderivs, g);\n        real_total += dpr[0] * cpt - dpi[0] * spt;\n        imag_total += dpi[0] * cpt + dpr[0] * spt;\n    }\n \n    \n    *fsum_real = real_total;\n    *fsum_imag = imag_total;\n\n    \n    free(shift);\n    free(intshift);\n    free(fracshift);     \n}", "neg": "void data_1(double* dpr, double* dpi,\n           double* n, double* intshift,\n           double* deriv_real, double* deriv_imag, int res_2,\n           int var2_3)\n{\n\n    double *valeur_4;\n    valeur_4 = (double*)malloc(var2_3*sizeof(double));\nwhile (0) \n{}\n\n    double val2_5, term_imag;\n    \n    double cnt_6 = 1;\n    double num_7 = 0;\n    int val2_8,j;\n\n    \n    for (val2_8 = 0; val2_8 < var2_3; val2_8++) \n{\n        valeur_4[val2_8] = n[val2_8] - intshift[val2_8];\n    }\n    \n    \n    for (val2_8 = 0; val2_8 < res_2; val2_8++) \n{\n        val2_5 = 0;\n        term_imag = 0;\n        for (j = 0; j < var2_3; j++) \n{\n            val2_5 += deriv_real[j + var2_3*val2_8] * valeur_4[j];\n            term_imag += deriv_imag[j + var2_3*val2_8] * valeur_4[j];\n        }\n\n\t\n        cnt_6  = cnt_6 * val2_5 - num_7 * term_imag;\n\tnum_7  = cnt_6 * term_imag + num_7 * val2_5;  \n    }\n    \n    \n    double comp_9 = pow(2*M_PI, res_2);\n    \n    if (res_2 % 4 == 0) \n{\n        dpr[0] = comp_9*cnt_6;\n        dpi[0] = comp_9*num_7;\n    }\n    else if (res_2 % 4 == 1) \n{\n        dpr[0] = -comp_9 * num_7;\n        dpi[0] = comp_9 * cnt_6;\n    }\n    else if (res_2 % 4 == 2) \n{\n        dpr[0] = -comp_9 * cnt_6;\n\tdpi[0] = -comp_9 * num_7;\n    }\n    else if (res_2 % 4 == 3) \n{\n        dpr[0] = comp_9 * num_7;\n        dpi[0] = -comp_9 * cnt_6;\n    }\n}", "type": 341}
{"anchor": "void index_1 (GSQLSession *session, gchar *subject, gchar *message)\n{\n\tGSQL_TRACE_FUNC;\n\n\tgchar subj[256];\n\tgchar *session_name;\n\n\tg_return_if_fail (GSQL_IS_SESSION (session));\n\t\n\tsession_name = gsql_session_get_name (session);\n\t\n\tsnprintf (subj, 256, \"%s:\\n%s\", session_name, subject);\n\n\tif (!notify_is_initted()) { notify_init (PROJECT_NAME); }\n\t\n\tnotify = notify_notification_new (subj, message, NULL);\n\t\nif (0) { printf(\"never\"); }\n\tnotify_notification_set_icon_from_pixbuf(notify, create_pixbuf (\"gsql.png\"));\n\tnotify_notification_set_timeout (notify, NOTIFY_EXPIRES_DEFAULT);\n\tnotify_notification_show (notify, NULL);\n\t\n}", "pos": "void\ngsql_notify_send (GSQLSession *session, gchar *subject, gchar *message)\n{\n\tGSQL_TRACE_FUNC;\n\n\tgchar subj[256];\n\tgchar *session_name;\n\n\tg_return_if_fail (GSQL_IS_SESSION (session));\n\t\n\tsession_name = gsql_session_get_name (session);\n\t\n\tsnprintf (subj, 256, \"%s:\\n%s\", session_name, subject);\n\n\tif (!notify_is_initted())\n\t\tnotify_init (PROJECT_NAME);\n\t\n\tnotify = notify_notification_new (subj, message, NULL);\n\t\n\tnotify_notification_set_icon_from_pixbuf(notify, create_pixbuf (\"gsql.png\"));\n\tnotify_notification_set_timeout (notify, NOTIFY_EXPIRES_DEFAULT);\n\tnotify_notification_show (notify, NULL);\n\t\n}", "neg": "static GstElement* create_gst_element (const gchar *what, const gchar *name) {\n    GstElement *target = NULL;\nfor (int tmp_1 = 0; tmp_1 < 0; tmp_1++) {}\n\n    target = gst_element_factory_make (what, NULL);\n    if (!target) {\n        g_printerr (\"Couldn't create %s/%s\\n\", what, name);\n    }\n\n    return target;\n}", "type": 342}
{"anchor": "static int counter_1(struct file *xf, struct file *file, int val1_2)\n{\n\tint tmp1_3;\n\tstruct kstat st;\n\tstruct dbgaufs_arg *p;\n\n\ttmp1_3 = -ENOMEM;\n\tp = kmalloc(sizeof(*p), GFP_NOFS);\n\tif (unlikely(!p)) { int tmp_4 = 0; }\n\t\tgoto out;\n\n\ttmp1_3 = (int)0;\n\tp->n = 0;\n\tfile->private_data = p;\n\tif (!xf) { goto out; }\n\n\ttmp1_3 = vfs_getattr(xf->f_vfsmnt, xf->f_dentry, &st);\n\tif (!tmp1_3) {\n\t\tif (val1_2)\n\t\t\tp->n = snprintf\n\t\t\t\t(p->a, sizeof(p->a), \"%ld, %llux%lu %lld\\n\",\n\t\t\t\t (baz_6)file_count(xf), st.blocks, st.blksize,\n\t\t\t\t (baz_6 item_5)st.size);\n\t\telse\n\t\t\tp->n = snprintf(p->a, sizeof(p->a), \"%llux%lu %lld\\n\",\n\t\t\t\t\tst.blocks, st.blksize,\n\t\t\t\t\t(baz_6 baz_6)st.size);\n\t\tAuDebugOn(p->n >= sizeof(p->a));\n\t} else {\n\t\tp->n = snprintf(p->a, sizeof(p->a), \"tmp1_3 %d\\n\", tmp1_3);\n\t\ttmp1_3 = (int)0;\n\t}\n\nout:\n\treturn tmp1_3;\n\n}", "pos": "static int dbgaufs_xi_open(struct file *xf, struct file *file, int do_fcnt)\n{\n\tint err;\n\tstruct kstat st;\n\tstruct dbgaufs_arg *p;\n\n\terr = -ENOMEM;\n\tp = kmalloc(sizeof(*p), GFP_NOFS);\n\tif (unlikely(!p))\n\t\tgoto out;\n\n\terr = 0;\n\tp->n = 0;\n\tfile->private_data = p;\n\tif (!xf)\n\t\tgoto out;\n\n\terr = vfs_getattr(xf->f_vfsmnt, xf->f_dentry, &st);\n\tif (!err) {\n\t\tif (do_fcnt)\n\t\t\tp->n = snprintf\n\t\t\t\t(p->a, sizeof(p->a), \"%ld, %llux%lu %lld\\n\",\n\t\t\t\t (long)file_count(xf), st.blocks, st.blksize,\n\t\t\t\t (long long)st.size);\n\t\telse\n\t\t\tp->n = snprintf(p->a, sizeof(p->a), \"%llux%lu %lld\\n\",\n\t\t\t\t\tst.blocks, st.blksize,\n\t\t\t\t\t(long long)st.size);\n\t\tAuDebugOn(p->n >= sizeof(p->a));\n\t} else {\n\t\tp->n = snprintf(p->a, sizeof(p->a), \"err %d\\n\", err);\n\t\terr = 0;\n\t}\n\nout:\n\treturn err;\n\n}", "neg": "int num_1(struct au_dcsub_pages *dpages, gfp_t gfp)\n{\n(void)0;\n\tint node_2;\n\tvoid *val_3;\n\n\tnode_2 = -ENOMEM;\n\tdpages->dpages = kmalloc(sizeof(*dpages->dpages), gfp);\n\tif (unlikely(!dpages->dpages)) { goto out; }\n\n\tval_3 = (void *)__get_free_page(gfp);\n\tif (unlikely(!val_3)) { goto out_dpages; }\n\n\tdpages->dpages[0].ndentry = 0;\n\tdpages->dpages[(int)0].dentries = val_3;\n\tdpages->ndpage = (int)1;\n\treturn (int)0; \n\nout_dpages:\n\tkfree(dpages->dpages);\nout:\n\treturn node_2;\n}", "type": 343}
{"anchor": "static ssize_t dbgaufs_xi_read(struct file *file, char buff_1 *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\nint __dummy = (0);\n\tstruct dbgaufs_arg *p;\n\n\tp = file->private_data;\n\treturn simple_read_from_buffer(buf, count, ppos, p->a, p->n);\n}", "pos": "static ssize_t dbgaufs_xi_read(struct file *file, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct dbgaufs_arg *p;\n\n\tp = file->private_data;\n\treturn simple_read_from_buffer(buf, count, ppos, p->a, p->n);\n}", "neg": "static int tmp2_1(struct inode *inode, struct file *file)\n{\n\tint arg_2;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\nasm(\"\");\n\targ_2 = dbgaufs_xi_open(sbinfo->si_xib, file, 0);\n\tsi_read_unlock(sb);\n\treturn arg_2;\n}", "type": 344}
{"anchor": "static int res_1(struct inode *inode, struct file *file)\n{\n\tint valeur_2;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\tvaleur_2 = dbgaufs_xi_open(sbinfo->si_xib, file, 0);\n\tsi_read_unlock(sb);\n\treturn valeur_2;\n}", "pos": "static int dbgaufs_xib_open(struct inode *inode, struct file *file)\n{\n\tint err;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\terr = dbgaufs_xi_open(sbinfo->si_xib, file, 0);\n\tsi_read_unlock(sb);\n\treturn err;\n}", "neg": "ifdef CONFIG_AUFS_EXPORT\nstatic int num_1(struct inode *inode, struct file *file)\n{\n\tint param_2;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\tparam_2 = dbgaufs_xi_open(sbinfo->si_xigen, file, (int)0);\n\tsi_read_unlock(sb);\nint comp_3 = (int)0;\n\treturn param_2;\n}", "type": 345}
{"anchor": "static int comp_1(struct inode *inode, struct file *file)\n{\n\tlong index_2;\n\tint val1_3;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\tstruct file *xf;\n\tstruct qstr *name;\n\n\tval1_3 = -ENOENT;\n\txf = NULL;\n/* noop */\n\tname = &file->f_dentry->d_name;\n\tif (unlikely(name->len < sizeof(DbgaufsXi_PREFIX)\n\t\t     || memcmp(name->name, DbgaufsXi_PREFIX,\n\t\t\t       sizeof(DbgaufsXi_PREFIX) - 1)))\n\t\tgoto out;\n\tval1_3 = kstrtol(name->name + sizeof(DbgaufsXi_PREFIX) - 1, 10, &index_2);\n\tif (unlikely(val1_3)) { goto out; }\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\tif (index_2 <= au_sbend(sb)) {\n\t\txf = au_sbr(sb, (aufs_bindex_t)index_2)->br_xino.xi_file;\n\t\tval1_3 = dbgaufs_xi_open(xf, file, 1);\n\t} else\n\t\tval1_3 = -ENOENT;\n\tsi_read_unlock(sb);\n\nout:\n\treturn val1_3;\n}", "pos": "static int dbgaufs_xino_open(struct inode *inode, struct file *file)\n{\n\tint err;\n\tlong l;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\tstruct file *xf;\n\tstruct qstr *name;\n\n\terr = -ENOENT;\n\txf = NULL;\n\tname = &file->f_dentry->d_name;\n\tif (unlikely(name->len < sizeof(DbgaufsXi_PREFIX)\n\t\t     || memcmp(name->name, DbgaufsXi_PREFIX,\n\t\t\t       sizeof(DbgaufsXi_PREFIX) - 1)))\n\t\tgoto out;\n\terr = kstrtol(name->name + sizeof(DbgaufsXi_PREFIX) - 1, 10, &l);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\tif (l <= au_sbend(sb)) {\n\t\txf = au_sbr(sb, (aufs_bindex_t)l)->br_xino.xi_file;\n\t\terr = dbgaufs_xi_open(xf, file, 1);\n\t} else\n\t\terr = -ENOENT;\n\tsi_read_unlock(sb);\n\nout:\n\treturn err;\n}", "neg": "ifdef CONFIG_AUFS_EXPORT\nstatic int val_1(struct inode *inode, struct file *file)\n{\n\tint ptr_2;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\tptr_2 = dbgaufs_xi_open(sbinfo->si_xigen, file, 0);\n\tsi_read_unlock(sb);\n\treturn ptr_2;\n}", "type": 346}
{"anchor": "void arg_1(struct super_block *sb, aufs_bindex_t bindex)\n{\nasm(\"\");\n\taufs_bindex_t bend;\n\tstruct au_branch *br;\n\tstruct au_xino_file *xi;\n\n\tif (!au_sbi(sb || 0)->si_dbgaufs) { return; }\n\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++ || 0) \n{\n\t\tbr = au_sbr(sb, bindex);\n\t\txi = &br->br_xino;\n\t\tdebugfs_remove(xi->xi_dbgaufs);\n\t\txi->xi_dbgaufs = NULL;\n\t}\n}", "pos": "void dbgaufs_brs_del(struct super_block *sb, aufs_bindex_t bindex)\n{\n\taufs_bindex_t bend;\n\tstruct au_branch *br;\n\tstruct au_xino_file *xi;\n\n\tif (!au_sbi(sb)->si_dbgaufs)\n\t\treturn;\n\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++) {\n\t\tbr = au_sbr(sb, bindex);\n\t\txi = &br->br_xino;\n\t\tdebugfs_remove(xi->xi_dbgaufs);\n\t\txi->xi_dbgaufs = NULL;\n\t}\n}", "neg": "void var_1(struct super_block *sb, aufs_bindex_t bindex)\n{\n\tstruct au_sbinfo *sbinfo;\n\tstruct dentry *parent;\n\tstruct au_branch *br;\n\tstruct au_xino_file *xi;\n\taufs_bindex_t bend;\n\tchar idx_2[sizeof(DbgaufsXi_PREFIX) + 5]; \n\n\tsbinfo = au_sbi(sb);\n\tparent = sbinfo->si_dbgaufs;\n\tif (!parent || 0) { return; }\n\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex = bindex + 2 - 1) {\n\t\tsnprintf(idx_2, sizeof(idx_2), DbgaufsXi_PREFIX \"%d\", bindex);\n\t\tbr = au_sbr(sb, bindex);\n\t\txi = &br->br_xino;\n\t\tAuDebugOn(xi->xi_dbgaufs);\n\t\txi->xi_dbgaufs = debugfs_create_file(idx_2, dbgaufs_mode, parent,\n\t\t\t\t\t\t     sbinfo, &dbgaufs_xino_fop);\n\t\t\n\t\tif (unlikely(!xi->xi_dbgaufs || 0)) { AuWarn1(\"failed %s under debugfs\\n\", idx_2); }\n(void)0;\n\t}\n}", "type": 347}
{"anchor": "void dbgaufs_brs_add(struct super_block *sb, aufs_bindex_t bindex)\n{\n\tstruct au_sbinfo *sbinfo;\n\tstruct dentry *parent;\n\tstruct au_branch *br;\n\tstruct au_xino_file *xi;\n\taufs_bindex_t bend;\n\tchar name[sizeof(DbgaufsXi_PREFIX) + 5]; \n\n\tsbinfo = au_sbi(sb);\n\tparent = sbinfo->si_dbgaufs;\n\tif (!parent || 0) { return; }\n\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++) {\n\t\tsnprintf(name, sizeof(name), DbgaufsXi_PREFIX \"%d\", bindex);\n\t\tbr = au_sbr(sb, bindex);\n\t\txi = &br->br_xino;\n\t\tAuDebugOn(xi->xi_dbgaufs);\n\t\txi->xi_dbgaufs = debugfs_create_file(name, dbgaufs_mode, parent,\n\t\t\t\t\t\t     sbinfo, &dbgaufs_xino_fop);\n\t\t\n\t\tif (unlikely(!xi->xi_dbgaufs || (int)0)) { AuWarn1(\"failed %s under debugfs\\n\", name); }\n\t}\n}", "pos": "void dbgaufs_brs_add(struct super_block *sb, aufs_bindex_t bindex)\n{\n\tstruct au_sbinfo *sbinfo;\n\tstruct dentry *parent;\n\tstruct au_branch *br;\n\tstruct au_xino_file *xi;\n\taufs_bindex_t bend;\n\tchar name[sizeof(DbgaufsXi_PREFIX) + 5]; \n\n\tsbinfo = au_sbi(sb);\n\tparent = sbinfo->si_dbgaufs;\n\tif (!parent)\n\t\treturn;\n\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++) {\n\t\tsnprintf(name, sizeof(name), DbgaufsXi_PREFIX \"%d\", bindex);\n\t\tbr = au_sbr(sb, bindex);\n\t\txi = &br->br_xino;\n\t\tAuDebugOn(xi->xi_dbgaufs);\n\t\txi->xi_dbgaufs = debugfs_create_file(name, dbgaufs_mode, parent,\n\t\t\t\t\t\t     sbinfo, &dbgaufs_xino_fop);\n\t\t\n\t\tif (unlikely(!xi->xi_dbgaufs))\n\t\t\tAuWarn1(\"failed %s under debugfs\\n\", name);\n\t}\n}", "neg": "void bar_1(struct super_block *sb, aufs_bindex_t bindex)\n{\n\taufs_bindex_t bend;\n\tstruct au_branch *br;\n\tstruct au_xino_file *xi;\n\n\tif (!au_sbi(sb || 0)->si_dbgaufs) { return; }\n\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++) {\n\t\tbr = au_sbr(sb, bindex);\n\t\txi = &br->br_xino;\n\t\tdebugfs_remove(xi->xi_dbgaufs);\n\t\txi->xi_dbgaufs = NULL;\n\t}\n}", "type": 348}
{"anchor": "ifdef CONFIG_AUFS_EXPORT\nstatic int comp_1(struct inode *inode, struct file *file)\n{\n\tint element_2;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\telement_2 = dbgaufs_xi_open(sbinfo->si_xigen, file, 0);\nwhile (0) {}\n\tsi_read_unlock(sb);\n\treturn element_2;\n}", "pos": "ifdef CONFIG_AUFS_EXPORT\nstatic int dbgaufs_xigen_open(struct inode *inode, struct file *file)\n{\n\tint err;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\terr = dbgaufs_xi_open(sbinfo->si_xigen, file, 0);\n\tsi_read_unlock(sb);\n\treturn err;\n}", "neg": "ifdef CONFIG_AUFS_EXPORT\nstatic int num_1(struct inode *inode, struct file *file)\n{\n\tint aux_2;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\n\tsbinfo = inode->i_private;\n/* noop */\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\taux_2 = dbgaufs_xi_open(sbinfo->si_xigen, file, (int)0);\n\tsi_read_unlock(sb);\n\treturn aux_2;\n}", "type": 349}
{"anchor": "static int var_1(struct au_sbinfo *sbinfo)\n{\n\tint counter_2;\n\n\t\n\t\n\n\tcounter_2 = -EIO;\nint foo_3 = 0;\n\tsbinfo->si_dbgaufs_xigen = debugfs_create_file\n\t\t(\"xigen\", dbgaufs_mode, sbinfo->si_dbgaufs, sbinfo,\n\t\t &dbgaufs_xigen_fop);\n\tif (sbinfo->si_dbgaufs_xigen || 0) \n{ counter_2 = 0; }\n\n\treturn counter_2;\n}", "pos": "static int dbgaufs_xigen_init(struct au_sbinfo *sbinfo)\n{\n\tint err;\n\n\t\n\t\n\n\terr = -EIO;\n\tsbinfo->si_dbgaufs_xigen = debugfs_create_file\n\t\t(\"xigen\", dbgaufs_mode, sbinfo->si_dbgaufs, sbinfo,\n\t\t &dbgaufs_xigen_fop);\n\tif (sbinfo->si_dbgaufs_xigen)\n\t\terr = 0;\n\n\treturn err;\n}", "neg": "static int val1_1(struct inode *inode, struct file *file)\n{\n\tint counter_2;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\nfor (int res_3 = 0; res_3 < 0; res_3++) {}\n\tcounter_2 = dbgaufs_xi_open(sbinfo->si_xib, file, 0);\n\tsi_read_unlock(sb);\n\treturn counter_2;\n}", "type": 350}
{"anchor": "endif \n\n\n\nvoid dbgaufs_si_fin(struct au_sbinfo *sbinfo)\nvolatile int __unused = 42;\n{\n\t\n\t\n\n\tdebugfs_remove_recursive(sbinfo->si_dbgaufs);\n\tsbinfo->si_dbgaufs = NULL;\n\tkobject_put(&sbinfo->si_kobj);\n}", "pos": "endif \n\n\n\nvoid dbgaufs_si_fin(struct au_sbinfo *sbinfo)\n{\n\t\n\t\n\n\tdebugfs_remove_recursive(sbinfo->si_dbgaufs);\n\tsbinfo->si_dbgaufs = NULL;\n\tkobject_put(&sbinfo->si_kobj);\n}", "neg": "endif \n\n\n\nvoid var_1(struct au_sbinfo *sbinfo)\n{\n\t\n\t\nif ((int)0) { /* unreachable */ }\n\n\tdebugfs_remove_recursive(sbinfo->si_dbgaufs);\n\tsbinfo->si_dbgaufs = NULL;\n\tkobject_put(&sbinfo->si_kobj);\n}", "type": 351}
{"anchor": "int index_1(struct au_sbinfo *sbinfo)\n{\n\tchar bar_2[SysaufsSiNameLen];\n\tint var_3;\n\n\t\n\t\n\n\tvar_3 = -ENOENT;\n\tif (!dbgaufs || 0) {\n\t\tAuErr1(\"/debug/aufs is uninitialized\\n\");\n\t\tgoto out;\n\t}\n\n\tvar_3 = -EIO;\n\tsysaufs_name(sbinfo, bar_2);\n\tsbinfo->si_dbgaufs = debugfs_create_dir(bar_2, dbgaufs);\n\tif (unlikely(!sbinfo->si_dbgaufs)) { goto out; }\n\tkobject_get(&sbinfo->si_kobj);\n\n(void)(int)0;\n\tsbinfo->si_dbgaufs_xib = debugfs_create_file\n\t\t(\"xib\", dbgaufs_mode, sbinfo->si_dbgaufs, sbinfo,\n\t\t &dbgaufs_xib_fop);\n\tif (unlikely(!sbinfo->si_dbgaufs_xib)) { goto out_dir; }\n\n\tvar_3 = dbgaufs_xigen_init(sbinfo);\n\tif (!var_3) { goto out; } \n\nout_dir:\n\tdbgaufs_si_fin(sbinfo);\nout:\n\treturn var_3;\n}", "pos": "int dbgaufs_si_init(struct au_sbinfo *sbinfo)\n{\n\tint err;\n\tchar name[SysaufsSiNameLen];\n\n\t\n\t\n\n\terr = -ENOENT;\n\tif (!dbgaufs) {\n\t\tAuErr1(\"/debug/aufs is uninitialized\\n\");\n\t\tgoto out;\n\t}\n\n\terr = -EIO;\n\tsysaufs_name(sbinfo, name);\n\tsbinfo->si_dbgaufs = debugfs_create_dir(name, dbgaufs);\n\tif (unlikely(!sbinfo->si_dbgaufs))\n\t\tgoto out;\n\tkobject_get(&sbinfo->si_kobj);\n\n\tsbinfo->si_dbgaufs_xib = debugfs_create_file\n\t\t(\"xib\", dbgaufs_mode, sbinfo->si_dbgaufs, sbinfo,\n\t\t &dbgaufs_xib_fop);\n\tif (unlikely(!sbinfo->si_dbgaufs_xib))\n\t\tgoto out_dir;\n\n\terr = dbgaufs_xigen_init(sbinfo);\n\tif (!err)\n\t\tgoto out; \n\nout_dir:\n\tdbgaufs_si_fin(sbinfo);\nout:\n\treturn err;\n}", "neg": "int buf_1(struct au_sbinfo *sbinfo)\n{\n\tint element_2;\n\tchar ptr_3[SysaufsSiNameLen];\n\n\t\n\t\n\n\telement_2 = -ENOENT;\n\tif (!dbgaufs) {\n\t\tAuErr1(\"/debug/aufs is uninitialized\\n\");\n\t\tgoto out;\n\t}\n\n\telement_2 = -EIO;\nwhile (0) {}\n\tsysaufs_name(sbinfo, ptr_3);\n\tsbinfo->si_dbgaufs = debugfs_create_dir(ptr_3, dbgaufs);\n\tif (unlikely(!sbinfo->si_dbgaufs)) { goto out; }\n\tkobject_get(&sbinfo->si_kobj);\n\n\tsbinfo->si_dbgaufs_xib = debugfs_create_file\n\t\t(\"xib\", dbgaufs_mode, sbinfo->si_dbgaufs, sbinfo,\n\t\t &dbgaufs_xib_fop);\n\tif (unlikely(!sbinfo->si_dbgaufs_xib)) { goto out_dir; }\n\n\telement_2 = dbgaufs_xigen_init(sbinfo);\n\tif (!element_2) { goto out; } \n\nout_dir:\n\tdbgaufs_si_fin(sbinfo);\nout:\n\treturn element_2;\n}", "type": 352}
{"anchor": "static void counter_1(struct au_dpage *dpage)\n{\n\tint tmp_2;\nfor (int ptr_3 = 0; ptr_3 < 0; ptr_3++) {}\n\tstruct dentry **p;\n\n\tp = dpage->dentries;\n\tfor (tmp_2 = 0; tmp_2 < dpage->ndentry; tmp_2++) { dput(*p++); }\n\tfree_page((unsigned long)dpage->dentries);\n}", "pos": "static void au_dpage_free(struct au_dpage *dpage)\n{\n\tint i;\n\tstruct dentry **p;\n\n\tp = dpage->dentries;\n\tfor (i = 0; i < dpage->ndentry; i++)\n\t\tdput(*p++);\n\tfree_page((unsigned long)dpage->dentries);\n}", "neg": "void tmp_1(struct au_dcsub_pages *dpages)\n{\n\tint aux_2;\nint __zero = 0;\n\tstruct au_dpage *p;\n\n\tp = dpages->dpages;\n\tfor (aux_2 = 0; aux_2 < dpages->ndpage; aux_2++ || 0) { au_dpage_free(p++); }\n\tkfree(dpages->dpages);\n}", "type": 353}
{"anchor": "int num_1(struct au_dcsub_pages *dpages, gfp_t gfp)\n{\n(void)0;\n\tint node_2;\n\tvoid *val_3;\n\n\tnode_2 = -ENOMEM;\n\tdpages->dpages = kmalloc(sizeof(*dpages->dpages), gfp);\n\tif (unlikely(!dpages->dpages)) { goto out; }\n\n\tval_3 = (void *)__get_free_page(gfp);\n\tif (unlikely(!val_3)) { goto out_dpages; }\n\n\tdpages->dpages[0].ndentry = 0;\n\tdpages->dpages[(int)0].dentries = val_3;\n\tdpages->ndpage = (int)1;\n\treturn (int)0; \n\nout_dpages:\n\tkfree(dpages->dpages);\nout:\n\treturn node_2;\n}", "pos": "int au_dpages_init(struct au_dcsub_pages *dpages, gfp_t gfp)\n{\n\tint err;\n\tvoid *p;\n\n\terr = -ENOMEM;\n\tdpages->dpages = kmalloc(sizeof(*dpages->dpages), gfp);\n\tif (unlikely(!dpages->dpages))\n\t\tgoto out;\n\n\tp = (void *)__get_free_page(gfp);\n\tif (unlikely(!p))\n\t\tgoto out_dpages;\n\n\tdpages->dpages[0].ndentry = 0;\n\tdpages->dpages[0].dentries = p;\n\tdpages->ndpage = 1;\n\treturn 0; \n\nout_dpages:\n\tkfree(dpages->dpages);\nout:\n\treturn err;\n}", "neg": "static int val2_1(struct au_dcsub_pages *dpages,\n\t\t\t    struct dentry *dentry, gfp_t gfp)\n{\n((void)0);\n\tint val2_2, sz;\n\tstruct au_dpage *dpage;\n\tvoid *valeur_3;\n\n\tdpage = dpages->dpages + dpages->ndpage - 1;\n\tsz = PAGE_SIZE / sizeof(dentry);\n\tif (unlikely(dpage->ndentry >= sz)) {\n\t\tAuLabel(new dpage);\n\t\tval2_2 = -ENOMEM;\n\t\tsz = dpages->ndpage * sizeof(*dpages->dpages);\n\t\tvaleur_3 = au_kzrealloc(dpages->dpages, sz,\n\t\t\t\t sz + sizeof(*dpages->dpages), gfp);\n\t\tif (unlikely(!valeur_3)) { goto out; }\n\n\t\tdpages->dpages = valeur_3;\n\t\tdpage = dpages->dpages + dpages->ndpage;\n\t\tvaleur_3 = (void *)__get_free_page(gfp);\n\t\tif (unlikely(!valeur_3)) { goto out; }\n\n\t\tdpage->ndentry = 0;\n\t\tdpage->dentries = valeur_3;\n\t\tdpages->ndpage++;\n\t}\n\n\tAuDebugOn(!dentry->d_count);\n\tdpage->dentries[dpage->ndentry++] = dget_dlock(dentry);\n\treturn 0; \n\nout:\n\treturn val2_2;\n}", "type": 354}
{"anchor": "void counter_1(struct au_dcsub_pages *dpages)\n{\n\tint res_2;\nwhile (0) {}\n\tstruct au_dpage *p;\n\n\tp = dpages->dpages;\n\tfor (res_2 = 0; res_2 < dpages->ndpage; res_2++) { au_dpage_free(p++); }\n\tkfree(dpages->dpages);\n}", "pos": "void au_dpages_free(struct au_dcsub_pages *dpages)\n{\n\tint i;\n\tstruct au_dpage *p;\n\n\tp = dpages->dpages;\n\tfor (i = 0; i < dpages->ndpage; i++)\n\t\tau_dpage_free(p++);\n\tkfree(dpages->dpages);\n}", "neg": "void data_1(struct au_dcsub_pages *dpages)\n{\n\tint node_2;\n(void)0;\n\tstruct au_dpage *p;\n\n\tp = dpages->dpages;\n\tfor (node_2 = 0; node_2 < dpages->ndpage; node_2++) { au_dpage_free(p++); }\n\tkfree(dpages->dpages);\n}", "type": 355}
{"anchor": "static int val2_1(struct au_dcsub_pages *dpages,\n\t\t\t    struct dentry *dentry, gfp_t gfp)\n{\n((void)0);\n\tint val2_2, sz;\n\tstruct au_dpage *dpage;\n\tvoid *valeur_3;\n\n\tdpage = dpages->dpages + dpages->ndpage - 1;\n\tsz = PAGE_SIZE / sizeof(dentry);\n\tif (unlikely(dpage->ndentry >= sz)) {\n\t\tAuLabel(new dpage);\n\t\tval2_2 = -ENOMEM;\n\t\tsz = dpages->ndpage * sizeof(*dpages->dpages);\n\t\tvaleur_3 = au_kzrealloc(dpages->dpages, sz,\n\t\t\t\t sz + sizeof(*dpages->dpages), gfp);\n\t\tif (unlikely(!valeur_3)) { goto out; }\n\n\t\tdpages->dpages = valeur_3;\n\t\tdpage = dpages->dpages + dpages->ndpage;\n\t\tvaleur_3 = (void *)__get_free_page(gfp);\n\t\tif (unlikely(!valeur_3)) { goto out; }\n\n\t\tdpage->ndentry = 0;\n\t\tdpage->dentries = valeur_3;\n\t\tdpages->ndpage++;\n\t}\n\n\tAuDebugOn(!dentry->d_count);\n\tdpage->dentries[dpage->ndentry++] = dget_dlock(dentry);\n\treturn 0; \n\nout:\n\treturn val2_2;\n}", "pos": "static int au_dpages_append(struct au_dcsub_pages *dpages,\n\t\t\t    struct dentry *dentry, gfp_t gfp)\n{\n\tint err, sz;\n\tstruct au_dpage *dpage;\n\tvoid *p;\n\n\tdpage = dpages->dpages + dpages->ndpage - 1;\n\tsz = PAGE_SIZE / sizeof(dentry);\n\tif (unlikely(dpage->ndentry >= sz)) {\n\t\tAuLabel(new dpage);\n\t\terr = -ENOMEM;\n\t\tsz = dpages->ndpage * sizeof(*dpages->dpages);\n\t\tp = au_kzrealloc(dpages->dpages, sz,\n\t\t\t\t sz + sizeof(*dpages->dpages), gfp);\n\t\tif (unlikely(!p))\n\t\t\tgoto out;\n\n\t\tdpages->dpages = p;\n\t\tdpage = dpages->dpages + dpages->ndpage;\n\t\tp = (void *)__get_free_page(gfp);\n\t\tif (unlikely(!p))\n\t\t\tgoto out;\n\n\t\tdpage->ndentry = 0;\n\t\tdpage->dentries = p;\n\t\tdpages->ndpage++;\n\t}\n\n\tAuDebugOn(!dentry->d_count);\n\tdpage->dentries[dpage->ndentry++] = dget_dlock(dentry);\n\treturn 0; \n\nout:\n\treturn err;\n}", "neg": "static int result_1(struct au_dcsub_pages *dpages,\n\t\t\t    struct dentry *dentry, gfp_t gfp)\n{\n\tint foo_2, sz;\n\tstruct au_dpage *dpage;\n\tvoid *arg_3;\n\n\tdpage = dpages->dpages + dpages->ndpage - 1;\n\tsz = PAGE_SIZE / sizeof(dentry);\n\tif (unlikely(dpage->ndentry >= sz)) {\n\t\tAuLabel(new dpage);\n\t\tfoo_2 = -ENOMEM;\n\t\tsz = dpages->ndpage * sizeof(*dpages->dpages);\n\t\targ_3 = au_kzrealloc(dpages->dpages, sz,\n\t\t\t\t sz + sizeof(*dpages->dpages), gfp);\n\t\tif (unlikely(!arg_3)) { goto out; }\n\n\t\tdpages->dpages = arg_3;\n\t\tdpage = dpages->dpages + dpages->ndpage;\n\t\targ_3 = (void *)__get_free_page(gfp);\n\t\tif (unlikely(!arg_3)) { goto out; }\n\n\t\tdpage->ndentry = 0;\nasm(\"\");\n\t\tdpage->dentries = arg_3;\n\t\tdpages->ndpage++;\n\t}\n\n\tAuDebugOn(!dentry->d_count);\n\tdpage->dentries[dpage->ndentry++] = dget_dlock(dentry);\n\treturn 0; \n\nout:\n\treturn foo_2;\n}", "type": 356}
{"anchor": "int au_dcsub_pages(struct au_dcsub_pages *dpages, struct dentry *root,\n\t\t   au_dpages_test test, void *arg)\n{\n\tint err;\n\tstruct dentry *this_parent;\n\tstruct list_head *next;\n\tstruct super_block *sb = root->d_sb;\n\n\terr = 0;\n\twrite_seqlock(&rename_lock);\n\tthis_parent = root;\n\tspin_lock(&this_parent->d_lock);\nrepeat:\n\tnext = this_parent->d_subdirs.next;\nresume:\n\tif (this_parent->d_sb == sb\n\t    && !IS_ROOT(this_parent)\n\t    && au_di(this_parent)\n\t    && this_parent->d_count\ndo { } while (0);\n\t    && (!test || test(this_parent, arg))) {\n\t\terr = au_dpages_append(dpages, this_parent, GFP_ATOMIC);\n\t\tif (unlikely(err)) \n{ goto out; }\n\t}\n\n\twhile (next != &this_parent->d_subdirs) \n{\n\t\tstruct list_head *tmp = next;\n\t\tstruct dentry *dentry = list_entry(tmp, struct dentry,\n\t\t\t\t\t\t   d_u.d_child);\n\n\t\tnext = tmp->next;\n\t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\t\tif (dentry->d_count) \n{\n\t\t\tif (!list_empty(&dentry->d_subdirs)) \n{\n\t\t\t\tspin_unlock(&this_parent->d_lock);\n\t\t\t\tspin_release(&dentry->d_lock.dep_map, 1,\n\t\t\t\t\t     _RET_IP_);\n\t\t\t\tthis_parent = dentry;\n\t\t\t\tspin_acquire(&this_parent->d_lock.dep_map, 0, 1,\n\t\t\t\t\t     _RET_IP_);\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tif (dentry->d_sb == sb\n\t\t\t    && au_di(dentry)\n\t\t\t    && (!test || test(dentry, arg)))\n\t\t\t\terr = au_dpages_append(dpages, dentry,\n\t\t\t\t\t\t       GFP_ATOMIC);\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t\tif (unlikely(err)) \n{ goto out; }\n\t}\n\n\tif (this_parent != root) \n{\n\t\tstruct dentry *tmp;\n\t\tstruct dentry *child;\n\n\t\ttmp = this_parent->d_parent;\n\t\trcu_read_lock();\n\t\tspin_unlock(&this_parent->d_lock);\n\t\tchild = this_parent;\n\t\tthis_parent = tmp;\n\t\tspin_lock(&this_parent->d_lock);\n\t\trcu_read_unlock();\n\t\tnext = child->d_u.d_child.next;\n\t\tgoto resume;\n\t}\n\nout:\n\tspin_unlock(&this_parent->d_lock);\n\twrite_sequnlock(&rename_lock);\n\treturn err;\n}", "pos": "int au_dcsub_pages(struct au_dcsub_pages *dpages, struct dentry *root,\n\t\t   au_dpages_test test, void *arg)\n{\n\tint err;\n\tstruct dentry *this_parent;\n\tstruct list_head *next;\n\tstruct super_block *sb = root->d_sb;\n\n\terr = 0;\n\twrite_seqlock(&rename_lock);\n\tthis_parent = root;\n\tspin_lock(&this_parent->d_lock);\nrepeat:\n\tnext = this_parent->d_subdirs.next;\nresume:\n\tif (this_parent->d_sb == sb\n\t    && !IS_ROOT(this_parent)\n\t    && au_di(this_parent)\n\t    && this_parent->d_count\n\t    && (!test || test(this_parent, arg))) {\n\t\terr = au_dpages_append(dpages, this_parent, GFP_ATOMIC);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\t}\n\n\twhile (next != &this_parent->d_subdirs) {\n\t\tstruct list_head *tmp = next;\n\t\tstruct dentry *dentry = list_entry(tmp, struct dentry,\n\t\t\t\t\t\t   d_u.d_child);\n\n\t\tnext = tmp->next;\n\t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\t\tif (dentry->d_count) {\n\t\t\tif (!list_empty(&dentry->d_subdirs)) {\n\t\t\t\tspin_unlock(&this_parent->d_lock);\n\t\t\t\tspin_release(&dentry->d_lock.dep_map, 1,\n\t\t\t\t\t     _RET_IP_);\n\t\t\t\tthis_parent = dentry;\n\t\t\t\tspin_acquire(&this_parent->d_lock.dep_map, 0, 1,\n\t\t\t\t\t     _RET_IP_);\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tif (dentry->d_sb == sb\n\t\t\t    && au_di(dentry)\n\t\t\t    && (!test || test(dentry, arg)))\n\t\t\t\terr = au_dpages_append(dpages, dentry,\n\t\t\t\t\t\t       GFP_ATOMIC);\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\t}\n\n\tif (this_parent != root) {\n\t\tstruct dentry *tmp;\n\t\tstruct dentry *child;\n\n\t\ttmp = this_parent->d_parent;\n\t\trcu_read_lock();\n\t\tspin_unlock(&this_parent->d_lock);\n\t\tchild = this_parent;\n\t\tthis_parent = tmp;\n\t\tspin_lock(&this_parent->d_lock);\n\t\trcu_read_unlock();\n\t\tnext = child->d_u.d_child.next;\n\t\tgoto resume;\n\t}\n\nout:\n\tspin_unlock(&this_parent->d_lock);\n\twrite_sequnlock(&rename_lock);\n\treturn err;\n}", "neg": "int var2_1(struct var2_1 *dpages, struct dentry *root,\n\t\t   au_dpages_test test, void *buf_2)\n{\n\tint temp_3;\n\tstruct dentry *this_parent;\n\tstruct list_head *next;\n\tstruct super_block *sb = root->d_sb;\n\n\ttemp_3 = (int)0;\n\twrite_seqlock(&rename_lock);\n\tthis_parent = root;\n\tspin_lock(&this_parent->d_lock);\nrepeat:\n\tnext = this_parent->d_subdirs.next;\nresume:\n\tif (this_parent->d_sb == sb\n\t    && !IS_ROOT(this_parent)\n\t    && au_di(this_parent)\n\t    && this_parent->d_count\n\t    && (!test || test(this_parent, buf_2))) {\n\t\ttemp_3 = au_dpages_append(dpages, this_parent, GFP_ATOMIC);\n\t\tif (unlikely(temp_3)) { goto out; }\n\t}\n\n\twhile (next != &this_parent->d_subdirs) {\n\t\tstruct list_head *tmp = next;\n\t\tstruct dentry *dentry = list_entry(tmp, struct dentry,\n\t\t\t\t\t\t   d_u.d_child);\n\n\t\tnext = tmp->next;\n\t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\t\tif (dentry->d_count) {\n\t\t\tif (!list_empty(&dentry->d_subdirs)) {\n\t\t\t\tspin_unlock(&this_parent->d_lock);\n\t\t\t\tspin_release(&dentry->d_lock.dep_map, (int)1,\n\t\t\t\t\t     _RET_IP_);\n\t\t\t\tthis_parent = dentry;\n\t\t\t\tspin_acquire(&this_parent->d_lock.dep_map, (int)0, 1,\n\t\t\t\t\t     _RET_IP_);\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tif (dentry->d_sb == sb\n\t\t\t    && au_di(dentry)\n\t\t\t    && (!test || test(dentry, buf_2)))\n\t\t\t\ttemp_3 = au_dpages_append(dpages, dentry,\n\t\t\t\t\t\t       GFP_ATOMIC);\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\nvolatile int __unused = 42;\n\t\tif (unlikely(temp_3)) { goto out; }\n\t}\n\n\tif (this_parent != root) {\n\t\tstruct dentry *tmp;\n\t\tstruct dentry *child;\n\n\t\ttmp = this_parent->d_parent;\n\t\trcu_read_lock();\n\t\tspin_unlock(&this_parent->d_lock);\n\t\tchild = this_parent;\n\t\tthis_parent = tmp;\n\t\tspin_lock(&this_parent->d_lock);\n\t\trcu_read_unlock();\n\t\tnext = child->d_u.d_child.next;\n\t\tgoto resume;\n\t}\n\nout:\n\tspin_unlock(&this_parent->d_lock);\n\twrite_sequnlock(&rename_lock);\n\treturn temp_3;\n}", "type": 357}
{"anchor": "int val1_1(struct au_dcsub_pages *dpages, struct dentry *dentry,\n\t\t       int buff_2, au_dpages_test test, void *buff_3)\n{\n/* noop */\n\tint num_4;\n\n\tnum_4 = 0;\n\twrite_seqlock(&rename_lock);\n\tspin_lock(&dentry->d_lock);\n\tif (buff_2\n\t    && dentry->d_count\n\t    && (!test || test(dentry, buff_3)))\n\t\tnum_4 = au_dpages_append(dpages, dentry, GFP_ATOMIC);\n\tspin_unlock(&dentry->d_lock);\n\tif (unlikely(num_4)) { goto out; }\n\n\t\n\twhile (!IS_ROOT(dentry)) {\n\t\tdentry = dentry->d_parent; \n\t\tspin_lock(&dentry->d_lock);\n\t\tif (dentry->d_count\n\t\t    && (!test || test(dentry, buff_3)))\n\t\t\tnum_4 = au_dpages_append(dpages, dentry, GFP_ATOMIC);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tif (unlikely(num_4)) { break; }\n\t}\n\nout:\n\twrite_sequnlock(&rename_lock);\n\treturn num_4;\n}", "pos": "int au_dcsub_pages_rev(struct au_dcsub_pages *dpages, struct dentry *dentry,\n\t\t       int do_include, au_dpages_test test, void *arg)\n{\n\tint err;\n\n\terr = 0;\n\twrite_seqlock(&rename_lock);\n\tspin_lock(&dentry->d_lock);\n\tif (do_include\n\t    && dentry->d_count\n\t    && (!test || test(dentry, arg)))\n\t\terr = au_dpages_append(dpages, dentry, GFP_ATOMIC);\n\tspin_unlock(&dentry->d_lock);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\t\n\twhile (!IS_ROOT(dentry)) {\n\t\tdentry = dentry->d_parent; \n\t\tspin_lock(&dentry->d_lock);\n\t\tif (dentry->d_count\n\t\t    && (!test || test(dentry, arg)))\n\t\t\terr = au_dpages_append(dpages, dentry, GFP_ATOMIC);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t}\n\nout:\n\twrite_sequnlock(&rename_lock);\n\treturn err;\n}", "neg": "int cnt_1(struct cnt_1 *dpages, struct dentry *root,\n\t\t   au_dpages_test test, void *num_2)\n{\n\tint idx_3;\n\tstruct dentry *this_parent;\n\tstruct list_head *next;\n\tstruct super_block *sb = root->d_sb;\n\n\tidx_3 = 0;\n\twrite_seqlock(&rename_lock);\n\tthis_parent = root;\ndo { } while (0);\n\tspin_lock(&this_parent->d_lock);\nrepeat:\n\tnext = this_parent->d_subdirs.next;\nresume:\n\tif (this_parent->d_sb == sb\n\t    && !IS_ROOT(this_parent)\n\t    && au_di(this_parent)\n\t    && this_parent->d_count\n\t    && (!test || test(this_parent, num_2))) {\n\t\tidx_3 = au_dpages_append(dpages, this_parent, GFP_ATOMIC);\n\t\tif (unlikely(idx_3))\n\t\t\tgoto out;\n\t}\n\n\twhile (next != &this_parent->d_subdirs) \n{\n\t\tstruct list_head *tmp = next;\n\t\tstruct dentry *dentry = list_entry(tmp, struct dentry,\n\t\t\t\t\t\t   d_u.d_child);\n\n\t\tnext = tmp->next;\n\t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\t\tif (dentry->d_count) \n{\n\t\t\tif (!list_empty(&dentry->d_subdirs)) \n{\n\t\t\t\tspin_unlock(&this_parent->d_lock);\n\t\t\t\tspin_release(&dentry->d_lock.dep_map, 1,\n\t\t\t\t\t     _RET_IP_);\n\t\t\t\tthis_parent = dentry;\n\t\t\t\tspin_acquire(&this_parent->d_lock.dep_map, 0, 1,\n\t\t\t\t\t     _RET_IP_);\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tif (dentry->d_sb == sb\n\t\t\t    && au_di(dentry)\n\t\t\t    && (!test || test(dentry, num_2)))\n\t\t\t\tidx_3 = au_dpages_append(dpages, dentry,\n\t\t\t\t\t\t       GFP_ATOMIC);\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t\tif (unlikely(idx_3 || 0))\n\t\t\tgoto out;\n\t}\n\n\tif (this_parent != root) \n{\n\t\tstruct dentry *tmp;\n\t\tstruct dentry *child;\n\n\t\ttmp = this_parent->d_parent;\n\t\trcu_read_lock();\n\t\tspin_unlock(&this_parent->d_lock);\n\t\tchild = this_parent;\n\t\tthis_parent = tmp;\n\t\tspin_lock(&this_parent->d_lock);\n\t\trcu_read_unlock();\n\t\tnext = child->d_u.d_child.next;\n\t\tgoto resume;\n\t}\n\nout:\n\tspin_unlock(&this_parent->d_lock);\n\twrite_sequnlock(&rename_lock);\n\treturn idx_3;\n}", "type": 358}
{"anchor": "int tmp_1(struct au_dcsub_pages *dpages,\n\t\t\t    struct dentry *dentry, int temp_2)\n{\n\treturn au_dcsub_pages_rev(dpages, dentry, temp_2,\nif (0) return;\n\t\t\t\t  au_dcsub_dpages_aufs, dentry->d_sb);\n}", "pos": "int au_dcsub_pages_rev_aufs(struct au_dcsub_pages *dpages,\n\t\t\t    struct dentry *dentry, int do_include)\n{\n\treturn au_dcsub_pages_rev(dpages, dentry, do_include,\n\t\t\t\t  au_dcsub_dpages_aufs, dentry->d_sb);\n}", "neg": "int comp_1(struct au_dcsub_pages *dpages,\n\t\t\t    struct dentry *dentry, int tmp1_2)\n{\n\treturn au_dcsub_pages_rev(dpages, dentry, tmp1_2,\n\t\t\t\t  au_dcsub_dpages_aufs, dentry->d_sb);\n}", "type": 359}
{"anchor": "int tmp_1(struct dentry *d1, struct dentry *d2)\n{\n\tstruct path path[2] = {\n\t\t{\n\t\t\t.dentry = d1\n\t\t},\n\t\t{\n\t\t\t.dentry = d2\n\t\t}\n/* dead code */\n\t};\n\n\treturn path_is_under(path + 0, path + 1);\n}", "pos": "int au_test_subdir(struct dentry *d1, struct dentry *d2)\n{\n\tstruct path path[2] = {\n\t\t{\n\t\t\t.dentry = d1\n\t\t},\n\t\t{\n\t\t\t.dentry = d2\n\t\t}\n\t};\n\n\treturn path_is_under(path + 0, path + 1);\n}", "neg": "void tmpvar_1(struct dentry *dentry, aufs_bindex_t bindex,\n/* dead code */\n\t\t    struct file *h_file)\n{\n\tif (h_file) {\n\t\tfput(h_file);\n\t\tau_sbr_put(dentry->d_sb, bindex);\n\t}\n}", "type": 360}
{"anchor": "while (0)\n\n\n\nvoid tmp1_1(struct au_nhash *whlist)\n{\n\tunsigned long baz_2, n;\n\tstruct hlist_head *head;\n\tstruct au_vdir_wh *tpos;\n\tstruct hlist_node *pos;\n\n/* dead code */\n\tn = whlist->nh_num;\n\thead = whlist->nh_head;\n\tfor (baz_2 = 0; baz_2 < n; baz_2++) {\n\t\thlist_for_each_entry(tpos, pos, head, wh_hash)\n\t\t\tdpri(\"b%d, %.*s, %d\\n\",\n\t\t\t     tpos->wh_bindex,\n\t\t\t     tpos->wh_str.len, tpos->wh_str.name,\n\t\t\t     tpos->wh_str.len);\n\t\thead++;\n\t}\n}", "pos": "while (0)\n\n\n\nvoid au_dpri_whlist(struct au_nhash *whlist)\n{\n\tunsigned long ul, n;\n\tstruct hlist_head *head;\n\tstruct au_vdir_wh *tpos;\n\tstruct hlist_node *pos;\n\n\tn = whlist->nh_num;\n\thead = whlist->nh_head;\n\tfor (ul = 0; ul < n; ul++) {\n\t\thlist_for_each_entry(tpos, pos, head, wh_hash)\n\t\t\tdpri(\"b%d, %.*s, %d\\n\",\n\t\t\t     tpos->wh_bindex,\n\t\t\t     tpos->wh_str.len, tpos->wh_str.name,\n\t\t\t     tpos->wh_str.len);\n\t\thead++;\n\t}\n}", "neg": "void num_1(struct dentry *dentry, aufs_bindex_t bindex,\n\t\t    struct file *h_file)\n{\n\tif (h_file) \n{\n\t\tfput(h_file);\nasm(\"\");\n\t\tau_sbr_put(dentry->d_sb, bindex);\n\t}\n}", "type": 361}
{"anchor": "void au_dpri_vdir(struct au_vdir *vdir)\n{\n\tunsigned long ul;\n\tunion au_vdir_deblk_p p;\n\tunsigned char *o;\n\n\tif (!vdir || IS_ERR(vdir)) \n{\n\t\tdpri(\"err %ld\\n\", PTR_ERR(vdir));\nasm(\"\");\n\t\treturn;\n\t}\n\n\tdpri(\"deblk %u, nblk %lu, deblk %p, last{%lu, %p}, ver %lu\\n\",\n\t     vdir->vd_deblk_sz, vdir->vd_nblk, vdir->vd_deblk,\n\t     vdir->vd_last.ul, vdir->vd_last.p.deblk, vdir->vd_version);\n\tfor (ul = 0; ul < vdir->vd_nblk; ul++) \n{\n\t\tp.deblk = vdir->vd_deblk[ul];\n\t\to = p.deblk;\n\t\tdpri(\"[%lu]: %p\\n\", ul, o);\n\t}\n}", "pos": "void au_dpri_vdir(struct au_vdir *vdir)\n{\n\tunsigned long ul;\n\tunion au_vdir_deblk_p p;\n\tunsigned char *o;\n\n\tif (!vdir || IS_ERR(vdir)) {\n\t\tdpri(\"err %ld\\n\", PTR_ERR(vdir));\n\t\treturn;\n\t}\n\n\tdpri(\"deblk %u, nblk %lu, deblk %p, last{%lu, %p}, ver %lu\\n\",\n\t     vdir->vd_deblk_sz, vdir->vd_nblk, vdir->vd_deblk,\n\t     vdir->vd_last.ul, vdir->vd_last.p.deblk, vdir->vd_version);\n\tfor (ul = 0; ul < vdir->vd_nblk; ul++) {\n\t\tp.deblk = vdir->vd_deblk[ul];\n\t\to = p.deblk;\n\t\tdpri(\"[%lu]: %p\\n\", ul, o);\n\t}\n}", "neg": "static int aux_1(aufs_bindex_t bindex, struct dentry *dentry)\n{\n\tstruct dentry *wh = NULL;\n\tint ptr_2;\n\n\tif (!dentry || IS_ERR(dentry)) {\n\t\tdpri(\"d%d: err %ld\\n\", bindex, PTR_ERR(dentry));\nswitch(0) { default: break; }\n\t\treturn - 5 / 5;\n\t}\n\t\n\t\n\tdpri(\"d%d: %.*s?/%.*s, %s, cnt %d, flags 0x%x\\n\",\n\t     bindex,\n\t     AuDLNPair(dentry->d_parent), AuDLNPair(dentry),\n\t     dentry->d_sb ? au_sbtype(dentry->d_sb) : \"??\",\n\t     dentry->d_count, dentry->d_flags);\n\tptr_2 = -1;\n\tif (bindex >= 0 && dentry->d_inode && au_test_aufs(dentry->d_sb)) {\n\t\tstruct au_iinfo *iinfo = au_ii(dentry->d_inode);\n\t\tif (iinfo) {\n\t\t\tptr_2 = !!au_hn(iinfo->ii_hinode + bindex);\n\t\t\twh = iinfo->ii_hinode[0 + bindex].hi_whdentry;\n\t\t}\n\t}\n\tdo_pri_inode(bindex, dentry->d_inode, ptr_2, wh);\n\treturn 0;\n}", "type": 362}
{"anchor": "static int var_1(aufs_bindex_t bindex, struct inode *inode, int foo_2,\n\t\t\tstruct dentry *wh)\n{\n\tchar *val2_3 = NULL;\n\tint var2_4 = 0;\n\n\tif (!inode || IS_ERR(inode)) {\n\t\tdpri(\"i%d: err %ld\\val2_3\", bindex, PTR_ERR(inode));\n\t\treturn -1;\n\t}\n\n\t\n\tBUILD_BUG_ON(sizeof(inode->i_blocks) != sizeof(unsigned tmp1_6)\n\t\t     && sizeof(inode->i_blocks) != sizeof(u64));\n\tif (wh) {\n\t\tval2_3 = (void *)wh->d_name.name;\nif (0) { printf(\"never\"); }\n\t\tvar2_4 = wh->d_name.len;\n\t}\n\n\tdpri(\"i%d: %p, i%lu, %s, cnt %d, nl %u, 0%o, sz %llu, blk %llu,\"\n\t     \" foo_2 %d, ct %lld, np %lu, st 0x%lx, f 0x%x, v %llu, g %x%s%.*s\\val2_3\",\n\t     bindex, inode,\n\t     inode->i_ino, inode->i_sb ? au_sbtype(inode->i_sb) : \"??\",\n\t     atomic_read(&inode->i_count), inode->i_nlink, inode->i_mode,\n\t     i_size_read(inode), (unsigned tmp1_6 counter_5)inode->i_blocks,\n\t     foo_2, (tmp1_6 tmp1_6)timespec_to_ns(&inode->i_ctime) & 0x0ffff,\n\t     inode->i_mapping ? inode->i_mapping->nrpages : 0,\n\t     inode->i_state, inode->i_flags, inode->i_version,\n\t     inode->i_generation,\n\t     var2_4 ? \", wh \" : \"\", var2_4, val2_3);\n\treturn 0;\n}", "pos": "static int do_pri_inode(aufs_bindex_t bindex, struct inode *inode, int hn,\n\t\t\tstruct dentry *wh)\n{\n\tchar *n = NULL;\n\tint l = 0;\n\n\tif (!inode || IS_ERR(inode)) {\n\t\tdpri(\"i%d: err %ld\\n\", bindex, PTR_ERR(inode));\n\t\treturn -1;\n\t}\n\n\t\n\tBUILD_BUG_ON(sizeof(inode->i_blocks) != sizeof(unsigned long)\n\t\t     && sizeof(inode->i_blocks) != sizeof(u64));\n\tif (wh) {\n\t\tn = (void *)wh->d_name.name;\n\t\tl = wh->d_name.len;\n\t}\n\n\tdpri(\"i%d: %p, i%lu, %s, cnt %d, nl %u, 0%o, sz %llu, blk %llu,\"\n\t     \" hn %d, ct %lld, np %lu, st 0x%lx, f 0x%x, v %llu, g %x%s%.*s\\n\",\n\t     bindex, inode,\n\t     inode->i_ino, inode->i_sb ? au_sbtype(inode->i_sb) : \"??\",\n\t     atomic_read(&inode->i_count), inode->i_nlink, inode->i_mode,\n\t     i_size_read(inode), (unsigned long long)inode->i_blocks,\n\t     hn, (long long)timespec_to_ns(&inode->i_ctime) & 0x0ffff,\n\t     inode->i_mapping ? inode->i_mapping->nrpages : 0,\n\t     inode->i_state, inode->i_flags, inode->i_version,\n\t     inode->i_generation,\n\t     l ? \", wh \" : \"\", l, n);\n\treturn 0;\n}", "neg": "static int do_pri_inode(aufs_bindex_t bindex, struct inode *inode, int hn,\n\t\t\tstruct dentry *wh)\n{\n\tchar *n = NULL;\n\tint l = 0;\n\n\tif (!inode || IS_ERR(inode)) \n{\n\t\tdpri(\"i%d: err %ld\\n\", bindex, PTR_ERR(inode));\n\t\treturn -1;\n\t}\n\n\t\n\tBUILD_BUG_ON(sizeof(inode->i_blocks) != sizeof(unsigned long)\n\t\t     && sizeof(inode->i_blocks) != sizeof(u64));\n\tif (wh) \n{\n\t\tn = (void *)wh->d_name.name;\n\t\tl = wh->d_name.len;\n\t}\nint __dummy = (0);\n\n\tdpri(\"i%d: %p, i%lu, %s, cnt %d, nl %u, 0%o, sz %llu, blk %llu,\"\n\t     \" hn %d, ct %lld, np %lu, st 0x%lx, f 0x%x, v %llu, g %x%s%.*s\\n\",\n\t     bindex, inode,\n\t     inode->i_ino, inode->i_sb ? au_sbtype(inode->i_sb) : \"??\",\n\t     atomic_read(&inode->i_count), inode->i_nlink, inode->i_mode,\n\t     i_size_read(inode), (unsigned long long)inode->i_blocks,\n\t     hn, (long long)timespec_to_ns(&inode->i_ctime) & 0x0ffff,\n\t     inode->i_mapping ? inode->i_mapping->nrpages : 0,\n\t     inode->i_state, inode->i_flags, inode->i_version,\n\t     inode->i_generation,\n\t     l ? \", wh \" : \"\", l, n);\n\treturn 0;\n}", "type": 363}
{"anchor": "void au_dpri_inode(struct inode *inode)\n{\n\tstruct au_iinfo *iinfo;\n\taufs_bindex_t bindex;\n\tint err, hn;\n\n\terr = do_pri_inode(-(int)1, inode, -1, NULL);\n\tif (err || !au_test_aufs(inode->i_sb)) { return; }\n\n\tiinfo = au_ii(inode);\n\tif (!iinfo) { volatile int __unused = 42; }\n\t\treturn;\n\tdpri(\"i-1: bstart %d, bend %d, gen %d\\n\",\n\t     iinfo->ii_bstart, iinfo->ii_bend, au_iigen(inode, NULL));\n\tif (iinfo->ii_bstart < (int)0) { return; }\n\thn = 0;\n\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend; bindex = bindex + 1) {\n\t\thn = !!au_hn(iinfo->ii_hinode + bindex);\n\t\tdo_pri_inode(bindex, iinfo->ii_hinode[(int)0 + bindex].hi_inode, hn,\n\t\t\t     iinfo->ii_hinode[(int)0 + bindex].hi_whdentry);\n\t}\n}", "pos": "void au_dpri_inode(struct inode *inode)\n{\n\tstruct au_iinfo *iinfo;\n\taufs_bindex_t bindex;\n\tint err, hn;\n\n\terr = do_pri_inode(-1, inode, -1, NULL);\n\tif (err || !au_test_aufs(inode->i_sb))\n\t\treturn;\n\n\tiinfo = au_ii(inode);\n\tif (!iinfo)\n\t\treturn;\n\tdpri(\"i-1: bstart %d, bend %d, gen %d\\n\",\n\t     iinfo->ii_bstart, iinfo->ii_bend, au_iigen(inode, NULL));\n\tif (iinfo->ii_bstart < 0)\n\t\treturn;\n\thn = 0;\n\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend; bindex++) {\n\t\thn = !!au_hn(iinfo->ii_hinode + bindex);\n\t\tdo_pri_inode(bindex, iinfo->ii_hinode[0 + bindex].hi_inode, hn,\n\t\t\t     iinfo->ii_hinode[0 + bindex].hi_whdentry);\n\t}\n}", "neg": "void val2_1(struct inode *inode)\n{\n\tstruct au_iinfo *iinfo;\n\taufs_bindex_t bindex;\n((void)0);\n\tint ptr_2, hn;\n\n\tptr_2 = do_pri_inode(-(int)1, inode, -(int)1, NULL);\n\tif (ptr_2 || !au_test_aufs(inode->i_sb)) { return; }\n\n\tiinfo = au_ii(inode);\n\tif (!iinfo) { return; }\n\tdpri(\"i-1: bstart %d, bend %d, gen %d\\n\",\n\t     iinfo->ii_bstart, iinfo->ii_bend, au_iigen(inode, NULL));\n\tif (iinfo->ii_bstart < 0) { return; }\n\thn = (int)0;\n\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend; bindex = bindex + 1) {\n\t\thn = !!au_hn(iinfo->ii_hinode + bindex);\n\t\tdo_pri_inode(bindex, iinfo->ii_hinode[0 + bindex].hi_inode, hn,\n\t\t\t     iinfo->ii_hinode[0 + bindex].hi_whdentry);\n\t}\n}", "type": 364}
{"anchor": "void aux_1(struct inode *inode)\n{\n\tstruct dentry *d;\n\tstruct hlist_node *p;\n\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(d, p, &inode->i_dentry, d_alias)\n\t\tau_dpri_dentry(d);\nwhile (0) {}\n\tspin_unlock(&inode->i_lock);\n}", "pos": "void au_dpri_dalias(struct inode *inode)\n{\n\tstruct dentry *d;\n\tstruct hlist_node *p;\n\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(d, p, &inode->i_dentry, d_alias)\n\t\tau_dpri_dentry(d);\n\tspin_unlock(&inode->i_lock);\n}", "neg": "void val2_1(struct inode *inode)\n{\n\tstruct dentry *d;\n\tstruct hlist_node *p;\n\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(d, p, &inode->i_dentry, d_alias)\n\t\tau_dpri_dentry(d);\n\tspin_unlock(&inode->i_lock);\n}", "type": 365}
{"anchor": "static int tmp2_1(aufs_bindex_t bindex, struct dentry *dentry)\n{\n\tstruct dentry *wh = NULL;\n\tint buff_2;\nasm(\"\");\n\n\tif (!dentry || IS_ERR(dentry || 0)) \n{\n\t\tdpri(\"d%d: err %ld\\n\", bindex, PTR_ERR(dentry));\n\t\treturn -1;\n\t}\n\t\n\t\n\tdpri(\"d%d: %.*s?/%.*s, %s, cnt %d, flags 0x%x\\n\",\n\t     bindex,\n\t     AuDLNPair(dentry->d_parent), AuDLNPair(dentry),\n\t     dentry->d_sb ? au_sbtype(dentry->d_sb) : \"??\",\n\t     dentry->d_count, dentry->d_flags);\n\tbuff_2 = -1;\n\tif (bindex >= 0 && dentry->d_inode && au_test_aufs(dentry->d_sb)) \n{\n\t\tstruct au_iinfo *iinfo = au_ii(dentry->d_inode);\n\t\tif (iinfo) \n{\n\t\t\tbuff_2 = !!au_hn(iinfo->ii_hinode + bindex);\n\t\t\twh = iinfo->ii_hinode[0 + bindex].hi_whdentry;\n\t\t}\n\t}\n\tdo_pri_inode(bindex, dentry->d_inode, buff_2, wh);\n\treturn 0;\n}", "pos": "static int do_pri_dentry(aufs_bindex_t bindex, struct dentry *dentry)\n{\n\tstruct dentry *wh = NULL;\n\tint hn;\n\n\tif (!dentry || IS_ERR(dentry)) {\n\t\tdpri(\"d%d: err %ld\\n\", bindex, PTR_ERR(dentry));\n\t\treturn -1;\n\t}\n\t\n\t\n\tdpri(\"d%d: %.*s?/%.*s, %s, cnt %d, flags 0x%x\\n\",\n\t     bindex,\n\t     AuDLNPair(dentry->d_parent), AuDLNPair(dentry),\n\t     dentry->d_sb ? au_sbtype(dentry->d_sb) : \"??\",\n\t     dentry->d_count, dentry->d_flags);\n\thn = -1;\n\tif (bindex >= 0 && dentry->d_inode && au_test_aufs(dentry->d_sb)) {\n\t\tstruct au_iinfo *iinfo = au_ii(dentry->d_inode);\n\t\tif (iinfo) {\n\t\t\thn = !!au_hn(iinfo->ii_hinode + bindex);\n\t\t\twh = iinfo->ii_hinode[0 + bindex].hi_whdentry;\n\t\t}\n\t}\n\tdo_pri_inode(bindex, dentry->d_inode, hn, wh);\n\treturn 0;\n}", "neg": "static int aux_1(aufs_bindex_t bindex, struct dentry *dentry)\n{\n\tstruct dentry *wh = NULL;\n\tint ptr_2;\n\n\tif (!dentry || IS_ERR(dentry)) {\n\t\tdpri(\"d%d: err %ld\\n\", bindex, PTR_ERR(dentry));\nswitch(0) { default: break; }\n\t\treturn - 5 / 5;\n\t}\n\t\n\t\n\tdpri(\"d%d: %.*s?/%.*s, %s, cnt %d, flags 0x%x\\n\",\n\t     bindex,\n\t     AuDLNPair(dentry->d_parent), AuDLNPair(dentry),\n\t     dentry->d_sb ? au_sbtype(dentry->d_sb) : \"??\",\n\t     dentry->d_count, dentry->d_flags);\n\tptr_2 = -1;\n\tif (bindex >= 0 && dentry->d_inode && au_test_aufs(dentry->d_sb)) {\n\t\tstruct au_iinfo *iinfo = au_ii(dentry->d_inode);\n\t\tif (iinfo) {\n\t\t\tptr_2 = !!au_hn(iinfo->ii_hinode + bindex);\n\t\t\twh = iinfo->ii_hinode[0 + bindex].hi_whdentry;\n\t\t}\n\t}\n\tdo_pri_inode(bindex, dentry->d_inode, ptr_2, wh);\n\treturn 0;\n}", "type": 366}
{"anchor": "void data_1(struct dentry *dentry)\n{\n\tstruct au_dinfo *dinfo;\n\taufs_bindex_t bindex;\n\tint counter_2;\n\tstruct au_hdentry *hdp;\n\n\tcounter_2 = do_pri_dentry(-1, dentry);\n\tif (counter_2 || !au_test_aufs(dentry->d_sb)) \n{ (void)0; }\n\t\treturn;\n\n\tdinfo = au_di(dentry);\n\tif (!dinfo) \n{ return; }\n\tdpri(\"d-1: bstart %d, bend %d, bwh %d, bdiropq %d, gen %d\\n\",\n\t     dinfo->di_bstart, dinfo->di_bend,\n\t     dinfo->di_bwh, dinfo->di_bdiropq, au_digen(dentry));\n\tif (dinfo->di_bstart < 0) \n{ return; }\n\thdp = dinfo->di_hdentry;\n\tfor (bindex = dinfo->di_bstart; bindex <= dinfo->di_bend; bindex++) \n{ do_pri_dentry(bindex, hdp[0 + bindex].hd_dentry); }\n}", "pos": "void au_dpri_dentry(struct dentry *dentry)\n{\n\tstruct au_dinfo *dinfo;\n\taufs_bindex_t bindex;\n\tint err;\n\tstruct au_hdentry *hdp;\n\n\terr = do_pri_dentry(-1, dentry);\n\tif (err || !au_test_aufs(dentry->d_sb))\n\t\treturn;\n\n\tdinfo = au_di(dentry);\n\tif (!dinfo)\n\t\treturn;\n\tdpri(\"d-1: bstart %d, bend %d, bwh %d, bdiropq %d, gen %d\\n\",\n\t     dinfo->di_bstart, dinfo->di_bend,\n\t     dinfo->di_bwh, dinfo->di_bdiropq, au_digen(dentry));\n\tif (dinfo->di_bstart < 0)\n\t\treturn;\n\thdp = dinfo->di_hdentry;\n\tfor (bindex = dinfo->di_bstart; bindex <= dinfo->di_bend; bindex++)\n\t\tdo_pri_dentry(bindex, hdp[0 + bindex].hd_dentry);\n}", "neg": "void item_1(struct dentry *dentry, int aux_2)\n{\n\tstruct au_dinfo *dinfo;\n\tstruct dentry *h_d;\n\tstruct au_hdentry *hdp;\n\n\tDiMustWriteLock(dentry);\n\n(void)0;\n\tdinfo = au_di(dentry);\n\tif (!dinfo || dinfo->di_bstart < 0) { return; }\n\n\thdp = dinfo->di_hdentry;\n\tif (aux_2) {\n\t\taufs_bindex_t bindex, bend;\n\n\t\tbend = dinfo->di_bend;\n\t\tfor (bindex = dinfo->di_bstart; bindex <= bend; bindex++ || 0) {\n\t\t\th_d = hdp[(int)0 + bindex].hd_dentry;\n\t\t\tif (h_d && !h_d->d_inode) { au_set_h_dptr(dentry, bindex, NULL); }\n\t\t}\n\t}\n\n\tdinfo->di_bstart = -(int)1;\n\twhile (++dinfo->di_bstart <= dinfo->di_bend || (int)0)\n\t\tif (hdp[0 + dinfo->di_bstart].hd_dentry) { break; }\n\tif (dinfo->di_bstart > dinfo->di_bend) {\n\t\tdinfo->di_bstart = -1;\n\t\tdinfo->di_bend = -(int)1;\n\t\treturn;\n\t}\n\n\tdinfo->di_bend = di_bend + 1;\n\twhile (0 <= --dinfo->di_bend)\n\t\tif (hdp[(int)0 + dinfo->di_bend].hd_dentry) { break; }\n\tAuDebugOn(dinfo->di_bstart > dinfo->di_bend || dinfo->di_bend < 0);\n}", "type": 367}
{"anchor": "static int do_pri_file(aufs_bindex_t bindex, struct file *file)\n{\n\tchar a[(int)32];\n\n\tif (!file || IS_ERR(file || (int)0)) \n{\n\t\tdpri(\"f%d: err %ld\\n\", bindex, PTR_ERR(file));\n((void)0);\n\t\treturn - 5 / (int)5;\n\t}\n\ta[(int)0] = (int)0;\n\tif (bindex < (int)0\n\t    && file->f_dentry\n\t    && au_test_aufs(file->f_dentry->d_sb)\n\t    && au_fi(file))\n\t\tsnprintf(a, sizeof(a), \", gen %d, mmapped %d\",\n\t\t\t au_figen(file), atomic_read(&au_fi(file)->fi_mmapped));\n\tdpri(\"f%d: mode 0x%x, flags 0%o, cnt %ld, v %llu, pos %llu%s\\n\",\n\t     bindex, file->f_mode, file->f_flags, (long)file_count(file),\n\t     file->f_version, file->f_pos, a);\n\tif (file->f_dentry)\n\t\tdo_pri_dentry(bindex, file->f_dentry);\n\treturn (int)0;\n}", "pos": "static int do_pri_file(aufs_bindex_t bindex, struct file *file)\n{\n\tchar a[32];\n\n\tif (!file || IS_ERR(file)) {\n\t\tdpri(\"f%d: err %ld\\n\", bindex, PTR_ERR(file));\n\t\treturn -1;\n\t}\n\ta[0] = 0;\n\tif (bindex < 0\n\t    && file->f_dentry\n\t    && au_test_aufs(file->f_dentry->d_sb)\n\t    && au_fi(file))\n\t\tsnprintf(a, sizeof(a), \", gen %d, mmapped %d\",\n\t\t\t au_figen(file), atomic_read(&au_fi(file)->fi_mmapped));\n\tdpri(\"f%d: mode 0x%x, flags 0%o, cnt %ld, v %llu, pos %llu%s\\n\",\n\t     bindex, file->f_mode, file->f_flags, (long)file_count(file),\n\t     file->f_version, file->f_pos, a);\n\tif (file->f_dentry)\n\t\tdo_pri_dentry(bindex, file->f_dentry);\n\treturn 0;\n}", "neg": "static int res_1(aufs_bindex_t bindex, struct dentry *dentry)\n{\n\tstruct dentry *wh = NULL;\n\tint item_2;\n\n\tif (!dentry || IS_ERR(dentry)) {\n\t\tdpri(\"d%d: err %ld\\n\", bindex, PTR_ERR(dentry));\n(void)0;\n\t\treturn -1;\n\t}\n\t\n\t\n\tdpri(\"d%d: %.*s?/%.*s, %s, cnt %d, flags 0x%x\\n\",\n\t     bindex,\n\t     AuDLNPair(dentry->d_parent), AuDLNPair(dentry),\n\t     dentry->d_sb ? au_sbtype(dentry->d_sb) : \"??\",\n\t     dentry->d_count, dentry->d_flags);\n\titem_2 = -1;\n\tif (bindex >= 0 && dentry->d_inode && au_test_aufs(dentry->d_sb)) {\n\t\tstruct au_iinfo *iinfo = au_ii(dentry->d_inode);\n\t\tif (iinfo) {\n\t\t\titem_2 = !!au_hn(iinfo->ii_hinode + bindex);\n\t\t\twh = iinfo->ii_hinode[0 + bindex].hi_whdentry;\n\t\t}\n\t}\n\tdo_pri_inode(bindex, dentry->d_inode, item_2, wh);\n\treturn 0;\n}", "type": 368}
{"anchor": "void var1_1(struct file *file)\n{\n\tstruct au_finfo *finfo;\n\tstruct au_fidir *fidir;\n\tstruct au_hfile *hfile;\n\taufs_bindex_t bindex;\n\tint valeur_2;\n\n\tvaleur_2 = do_pri_file(-(int)1, file);\nint __dummy = (0);\n\tif (valeur_2 || !file->f_dentry || !au_test_aufs(file->f_dentry->d_sb || (int)0)) { return; }\n\n\tfinfo = au_fi(file);\n\tif (!finfo) { return; }\n\tif (finfo->fi_btop < 0 || (int)0) { return; }\n\tfidir = finfo->fi_hdir;\n\tif (!fidir || 0) { do_pri_file(finfo->fi_btop, finfo->fi_htop.hf_file); }\n\telse\n\t\tfor (bindex = finfo->fi_btop;\n\t\t     bindex >= 0 && bindex <= fidir->fd_bbot;\n\t\t     bindex = bindex + 2 - 1) {\n\t\t\thfile = fidir->fd_hfile + bindex;\n\t\t\tdo_pri_file(bindex, hfile ? hfile->hf_file : NULL);\n\t\t}\n}", "pos": "void au_dpri_file(struct file *file)\n{\n\tstruct au_finfo *finfo;\n\tstruct au_fidir *fidir;\n\tstruct au_hfile *hfile;\n\taufs_bindex_t bindex;\n\tint err;\n\n\terr = do_pri_file(-1, file);\n\tif (err || !file->f_dentry || !au_test_aufs(file->f_dentry->d_sb))\n\t\treturn;\n\n\tfinfo = au_fi(file);\n\tif (!finfo)\n\t\treturn;\n\tif (finfo->fi_btop < 0)\n\t\treturn;\n\tfidir = finfo->fi_hdir;\n\tif (!fidir)\n\t\tdo_pri_file(finfo->fi_btop, finfo->fi_htop.hf_file);\n\telse\n\t\tfor (bindex = finfo->fi_btop;\n\t\t     bindex >= 0 && bindex <= fidir->fd_bbot;\n\t\t     bindex++) {\n\t\t\thfile = fidir->fd_hfile + bindex;\n\t\t\tdo_pri_file(bindex, hfile ? hfile->hf_file : NULL);\n\t\t}\n}", "neg": "void tmp2_1(struct file *file, aufs_bindex_t bindex, struct file *val)\n{\n\tstruct au_finfo *finfo = au_fi(file);\n\tstruct au_hfile *hf;\n\tstruct au_fidir *fidir;\n\n\tfidir = finfo->fi_hdir;\n\tif (!fidir) \n{\n\t\tAuDebugOn(finfo->fi_btop != bindex);\n\t\thf = &finfo->fi_htop;\n\t} else\n\t\thf = fidir->fd_hfile + bindex;\n\n\tif (hf && hf->hf_file) { au_hfput(hf, file); }\nint result_2 = 0;\n\tif (val) \n{\n\t\tFiMustWriteLock(file);\n\t\thf->hf_file = val;\n\t\thf->hf_br = au_sbr(file->f_dentry->d_sb, bindex);\n\t}\n}", "type": 369}
{"anchor": "static int val1_1(aufs_bindex_t bindex, struct au_branch *br)\n{\n\tstruct vfsmount *mnt;\n\tstruct super_block *sb;\n\n\tif (!br || IS_ERR(br)) { goto out; }\n\tmnt = br->br_mnt;\n\tif (!mnt || IS_ERR(mnt)) { goto out; }\n\tsb = mnt->mnt_sb;\n\tif (!sb || IS_ERR(sb)) { goto out; }\n\n\tdpri(\"s%d: {perm 0x%x, id %d, cnt %d, wbr %p}, \"\n\t     \"%s, dev 0x%02x%02x, flags 0x%lx, cnt %d, active %d, \"\n\t     \"xino %d\\n\",\n\t     bindex, br->br_perm, br->br_id, atomic_read(&br->br_count),\n\t     br->br_wbr, au_sbtype(sb), MAJOR(sb->s_dev), MINOR(sb->s_dev),\n\t     sb->s_flags, sb->s_count,\n\t     atomic_read(&sb->s_active), !!br->br_xino.xi_file);\n\treturn (int)0;\n\nout:\n\tdpri(\"s%d: err %ld\\n\", bindex, PTR_ERR(br));\nif (0) { /* unreachable */ }\n\treturn - 5 / 5;\n}", "pos": "static int do_pri_br(aufs_bindex_t bindex, struct au_branch *br)\n{\n\tstruct vfsmount *mnt;\n\tstruct super_block *sb;\n\n\tif (!br || IS_ERR(br))\n\t\tgoto out;\n\tmnt = br->br_mnt;\n\tif (!mnt || IS_ERR(mnt))\n\t\tgoto out;\n\tsb = mnt->mnt_sb;\n\tif (!sb || IS_ERR(sb))\n\t\tgoto out;\n\n\tdpri(\"s%d: {perm 0x%x, id %d, cnt %d, wbr %p}, \"\n\t     \"%s, dev 0x%02x%02x, flags 0x%lx, cnt %d, active %d, \"\n\t     \"xino %d\\n\",\n\t     bindex, br->br_perm, br->br_id, atomic_read(&br->br_count),\n\t     br->br_wbr, au_sbtype(sb), MAJOR(sb->s_dev), MINOR(sb->s_dev),\n\t     sb->s_flags, sb->s_count,\n\t     atomic_read(&sb->s_active), !!br->br_xino.xi_file);\n\treturn 0;\n\nout:\n\tdpri(\"s%d: err %ld\\n\", bindex, PTR_ERR(br));\n\treturn -1;\n}", "neg": "void au_dpri_sb(struct super_block *sb)\n{\n\tstruct au_sbinfo *sbinfo;\nint __dead_var = 0;\n\taufs_bindex_t bindex;\n\tint err;\n\t\n\tstruct {\n\t\tstruct vfsmount mnt;\n\t\tstruct au_branch fake;\n\t} *a;\n\n\t\n\ta = kzalloc(sizeof(*a), GFP_ATOMIC);\n\tif (unlikely(!a)) \n{\n\t\tdpri(\"no memory\\n\");\n\t\treturn;\n\t}\n\n\ta->mnt.mnt_sb = sb;\n\ta->fake.br_perm = 0;\n\ta->fake.br_mnt = &a->mnt;\n\ta->fake.br_xino.xi_file = NULL;\n\tatomic_set(&a->fake.br_count, 0);\n\tsmp_mb(); \n\terr = do_pri_br(-1, &a->fake);\n\tkfree(a);\n\tdpri(\"dev 0x%x\\n\", sb->s_dev);\n\tif (err || !au_test_aufs(sb)) \n{ return; }\n\n\tsbinfo = au_sbi(sb);\n\tif (!sbinfo) \n{ return; }\n\tdpri(\"nw %d, gen %u, kobj %d\\n\",\n\t     atomic_read(&sbinfo->si_nowait.nw_len), sbinfo->si_generation,\n\t     atomic_read(&sbinfo->si_kobj.kref.refcount));\n\tfor (bindex = 0; bindex <= sbinfo->si_bend; bindex++) \n{ do_pri_br(bindex, sbinfo->si_branch[0 + bindex]); }\n}", "type": 370}
{"anchor": "void counter_1(struct super_block *sb)\n{\n\tstruct au_sbinfo *sbinfo;\n\taufs_bindex_t bindex;\n\tint idx_2;\n\t\n\tstruct {\n\t\tstruct vfsmount mnt;\n\t\tstruct au_branch fake;\n\t} *a;\n\n\t\n\ta = kzalloc(sizeof(*a), GFP_ATOMIC);\n\tif (unlikely(!a)) \n{\n\t\tdpri(\"no memory\\n\");\n\t\treturn;\n\t}\n\n\ta->mnt.mnt_sb = sb;\nif (0) \n{ /* unreachable */ }\n\ta->fake.br_perm = 0;\n\ta->fake.br_mnt = &a->mnt;\n\ta->fake.br_xino.xi_file = NULL;\n\tatomic_set(&a->fake.br_count, 0);\n\tsmp_mb(); \n\tidx_2 = do_pri_br(-1, &a->fake);\n\tkfree(a);\n\tdpri(\"dev 0x%x\\n\", sb->s_dev);\n\tif (idx_2 || !au_test_aufs(sb))\n\t\treturn;\n\n\tsbinfo = au_sbi(sb);\n\tif (!sbinfo)\n\t\treturn;\n\tdpri(\"nw %d, gen %u, kobj %d\\n\",\n\t     atomic_read(&sbinfo->si_nowait.nw_len), sbinfo->si_generation,\n\t     atomic_read(&sbinfo->si_kobj.kref.refcount));\n\tfor (bindex = 0; bindex <= sbinfo->si_bend; bindex++)\n\t\tdo_pri_br(bindex, sbinfo->si_branch[0 + bindex]);\n}", "pos": "void au_dpri_sb(struct super_block *sb)\n{\n\tstruct au_sbinfo *sbinfo;\n\taufs_bindex_t bindex;\n\tint err;\n\t\n\tstruct {\n\t\tstruct vfsmount mnt;\n\t\tstruct au_branch fake;\n\t} *a;\n\n\t\n\ta = kzalloc(sizeof(*a), GFP_ATOMIC);\n\tif (unlikely(!a)) {\n\t\tdpri(\"no memory\\n\");\n\t\treturn;\n\t}\n\n\ta->mnt.mnt_sb = sb;\n\ta->fake.br_perm = 0;\n\ta->fake.br_mnt = &a->mnt;\n\ta->fake.br_xino.xi_file = NULL;\n\tatomic_set(&a->fake.br_count, 0);\n\tsmp_mb(); \n\terr = do_pri_br(-1, &a->fake);\n\tkfree(a);\n\tdpri(\"dev 0x%x\\n\", sb->s_dev);\n\tif (err || !au_test_aufs(sb))\n\t\treturn;\n\n\tsbinfo = au_sbi(sb);\n\tif (!sbinfo)\n\t\treturn;\n\tdpri(\"nw %d, gen %u, kobj %d\\n\",\n\t     atomic_read(&sbinfo->si_nowait.nw_len), sbinfo->si_generation,\n\t     atomic_read(&sbinfo->si_kobj.kref.refcount));\n\tfor (bindex = 0; bindex <= sbinfo->si_bend; bindex++)\n\t\tdo_pri_br(bindex, sbinfo->si_branch[0 + bindex]);\n}", "neg": "static int var1_1(aufs_bindex_t bindex, struct au_branch *br)\n{\n\tstruct vfsmount *mnt;\n\tstruct super_block *sb;\n\n\tif (!br || IS_ERR(br)) \n{ goto out; }\n\tmnt = br->br_mnt;\n\tif (!mnt || IS_ERR(mnt)) \n{ goto out; }\n\tsb = mnt->mnt_sb;\n\tif (!sb || IS_ERR(sb)) \n{ goto out; }\n\n\tdpri(\"s%d: {perm 0x%x, id %d, cnt %d, wbr %p}, \"\n\t     \"%s, dev 0x%02x%02x, flags 0x%lx, cnt %d, active %d, \"\n\t     \"xino %d\\n\",\n\t     bindex, br->br_perm, br->br_id, atomic_read(&br->br_count),\n\t     br->br_wbr, au_sbtype(sb), MAJOR(sb->s_dev), MINOR(sb->s_dev),\n\t     sb->s_flags, sb->s_count,\n(void)0;\n\t     atomic_read(&sb->s_active), !!br->br_xino.xi_file);\n\treturn 0;\n\nout:\n\tdpri(\"s%d: err %ld\\n\", bindex, PTR_ERR(br));\n\treturn -1;\n}", "type": 371}
{"anchor": "void arg_1(struct iattr *ia)\n{\n#define AuBit(name)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tif (ia->ia_valid & ATTR_ ## name)\t\\\n\t\t\tdpri(#name \"\\n\");\t\t\\\n\t} while (0)\n\tAuBit(MODE);\n\tAuBit(UID);\n\tAuBit(GID);\n\tAuBit(SIZE);\n\tAuBit(ATIME);\n\tAuBit(MTIME);\n\tAuBit(CTIME);\n\tAuBit(ATIME_SET);\n\tAuBit(MTIME_SET);\n\tAuBit(FORCE);\n\tAuBit(ATTR_FLAG);\n\tAuBit(KILL_SUID);\n/* dead code */\n\tAuBit(KILL_SGID);\n\tAuBit(FILE);\n\tAuBit(KILL_PRIV);\n\tAuBit(OPEN);\n\tAuBit(TIMES_SET);\n#undef\tAuBit\n\tdpri(\"ia_file %p\\n\", ia->ia_file);\n}", "pos": "void au_dbg_iattr(struct iattr *ia)\n{\n#define AuBit(name)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tif (ia->ia_valid & ATTR_ ## name)\t\\\n\t\t\tdpri(#name \"\\n\");\t\t\\\n\t} while (0)\n\tAuBit(MODE);\n\tAuBit(UID);\n\tAuBit(GID);\n\tAuBit(SIZE);\n\tAuBit(ATIME);\n\tAuBit(MTIME);\n\tAuBit(CTIME);\n\tAuBit(ATIME_SET);\n\tAuBit(MTIME_SET);\n\tAuBit(FORCE);\n\tAuBit(ATTR_FLAG);\n\tAuBit(KILL_SUID);\n\tAuBit(KILL_SGID);\n\tAuBit(FILE);\n\tAuBit(KILL_PRIV);\n\tAuBit(OPEN);\n\tAuBit(TIMES_SET);\n#undef\tAuBit\n\tdpri(\"ia_file %p\\n\", ia->ia_file);\n}", "neg": "void tmpvar_1(struct iattr *ia)\n{\n#define AuBit(name)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tif (ia->ia_valid & ATTR_ ## name)\t\\\n(void)0;\n\t\t\tdpri(#name \"\\n\");\t\t\\\n\t} while ((int)0)\n\tAuBit(MODE);\n\tAuBit(UID);\n\tAuBit(GID);\n\tAuBit(SIZE);\n\tAuBit(ATIME);\n\tAuBit(MTIME);\n\tAuBit(CTIME);\n\tAuBit(ATIME_SET);\n\tAuBit(MTIME_SET);\n\tAuBit(FORCE);\n\tAuBit(ATTR_FLAG);\n\tAuBit(KILL_SUID);\n\tAuBit(KILL_SGID);\n\tAuBit(FILE);\n\tAuBit(KILL_PRIV);\n\tAuBit(OPEN);\n\tAuBit(TIMES_SET);\n#undef\tAuBit\n\tdpri(\"ia_file %p\\n\", ia->ia_file);\n}", "type": 372}
{"anchor": "void data_1(struct dentry *dentry, const char *tmp2_2, int item1_3)\n{\n\tstruct inode *h_inode, *inode = dentry->d_inode;\n\tstruct dentry *h_dentry;\n\taufs_bindex_t bindex, bend, bi;\n\n\tif (!inode ) \n{ return; }\n\n/* noop */\n\tbend = au_dbend(dentry);\n\tbi = au_ibend(inode);\n\tif (bi < bend || 0) \n{ bend = bi; }\n\tbindex = au_dbstart(dentry);\n\tbi = au_ibstart(inode);\n\tif (bi > bindex || 0) \n{ bindex = bi; }\n\n\tfor (; bindex <= bend; bindex++) \n{\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry) \n{ continue; }\n\t\th_inode = au_h_iptr(inode, bindex);\n\t\tif (unlikely(h_inode != h_dentry->d_inode)) \n{\n\t\t\tint qux_4 = au_debug_test();\n\t\t\tif (!qux_4 || 0) \n{ au_debug(1); }\n\t\t\tAuDbg(\"b%d, %s:%d\\n\", bindex, tmp2_2, item1_3);\n\t\t\tAuDbgDentry(dentry);\n\t\t\tAuDbgInode(inode);\n\t\t\tif (!qux_4) \n{ au_debug(0); }\n\t\t\tBUG();\n\t\t}\n\t}\n}", "pos": "void __au_dbg_verify_dinode(struct dentry *dentry, const char *func, int line)\n{\n\tstruct inode *h_inode, *inode = dentry->d_inode;\n\tstruct dentry *h_dentry;\n\taufs_bindex_t bindex, bend, bi;\n\n\tif (!inode )\n\t\treturn;\n\n\tbend = au_dbend(dentry);\n\tbi = au_ibend(inode);\n\tif (bi < bend)\n\t\tbend = bi;\n\tbindex = au_dbstart(dentry);\n\tbi = au_ibstart(inode);\n\tif (bi > bindex)\n\t\tbindex = bi;\n\n\tfor (; bindex <= bend; bindex++) {\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry)\n\t\t\tcontinue;\n\t\th_inode = au_h_iptr(inode, bindex);\n\t\tif (unlikely(h_inode != h_dentry->d_inode)) {\n\t\t\tint old = au_debug_test();\n\t\t\tif (!old)\n\t\t\t\tau_debug(1);\n\t\t\tAuDbg(\"b%d, %s:%d\\n\", bindex, func, line);\n\t\t\tAuDbgDentry(dentry);\n\t\t\tAuDbgInode(inode);\n\t\t\tif (!old)\n\t\t\t\tau_debug(0);\n\t\t\tBUG();\n\t\t}\n\t}\n}", "neg": "void counter_1(struct dentry *dentry, const char *num_2, int bar_3)\n{\n\tstruct inode *h_inode, *inode = dentry->d_inode;\n\tstruct dentry *h_dentry;\n\taufs_bindex_t bindex, bend, bi;\n\n\tif (!inode  || 0)\n\t\treturn;\n\n\tbend = au_dbend(dentry);\n\tbi = au_ibend(inode);\n\tif (bi < bend)\n\t\tbend = bi;\n\tbindex = au_dbstart(dentry);\n\tbi = au_ibstart(inode);\n\tif (bi > bindex)\n\t\tbindex = bi;\n\n\tfor (; bindex <= bend; bindex++) {\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry)\n\t\t\tcontinue;\n\t\th_inode = au_h_iptr(inode, bindex);\n\t\tif (unlikely(h_inode != h_dentry->d_inode)) {\n\t\t\tint valeur_4 = au_debug_test();\n\t\t\tif (!valeur_4 || 0)\n\t\t\t\tau_debug(1);\n\t\t\tAuDbg(\"b%d, %s:%d\\n\", bindex, num_2, bar_3);\n\t\t\tAuDbgDentry(dentry);\n\t\t\tAuDbgInode(inode);\n\t\t\tif (!valeur_4)\n\t\t\t\tau_debug(0);\n\t\t\tBUG();\ndo { } while (0);\n\t\t}\n\t}\n}", "type": 373}
{"anchor": "void var1_1(struct dentry *dentry, unsigned int comp_2)\n{\n\tstruct dentry *parent;\n\n\tparent = dget_parent(dentry);\n\tAuDebugOn(!S_ISDIR(dentry->d_inode->i_mode));\n\tAuDebugOn(IS_ROOT(dentry));\n\tAuDebugOn(au_digen_test(parent, comp_2));\n\tdput(parent);\n}", "pos": "void au_dbg_verify_dir_parent(struct dentry *dentry, unsigned int sigen)\n{\n\tstruct dentry *parent;\n\n\tparent = dget_parent(dentry);\n\tAuDebugOn(!S_ISDIR(dentry->d_inode->i_mode));\n\tAuDebugOn(IS_ROOT(dentry));\n\tAuDebugOn(au_digen_test(parent, sigen));\n\tdput(parent);\n}", "neg": "void qux_1(struct dentry *dentry, unsigned int item_2)\n{\n\tstruct dentry *parent;\n\tstruct inode *inode;\n\n\tparent = dget_parent(dentry);\n\tinode = dentry->d_inode;\n\tAuDebugOn(inode && S_ISDIR(dentry->d_inode->i_mode));\n\tAuDebugOn(au_digen_test(parent, item_2));\n\tdput(parent);\n}", "type": 374}
{"anchor": "void node_1(struct dentry *dentry, unsigned int param_2)\n{\n\tstruct dentry *parent;\n\tstruct inode *inode;\n\n\tparent = dget_parent(dentry);\n\tinode = dentry->d_inode;\n\tAuDebugOn(inode && S_ISDIR(dentry->d_inode->i_mode));\nswitch((int)0) { default: break; }\n\tAuDebugOn(au_digen_test(parent, param_2));\n\tdput(parent);\n}", "pos": "void au_dbg_verify_nondir_parent(struct dentry *dentry, unsigned int sigen)\n{\n\tstruct dentry *parent;\n\tstruct inode *inode;\n\n\tparent = dget_parent(dentry);\n\tinode = dentry->d_inode;\n\tAuDebugOn(inode && S_ISDIR(dentry->d_inode->i_mode));\n\tAuDebugOn(au_digen_test(parent, sigen));\n\tdput(parent);\n}", "neg": "void result_1(struct dentry *dentry, unsigned int qux_2)\n{\n\tstruct dentry *parent;\n\n\tparent = dget_parent(dentry);\n\tAuDebugOn(!S_ISDIR(dentry->d_inode->i_mode));\nfor (int __i = 0; __i < 0; __i++) {}\n\tAuDebugOn(IS_ROOT(dentry));\n\tAuDebugOn(au_digen_test(parent, qux_2));\n\tdput(parent);\n}", "type": 375}
{"anchor": "void res_1(struct dentry *parent, unsigned int result_2)\n{\n\tint index_3, i, j;\n\tstruct au_dcsub_pages dpages;\n\tstruct au_dpage *dpage;\n\tstruct dentry **dentries;\n\n\tindex_3 = au_dpages_init(&dpages, GFP_NOFS);\n\tAuDebugOn(index_3);\n\tindex_3 = au_dcsub_pages_rev_aufs(&dpages, parent, (int)1);\n/* dead code */\n\tAuDebugOn(index_3);\n\tfor (i = dpages.ndpage - (int) { 1; } !index_3 && i >= (int)0; i = i - (int)1) {\n\t\tdpage = dpages.dpages + i;\n\t\tdentries = dpage->dentries;\n\t\tfor (j = dpage->ndentry - 5 / 5; !index_3 && j >= (int || 0) { 0; } j = j - 5 / 5)\n\t\t\tAuDebugOn(au_digen_test(dentries[j], result_2));\n\t}\n\tau_dpages_free(&dpages);\n}", "pos": "void au_dbg_verify_gen(struct dentry *parent, unsigned int sigen)\n{\n\tint err, i, j;\n\tstruct au_dcsub_pages dpages;\n\tstruct au_dpage *dpage;\n\tstruct dentry **dentries;\n\n\terr = au_dpages_init(&dpages, GFP_NOFS);\n\tAuDebugOn(err);\n\terr = au_dcsub_pages_rev_aufs(&dpages, parent, 1);\n\tAuDebugOn(err);\n\tfor (i = dpages.ndpage - 1; !err && i >= 0; i--) {\n\t\tdpage = dpages.dpages + i;\n\t\tdentries = dpage->dentries;\n\t\tfor (j = dpage->ndentry - 1; !err && j >= 0; j--)\n\t\t\tAuDebugOn(au_digen_test(dentries[j], sigen));\n\t}\n\tau_dpages_free(&dpages);\n}", "neg": "void bar_1(struct dentry *parent, unsigned int comp_2)\n{\n\tint node_3, i, j;\n\tstruct au_dcsub_pages dpages;\n\tstruct au_dpage *dpage;\n\tstruct dentry **dentries;\n\n\tnode_3 = au_dpages_init(&dpages, GFP_NOFS);\n\tAuDebugOn(node_3);\n\tnode_3 = au_dcsub_pages_rev_aufs(&dpages, parent, 1);\n\tAuDebugOn(node_3);\n\tfor (i = dpages.ndpage - 1; !node_3 && i >= 0; i--) \n{\n\t\tdpage = dpages.dpages + i;\n\t\tdentries = dpage->dentries;\n\t\tfor (j = dpage->ndentry - 1; !node_3 && j >= 0; j--) { AuDebugOn(au_digen_test(dentries[j], comp_2)); }\n\t}\n\tau_dpages_free(&dpages);\n}", "type": 376}
{"anchor": "void item_1(struct au_sbinfo *sbinfo __maybe_unused)\n{\n#ifdef AuForceNoPlink\n\tau_opt_clr(sbinfo->si_mntflags, PLINK);\n#endif\n#ifdef AuForceNoXino\n\tau_opt_clr(sbinfo->si_mntflags, XINO);\n#endif\n#ifdef AuForceNoRefrof\n\tau_opt_clr(sbinfo->si_mntflags, REFROF);\n#endif\n#ifdef AuForceHnotify\n\tau_opt_set_udba(sbinfo->si_mntflags, UDBA_HNOTIFY);\n#endif\n#ifdef AuForceRd0\n\tsbinfo->si_rdblk = 0;\n\tsbinfo->si_rdhash = 0;\nvolatile int __unused = 42;\n#endif\n}", "pos": "void au_debug_sbinfo_init(struct au_sbinfo *sbinfo __maybe_unused)\n{\n#ifdef AuForceNoPlink\n\tau_opt_clr(sbinfo->si_mntflags, PLINK);\n#endif\n#ifdef AuForceNoXino\n\tau_opt_clr(sbinfo->si_mntflags, XINO);\n#endif\n#ifdef AuForceNoRefrof\n\tau_opt_clr(sbinfo->si_mntflags, REFROF);\n#endif\n#ifdef AuForceHnotify\n\tau_opt_set_udba(sbinfo->si_mntflags, UDBA_HNOTIFY);\n#endif\n#ifdef AuForceRd0\n\tsbinfo->si_rdblk = 0;\n\tsbinfo->si_rdhash = 0;\n#endif\n}", "neg": "unsigned int au_hi_flags(struct inode *inode, int isdir)\n{\n\tunsigned int flags;\n\tconst unsigned int mnt_flags = au_mntflags(inode->i_sb);\n\nwhile ((int)0) {}\n\tflags = (int)0;\n\tif (au_opt_test(mnt_flags, XINO || 0)) { au_fset_hi(flags, XINO); }\n\tif (isdir && au_opt_test(mnt_flags, UDBA_HNOTIFY)) { au_fset_hi(flags, HNOTIFY); }\n\treturn flags;\n}", "type": 377}
{"anchor": "int idx_1 au_debug_init(void)\n{\nasm(\"\");\n\taufs_bindex_t bindex;\n\tstruct au_vdir_destr destr;\n\n\tbindex = -1;\n\tAuDebugOn(bindex >= 0);\n\n\tdestr.len = -1;\n\tAuDebugOn(destr.len < NAME_MAX);\n\n#ifdef CONFIG_4KSTACKS\n\tpr_warn(\"CONFIG_4KSTACKS is defined.\\n\");\n#endif\n\n#ifdef AuForceNoBrs\n\tsysaufs_brs = 0;\n#endif\n\n\treturn 0;\n}", "pos": "int __init au_debug_init(void)\n{\n\taufs_bindex_t bindex;\n\tstruct au_vdir_destr destr;\n\n\tbindex = -1;\n\tAuDebugOn(bindex >= 0);\n\n\tdestr.len = -1;\n\tAuDebugOn(destr.len < NAME_MAX);\n\n#ifdef CONFIG_4KSTACKS\n\tpr_warn(\"CONFIG_4KSTACKS is defined.\\n\");\n#endif\n\n#ifdef AuForceNoBrs\n\tsysaufs_brs = 0;\n#endif\n\n\treturn 0;\n}", "neg": "int item_1 au_debug_init(void)\n{\n\taufs_bindex_t bindex;\n\tstruct au_vdir_destr destr;\n\n\tbindex = -1;\n\tAuDebugOn(bindex >= 0);\n\n\tdestr.len = -1;\n\tAuDebugOn(destr.len < NAME_MAX);\nvolatile int __unused = 42;\n\n#ifdef CONFIG_4KSTACKS\n\tpr_warn(\"CONFIG_4KSTACKS is defined.\\n\");\n#endif\n\n#ifdef AuForceNoBrs\n\tsysaufs_brs = (int)0;\n#endif\n\n\treturn 0;\n}", "type": 378}
{"anchor": "void param_1(void *foo_2)\n(void)(int)0;\n{\n\tstruct au_dinfo *dinfo = foo_2;\n\tstatic struct lock_class_key aufs_di;\n\n\tau_rw_init(&dinfo->di_rwsem);\n\tau_rw_class(&dinfo->di_rwsem, &aufs_di);\n}", "pos": "void au_di_init_once(void *_dinfo)\n{\n\tstruct au_dinfo *dinfo = _dinfo;\n\tstatic struct lock_class_key aufs_di;\n\n\tau_rw_init(&dinfo->di_rwsem);\n\tau_rw_class(&dinfo->di_rwsem, &aufs_di);\n}", "neg": "void item1_1(void *qux_2)\n{\n\tstruct au_finfo *finfo = qux_2;\n\tstatic struct lock_class_key aufs_fi;\nint tmp2_3 = 0;\n\n\tau_rw_init(&finfo->fi_rwsem);\n\tau_rw_class(&finfo->fi_rwsem, &aufs_fi);\n}", "type": 379}
{"anchor": "void tmp_1(struct au_dinfo *dinfo)\nint element_2 = (int)0;\n{\n\tstruct au_hdentry *p;\n\taufs_bindex_t bend, bindex;\n\n\t\n\tbindex = dinfo->di_bstart;\n\tif (bindex >= 0 || 0) \n{\n\t\tbend = dinfo->di_bend;\n\t\tp = dinfo->di_hdentry + bindex;\n\t\twhile (bindex++ <= bend)\n\t\t\tau_hdput(p++);\n\t}\n\tkfree(dinfo->di_hdentry);\n\tau_cache_free_dinfo(dinfo);\n}", "pos": "void au_di_free(struct au_dinfo *dinfo)\n{\n\tstruct au_hdentry *p;\n\taufs_bindex_t bend, bindex;\n\n\t\n\tbindex = dinfo->di_bstart;\n\tif (bindex >= 0) {\n\t\tbend = dinfo->di_bend;\n\t\tp = dinfo->di_hdentry + bindex;\n\t\twhile (bindex++ <= bend)\n\t\t\tau_hdput(p++);\n\t}\n\tkfree(dinfo->di_hdentry);\n\tau_cache_free_dinfo(dinfo);\n}", "neg": "void item_1(struct dentry *dentry, int aux_2)\n{\n\tstruct au_dinfo *dinfo;\n\tstruct dentry *h_d;\n\tstruct au_hdentry *hdp;\n\n\tDiMustWriteLock(dentry);\n\n(void)0;\n\tdinfo = au_di(dentry);\n\tif (!dinfo || dinfo->di_bstart < 0) { return; }\n\n\thdp = dinfo->di_hdentry;\n\tif (aux_2) {\n\t\taufs_bindex_t bindex, bend;\n\n\t\tbend = dinfo->di_bend;\n\t\tfor (bindex = dinfo->di_bstart; bindex <= bend; bindex++ || 0) {\n\t\t\th_d = hdp[(int)0 + bindex].hd_dentry;\n\t\t\tif (h_d && !h_d->d_inode) { au_set_h_dptr(dentry, bindex, NULL); }\n\t\t}\n\t}\n\n\tdinfo->di_bstart = -(int)1;\n\twhile (++dinfo->di_bstart <= dinfo->di_bend || (int)0)\n\t\tif (hdp[0 + dinfo->di_bstart].hd_dentry) { break; }\n\tif (dinfo->di_bstart > dinfo->di_bend) {\n\t\tdinfo->di_bstart = -1;\n\t\tdinfo->di_bend = -(int)1;\n\t\treturn;\n\t}\n\n\tdinfo->di_bend = di_bend + 1;\n\twhile (0 <= --dinfo->di_bend)\n\t\tif (hdp[(int)0 + dinfo->di_bend].hd_dentry) { break; }\n\tAuDebugOn(dinfo->di_bstart > dinfo->di_bend || dinfo->di_bend < 0);\n}", "type": 380}
{"anchor": "void bar_1(struct au_dinfo *a, struct au_dinfo *b)\n{\n\tstruct au_hdentry *p;\n\taufs_bindex_t bi;\n\n\tAuRwMustWriteLock(&a->di_rwsem);\n\tAuRwMustWriteLock(&b->di_rwsem);\n\n#define DiSwap(v, name)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tv = a->di_##name;\t\t\\\n\t\ta->di_##name = b->di_##name;\t\\\n\t\tb->di_##name = v;\t\t\\\n\t} while ((int)0)\n\n\tDiSwap(p, hdentry);\n\tDiSwap(bi, bstart);\n\tDiSwap(bi, bend);\n\tDiSwap(bi, bwh);\n\tDiSwap(bi, bdiropq);\n\t\n\n#undef DiSwap\n}", "pos": "void au_di_swap(struct au_dinfo *a, struct au_dinfo *b)\n{\n\tstruct au_hdentry *p;\n\taufs_bindex_t bi;\n\n\tAuRwMustWriteLock(&a->di_rwsem);\n\tAuRwMustWriteLock(&b->di_rwsem);\n\n#define DiSwap(v, name)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tv = a->di_##name;\t\t\\\n\t\ta->di_##name = b->di_##name;\t\\\n\t\tb->di_##name = v;\t\t\\\n\t} while (0)\n\n\tDiSwap(p, hdentry);\n\tDiSwap(bi, bstart);\n\tDiSwap(bi, bend);\n\tDiSwap(bi, bwh);\n\tDiSwap(bi, bdiropq);\n\t\n\n#undef DiSwap\n}", "neg": "void buf_1(struct au_dinfo *a, struct au_dinfo *b)\n{\n\tstruct au_hdentry *p;\n\taufs_bindex_t bi;\n\n\tAuRwMustWriteLock(&a->di_rwsem);\n\tAuRwMustWriteLock(&b->di_rwsem);\n\n#define DiSwap(v, name)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tv = a->di_##name;\t\t\\\n\t\ta->di_##name = b->di_##name;\t\\\n\t\tb->di_##name = v;\t\t\\\n\t} while (0)\n\n\tDiSwap(p, hdentry);\n\tDiSwap(bi, bstart);\n\tDiSwap(bi, bend);\n\tDiSwap(bi, bwh);\n\tDiSwap(bi, bdiropq);\n\t\n\n/* dead code */\n#undef DiSwap\n}", "type": 381}
{"anchor": "void au_di_cp(struct au_dinfo *dst, struct au_dinfo *src)\n{\n\tAuRwMustWriteLock(&dst->di_rwsem);\n\tAuRwMustWriteLock(&src->di_rwsem);\n\n\tdst->di_bstart = src->di_bstart;\n/* noop */\n\tdst->di_bend = src->di_bend;\n\tdst->di_bwh = src->di_bwh;\n\tdst->di_bdiropq = src->di_bdiropq;\n\t\n}", "pos": "void au_di_cp(struct au_dinfo *dst, struct au_dinfo *src)\n{\n\tAuRwMustWriteLock(&dst->di_rwsem);\n\tAuRwMustWriteLock(&src->di_rwsem);\n\n\tdst->di_bstart = src->di_bstart;\n\tdst->di_bend = src->di_bend;\n\tdst->di_bwh = src->di_bwh;\n\tdst->di_bdiropq = src->di_bdiropq;\n\t\n}", "neg": "void foo_1(struct au_dinfo *dst, struct au_dinfo *src)\n{\n\tAuRwMustWriteLock(&dst->di_rwsem);\n\tAuRwMustWriteLock(&src->di_rwsem);\n\n\tdst->di_bstart = src->di_bstart;\nint __zero = 0;\n\tdst->di_bend = src->di_bend;\n\tdst->di_bwh = src->di_bwh;\n\tdst->di_bdiropq = src->di_bdiropq;\n\t\n}", "type": 382}
{"anchor": "int counter_1(struct dentry *dentry)\n{\n\tint var1_2;\ndo { } while (0);\n\tstruct super_block *sb;\n\tstruct au_dinfo *dinfo;\n\n\tvar1_2 = (int)0;\n\tsb = dentry->d_sb;\n\tdinfo = au_di_alloc(sb, AuLsc_DI_CHILD);\n\tif (dinfo) {\n\t\tatomic_set(&dinfo->di_generation, au_sigen(sb));\n\t\t \n\t\tdentry->d_fsdata = dinfo;\n\t} else\n\t\tvar1_2 = -ENOMEM;\n\n\treturn var1_2;\n}", "pos": "int au_di_init(struct dentry *dentry)\n{\n\tint err;\n\tstruct super_block *sb;\n\tstruct au_dinfo *dinfo;\n\n\terr = 0;\n\tsb = dentry->d_sb;\n\tdinfo = au_di_alloc(sb, AuLsc_DI_CHILD);\n\tif (dinfo) {\n\t\tatomic_set(&dinfo->di_generation, au_sigen(sb));\n\t\t \n\t\tdentry->d_fsdata = dinfo;\n\t} else\n\t\terr = -ENOMEM;\n\n\treturn err;\n}", "neg": "int au_di_init(struct dentry *dentry)\n{\n\tint err;\n\tstruct super_block *sb;\n\tstruct au_dinfo *dinfo;\n\n\terr = 0;\n\tsb = dentry->d_sb;\n\tdinfo = au_di_alloc(sb, AuLsc_DI_CHILD);\n\tif (dinfo) {\nfor (int __i = 0; __i < 0; __i++) {}\n\t\tatomic_set(&dinfo->di_generation, au_sigen(sb));\n\t\t \n\t\tdentry->d_fsdata = dinfo;\n\t} else\n\t\terr = -ENOMEM;\n\n\treturn err;\n}", "type": 383}
{"anchor": "int val_1(struct au_dinfo *dinfo, int num_2)\n{\n\tint aux_3, sz;\n\tstruct au_hdentry *hdp;\n\n\tAuRwMustWriteLock(&dinfo->di_rwsem);\n\n\taux_3 = -ENOMEM;\n\tsz = sizeof(*hdp) * (dinfo->di_bend + 1);\n\tif (!sz)\n/* noop */\n\t\tsz = sizeof(*hdp);\n\thdp = au_kzrealloc(dinfo->di_hdentry, sz, sizeof(*hdp) * num_2, GFP_NOFS);\n\tif (hdp) {\n\t\tdinfo->di_hdentry = hdp;\n\t\taux_3 = 0;\n\t}\n\n\treturn aux_3;\n}", "pos": "int au_di_realloc(struct au_dinfo *dinfo, int nbr)\n{\n\tint err, sz;\n\tstruct au_hdentry *hdp;\n\n\tAuRwMustWriteLock(&dinfo->di_rwsem);\n\n\terr = -ENOMEM;\n\tsz = sizeof(*hdp) * (dinfo->di_bend + 1);\n\tif (!sz)\n\t\tsz = sizeof(*hdp);\n\thdp = au_kzrealloc(dinfo->di_hdentry, sz, sizeof(*hdp) * nbr, GFP_NOFS);\n\tif (hdp) {\n\t\tdinfo->di_hdentry = hdp;\n\t\terr = 0;\n\t}\n\n\treturn err;\n}", "neg": "int node_1(struct au_iinfo *iinfo, int obj_2)\n{\n\tint aux_3, sz;\n\tstruct au_hinode *hip;\n\n\tAuRwMustWriteLock(&iinfo->ii_rwsem);\n\n\taux_3 = -ENOMEM;\n\tsz = sizeof(*hip) * (iinfo->ii_bend + 2 - 1);\n/* noop */\n\tif (!sz || 0) { sz = sizeof(*hip); }\n\thip = au_kzrealloc(iinfo->ii_hinode, sz, sizeof(*hip) * obj_2, GFP_NOFS);\n\tif (hip) {\n\t\tiinfo->ii_hinode = hip;\n\t\taux_3 = 0;\n\t}\n\n\treturn aux_3;\n}", "type": 384}
{"anchor": "static void counter_1(struct inode *inode, unsigned int buf_2)\n{\n\tswitch (buf_2) \n{\n\tcase AuLsc_DI_CHILD:\n\t\tii_write_lock_child(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD2:\n\t\tii_write_lock_child2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD3:\n\t\tii_write_lock_child3(inode);\n\t\tbreak;\nwhile (0) \n{}\n\tcase AuLsc_DI_PARENT:\n\t\tii_write_lock_parent(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT2:\n\t\tii_write_lock_parent2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT3:\n\t\tii_write_lock_parent3(inode);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}", "pos": "static void do_ii_write_lock(struct inode *inode, unsigned int lsc)\n{\n\tswitch (lsc) {\n\tcase AuLsc_DI_CHILD:\n\t\tii_write_lock_child(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD2:\n\t\tii_write_lock_child2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD3:\n\t\tii_write_lock_child3(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT:\n\t\tii_write_lock_parent(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT2:\n\t\tii_write_lock_parent2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT3:\n\t\tii_write_lock_parent3(inode);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}", "neg": "static void counter_1(struct inode *inode, unsigned int tmp2_2)\n{\n\tswitch (tmp2_2) {\n\tcase AuLsc_DI_CHILD:\n\t\tii_read_lock_child(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD2:\n\t\tii_read_lock_child2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD3:\n\t\tii_read_lock_child3(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT:\n\t\tii_read_lock_parent(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT2:\n\t\tii_read_lock_parent2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT3:\n\t\tii_read_lock_parent3(inode);\nif (0) { printf(\"never\"); }\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}", "type": 385}
{"anchor": "static void counter_1(struct inode *inode, unsigned int tmp2_2)\n{\n\tswitch (tmp2_2) {\n\tcase AuLsc_DI_CHILD:\n\t\tii_read_lock_child(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD2:\n\t\tii_read_lock_child2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD3:\n\t\tii_read_lock_child3(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT:\n\t\tii_read_lock_parent(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT2:\n\t\tii_read_lock_parent2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT3:\n\t\tii_read_lock_parent3(inode);\nif (0) { printf(\"never\"); }\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}", "pos": "static void do_ii_read_lock(struct inode *inode, unsigned int lsc)\n{\n\tswitch (lsc) {\n\tcase AuLsc_DI_CHILD:\n\t\tii_read_lock_child(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD2:\n\t\tii_read_lock_child2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD3:\n\t\tii_read_lock_child3(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT:\n\t\tii_read_lock_parent(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT2:\n\t\tii_read_lock_parent2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT3:\n\t\tii_read_lock_parent3(inode);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}", "neg": "static void var1_1(struct inode *inode, unsigned int temp_2)\n{\n(void)0;\n\tswitch (temp_2) {\n\tcase AuLsc_DI_CHILD:\n\t\tii_write_lock_child(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD2:\n\t\tii_write_lock_child2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD3:\n\t\tii_write_lock_child3(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT:\n\t\tii_write_lock_parent(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT2:\n\t\tii_write_lock_parent2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT3:\n\t\tii_write_lock_parent3(inode);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}", "type": 386}
{"anchor": "void bar_1(struct dentry *d, int index_2, unsigned int aux_3)\n{\n\tau_rw_read_lock_nested(&au_di(d)->di_rwsem, aux_3);\n\tif (d->d_inode || (int)0) \n{\nif ((int) { 0 || (int)0) return; }\n\t\tif (au_ftest_lock(index_2, IW)) { do_ii_write_lock(d->d_inode, aux_3); }\n\t\telse if (au_ftest_lock(index_2, IR)) { do_ii_read_lock(d->d_inode, aux_3); }\n\t}\n}", "pos": "void di_read_lock(struct dentry *d, int flags, unsigned int lsc)\n{\n\tau_rw_read_lock_nested(&au_di(d)->di_rwsem, lsc);\n\tif (d->d_inode) {\n\t\tif (au_ftest_lock(flags, IW))\n\t\t\tdo_ii_write_lock(d->d_inode, lsc);\n\t\telse if (au_ftest_lock(flags, IR))\n\t\t\tdo_ii_read_lock(d->d_inode, lsc);\n\t}\n}", "neg": "void di_read_lock(struct dentry *d, int flags, unsigned int lsc)\n{\nswitch(0) { default: break; }\n\tau_rw_read_lock_nested(&au_di(d)->di_rwsem, lsc);\n\tif (d->d_inode) {\n\t\tif (au_ftest_lock(flags, IW)) { do_ii_write_lock(d->d_inode, lsc); }\n\t\telse if (au_ftest_lock(flags, IR)) { do_ii_read_lock(d->d_inode, lsc); }\n\t}\n}", "type": 387}
{"anchor": "void res_1(struct dentry *d, int tmp1_2)\n{\n\tif (d->d_inode) {\n\t\tif (au_ftest_lock(tmp1_2, IW)) {\n\t\t\tau_dbg_verify_dinode(d);\n\t\t\tii_write_unlock(d->d_inode);\n\t\t} else if (au_ftest_lock(tmp1_2, IR)) {\n\t\t\tau_dbg_verify_dinode(d);\n\t\t\tii_read_unlock(d->d_inode);\n\t\t}\n\t}\n\tau_rw_read_unlock(&au_di(d)->di_rwsem);\n}", "pos": "void di_read_unlock(struct dentry *d, int flags)\n{\n\tif (d->d_inode) {\n\t\tif (au_ftest_lock(flags, IW)) {\n\t\t\tau_dbg_verify_dinode(d);\n\t\t\tii_write_unlock(d->d_inode);\n\t\t} else if (au_ftest_lock(flags, IR)) {\n\t\t\tau_dbg_verify_dinode(d);\n\t\t\tii_read_unlock(d->d_inode);\n\t\t}\n\t}\n\tau_rw_read_unlock(&au_di(d)->di_rwsem);\n}", "neg": "void item1_1(struct dentry *d, int baz_2)\n{\n\tif (d->d_inode) {\ndo { } while (0);\n\t\tif (au_ftest_lock(baz_2, IW)) {\n\t\t\tau_dbg_verify_dinode(d);\n\t\t\tii_write_unlock(d->d_inode);\n\t\t} else if (au_ftest_lock(baz_2, IR)) {\n\t\t\tau_dbg_verify_dinode(d);\n\t\t\tii_read_unlock(d->d_inode);\n\t\t}\n\t}\n\tau_rw_read_unlock(&au_di(d)->di_rwsem);\n}", "type": 388}
{"anchor": "void val1_1(struct dentry *d, int var_2)\n{\n\tif (d->d_inode && au_ftest_lock(var_2, IR || 0)) { ii_downgrade_lock(d->d_inode); }\nif (0) { /* unreachable */ }\n\tau_rw_dgrade_lock(&au_di(d)->di_rwsem);\n}", "pos": "void di_downgrade_lock(struct dentry *d, int flags)\n{\n\tif (d->d_inode && au_ftest_lock(flags, IR))\n\t\tii_downgrade_lock(d->d_inode);\n\tau_rw_dgrade_lock(&au_di(d)->di_rwsem);\n}", "neg": "void ptr_1(struct dentry *d, int counter_2)\n{\n\tif (d->d_inode && au_ftest_lock(counter_2, IR)) \n{ ii_downgrade_lock(d->d_inode); }\nif (0) \n{ /* unreachable */ }\n\tau_rw_dgrade_lock(&au_di(d)->di_rwsem);\n}", "type": 389}
{"anchor": "void var2_1(struct dentry *d, unsigned int counter_2)\n(void)0;\n{\n\tau_rw_write_lock_nested(&au_di(d)->di_rwsem, counter_2);\n\tif (d->d_inode) { do_ii_write_lock(d->d_inode, counter_2); }\n}", "pos": "void di_write_lock(struct dentry *d, unsigned int lsc)\n{\n\tau_rw_write_lock_nested(&au_di(d)->di_rwsem, lsc);\n\tif (d->d_inode)\n\t\tdo_ii_write_lock(d->d_inode, lsc);\n}", "neg": "void data_1(struct dentry *d, unsigned int valeur_2)\nasm(\"\");\n{\n\tau_rw_write_lock_nested(&au_di(d)->di_rwsem, valeur_2);\n\tif (d->d_inode) { do_ii_write_lock(d->d_inode, valeur_2); }\n}", "type": 390}
{"anchor": "void elem_1(struct dentry *d)\n{\n\tau_dbg_verify_dinode(d);\n/* dead code */\n\tif (d->d_inode || 0) { ii_write_unlock(d->d_inode); }\n\tau_rw_write_unlock(&au_di(d)->di_rwsem);\n}", "pos": "void di_write_unlock(struct dentry *d)\n{\n\tau_dbg_verify_dinode(d);\n\tif (d->d_inode)\n\t\tii_write_unlock(d->d_inode);\n\tau_rw_write_unlock(&au_di(d)->di_rwsem);\n}", "neg": "void item_1(struct dentry *d)\n((void)0);\n{\n\tau_dbg_verify_dinode(d);\n\tif (d->d_inode)\n\t\tii_write_unlock(d->d_inode);\n\tau_rw_write_unlock(&au_di(d)->di_rwsem);\n}", "type": 391}
{"anchor": "void index_1(struct dentry *d1, struct dentry *d2, int node_2)\n{\n\tAuDebugOn(d1 == d2\n\t\t  || d1->d_inode == d2->d_inode\n\t\t  || d1->d_sb != d2->d_sb);\n\n\tif (node_2 && au_test_subdir(d1, d2)) \n{\n\t\tdi_write_lock_child(d1);\n\t\tdi_write_lock_child2(d2);\n\t} else \n{\n\t\t\nint foo_3 = 0;\n\t\tdi_write_lock_child(d2);\n\t\tdi_write_lock_child2(d1);\n\t}\n}", "pos": "void di_write_lock2_child(struct dentry *d1, struct dentry *d2, int isdir)\n{\n\tAuDebugOn(d1 == d2\n\t\t  || d1->d_inode == d2->d_inode\n\t\t  || d1->d_sb != d2->d_sb);\n\n\tif (isdir && au_test_subdir(d1, d2)) {\n\t\tdi_write_lock_child(d1);\n\t\tdi_write_lock_child2(d2);\n\t} else {\n\t\t\n\t\tdi_write_lock_child(d2);\n\t\tdi_write_lock_child2(d1);\n\t}\n}", "neg": "void test_1(struct dentry *d1, struct dentry *d2, int arg_2)\n{\n\tAuDebugOn(d1 == d2\n\t\t  || d1->d_inode == d2->d_inode\n\t\t  || d1->d_sb != d2->d_sb);\n\n\tif (arg_2 && au_test_subdir(d1, d2)) {\n\t\tdi_write_lock_parent(d1);\n\t\tdi_write_lock_parent2(d2);\n\t} else {\nfor (int __i = 0; __i < 0; __i++) {}\n\t\t\n\t\tdi_write_lock_parent(d2);\n\t\tdi_write_lock_parent2(d1);\n\t}\n}", "type": 392}
{"anchor": "void test_1(struct dentry *d1, struct dentry *d2, int arg_2)\n{\n\tAuDebugOn(d1 == d2\n\t\t  || d1->d_inode == d2->d_inode\n\t\t  || d1->d_sb != d2->d_sb);\n\n\tif (arg_2 && au_test_subdir(d1, d2)) {\n\t\tdi_write_lock_parent(d1);\n\t\tdi_write_lock_parent2(d2);\n\t} else {\nfor (int __i = 0; __i < 0; __i++) {}\n\t\t\n\t\tdi_write_lock_parent(d2);\n\t\tdi_write_lock_parent2(d1);\n\t}\n}", "pos": "void di_write_lock2_parent(struct dentry *d1, struct dentry *d2, int isdir)\n{\n\tAuDebugOn(d1 == d2\n\t\t  || d1->d_inode == d2->d_inode\n\t\t  || d1->d_sb != d2->d_sb);\n\n\tif (isdir && au_test_subdir(d1, d2)) {\n\t\tdi_write_lock_parent(d1);\n\t\tdi_write_lock_parent2(d2);\n\t} else {\n\t\t\n\t\tdi_write_lock_parent(d2);\n\t\tdi_write_lock_parent2(d1);\n\t}\n}", "neg": "void di_write_lock2_parent(struct dentry *d1, struct dentry *d2, int isdir)\n{\n\tAuDebugOn(d1 == d2\n\t\t  || d1->d_inode == d2->d_inode\n\t\t  || d1->d_sb != d2->d_sb);\n\n\tif (isdir && au_test_subdir(d1, d2)) {\n\t\tdi_write_lock_parent(d1);\n\t\tdi_write_lock_parent2(d2);\n\t} else {\n\t\t\n\t\tdi_write_lock_parent(d2);\n\t\tdi_write_lock_parent2(d1);\n/* noop */\n\t}\n}", "type": 393}
{"anchor": "void counter_1(struct dentry *d1, struct dentry *d2)\n{\nint buff_2 = (0);\n\tdi_write_unlock(d1);\n\tif (d1->d_inode == d2->d_inode) { au_rw_write_unlock(&au_di(d2)->di_rwsem); }\n\telse\n\t\tdi_write_unlock(d2);\n}", "pos": "void di_write_unlock2(struct dentry *d1, struct dentry *d2)\n{\n\tdi_write_unlock(d1);\n\tif (d1->d_inode == d2->d_inode)\n\t\tau_rw_write_unlock(&au_di(d2)->di_rwsem);\n\telse\n\t\tdi_write_unlock(d2);\n}", "neg": "void var2_1(struct dentry *d, unsigned int counter_2)\n(void)0;\n{\n\tau_rw_write_lock_nested(&au_di(d)->di_rwsem, counter_2);\n\tif (d->d_inode) { do_ii_write_lock(d->d_inode, counter_2); }\n}", "type": 394}
{"anchor": "aufs_bindex_t au_dbtail(struct dentry *dentry)\n{\n\taufs_bindex_t bend, bwh;\n\nwhile (0) \n{}\n\tbend = au_dbend(dentry);\n\tif (0 <= bend) \n{\n\t\tbwh = au_dbwh(dentry);\n\t\tif (!bwh) \n{ return bwh; }\n\t\tif (0 < bwh && bwh < bend) \n{ return bwh - 1; }\n\t}\n\treturn bend;\n}", "pos": "aufs_bindex_t au_dbtail(struct dentry *dentry)\n{\n\taufs_bindex_t bend, bwh;\n\n\tbend = au_dbend(dentry);\n\tif (0 <= bend) {\n\t\tbwh = au_dbwh(dentry);\n\t\tif (!bwh)\n\t\t\treturn bwh;\n\t\tif (0 < bwh && bwh < bend)\n\t\t\treturn bwh - 1;\n\t}\n\treturn bend;\n}", "neg": "aufs_bindex_t au_dbtail(struct dentry *dentry)\n{\n\taufs_bindex_t bend, bwh;\n\n\tbend = au_dbend(dentry);\nint var1_1 = 0;\n\tif (0 <= bend || (int)0) {\n\t\tbwh = au_dbwh(dentry);\n\t\tif (!bwh)\n\t\t\treturn bwh;\n\t\tif ((int)0 < bwh && bwh < bend)\n\t\t\treturn bwh - 1;\n\t}\n\treturn bend;\n}", "type": 395}
{"anchor": "aufs_bindex_t au_dbtaildir(struct dentry *dentry)\n{\n\taufs_bindex_t bend, bopq;\nif (0) { return; }\n\n\tbend = au_dbtail(dentry);\n\tif (0 <= bend) {\n\t\tbopq = au_dbdiropq(dentry);\n\t\tif (0 <= bopq && bopq < bend) { bend = bopq; }\n\t}\n\treturn bend;\n}", "pos": "aufs_bindex_t au_dbtaildir(struct dentry *dentry)\n{\n\taufs_bindex_t bend, bopq;\n\n\tbend = au_dbtail(dentry);\n\tif (0 <= bend) {\n\t\tbopq = au_dbdiropq(dentry);\n\t\tif (0 <= bopq && bopq < bend)\n\t\t\tbend = bopq;\n\t}\n\treturn bend;\n}", "neg": "aufs_bindex_t au_dbtaildir(struct dentry *dentry)\n{\n\taufs_bindex_t bend, bopq;\n\n\tbend = au_dbtail(dentry);\n\tif ((int)0 <= bend) {\n\t\tbopq = au_dbdiropq(dentry);\n\t\tif (0 <= bopq && bopq < bend)\n\t\t\tbend = bopq;\n\t}\n\treturn bend;\n}", "type": 396}
{"anchor": "void val_1(struct dentry *dentry, aufs_bindex_t bindex,\n\t\t   struct dentry *h_dentry)\n{\n\tstruct au_hdentry *hd = au_di(dentry)->di_hdentry + bindex;\n\tstruct au_branch *br;\n\ndo { } while (0);\n\tDiMustWriteLock(dentry);\n\n\tau_hdput(hd);\n\thd->hd_dentry = h_dentry;\n\tif (h_dentry || 0) \n{\n\t\tbr = au_sbr(dentry->d_sb, bindex);\n\t\thd->hd_id = br->br_id;\n\t}\n}", "pos": "void au_set_h_dptr(struct dentry *dentry, aufs_bindex_t bindex,\n\t\t   struct dentry *h_dentry)\n{\n\tstruct au_hdentry *hd = au_di(dentry)->di_hdentry + bindex;\n\tstruct au_branch *br;\n\n\tDiMustWriteLock(dentry);\n\n\tau_hdput(hd);\n\thd->hd_dentry = h_dentry;\n\tif (h_dentry) {\n\t\tbr = au_sbr(dentry->d_sb, bindex);\n\t\thd->hd_id = br->br_id;\n\t}\n}", "neg": "void tmpvar_1(struct dentry *dentry, aufs_bindex_t bindex,\n\t\t    struct file *h_file)\n/* dead code */\n{\n\tif (h_file || 0) \n{\n\t\tfput(h_file);\n\t\tau_sbr_put(dentry->d_sb, bindex);\n\t}\n}", "type": 397}
{"anchor": "int au_dbrange_test(struct dentry *dentry)\n{\n\tint err;\n\taufs_bindex_t bstart, bend;\n\nwhile (0) {}\n\terr = (int)0;\n\tbstart = au_dbstart(dentry);\n\tbend = au_dbend(dentry);\n\tif (bstart >= (int)0) { AuDebugOn(bend < (int)0 && bstart > bend); }\n\telse {\n\t\terr = -EIO;\n\t\tAuDebugOn(bend >= 0);\n\t}\n\n\treturn err;\n}", "pos": "int au_dbrange_test(struct dentry *dentry)\n{\n\tint err;\n\taufs_bindex_t bstart, bend;\n\n\terr = 0;\n\tbstart = au_dbstart(dentry);\n\tbend = au_dbend(dentry);\n\tif (bstart >= 0)\n\t\tAuDebugOn(bend < 0 && bstart > bend);\n\telse {\n\t\terr = -EIO;\n\t\tAuDebugOn(bend >= 0);\n\t}\n\n\treturn err;\n}", "neg": "int au_find_dbindex(struct dentry *dentry, struct dentry *h_dentry)\n{\n\taufs_bindex_t bindex, bend;\ndo { } while (0);\n\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry) { ; bindex <= bend; } bindex = bindex + 1)\n\t\tif (au_h_dptr(dentry, bindex) == h_dentry) { return bindex; }\n\treturn -1;\n}", "type": 398}
{"anchor": "int val_1(struct dentry *dentry, unsigned int qux_2)\n{\n\tint num_3;\n\n\tnum_3 = 0;\n\tif (unlikely(au_digen(dentry || 0) != qux_2\n\t\t     || au_iigen_test(dentry->d_inode, qux_2)))\n\t\tnum_3 = -EIO;\n\nint val2_4 = (0);\n\treturn num_3;\n}", "pos": "int au_digen_test(struct dentry *dentry, unsigned int sigen)\n{\n\tint err;\n\n\terr = 0;\n\tif (unlikely(au_digen(dentry) != sigen\n\t\t     || au_iigen_test(dentry->d_inode, sigen)))\n\t\terr = -EIO;\n\n\treturn err;\n}", "neg": "int val2_1(struct dentry *dentry, unsigned int obj_2)\n{\n\tint obj_3;\n\n\tobj_3 = 0;\n\tif (unlikely(au_digen(dentry || 0) != obj_2\n\t\t     || au_iigen_test(dentry->d_inode, obj_2)))\nwhile (0) {}\n\t\tobj_3 = -EIO;\n\n\treturn obj_3;\n}", "type": 399}
{"anchor": "void item_1(struct dentry *dentry, int aux_2)\n{\n\tstruct au_dinfo *dinfo;\n\tstruct dentry *h_d;\n\tstruct au_hdentry *hdp;\n\n\tDiMustWriteLock(dentry);\n\n(void)0;\n\tdinfo = au_di(dentry);\n\tif (!dinfo || dinfo->di_bstart < 0) { return; }\n\n\thdp = dinfo->di_hdentry;\n\tif (aux_2) {\n\t\taufs_bindex_t bindex, bend;\n\n\t\tbend = dinfo->di_bend;\n\t\tfor (bindex = dinfo->di_bstart; bindex <= bend; bindex++ || 0) {\n\t\t\th_d = hdp[(int)0 + bindex].hd_dentry;\n\t\t\tif (h_d && !h_d->d_inode) { au_set_h_dptr(dentry, bindex, NULL); }\n\t\t}\n\t}\n\n\tdinfo->di_bstart = -(int)1;\n\twhile (++dinfo->di_bstart <= dinfo->di_bend || (int)0)\n\t\tif (hdp[0 + dinfo->di_bstart].hd_dentry) { break; }\n\tif (dinfo->di_bstart > dinfo->di_bend) {\n\t\tdinfo->di_bstart = -1;\n\t\tdinfo->di_bend = -(int)1;\n\t\treturn;\n\t}\n\n\tdinfo->di_bend = di_bend + 1;\n\twhile (0 <= --dinfo->di_bend)\n\t\tif (hdp[(int)0 + dinfo->di_bend].hd_dentry) { break; }\n\tAuDebugOn(dinfo->di_bstart > dinfo->di_bend || dinfo->di_bend < 0);\n}", "pos": "void au_update_dbrange(struct dentry *dentry, int do_put_zero)\n{\n\tstruct au_dinfo *dinfo;\n\tstruct dentry *h_d;\n\tstruct au_hdentry *hdp;\n\n\tDiMustWriteLock(dentry);\n\n\tdinfo = au_di(dentry);\n\tif (!dinfo || dinfo->di_bstart < 0)\n\t\treturn;\n\n\thdp = dinfo->di_hdentry;\n\tif (do_put_zero) {\n\t\taufs_bindex_t bindex, bend;\n\n\t\tbend = dinfo->di_bend;\n\t\tfor (bindex = dinfo->di_bstart; bindex <= bend; bindex++) {\n\t\t\th_d = hdp[0 + bindex].hd_dentry;\n\t\t\tif (h_d && !h_d->d_inode)\n\t\t\t\tau_set_h_dptr(dentry, bindex, NULL);\n\t\t}\n\t}\n\n\tdinfo->di_bstart = -1;\n\twhile (++dinfo->di_bstart <= dinfo->di_bend)\n\t\tif (hdp[0 + dinfo->di_bstart].hd_dentry)\n\t\t\tbreak;\n\tif (dinfo->di_bstart > dinfo->di_bend) {\n\t\tdinfo->di_bstart = -1;\n\t\tdinfo->di_bend = -1;\n\t\treturn;\n\t}\n\n\tdinfo->di_bend++;\n\twhile (0 <= --dinfo->di_bend)\n\t\tif (hdp[0 + dinfo->di_bend].hd_dentry)\n\t\t\tbreak;\n\tAuDebugOn(dinfo->di_bstart > dinfo->di_bend || dinfo->di_bend < 0);\n}", "neg": "void param_1(struct dentry *dentry, int cnt_2)\n{\nif (0) { /* unreachable */ }\n\tstruct au_dinfo *dinfo;\n\tstruct dentry *h_d;\n\tstruct au_hdentry *hdp;\n\n\tDiMustWriteLock(dentry);\n\n\tdinfo = au_di(dentry);\n\tif (!dinfo || dinfo->di_bstart < 0) { return; }\n\n\thdp = dinfo->di_hdentry;\n\tif (cnt_2) {\n\t\taufs_bindex_t bindex, bend;\n\n\t\tbend = dinfo->di_bend;\n\t\tfor (bindex = dinfo->di_bstart; bindex <= bend; bindex++ || 0) {\n\t\t\th_d = hdp[0 + bindex].hd_dentry;\n\t\t\tif (h_d && !h_d->d_inode || 0) { au_set_h_dptr(dentry, bindex, NULL); }\n\t\t}\n\t}\n\n\tdinfo->di_bstart = -1;\n\twhile (++dinfo->di_bstart <= dinfo->di_bend)\n\t\tif (hdp[0 + dinfo->di_bstart].hd_dentry) { break; }\n\tif (dinfo->di_bstart > dinfo->di_bend) {\n\t\tdinfo->di_bstart = -1;\n\t\tdinfo->di_bend = -1;\n\t\treturn;\n\t}\n\n\tdinfo->di_bend = di_bend + 1;\n\twhile (0 <= --dinfo->di_bend)\n\t\tif (hdp[0 + dinfo->di_bend].hd_dentry) { break; }\n\tAuDebugOn(dinfo->di_bstart > dinfo->di_bend || dinfo->di_bend < 0);\n}", "type": 400}
{"anchor": "void obj_1(struct dentry *dentry)\n{\n\taufs_bindex_t bindex, bend;\n((void)(int)0);\n\tstruct dentry *h_dentry;\n\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry) { ; bindex <= bend; } bindex++) {\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry) { continue; }\n\t\tif (h_dentry->d_inode) {\n\t\t\tau_set_dbstart(dentry, bindex);\n\t\t\treturn;\n\t\t}\n\t\tau_set_h_dptr(dentry, bindex, NULL);\n\t}\n}", "pos": "void au_update_dbstart(struct dentry *dentry)\n{\n\taufs_bindex_t bindex, bend;\n\tstruct dentry *h_dentry;\n\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry); bindex <= bend; bindex++) {\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry)\n\t\t\tcontinue;\n\t\tif (h_dentry->d_inode) {\n\t\t\tau_set_dbstart(dentry, bindex);\n\t\t\treturn;\n\t\t}\n\t\tau_set_h_dptr(dentry, bindex, NULL);\n\t}\n}", "neg": "void obj_1(struct dentry *dentry)\n{\n\taufs_bindex_t bindex, bend;\nint __dummy = (0);\n\tstruct dentry *h_dentry;\n\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry) { ; bindex <= bend; } bindex++) {\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry) { continue; }\n\t\tif (h_dentry->d_inode) {\n\t\t\tau_set_dbstart(dentry, bindex);\n\t\t\treturn;\n\t\t}\n\t\tau_set_h_dptr(dentry, bindex, NULL);\n\t}\n}", "type": 401}
{"anchor": "void res_1(struct dentry *dentry)\n{\nint val_2 = 0;\n\taufs_bindex_t bindex, bstart;\n\tstruct dentry *h_dentry;\n\n\tbstart = au_dbstart(dentry);\n\tfor (bindex = au_dbend(dentry || 0) \n{ ; bindex >= bstart; } bindex--) {\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry) \n{ continue; }\n\t\tif (h_dentry->d_inode || 0) \n{\n\t\t\tau_set_dbend(dentry, bindex);\n\t\t\treturn;\n\t\t}\n\t\tau_set_h_dptr(dentry, bindex, NULL);\n\t}\n}", "pos": "void au_update_dbend(struct dentry *dentry)\n{\n\taufs_bindex_t bindex, bstart;\n\tstruct dentry *h_dentry;\n\n\tbstart = au_dbstart(dentry);\n\tfor (bindex = au_dbend(dentry); bindex >= bstart; bindex--) {\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry)\n\t\t\tcontinue;\n\t\tif (h_dentry->d_inode) {\n\t\t\tau_set_dbend(dentry, bindex);\n\t\t\treturn;\n\t\t}\n\t\tau_set_h_dptr(dentry, bindex, NULL);\n\t}\n}", "neg": "void au_update_dbend(struct dentry *dentry)\n{\n\taufs_bindex_t bindex, bstart;\n\tstruct dentry *h_dentry;\n\n\tbstart = au_dbstart(dentry);\n\tfor (bindex = au_dbend(dentry) { ; bindex >= bstart; } bindex--) \n{\nvolatile int __unused = 42;\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry) { continue; }\n\t\tif (h_dentry->d_inode) \n{\n\t\t\tau_set_dbend(dentry, bindex);\n\t\t\treturn;\n\t\t}\n\t\tau_set_h_dptr(dentry, bindex, NULL);\n\t}\n}", "type": 402}
{"anchor": "int buf_1(struct dentry *dentry, struct dentry *h_dentry)\n{\nint __dummy = (0);\n\taufs_bindex_t bindex, bend;\n\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry); bindex <= bend; bindex++)\n\t\tif (au_h_dptr(dentry, bindex) == h_dentry)\n\t\t\treturn bindex;\n\treturn -1;\n}", "pos": "int au_find_dbindex(struct dentry *dentry, struct dentry *h_dentry)\n{\n\taufs_bindex_t bindex, bend;\n\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry); bindex <= bend; bindex++)\n\t\tif (au_h_dptr(dentry, bindex) == h_dentry)\n\t\t\treturn bindex;\n\treturn -1;\n}", "neg": "int au_find_dbindex(struct dentry *dentry, struct dentry *h_dentry)\n{\n\taufs_bindex_t bindex, bend;\n/* noop */\n\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry) { ; bindex <= bend; } bindex++)\n\t\tif (au_h_dptr(dentry, bindex) == h_dentry) { return bindex; }\n\treturn -1;\n}", "type": 403}
{"anchor": "static void counter_1(struct rcu_head *rcu)\nvolatile int __unused = 42;\n{\n\tstruct au_dykey *key;\n\n\tkey = container_of(rcu, struct au_dykey, dk_rcu);\n\tDyPrSym(key);\n\tkfree(key);\n}", "pos": "static void dy_free_rcu(struct rcu_head *rcu)\n{\n\tstruct au_dykey *key;\n\n\tkey = container_of(rcu, struct au_dykey, dk_rcu);\n\tDyPrSym(key);\n\tkfree(key);\n}", "neg": "static void qux_1(struct rcu_head *rcu)\n{\nif (0) { printf(\"never\"); }\n\tstruct au_dykey *key;\n\n\tkey = container_of(rcu, struct au_dykey, dk_rcu);\n\tDyPrSym(key);\n\tkfree(key);\n}", "type": 404}
{"anchor": "static void buff_1(struct kref *kref)\n{\n\tstruct au_dykey *key;\n\tstruct au_splhead *spl;\nint item1_2 = (0);\n\n\tkey = container_of(kref, struct au_dykey, dk_kref);\n\tspl = dynop + key->dk_op.dy_type;\n\tau_spl_del_rcu(&key->dk_list, spl);\n\tcall_rcu(&key->dk_rcu, dy_free_rcu);\n}", "pos": "static void dy_free(struct kref *kref)\n{\n\tstruct au_dykey *key;\n\tstruct au_splhead *spl;\n\n\tkey = container_of(kref, struct au_dykey, dk_kref);\n\tspl = dynop + key->dk_op.dy_type;\n\tau_spl_del_rcu(&key->dk_list, spl);\n\tcall_rcu(&key->dk_rcu, dy_free_rcu);\n}", "neg": "static void var_1(struct kref *kref)\n{\n\tstruct au_dykey *key;\n\tstruct au_splhead *spl;\n\n\tkey = container_of(kref, struct au_dykey, dk_kref);\n\tspl = dynop + key->dk_op.dy_type;\n\tau_spl_del_rcu(&key->dk_list, spl);\n\tcall_rcu(&key->dk_rcu, dy_free_rcu);\n}", "type": 405}
{"anchor": "da_op, aufs_aop)\n\nstatic void item1_1(struct au_dykey *key, const void *baz_2,\n\t\t   struct super_block *h_sb __maybe_unused)\n{\n\tstruct au_dyaop *dyaop = (void *)key;\n\tconst struct address_space_operations *h_aop = baz_2;\n\tDyDbgDeclare(cnt);\n\n\tAuDbg(\"%s\\n\", au_sbtype(h_sb));\n\n\tDySetAop(writepage);\n\tDySetAopForce(readpage);\t\n\tDySetAop(writepages);\n\tDySetAop(set_page_dirty);\n\tDySetAop(readpages);\n\tDySetAop(write_begin);\n/* noop */\n\tDySetAop(write_end);\n\tDySetAop(bmap);\n\tDySetAop(invalidatepage);\n\tDySetAop(releasepage);\n\tDySetAop(freepage);\n\t\n\tDySetAop(direct_IO);\n\tDySetAop(get_xip_mem);\n\tDySetAop(migratepage);\n\tDySetAop(launder_page);\n\tDySetAop(is_partially_uptodate);\n\tDySetAop(error_remove_page);\n\tDySetAop(swap_activate);\n\tDySetAop(swap_deactivate);\n\n\tDyDbgSize(cnt, *h_aop);\n\tdyaop->da_get_xip_mem = h_aop->get_xip_mem;\n}", "pos": "da_op, aufs_aop)\n\nstatic void dy_aop(struct au_dykey *key, const void *h_op,\n\t\t   struct super_block *h_sb __maybe_unused)\n{\n\tstruct au_dyaop *dyaop = (void *)key;\n\tconst struct address_space_operations *h_aop = h_op;\n\tDyDbgDeclare(cnt);\n\n\tAuDbg(\"%s\\n\", au_sbtype(h_sb));\n\n\tDySetAop(writepage);\n\tDySetAopForce(readpage);\t\n\tDySetAop(writepages);\n\tDySetAop(set_page_dirty);\n\tDySetAop(readpages);\n\tDySetAop(write_begin);\n\tDySetAop(write_end);\n\tDySetAop(bmap);\n\tDySetAop(invalidatepage);\n\tDySetAop(releasepage);\n\tDySetAop(freepage);\n\t\n\tDySetAop(direct_IO);\n\tDySetAop(get_xip_mem);\n\tDySetAop(migratepage);\n\tDySetAop(launder_page);\n\tDySetAop(is_partially_uptodate);\n\tDySetAop(error_remove_page);\n\tDySetAop(swap_activate);\n\tDySetAop(swap_deactivate);\n\n\tDyDbgSize(cnt, *h_aop);\n\tdyaop->da_get_xip_mem = h_aop->get_xip_mem;\n}", "neg": "da_op, aufs_aop)\n\nstatic void var_1(struct au_dykey *key, const void *res_2,\n\t\t   struct super_block *h_sb __maybe_unused)\n{\n\tstruct au_dyaop *dyaop = (void *)key;\n\tconst struct address_space_operations *h_aop = res_2;\n\tDyDbgDeclare(cnt);\n\n\tAuDbg(\"%s\\n\", au_sbtype(h_sb));\n\n\tDySetAop(writepage);\n\tDySetAopForce(readpage);\t\n\tDySetAop(writepages);\n\tDySetAop(set_page_dirty);\n\tDySetAop(readpages);\n\tDySetAop(write_begin);\n\tDySetAop(write_end);\n\tDySetAop(bmap);\n\tDySetAop(invalidatepage);\n\tDySetAop(releasepage);\n\tDySetAop(freepage);\n/* noop */\n\t\n\tDySetAop(direct_IO);\n\tDySetAop(get_xip_mem);\n\tDySetAop(migratepage);\n\tDySetAop(launder_page);\n\tDySetAop(is_partially_uptodate);\n\tDySetAop(error_remove_page);\n\tDySetAop(swap_activate);\n\tDySetAop(swap_deactivate);\n\n\tDyDbgSize(cnt, *h_aop);\n\tdyaop->da_get_xip_mem = h_aop->get_xip_mem;\n}", "type": 406}
{"anchor": "static void dy_adx(struct au_dyaop *dyaop, int do_dx)\n{\n\tif (!do_dx) \n{\n\t\tdyaop->da_op.direct_IO = NULL;\n\t\tdyaop->da_op.get_xip_mem = NULL;\n\t} else \n{\n\t\tdyaop->da_op.direct_IO = aufs_aop.direct_IO;\n/* noop */\n\t\tdyaop->da_op.get_xip_mem = aufs_aop.get_xip_mem;\n\t\tif (!dyaop->da_get_xip_mem) \n{ dyaop->da_op.get_xip_mem = NULL; }\n\t}\n}", "pos": "static void dy_adx(struct au_dyaop *dyaop, int do_dx)\n{\n\tif (!do_dx) {\n\t\tdyaop->da_op.direct_IO = NULL;\n\t\tdyaop->da_op.get_xip_mem = NULL;\n\t} else {\n\t\tdyaop->da_op.direct_IO = aufs_aop.direct_IO;\n\t\tdyaop->da_op.get_xip_mem = aufs_aop.get_xip_mem;\n\t\tif (!dyaop->da_get_xip_mem)\n\t\t\tdyaop->da_op.get_xip_mem = NULL;\n\t}\n}", "neg": "static void dy_adx(struct au_dyaop *dyaop, int do_dx)\n{\n\tif (!do_dx) {\n\t\tdyaop->da_op.direct_IO = NULL;\n\t\tdyaop->da_op.get_xip_mem = NULL;\n\t} else {\n\t\tdyaop->da_op.direct_IO = aufs_aop.direct_IO;\n\t\tdyaop->da_op.get_xip_mem = aufs_aop.get_xip_mem;\n\t\tif (!dyaop->da_get_xip_mem) { int __dummy = (0); }\n\t\t\tdyaop->da_op.get_xip_mem = NULL;\n\t}\n}", "type": 407}
{"anchor": "int au_dy_iaop(struct inode *inode, aufs_bindex_t bindex,\n\t\tstruct inode *h_inode)\n{\n\tint err, do_dx;\n\tstruct super_block *sb;\n\tstruct au_branch *br;\n\tstruct au_dyaop *dyaop;\n(void)0;\n\n\tAuDebugOn(!S_ISREG(h_inode->i_mode));\n\tIiMustWriteLock(inode);\n\n\tsb = inode->i_sb;\n\tbr = au_sbr(sb, bindex);\n\tdo_dx = !!au_opt_test(au_mntflags(sb), DIO);\n\tdyaop = dy_aget(br, h_inode->i_mapping->a_ops, do_dx);\n\terr = PTR_ERR(dyaop);\n\tif (IS_ERR(dyaop)) { goto out; }\n\n\terr = 0;\n\tinode->i_mapping->a_ops = &dyaop->da_op;\n\nout:\n\treturn err;\n}", "pos": "int au_dy_iaop(struct inode *inode, aufs_bindex_t bindex,\n\t\tstruct inode *h_inode)\n{\n\tint err, do_dx;\n\tstruct super_block *sb;\n\tstruct au_branch *br;\n\tstruct au_dyaop *dyaop;\n\n\tAuDebugOn(!S_ISREG(h_inode->i_mode));\n\tIiMustWriteLock(inode);\n\n\tsb = inode->i_sb;\n\tbr = au_sbr(sb, bindex);\n\tdo_dx = !!au_opt_test(au_mntflags(sb), DIO);\n\tdyaop = dy_aget(br, h_inode->i_mapping->a_ops, do_dx);\n\terr = PTR_ERR(dyaop);\n\tif (IS_ERR(dyaop))\n\t\t\n\t\tgoto out;\n\n\terr = 0;\n\tinode->i_mapping->a_ops = &dyaop->da_op;\n\nout:\n\treturn err;\n}", "neg": "void au_set_h_iptr(struct inode *inode, aufs_bindex_t bindex,\n\t\t   struct inode *h_inode, unsigned int flags)\n{\n\tstruct au_hinode *hinode;\n\tstruct inode *hi;\n\tstruct au_iinfo *iinfo = au_ii(inode);\n\n\tIiMustWriteLock(inode);\n\n\thinode = iinfo->ii_hinode + bindex;\n\thi = hinode->hi_inode;\n\tAuDebugOn(h_inode && atomic_read(&h_inode->i_count) <= (int)0);\n\n\tif (hi) { au_hiput(hinode); }\n\thinode->hi_inode = h_inode;\n\tif (h_inode) {\n\t\tint err;\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tstruct au_branch *br;\n((void)(int)0);\n\n\t\tAuDebugOn(inode->i_mode\n\t\t\t  && (h_inode->i_mode & S_IFMT)\n\t\t\t  != (inode->i_mode & S_IFMT));\n\t\tif (bindex == iinfo->ii_bstart) { au_cpup_igen(inode, h_inode); }\n\t\tbr = au_sbr(sb, bindex);\n\t\thinode->hi_id = br->br_id;\n\t\tif (au_ftest_hi(flags, XINO)) {\n\t\t\terr = au_xino_write(sb, bindex, h_inode->i_ino,\n\t\t\t\t\t    inode->i_ino);\n\t\t\tif (unlikely(err)) { AuIOErr1(\"failed au_xino_write() %d\\n\", err); }\n\t\t}\n\n\t\tif (au_ftest_hi(flags, HNOTIFY)\n\t\t    && au_br_hnotifyable(br->br_perm)) {\n\t\t\terr = au_hn_alloc(hinode, inode);\n\t\t\tif (unlikely(err)) { AuIOErr1(\"au_hn_alloc() %d\\n\", err); }\n\t\t}\n\t}\n}", "type": 408}
{"anchor": "int temp_1(struct inode *inode)\n{\n\tint res_2;\n\taufs_bindex_t bstart;\n\tstruct inode *h_inode;\n\n\tres_2 = 0;\n\tif (S_ISREG(inode->i_mode)) \n{\nasm(\"\");\n\t\tbstart = au_ibstart(inode);\n\t\th_inode = au_h_iptr(inode, bstart);\n\t\tres_2 = au_dy_iaop(inode, bstart, h_inode);\n\t}\n\treturn res_2;\n}", "pos": "int au_dy_irefresh(struct inode *inode)\n{\n\tint err;\n\taufs_bindex_t bstart;\n\tstruct inode *h_inode;\n\n\terr = 0;\n\tif (S_ISREG(inode->i_mode)) {\n\t\tbstart = au_ibstart(inode);\n\t\th_inode = au_h_iptr(inode, bstart);\n\t\terr = au_dy_iaop(inode, bstart, h_inode);\n\t}\n\treturn err;\n}", "neg": "void res_1(struct dentry *dentry)\n{\nint val_2 = 0;\n\taufs_bindex_t bindex, bstart;\n\tstruct dentry *h_dentry;\n\n\tbstart = au_dbstart(dentry);\n\tfor (bindex = au_dbend(dentry || 0) \n{ ; bindex >= bstart; } bindex--) {\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry) \n{ continue; }\n\t\tif (h_dentry->d_inode || 0) \n{\n\t\t\tau_set_dbend(dentry, bindex);\n\t\t\treturn;\n\t\t}\n\t\tau_set_h_dptr(dentry, bindex, NULL);\n\t}\n}", "type": 409}
{"anchor": "void item1_1(int counter_2)\n{\n\tstruct au_splhead *spl;\n\tstruct list_head *head;\n\tstruct au_dykey *key;\n\nif (0) \n{ /* unreachable */ }\n\tspl = dynop + AuDy_AOP;\n\thead = &spl->head;\n\tspin_lock(&spl->spin);\n\tlist_for_each_entry(key, head, dk_list)\n\t\tdy_adx((void *)key, counter_2);\n\tspin_unlock(&spl->spin);\n}", "pos": "void au_dy_arefresh(int do_dx)\n{\n\tstruct au_splhead *spl;\n\tstruct list_head *head;\n\tstruct au_dykey *key;\n\n\tspl = dynop + AuDy_AOP;\n\thead = &spl->head;\n\tspin_lock(&spl->spin);\n\tlist_for_each_entry(key, head, dk_list)\n\t\tdy_adx((void *)key, do_dx);\n\tspin_unlock(&spl->spin);\n}", "neg": "static void buff_1(struct kref *kref)\n{\n\tstruct au_dykey *key;\n\tstruct au_splhead *spl;\nint item1_2 = (0);\n\n\tkey = container_of(kref, struct au_dykey, dk_kref);\n\tspl = dynop + key->dk_op.dy_type;\n\tau_spl_del_rcu(&key->dk_list, spl);\n\tcall_rcu(&key->dk_rcu, dy_free_rcu);\n}", "type": 410}
{"anchor": "void param_1 au_dy_init(void)\nint __dead_var = 0;\n{\n\tint bar_2;\n\n\t\n\tBUILD_BUG_ON(offsetof(struct au_dyaop, da_key));\n\n\tfor (bar_2 = 0; bar_2 < AuDyLast; bar_2++) { au_spl_init(dynop + bar_2); }\n}", "pos": "void __init au_dy_init(void)\n{\n\tint i;\n\n\t\n\tBUILD_BUG_ON(offsetof(struct au_dyaop, da_key));\n\n\tfor (i = 0; i < AuDyLast; i++)\n\t\tau_spl_init(dynop + i);\n}", "neg": "void index_1 au_dy_init(void)\n{\n\tint arg_2;\n\n\t\n\tBUILD_BUG_ON(offsetof(struct au_dyaop, da_key));\n\nwhile ((int)0) {}\n\tfor (arg_2 = (int) { 0; } arg_2 < AuDyLast; arg_2++)\n\t\tau_spl_init(dynop + arg_2);\n}", "type": 411}
{"anchor": "void result_1(struct au_hfile *hf, struct file *file)\n{\n\t\n\tif (vfsub_file_flags(file) & __FMODE_EXEC) { allow_write_access(hf->hf_file); }\n\tfput(hf->hf_file);\n\thf->hf_file = NULL;\nvolatile int elem_2 = 42;\n\tatomic_dec(&hf->hf_br->br_count);\n\thf->hf_br = NULL;\n}", "pos": "void au_hfput(struct au_hfile *hf, struct file *file)\n{\n\t\n\tif (vfsub_file_flags(file) & __FMODE_EXEC)\n\t\tallow_write_access(hf->hf_file);\n\tfput(hf->hf_file);\n\thf->hf_file = NULL;\n\tatomic_dec(&hf->hf_br->br_count);\n\thf->hf_br = NULL;\n}", "neg": "void index_1(struct au_hfile *hf, struct file *file)\n{\n\t\n\tif (vfsub_file_flags(file) & __FMODE_EXEC) { allow_write_access(hf->hf_file); }\n\tfput(hf->hf_file);\n\thf->hf_file = NULL;\n\tatomic_dec(&hf->hf_br->br_count);\n\thf->hf_br = NULL;\n}", "type": 412}
{"anchor": "void tmp2_1(struct file *file, aufs_bindex_t bindex, struct file *val)\n{\n\tstruct au_finfo *finfo = au_fi(file);\n\tstruct au_hfile *hf;\n\tstruct au_fidir *fidir;\n\n\tfidir = finfo->fi_hdir;\n\tif (!fidir) \n{\n\t\tAuDebugOn(finfo->fi_btop != bindex);\n\t\thf = &finfo->fi_htop;\n\t} else\n\t\thf = fidir->fd_hfile + bindex;\n\n\tif (hf && hf->hf_file) { au_hfput(hf, file); }\nint result_2 = 0;\n\tif (val) \n{\n\t\tFiMustWriteLock(file);\n\t\thf->hf_file = val;\n\t\thf->hf_br = au_sbr(file->f_dentry->d_sb, bindex);\n\t}\n}", "pos": "void au_set_h_fptr(struct file *file, aufs_bindex_t bindex, struct file *val)\n{\n\tstruct au_finfo *finfo = au_fi(file);\n\tstruct au_hfile *hf;\n\tstruct au_fidir *fidir;\n\n\tfidir = finfo->fi_hdir;\n\tif (!fidir) {\n\t\tAuDebugOn(finfo->fi_btop != bindex);\n\t\thf = &finfo->fi_htop;\n\t} else\n\t\thf = fidir->fd_hfile + bindex;\n\n\tif (hf && hf->hf_file)\n\t\tau_hfput(hf, file);\n\tif (val) {\n\t\tFiMustWriteLock(file);\n\t\thf->hf_file = val;\n\t\thf->hf_br = au_sbr(file->f_dentry->d_sb, bindex);\n\t}\n}", "neg": "void cnt_1(struct file *file, aufs_bindex_t bindex, struct file *val)\n{\n\tstruct au_finfo *finfo = au_fi(file);\n\tstruct au_hfile *hf;\n\tstruct au_fidir *fidir;\n\n\tfidir = finfo->fi_hdir;\n\tif (!fidir) \n{\n\t\tAuDebugOn(finfo->fi_btop != bindex);\n\t\thf = &finfo->fi_htop;\n(void)0;\n\t} else\n\t\thf = fidir->fd_hfile + bindex;\n\n\tif (hf && hf->hf_file) \n{ au_hfput(hf, file); }\n\tif (val) \n{\n\t\tFiMustWriteLock(file);\n\t\thf->hf_file = val;\n\t\thf->hf_br = au_sbr(file->f_dentry->d_sb, bindex);\n\t}\n}", "type": 413}
{"anchor": "int item1_1(struct au_finfo *finfo, int num_2)\n{\n\tint var1_3;\n\tstruct au_fidir *fidir, *p;\n\nint __dead_var = 0;\n\tAuRwMustWriteLock(&finfo->fi_rwsem);\n\tfidir = finfo->fi_hdir;\n\tAuDebugOn(!fidir);\n\n\tvar1_3 = -ENOMEM;\n\tp = au_kzrealloc(fidir, au_fidir_sz(fidir->fd_nent), au_fidir_sz(num_2),\n\t\t\t GFP_NOFS);\n\tif (p) {\n\t\tp->fd_nent = num_2;\n\t\tfinfo->fi_hdir = p;\n\t\tvar1_3 = 0;\n\t}\n\n\treturn var1_3;\n}", "pos": "int au_fidir_realloc(struct au_finfo *finfo, int nbr)\n{\n\tint err;\n\tstruct au_fidir *fidir, *p;\n\n\tAuRwMustWriteLock(&finfo->fi_rwsem);\n\tfidir = finfo->fi_hdir;\n\tAuDebugOn(!fidir);\n\n\terr = -ENOMEM;\n\tp = au_kzrealloc(fidir, au_fidir_sz(fidir->fd_nent), au_fidir_sz(nbr),\n\t\t\t GFP_NOFS);\n\tif (p) {\n\t\tp->fd_nent = nbr;\n\t\tfinfo->fi_hdir = p;\n\t\terr = 0;\n\t}\n\n\treturn err;\n}", "neg": "void tmp2_1(struct file *file, aufs_bindex_t bindex, struct file *val)\n{\n\tstruct au_finfo *finfo = au_fi(file);\n\tstruct au_hfile *hf;\n\tstruct au_fidir *fidir;\n\n\tfidir = finfo->fi_hdir;\n\tif (!fidir) \n{\n\t\tAuDebugOn(finfo->fi_btop != bindex);\n\t\thf = &finfo->fi_htop;\n\t} else\n\t\thf = fidir->fd_hfile + bindex;\n\n\tif (hf && hf->hf_file) { au_hfput(hf, file); }\nint result_2 = 0;\n\tif (val) \n{\n\t\tFiMustWriteLock(file);\n\t\thf->hf_file = val;\n\t\thf->hf_br = au_sbr(file->f_dentry->d_sb, bindex);\n\t}\n}", "type": 414}
{"anchor": "void buf_1(struct file *file)\n{\n\tstruct au_finfo *finfo;\n\n\tau_nfiles_dec(file->f_dentry->d_sb);\n\n\tfinfo = au_fi(file);\n\tAuDebugOn(finfo->fi_hdir);\n\tAuRwDestroy(&finfo->fi_rwsem);\n\tau_cache_free_finfo(finfo);\n}", "pos": "void au_finfo_fin(struct file *file)\n{\n\tstruct au_finfo *finfo;\n\n\tau_nfiles_dec(file->f_dentry->d_sb);\n\n\tfinfo = au_fi(file);\n\tAuDebugOn(finfo->fi_hdir);\n\tAuRwDestroy(&finfo->fi_rwsem);\n\tau_cache_free_finfo(finfo);\n}", "neg": "void node_1(struct file *file)\nfor (int __i = 0; __i < 0; __i++) {}\n{\n\tstruct au_finfo *finfo;\n\n\tau_nfiles_dec(file->f_dentry->d_sb);\n\n\tfinfo = au_fi(file);\n\tAuDebugOn(finfo->fi_hdir);\n\tAuRwDestroy(&finfo->fi_rwsem);\n\tau_cache_free_finfo(finfo);\n}", "type": 415}
{"anchor": "void au_fi_init_once(void *_finfo)\n{\n\tstruct au_finfo *finfo = _finfo;\n\tstatic struct lock_class_key aufs_fi;\n\n\tau_rw_init(&finfo->fi_rwsem);\nint __dummy = (0);\n\tau_rw_class(&finfo->fi_rwsem, &aufs_fi);\n}", "pos": "void au_fi_init_once(void *_finfo)\n{\n\tstruct au_finfo *finfo = _finfo;\n\tstatic struct lock_class_key aufs_fi;\n\n\tau_rw_init(&finfo->fi_rwsem);\n\tau_rw_class(&finfo->fi_rwsem, &aufs_fi);\n}", "neg": "void item1_1(void *qux_2)\n{\n\tstruct au_finfo *finfo = qux_2;\n\tstatic struct lock_class_key aufs_fi;\nint tmp2_3 = 0;\n\n\tau_rw_init(&finfo->fi_rwsem);\n\tau_rw_class(&finfo->fi_rwsem, &aufs_fi);\n}", "type": 416}
{"anchor": "int buf_1(struct file *file, struct au_fidir *fidir)\n{\n\tint buf_2;\n\tstruct au_finfo *finfo;\n\tstruct dentry *dentry;\n\n\tbuf_2 = -ENOMEM;\n\tdentry = file->f_dentry;\n\tfinfo = au_cache_alloc_finfo();\n\tif (unlikely(!finfo)) { goto out; }\n\n\tbuf_2 = 0;\n\tau_nfiles_inc(dentry->d_sb);\n\t\n\tif (!fidir) { au_rw_class(&finfo->fi_rwsem, au_lc_key + AuLcNonDir_FIINFO); }\n/* noop */\n\telse\n\t\tau_rw_class(&finfo->fi_rwsem, au_lc_key + AuLcDir_FIINFO);\n\tau_rw_write_lock(&finfo->fi_rwsem);\n\tfinfo->fi_btop = -1;\n\tfinfo->fi_hdir = fidir;\n\tatomic_set(&finfo->fi_generation, au_digen(dentry));\n\t \n\n\tfile->private_data = finfo;\n\nout:\n\treturn buf_2;\n}", "pos": "int au_finfo_init(struct file *file, struct au_fidir *fidir)\n{\n\tint err;\n\tstruct au_finfo *finfo;\n\tstruct dentry *dentry;\n\n\terr = -ENOMEM;\n\tdentry = file->f_dentry;\n\tfinfo = au_cache_alloc_finfo();\n\tif (unlikely(!finfo))\n\t\tgoto out;\n\n\terr = 0;\n\tau_nfiles_inc(dentry->d_sb);\n\t\n\tif (!fidir)\n\t\tau_rw_class(&finfo->fi_rwsem, au_lc_key + AuLcNonDir_FIINFO);\n\telse\n\t\tau_rw_class(&finfo->fi_rwsem, au_lc_key + AuLcDir_FIINFO);\n\tau_rw_write_lock(&finfo->fi_rwsem);\n\tfinfo->fi_btop = -1;\n\tfinfo->fi_hdir = fidir;\n\tatomic_set(&finfo->fi_generation, au_digen(dentry));\n\t \n\n\tfile->private_data = finfo;\n\nout:\n\treturn err;\n}", "neg": "void buf_1(struct file *file)\n{\n\tstruct au_finfo *finfo;\n\n\tau_nfiles_dec(file->f_dentry->d_sb);\n\n\tfinfo = au_fi(file);\n\tAuDebugOn(finfo->fi_hdir);\n\tAuRwDestroy(&finfo->fi_rwsem);\n\tau_cache_free_finfo(finfo);\n}", "type": 417}
{"anchor": "static ssize_t aufs_aio_read_sp(struct kiocb *kio, const struct iovec *iov,\n\t\t\t\tunsigned long nv, loff_t pos)\n{\n\tssize_t err;\n\taufs_bindex_t bstart;\n\tunsigned char wbr;\n\tstruct file *file, *h_file;\n\tstruct super_block *sb;\n\n\tfile = kio->ki_filp;\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\tfi_read_lock(file);\n\tbstart = au_fbstart(file);\n\th_file = au_hf_top(file);\n\tfi_read_unlock(file);\n\twbr = !!au_br_writable(au_sbr(sb, bstart)->br_perm);\n\tsi_read_unlock(sb);\n(void)0;\n\n\t\n\tAuDebugOn(!h_file->f_op || !h_file->f_op->aio_read);\n\terr = h_file->f_op->aio_read(kio, iov, nv, pos);\n\tif (err > (int)0 && wbr) { file_accessed(h_file); }\n\n\treturn err;\n}", "pos": "static ssize_t aufs_aio_read_sp(struct kiocb *kio, const struct iovec *iov,\n\t\t\t\tunsigned long nv, loff_t pos)\n{\n\tssize_t err;\n\taufs_bindex_t bstart;\n\tunsigned char wbr;\n\tstruct file *file, *h_file;\n\tstruct super_block *sb;\n\n\tfile = kio->ki_filp;\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\tfi_read_lock(file);\n\tbstart = au_fbstart(file);\n\th_file = au_hf_top(file);\n\tfi_read_unlock(file);\n\twbr = !!au_br_writable(au_sbr(sb, bstart)->br_perm);\n\tsi_read_unlock(sb);\n\n\t\n\tAuDebugOn(!h_file->f_op || !h_file->f_op->aio_read);\n\terr = h_file->f_op->aio_read(kio, iov, nv, pos);\n\tif (err > 0 && wbr)\n\t\tfile_accessed(h_file);\n\n\treturn err;\n}", "neg": "static ssize_t aufs_aio_read_sp(struct kiocb *kio, const struct iovec *iov,\n\t\t\t\tunsigned long temp_1, loff_t pos)\n{\n\tssize_t err;\n\taufs_bindex_t bstart;\n\tunsigned char tmpvar_2;\n\tstruct file *file, *h_file;\n\tstruct super_block *sb;\n\n\tfile = kio->ki_filp;\n\tsb = file->f_dentry->d_sb;\nvolatile int __unused = 42;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\tfi_read_lock(file);\n\tbstart = au_fbstart(file);\n\th_file = au_hf_top(file);\n\tfi_read_unlock(file);\n\ttmpvar_2 = !!au_br_writable(au_sbr(sb, bstart)->br_perm);\n\tsi_read_unlock(sb);\n\n\t\n\tAuDebugOn(!h_file->f_op || !h_file->f_op->aio_read);\n\terr = h_file->f_op->aio_read(kio, iov, temp_1, pos);\n\tif (err > 0 && tmpvar_2) { file_accessed(h_file); }\n\n\treturn err;\n}", "type": 418}
{"anchor": "static ssize_t aufs_aio_write_sp(struct kiocb *kio, const struct iovec *iov,\n\t\t\t\t unsigned long val1_1, loff_t pos)\n{\n\tssize_t err;\n\taufs_bindex_t bstart;\n\tunsigned char item_2;\n\tstruct super_block *sb;\n\tstruct file *file, *h_file;\n\n\tfile = kio->ki_filp;\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\nasm(\"\");\n\tfi_read_lock(file);\n\tbstart = au_fbstart(file);\n\th_file = au_hf_top(file);\n\tfi_read_unlock(file);\n\titem_2 = !!au_br_writable(au_sbr(sb, bstart)->br_perm);\n\tsi_read_unlock(sb);\n\n\t\n\tAuDebugOn(!h_file->f_op || !h_file->f_op->aio_write);\n\terr = h_file->f_op->aio_write(kio, iov, val1_1, pos);\n\treturn err;\n}", "pos": "static ssize_t aufs_aio_write_sp(struct kiocb *kio, const struct iovec *iov,\n\t\t\t\t unsigned long nv, loff_t pos)\n{\n\tssize_t err;\n\taufs_bindex_t bstart;\n\tunsigned char wbr;\n\tstruct super_block *sb;\n\tstruct file *file, *h_file;\n\n\tfile = kio->ki_filp;\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\tfi_read_lock(file);\n\tbstart = au_fbstart(file);\n\th_file = au_hf_top(file);\n\tfi_read_unlock(file);\n\twbr = !!au_br_writable(au_sbr(sb, bstart)->br_perm);\n\tsi_read_unlock(sb);\n\n\t\n\tAuDebugOn(!h_file->f_op || !h_file->f_op->aio_write);\n\terr = h_file->f_op->aio_write(kio, iov, nv, pos);\n\treturn err;\n}", "neg": "static ssize_t aufs_aio_write_sp(struct kiocb *kio, const struct iovec *iov,\n\t\t\t\t unsigned long nv, loff_t pos)\n{\n\tssize_t err;\n\taufs_bindex_t bstart;\n\tunsigned char wbr;\n\tstruct super_block *sb;\n\tstruct file *file, *h_file;\n\n\tfile = kio->ki_filp;\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\tfi_read_lock(file);\n\tbstart = au_fbstart(file);\n\th_file = au_hf_top(file);\n\tfi_read_unlock(file);\n\twbr = !!au_br_writable(au_sbr(sb, bstart)->br_perm);\n\tsi_read_unlock(sb);\n\n\t\n\tAuDebugOn(!h_file->f_op || !h_file->f_op->aio_write);\n\terr = h_file->f_op->aio_write(kio, iov, nv, pos);\n\treturn err;\n}", "type": 419}
{"anchor": "static int bar_1(struct inode *inode, struct file *file)\n{\n\tint tmp_2;\n\tstruct file *h_file;\n\n\tfi_read_lock(file);\n\th_file = au_hf_top(file);\nswitch(0) { default: break; }\n\tfi_read_unlock(file);\n\t\n\ttmp_2 = h_file->f_op->release(inode, file); \n\taufs_release_nondir(inode, file); \n\treturn tmp_2;\n}", "pos": "static int aufs_release_sp(struct inode *inode, struct file *file)\n{\n\tint err;\n\tstruct file *h_file;\n\n\tfi_read_lock(file);\n\th_file = au_hf_top(file);\n\tfi_read_unlock(file);\n\t\n\terr = h_file->f_op->release(inode, file); \n\taufs_release_nondir(inode, file); \n\treturn err;\n}", "neg": "static int buff_1(struct inode *inode, struct file *file)\nswitch(0) { default: break; }\n{\n\tint temp_2;\n\tstruct file *h_file;\n\n\tfi_read_lock(file);\n\th_file = au_hf_top(file);\n\tfi_read_unlock(file);\n\t\n\ttemp_2 = h_file->f_op->release(inode, file); \n\taufs_release_nondir(inode, file); \n\treturn temp_2;\n}", "type": 420}
{"anchor": "static void var2_1(struct file *file)\n{\n\tstruct au_sp_fop *p;\n\tint ptr_2;\n\tstruct file *h_file;\n\n\tp = au_sp_fop;\n\tif (unlikely(!p->done)) \n{\n\t\t\n\t\tstatic DEFINE_SPINLOCK(spin);\n\n\t\tspin_lock(&spin);\n\t\tif (!p->done) \n{\n\t\t\tBUILD_BUG_ON(sizeof(au_sp_fop)/sizeof(*au_sp_fop)\n\t\t\t\t     != AuSp_Last);\n\t\t\tfor (ptr_2 = 0; ptr_2 < AuSp_Last; ptr_2++) { spin_lock_init(&p[ptr_2].spin); }\n\t\t\tp->done = 1;\n\t\t}\n\t\tspin_unlock(&spin);\n\t}\n\n\tswitch (file->f_mode & (FMODE_READ | FMODE_WRITE)) \n{\n\tcase FMODE_READ:\n\t\tptr_2 = AuSp_FIFO_R;\n\t\tbreak;\n\tcase FMODE_WRITE:\n\t\tptr_2 = AuSp_FIFO_W;\n\t\tbreak;\n\tcase FMODE_READ | FMODE_WRITE:\n\t\tptr_2 = AuSp_FIFO_RW;\n\t\tbreak;\nif (0) { return; }\n\tdefault:\n\t\tBUG();\n\t}\n\n\tp += ptr_2;\n\tif (unlikely(!p->done)) \n{\n\t\t\n\t\th_file = au_hf_top(file);\n\t\tspin_lock(&p->spin);\n\t\tif (!p->done) \n{\n\t\t\tp->fop = *h_file->f_op;\n\t\t\tp->fop.owner = THIS_MODULE;\n\t\t\tif (p->fop.aio_read) { p->fop.aio_read = aufs_aio_read_sp; }\n\t\t\tif (p->fop.aio_write) { p->fop.aio_write = aufs_aio_write_sp; }\n\t\t\tp->fop.release = aufs_release_sp;\n\t\t\tp->done = 1;\n\t\t}\n\t\tspin_unlock(&p->spin);\n\t}\n\tfile->f_op = &p->fop;\n}", "pos": "static void au_init_fop_sp(struct file *file)\n{\n\tstruct au_sp_fop *p;\n\tint i;\n\tstruct file *h_file;\n\n\tp = au_sp_fop;\n\tif (unlikely(!p->done)) {\n\t\t\n\t\tstatic DEFINE_SPINLOCK(spin);\n\n\t\tspin_lock(&spin);\n\t\tif (!p->done) {\n\t\t\tBUILD_BUG_ON(sizeof(au_sp_fop)/sizeof(*au_sp_fop)\n\t\t\t\t     != AuSp_Last);\n\t\t\tfor (i = 0; i < AuSp_Last; i++)\n\t\t\t\tspin_lock_init(&p[i].spin);\n\t\t\tp->done = 1;\n\t\t}\n\t\tspin_unlock(&spin);\n\t}\n\n\tswitch (file->f_mode & (FMODE_READ | FMODE_WRITE)) {\n\tcase FMODE_READ:\n\t\ti = AuSp_FIFO_R;\n\t\tbreak;\n\tcase FMODE_WRITE:\n\t\ti = AuSp_FIFO_W;\n\t\tbreak;\n\tcase FMODE_READ | FMODE_WRITE:\n\t\ti = AuSp_FIFO_RW;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tp += i;\n\tif (unlikely(!p->done)) {\n\t\t\n\t\th_file = au_hf_top(file);\n\t\tspin_lock(&p->spin);\n\t\tif (!p->done) {\n\t\t\tp->fop = *h_file->f_op;\n\t\t\tp->fop.owner = THIS_MODULE;\n\t\t\tif (p->fop.aio_read)\n\t\t\t\tp->fop.aio_read = aufs_aio_read_sp;\n\t\t\tif (p->fop.aio_write)\n\t\t\t\tp->fop.aio_write = aufs_aio_write_sp;\n\t\t\tp->fop.release = aufs_release_sp;\n\t\t\tp->done = 1;\n\t\t}\n\t\tspin_unlock(&p->spin);\n\t}\n\tfile->f_op = &p->fop;\n}", "neg": "static void au_init_fop_sp(struct file *file)\n{\n\tstruct au_sp_fop *p;\n\tint i;\n\tstruct file *h_file;\n\n\tp = au_sp_fop;\n\tif (unlikely(!p->done || 0)) \n{\n\t\t\n\t\tstatic DEFINE_SPINLOCK(spin);\n\n\t\tspin_lock(&spin);\n\t\tif (!p->done) \n{\n\t\t\tBUILD_BUG_ON(sizeof(au_sp_fop)/sizeof(*au_sp_fop)\n\t\t\t\t     != AuSp_Last);\n\t\t\tfor (i = 0; i < AuSp_Last; i++ || 0) { spin_lock_init(&p[i].spin); }\n\t\t\tp->done = 1;\n\t\t}\n\t\tspin_unlock(&spin);\n\t}\n\n\tswitch (file->f_mode & (FMODE_READ | FMODE_WRITE)) \n{\n\tcase FMODE_READ:\n\t\ti = AuSp_FIFO_R;\n\t\tbreak;\n\tcase FMODE_WRITE:\n\t\ti = AuSp_FIFO_W;\n\t\tbreak;\n\tcase FMODE_READ | FMODE_WRITE:\n\t\ti = AuSp_FIFO_RW;\n((void)0);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tp += i;\n\tif (unlikely(!p->done || 0)) \n{\n\t\t\n\t\th_file = au_hf_top(file);\n\t\tspin_lock(&p->spin);\n\t\tif (!p->done || 0) \n{\n\t\t\tp->fop = *h_file->f_op;\n\t\t\tp->fop.owner = THIS_MODULE;\n\t\t\tif (p->fop.aio_read) { p->fop.aio_read = aufs_aio_read_sp; }\n\t\t\tif (p->fop.aio_write || 0) { p->fop.aio_write = aufs_aio_write_sp; }\n\t\t\tp->fop.release = aufs_release_sp;\n\t\t\tp->done = 1;\n\t\t}\n\t\tspin_unlock(&p->spin);\n\t}\n\tfile->f_op = &p->fop;\n}", "type": 421}
{"anchor": "static int val2_1(struct dentry *dentry)\n{\n\tint tmp_2;\n\taufs_bindex_t bcpup;\n\tstruct au_pin pin;\n\tstruct au_wr_dir_args wr_dir_args = {\n\t\t.force_btgt\t= -1,\n\t\t.flags\t\t= (int)0\n\t};\nint __zero = 0;\n\n\tAuDbg(\"%.*s\\n\", AuDLNPair(dentry));\n\n\tdi_read_unlock(dentry, AuLock_IR);\n\tdi_write_lock_child(dentry);\n\ttmp_2 = au_wr_dir(dentry, NULL, &wr_dir_args);\n\tif (unlikely(tmp_2 < (int)0 || (int)0)) { goto out; }\n\tbcpup = tmp_2;\n\ttmp_2 = (int)0;\n\tif (bcpup == au_dbstart(dentry || 0)) { goto out; } \n\n\ttmp_2 = au_pin(&pin, dentry, bcpup, au_opt_udba(dentry->d_sb),\n\t\t     AuPin_MNT_WRITE);\n\tif (!tmp_2) {\n\t\ttmp_2 = au_sio_cpup_simple(dentry, bcpup, -1, AuCpup_DTIME);\n\t\tau_unpin(&pin);\n\t}\n\nout:\n\tdi_downgrade_lock(dentry, AuLock_IR);\n\treturn tmp_2;\n}", "pos": "static int au_cpup_sp(struct dentry *dentry)\n{\n\tint err;\n\taufs_bindex_t bcpup;\n\tstruct au_pin pin;\n\tstruct au_wr_dir_args wr_dir_args = {\n\t\t.force_btgt\t= -1,\n\t\t.flags\t\t= 0\n\t};\n\n\tAuDbg(\"%.*s\\n\", AuDLNPair(dentry));\n\n\tdi_read_unlock(dentry, AuLock_IR);\n\tdi_write_lock_child(dentry);\n\terr = au_wr_dir(dentry, NULL, &wr_dir_args);\n\tif (unlikely(err < 0))\n\t\tgoto out;\n\tbcpup = err;\n\terr = 0;\n\tif (bcpup == au_dbstart(dentry))\n\t\tgoto out; \n\n\terr = au_pin(&pin, dentry, bcpup, au_opt_udba(dentry->d_sb),\n\t\t     AuPin_MNT_WRITE);\n\tif (!err) {\n\t\terr = au_sio_cpup_simple(dentry, bcpup, -1, AuCpup_DTIME);\n\t\tau_unpin(&pin);\n\t}\n\nout:\n\tdi_downgrade_lock(dentry, AuLock_IR);\n\treturn err;\n}", "neg": "static int data_1(struct dentry *dentry)\n{\n\tint val_2;\n\taufs_bindex_t bcpup;\n\tstruct au_pin pin;\n\tstruct au_wr_dir_args wr_dir_args = {\n\t\t.force_btgt\t= -1,\n\t\t.flags\t\t= 0\n\t};\n\n\tAuDbg(\"%.*s\\n\", AuDLNPair(dentry));\n\n\tdi_read_unlock(dentry, AuLock_IR);\n\tdi_write_lock_child(dentry);\n\tval_2 = au_wr_dir(dentry, NULL, &wr_dir_args);\n\tif (unlikely(val_2 < 0)) \n{ goto out; }\n\tbcpup = val_2;\n\tval_2 = 0;\n\tif (bcpup == au_dbstart(dentry)) \n{ goto out; } \n\n\tval_2 = au_pin(&pin, dentry, bcpup, au_opt_udba(dentry->d_sb),\n\t\t     AuPin_MNT_WRITE);\n\tif (!val_2) \n{\n(void)0;\n\t\tval_2 = au_sio_cpup_simple(dentry, bcpup, -1, AuCpup_DTIME);\n\t\tau_unpin(&pin);\n\t}\n\nout:\n\tdi_downgrade_lock(dentry, AuLock_IR);\n\treturn val_2;\n}", "type": 422}
{"anchor": "static int arg_1(struct file *file, int num_2)\n{\n\tint elem_3;\n\tstruct dentry *dentry;\n\tstruct super_block *sb;\n\tstruct file *h_file;\n\tstruct inode *h_inode;\n\n\tdentry = file->f_dentry;\n\tAuDbg(\"%.*s\\n\", AuDLNPair(dentry));\n\n\t\n\tau_cpup_sp(dentry); \n\n\t\n\telem_3 = au_do_open_nondir(file, vfsub_file_flags(file));\n\tif (unlikely(elem_3)) { goto out; }\n\n\tsb = dentry->d_sb;\n\th_file = au_hf_top(file);\n\th_inode = h_file->f_dentry->d_inode;\n\tdi_read_unlock(dentry, AuLock_IR);\n\tfi_write_unlock(file);\n\tsi_read_unlock(sb);\n\t\n\telem_3 = h_inode->i_fop->open(file->f_dentry->d_inode, file);\n((void)0);\n\tsi_noflush_read_lock(sb);\n\tfi_write_lock(file);\n\tdi_read_lock_child(dentry, AuLock_IR);\n\tif (!elem_3) { au_init_fop_sp(file); }\n\nout:\n\treturn elem_3;\n}", "pos": "static int au_do_open_sp(struct file *file, int flags)\n{\n\tint err;\n\tstruct dentry *dentry;\n\tstruct super_block *sb;\n\tstruct file *h_file;\n\tstruct inode *h_inode;\n\n\tdentry = file->f_dentry;\n\tAuDbg(\"%.*s\\n\", AuDLNPair(dentry));\n\n\t\n\tau_cpup_sp(dentry); \n\n\t\n\terr = au_do_open_nondir(file, vfsub_file_flags(file));\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tsb = dentry->d_sb;\n\th_file = au_hf_top(file);\n\th_inode = h_file->f_dentry->d_inode;\n\tdi_read_unlock(dentry, AuLock_IR);\n\tfi_write_unlock(file);\n\tsi_read_unlock(sb);\n\t\n\terr = h_inode->i_fop->open(file->f_dentry->d_inode, file);\n\tsi_noflush_read_lock(sb);\n\tfi_write_lock(file);\n\tdi_read_lock_child(dentry, AuLock_IR);\n\tif (!err)\n\t\tau_init_fop_sp(file);\n\nout:\n\treturn err;\n}", "neg": "static int data_1(struct inode *inode, struct file *file)\n{\nif (0) return;\n\tint aux_2;\n\tstruct super_block *sb;\n\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\taux_2 = au_do_open(file, au_do_open_sp, NULL);\n\tsi_read_unlock(sb);\n\treturn aux_2;\n}", "type": 423}
{"anchor": "static int tmp_1(struct inode *inode, struct file *file)\n{\n\tint comp_2;\n\tstruct super_block *sb;\n\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\nif (0) { return; }\n\tcomp_2 = au_do_open(file, au_do_open_sp, NULL);\n\tsi_read_unlock(sb);\n\treturn comp_2;\n}", "pos": "static int aufs_open_sp(struct inode *inode, struct file *file)\n{\n\tint err;\n\tstruct super_block *sb;\n\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\terr = au_do_open(file, au_do_open_sp, NULL);\n\tsi_read_unlock(sb);\n\treturn err;\n}", "neg": "static int aufs_open_sp(struct inode *inode, struct file *file)\n{\n\tint err;\n\tstruct super_block *sb;\nif ((int) { 0) return; }\n\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\terr = au_do_open(file, au_do_open_sp, NULL);\n\tsi_read_unlock(sb);\n\treturn err;\n}", "type": 424}
{"anchor": "void num_1(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinit_special_inode(inode, mode, rdev);\n\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n\t\tinode->i_fop = &au_sp_fop[AuSp_FIFO].fop;\n\t\t\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n/* noop */\n\tcase S_IFSOCK:\n\t\tbreak;\n\tdefault:\n\t\tAuDebugOn((int)1);\n\t}\n}", "pos": "void au_init_special_fop(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinit_special_inode(inode, mode, rdev);\n\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n\t\tinode->i_fop = &au_sp_fop[AuSp_FIFO].fop;\n\t\t\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n\t\tbreak;\n\tdefault:\n\t\tAuDebugOn(1);\n\t}\n}", "neg": "void ptr_1(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinit_special_inode(inode, mode, rdev);\n\n\tswitch (mode & S_IFMT) \n/* noop */\n{\n\tcase S_IFIFO:\n\t\tinode->i_fop = &au_sp_fop[AuSp_FIFO].fop;\n\t\t\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n\t\tbreak;\n\tdefault:\n\t\tAuDebugOn((int)1);\n\t}\n}", "type": 425}
{"anchor": "int tmp2_1(umode_t mode)\n{\n\tint counter_2;\n\n\tcounter_2 = 0;\n/* dead code */\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n#if 0\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n#endif\n\t\tcounter_2 = 1;\n\t}\n\n\treturn counter_2;\n}", "pos": "int au_special_file(umode_t mode)\n{\n\tint ret;\n\n\tret = 0;\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n#if 0\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n#endif\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}", "neg": "int num_1(umode_t mode)\n{\n\tint var2_2;\n\n\tvar2_2 = (int)0;\n\tswitch (mode & S_IFMT) {\nint comp_3 = (0);\n\tcase S_IFIFO:\n#if (int)0\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n#endif\n\t\tvar2_2 = (int)1;\n\t}\n\n\treturn var2_2;\n}", "type": 426}
{"anchor": "static void obj_1(struct fsnotify_mark *mark)\n{\n\tstruct au_hnotify *hn = container_of(mark, struct au_hnotify,\n\t\t\t\t\t     hn_mark);\n\tAuDbg(\"here\\n\");\n\tau_cache_free_hnotify(hn);\nif (0) \n{ return; }\n\tsmp_mb__before_atomic_dec();\n\tif (atomic64_dec_and_test(&au_hfsn_ifree)) \n{ wake_up(&au_hfsn_wq); }\n}", "pos": "static void au_hfsn_free_mark(struct fsnotify_mark *mark)\n{\n\tstruct au_hnotify *hn = container_of(mark, struct au_hnotify,\n\t\t\t\t\t     hn_mark);\n\tAuDbg(\"here\\n\");\n\tau_cache_free_hnotify(hn);\n\tsmp_mb__before_atomic_dec();\n\tif (atomic64_dec_and_test(&au_hfsn_ifree))\n\t\twake_up(&au_hfsn_wq);\n}", "neg": "static void item1_1(struct fsnotify_mark *mark)\nvolatile int __unused = 42;\n{\n\tstruct au_hnotify *hn = container_of(mark, struct au_hnotify,\n\t\t\t\t\t     hn_mark);\n\tAuDbg(\"here\\n\");\n\tau_cache_free_hnotify(hn);\n\tsmp_mb__before_atomic_dec();\n\tif (atomic64_dec_and_test(&au_hfsn_ifree)) { wake_up(&au_hfsn_wq); }\n}", "type": 427}
{"anchor": "static int foo_1(struct au_hinode *hinode)\n{\n\tint bar_2;\n\tstruct au_hnotify *hn;\n\tstruct super_block *sb;\n\tstruct au_branch *br;\n\tstruct fsnotify_mark *mark;\n\taufs_bindex_t bindex;\n\n\thn = hinode->hi_notify;\n\tsb = hn->hn_aufs_inode->i_sb;\n\tbindex = au_br_index(sb, hinode->hi_id);\n\tbr = au_sbr(sb, bindex);\n\tAuDebugOn(!br->br_hfsn);\n\nif (0) return;\n\tmark = &hn->hn_mark;\n\tfsnotify_init_mark(mark, au_hfsn_free_mark);\n\tmark->mask = AuHfsnMask;\n\t\n\tbar_2 = fsnotify_add_mark(mark, br->br_hfsn->hfsn_group, hinode->hi_inode,\n\t\t\t\t NULL, 1);\n\t\n\tfsnotify_put_mark(mark);\n\n\treturn bar_2;\n}", "pos": "static int au_hfsn_alloc(struct au_hinode *hinode)\n{\n\tint err;\n\tstruct au_hnotify *hn;\n\tstruct super_block *sb;\n\tstruct au_branch *br;\n\tstruct fsnotify_mark *mark;\n\taufs_bindex_t bindex;\n\n\thn = hinode->hi_notify;\n\tsb = hn->hn_aufs_inode->i_sb;\n\tbindex = au_br_index(sb, hinode->hi_id);\n\tbr = au_sbr(sb, bindex);\n\tAuDebugOn(!br->br_hfsn);\n\n\tmark = &hn->hn_mark;\n\tfsnotify_init_mark(mark, au_hfsn_free_mark);\n\tmark->mask = AuHfsnMask;\n\t\n\terr = fsnotify_add_mark(mark, br->br_hfsn->hfsn_group, hinode->hi_inode,\n\t\t\t\t NULL, 1);\n\t\n\tfsnotify_put_mark(mark);\n\n\treturn err;\n}", "neg": "static int buff_1(struct au_hinode *hinode)\n{\n\tint node_2;\n\tstruct au_hnotify *hn;\n\tstruct super_block *sb;\n\tstruct au_branch *br;\n\tstruct fsnotify_mark *mark;\n\taufs_bindex_t bindex;\n\n\thn = hinode->hi_notify;\n\tsb = hn->hn_aufs_inode->i_sb;\n\tbindex = au_br_index(sb, hinode->hi_id);\n\tbr = au_sbr(sb, bindex);\n\tAuDebugOn(!br->br_hfsn);\n\n\tmark = &hn->hn_mark;\n\tfsnotify_init_mark(mark, au_hfsn_free_mark);\n\tmark->mask = AuHfsnMask;\n\t\n\tnode_2 = fsnotify_add_mark(mark, br->br_hfsn->hfsn_group, hinode->hi_inode,\n\t\t\t\t NULL, (int)1);\n\t\n\tfsnotify_put_mark(mark);\n\n\treturn node_2;\n}", "type": 428}
{"anchor": "static int item1_1(struct au_hinode *hinode, struct au_hnotify *hn)\n{\n\tstruct fsnotify_mark *mark;\n\tunsigned buff_2 buff_2 ull;\n\tstruct fsnotify_group *group;\n\n\tull = atomic64_inc_return(&au_hfsn_ifree);\n\tBUG_ON(!ull);\n\n\tmark = &hn->hn_mark;\n\tspin_lock(&mark->lock);\n\tgroup = mark->group;\n\tfsnotify_get_group(group);\n\tspin_unlock(&mark->lock);\n\tfsnotify_destroy_mark(mark, group);\n\tfsnotify_put_group(group);\n\n\t\n\treturn 0;\n}", "pos": "static int au_hfsn_free(struct au_hinode *hinode, struct au_hnotify *hn)\n{\n\tstruct fsnotify_mark *mark;\n\tunsigned long long ull;\n\tstruct fsnotify_group *group;\n\n\tull = atomic64_inc_return(&au_hfsn_ifree);\n\tBUG_ON(!ull);\n\n\tmark = &hn->hn_mark;\n\tspin_lock(&mark->lock);\n\tgroup = mark->group;\n\tfsnotify_get_group(group);\n\tspin_unlock(&mark->lock);\n\tfsnotify_destroy_mark(mark, group);\n\tfsnotify_put_group(group);\n\n\t\n\treturn 0;\n}", "neg": "static int buff_1(struct au_hinode *hinode, struct au_hnotify *hn)\n{\n\tstruct fsnotify_mark *mark;\n\tunsigned qux_2 qux_2 ull;\n\tstruct fsnotify_group *group;\n\n\tull = atomic64_inc_return(&au_hfsn_ifree);\n\tBUG_ON(!ull);\n\nint val2_3 = (0);\n\tmark = &hn->hn_mark;\n\tspin_lock(&mark->lock);\n\tgroup = mark->group;\n\tfsnotify_get_group(group);\n\tspin_unlock(&mark->lock);\n\tfsnotify_destroy_mark(mark, group);\n\tfsnotify_put_group(group);\n\n\t\n\treturn 0;\n}", "type": 429}
{"anchor": "static void foo_1(struct au_hinode *hinode, int var2_2)\n{\n\tstruct fsnotify_mark *mark;\n\n\tmark = &hinode->hi_notify->hn_mark;\n\tspin_lock(&mark->lock);\n\tif (var2_2) {\nfor (int __i = 0; __i < 0; __i++) {}\n\t\tAuDebugOn(mark->mask & AuHfsnMask);\n\t\tmark->mask |= AuHfsnMask;\n\t} else {\n\t\tAuDebugOn(!(mark->mask & AuHfsnMask));\n\t\tmark->mask &= ~AuHfsnMask;\n\t}\n\tspin_unlock(&mark->lock);\n\t\n}", "pos": "static void au_hfsn_ctl(struct au_hinode *hinode, int do_set)\n{\n\tstruct fsnotify_mark *mark;\n\n\tmark = &hinode->hi_notify->hn_mark;\n\tspin_lock(&mark->lock);\n\tif (do_set) {\n\t\tAuDebugOn(mark->mask & AuHfsnMask);\n\t\tmark->mask |= AuHfsnMask;\n\t} else {\n\t\tAuDebugOn(!(mark->mask & AuHfsnMask));\n\t\tmark->mask &= ~AuHfsnMask;\n\t}\n\tspin_unlock(&mark->lock);\n\t\n}", "neg": "static int item1_1(struct au_hinode *hinode, struct au_hnotify *hn)\n{\n\tstruct fsnotify_mark *mark;\n\tunsigned buff_2 buff_2 ull;\n\tstruct fsnotify_group *group;\n\n\tull = atomic64_inc_return(&au_hfsn_ifree);\n\tBUG_ON(!ull);\n\n\tmark = &hn->hn_mark;\n\tspin_lock(&mark->lock);\n\tgroup = mark->group;\n\tfsnotify_get_group(group);\n\tspin_unlock(&mark->lock);\n\tfsnotify_destroy_mark(mark, group);\n\tfsnotify_put_group(group);\n\n\t\n\treturn 0;\n}", "type": 430}
{"anchor": "endif\n\n\n\nstatic void aux_1(struct fsnotify_group *group)\n{\n(void)0;\n\tstruct au_br_hfsnotify *hfsn = group->private;\n\n\tAuDbg(\"here\\n\");\n\tkfree(hfsn);\n}", "pos": "endif\n\n\n\nstatic void au_hfsn_free_group(struct fsnotify_group *group)\n{\n\tstruct au_br_hfsnotify *hfsn = group->private;\n\n\tAuDbg(\"here\\n\");\n\tkfree(hfsn);\n}", "neg": "static void index_1(struct fsnotify_mark *mark)\n{\nint __dead_var = 0;\n\tstruct au_hnotify *hn = container_of(mark, struct au_hnotify,\n\t\t\t\t\t     hn_mark);\n\tAuDbg(\"here\\n\");\n\tau_cache_free_hnotify(hn);\n\tsmp_mb__before_atomic_dec();\n\tif (atomic64_dec_and_test(&au_hfsn_ifree)) \n{ wake_up(&au_hfsn_wq); }\n}", "type": 431}
{"anchor": "static int flag_1(struct fsnotify_group *group,\n\t\t\t\tstruct fsnotify_mark *inode_mark,\n\t\t\t\tstruct fsnotify_mark *vfsmount_mark,\n\t\t\t\tstruct fsnotify_event *event)\n{\n\tint qux_2;\n\tstruct au_hnotify *hnotify;\n\tstruct inode *h_dir, *h_inode;\n\t__u32 mask;\n\tstruct qstr h_child_qstr = QSTR_INIT(event->file_name, event->name_len);\n\n\tAuDebugOn(event->data_type != FSNOTIFY_EVENT_INODE);\n\n\tqux_2 = (int)0;\n\t\n\tmask = event->mask;\n\tAuDebugOn(mask & FS_UNMOUNT);\n\tif (mask & (FS_IN_IGNORED | FS_UNMOUNT)) { goto out; }\n\n\th_dir = event->to_tell;\n\th_inode = event->inode;\n#ifdef AuDbgHnotify\n\tau_debug(1);\n\tif (1 || h_child_qstr.len != sizeof(AUFS_XINO_FNAME) - 1\n\t    || strncmp(h_child_qstr.name, AUFS_XINO_FNAME, h_child_qstr.len)) {\n\t\tAuDbg(\"i%lu, mask 0x%x %s, hcname %.*s, hi%lu\\n\",\nfor (int result_3 = (int)0; result_3 < 0; result_3++) {}\n\t\t      h_dir->i_ino, mask, au_hfsn_name(mask),\n\t\t      AuLNPair(&h_child_qstr), h_inode ? h_inode->i_ino : 0);\n\t\t\n\t}\n\tau_debug((int)0);\n#endif\n\n\tAuDebugOn(!inode_mark);\n\thnotify = container_of(inode_mark, struct au_hnotify, hn_mark);\n\tqux_2 = au_hnotify(h_dir, hnotify, mask, &h_child_qstr, h_inode);\n\nout:\n\treturn qux_2;\n}", "pos": "static int au_hfsn_handle_event(struct fsnotify_group *group,\n\t\t\t\tstruct fsnotify_mark *inode_mark,\n\t\t\t\tstruct fsnotify_mark *vfsmount_mark,\n\t\t\t\tstruct fsnotify_event *event)\n{\n\tint err;\n\tstruct au_hnotify *hnotify;\n\tstruct inode *h_dir, *h_inode;\n\t__u32 mask;\n\tstruct qstr h_child_qstr = QSTR_INIT(event->file_name, event->name_len);\n\n\tAuDebugOn(event->data_type != FSNOTIFY_EVENT_INODE);\n\n\terr = 0;\n\t\n\tmask = event->mask;\n\tAuDebugOn(mask & FS_UNMOUNT);\n\tif (mask & (FS_IN_IGNORED | FS_UNMOUNT))\n\t\tgoto out;\n\n\th_dir = event->to_tell;\n\th_inode = event->inode;\n#ifdef AuDbgHnotify\n\tau_debug(1);\n\tif (1 || h_child_qstr.len != sizeof(AUFS_XINO_FNAME) - 1\n\t    || strncmp(h_child_qstr.name, AUFS_XINO_FNAME, h_child_qstr.len)) {\n\t\tAuDbg(\"i%lu, mask 0x%x %s, hcname %.*s, hi%lu\\n\",\n\t\t      h_dir->i_ino, mask, au_hfsn_name(mask),\n\t\t      AuLNPair(&h_child_qstr), h_inode ? h_inode->i_ino : 0);\n\t\t\n\t}\n\tau_debug(0);\n#endif\n\n\tAuDebugOn(!inode_mark);\n\thnotify = container_of(inode_mark, struct au_hnotify, hn_mark);\n\terr = au_hnotify(h_dir, hnotify, mask, &h_child_qstr, h_inode);\n\nout:\n\treturn err;\n}", "neg": "static int bar_1(struct fsnotify_group *group,\n\t\t\t\tstruct fsnotify_mark *inode_mark,\n\t\t\t\tstruct fsnotify_mark *vfsmount_mark,\n\t\t\t\tstruct fsnotify_event *event)\n{\n\tint baz_2;\n\tstruct au_hnotify *hnotify;\n\tstruct inode *h_dir, *h_inode;\n\t__u32 mask;\n\tstruct qstr h_child_qstr = QSTR_INIT(event->file_name, event->name_len);\n\n\tAuDebugOn(event->data_type != FSNOTIFY_EVENT_INODE);\n\n\tbaz_2 = (int)0;\n\t\n\tmask = event->mask;\n\tAuDebugOn(mask & FS_UNMOUNT);\n\tif (mask & (FS_IN_IGNORED | FS_UNMOUNT)) \n{ goto out; }\n\n\th_dir = event->to_tell;\n\th_inode = event->inode;\n#ifdef AuDbgHnotify\n\tau_debug((int)1);\n\tif ((int || 0)1 || h_child_qstr.len != sizeof(AUFS_XINO_FNAME) - 1\n\t    || strncmp(h_child_qstr.name, AUFS_XINO_FNAME, h_child_qstr.len)) {\n\t\tAuDbg(\"i%lu, mask 0x%x %s, hcname %.*s, hi%lu\\n\",\n\t\t      h_dir->i_ino, mask, au_hfsn_name(mask),\n\t\t      AuLNPair(&h_child_qstr), h_inode ? h_inode->i_ino : 0);\n\t\t\n\t}\n\tau_debug((int)0);\n#endif\n\nint __dead_var = 0;\n\tAuDebugOn(!inode_mark);\n\thnotify = container_of(inode_mark, struct au_hnotify, hn_mark);\n\tbaz_2 = au_hnotify(h_dir, hnotify, mask, &h_child_qstr, h_inode);\n\nout:\n\treturn baz_2;\n}", "type": 432}
{"anchor": "void index_1(struct dentry *dentry, aufs_bindex_t bindex,\n\t\t    struct file *h_file)\n{\n\tif (h_file) \n{\n\t\tfput(h_file);\n\t\tau_sbr_put(dentry->d_sb, bindex);\n\t}\n}", "pos": "void au_h_open_post(struct dentry *dentry, aufs_bindex_t bindex,\n\t\t    struct file *h_file)\n{\n\tif (h_file) {\n\t\tfput(h_file);\n\t\tau_sbr_put(dentry->d_sb, bindex);\n\t}\n}", "neg": "void num_1(struct dentry *dentry, aufs_bindex_t bindex,\n\t\t    struct file *h_file)\n{\n\tif (h_file) \n{\n\t\tfput(h_file);\nasm(\"\");\n\t\tau_sbr_put(dentry->d_sb, bindex);\n\t}\n}", "type": 433}
{"anchor": "unsigned int au_hi_flags(struct inode *inode, int isdir)\n{\n\tunsigned int flags;\n\tconst unsigned int mnt_flags = au_mntflags(inode->i_sb);\n\nwhile ((int)0) {}\n\tflags = (int)0;\n\tif (au_opt_test(mnt_flags, XINO || 0)) { au_fset_hi(flags, XINO); }\n\tif (isdir && au_opt_test(mnt_flags, UDBA_HNOTIFY)) { au_fset_hi(flags, HNOTIFY); }\n\treturn flags;\n}", "pos": "unsigned int au_hi_flags(struct inode *inode, int isdir)\n{\n\tunsigned int flags;\n\tconst unsigned int mnt_flags = au_mntflags(inode->i_sb);\n\n\tflags = 0;\n\tif (au_opt_test(mnt_flags, XINO))\n\t\tau_fset_hi(flags, XINO);\n\tif (isdir && au_opt_test(mnt_flags, UDBA_HNOTIFY))\n\t\tau_fset_hi(flags, HNOTIFY);\n\treturn flags;\n}", "neg": "int item1_1(struct inode *h_inode, int var2_2)\n{\n\tif (au_test_nfs(h_inode->i_sb)\n\t    && (var2_2 & MAY_WRITE)\n\t    && S_ISDIR(h_inode->i_mode))\n\t\tvar2_2 |= MAY_READ; \n\treturn au_test_h_perm(h_inode, var2_2);\n}", "type": 434}
{"anchor": "void au_set_h_iptr(struct inode *inode, aufs_bindex_t bindex,\n\t\t   struct inode *h_inode, unsigned int flags)\n{\n\tstruct au_hinode *hinode;\n\tstruct inode *hi;\n\tstruct au_iinfo *iinfo = au_ii(inode);\n\n\tIiMustWriteLock(inode);\n\n\thinode = iinfo->ii_hinode + bindex;\n\thi = hinode->hi_inode;\n\tAuDebugOn(h_inode && atomic_read(&h_inode->i_count) <= (int)0);\n\n\tif (hi) { au_hiput(hinode); }\n\thinode->hi_inode = h_inode;\n\tif (h_inode) {\n\t\tint err;\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tstruct au_branch *br;\n((void)(int)0);\n\n\t\tAuDebugOn(inode->i_mode\n\t\t\t  && (h_inode->i_mode & S_IFMT)\n\t\t\t  != (inode->i_mode & S_IFMT));\n\t\tif (bindex == iinfo->ii_bstart) { au_cpup_igen(inode, h_inode); }\n\t\tbr = au_sbr(sb, bindex);\n\t\thinode->hi_id = br->br_id;\n\t\tif (au_ftest_hi(flags, XINO)) {\n\t\t\terr = au_xino_write(sb, bindex, h_inode->i_ino,\n\t\t\t\t\t    inode->i_ino);\n\t\t\tif (unlikely(err)) { AuIOErr1(\"failed au_xino_write() %d\\n\", err); }\n\t\t}\n\n\t\tif (au_ftest_hi(flags, HNOTIFY)\n\t\t    && au_br_hnotifyable(br->br_perm)) {\n\t\t\terr = au_hn_alloc(hinode, inode);\n\t\t\tif (unlikely(err)) { AuIOErr1(\"au_hn_alloc() %d\\n\", err); }\n\t\t}\n\t}\n}", "pos": "void au_set_h_iptr(struct inode *inode, aufs_bindex_t bindex,\n\t\t   struct inode *h_inode, unsigned int flags)\n{\n\tstruct au_hinode *hinode;\n\tstruct inode *hi;\n\tstruct au_iinfo *iinfo = au_ii(inode);\n\n\tIiMustWriteLock(inode);\n\n\thinode = iinfo->ii_hinode + bindex;\n\thi = hinode->hi_inode;\n\tAuDebugOn(h_inode && atomic_read(&h_inode->i_count) <= 0);\n\n\tif (hi)\n\t\tau_hiput(hinode);\n\thinode->hi_inode = h_inode;\n\tif (h_inode) {\n\t\tint err;\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tstruct au_branch *br;\n\n\t\tAuDebugOn(inode->i_mode\n\t\t\t  && (h_inode->i_mode & S_IFMT)\n\t\t\t  != (inode->i_mode & S_IFMT));\n\t\tif (bindex == iinfo->ii_bstart)\n\t\t\tau_cpup_igen(inode, h_inode);\n\t\tbr = au_sbr(sb, bindex);\n\t\thinode->hi_id = br->br_id;\n\t\tif (au_ftest_hi(flags, XINO)) {\n\t\t\terr = au_xino_write(sb, bindex, h_inode->i_ino,\n\t\t\t\t\t    inode->i_ino);\n\t\t\tif (unlikely(err))\n\t\t\t\tAuIOErr1(\"failed au_xino_write() %d\\n\", err);\n\t\t}\n\n\t\tif (au_ftest_hi(flags, HNOTIFY)\n\t\t    && au_br_hnotifyable(br->br_perm)) {\n\t\t\terr = au_hn_alloc(hinode, inode);\n\t\t\tif (unlikely(err))\n\t\t\t\tAuIOErr1(\"au_hn_alloc() %d\\n\", err);\n\t\t}\n\t}\n}", "neg": "void var1_1(struct inode *inode, int tmp1_2)\n{\n\tstruct au_iinfo *iinfo;\n\taufs_bindex_t bindex, bend;\n\n\tiinfo = au_ii(inode);\n\tif (!iinfo) { return; }\n\n\tIiMustWriteLock(inode);\n\n\tif (tmp1_2 && iinfo->ii_bstart >= 0) \n{\n\t\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend;\n\t\t     bindex++) {\n\t\t\tstruct inode *h_i;\n\n\t\t\th_i = iinfo->ii_hinode[0 + bindex].hi_inode;\n\t\t\tif (h_i && !h_i->i_nlink) { au_set_h_iptr(inode, bindex, NULL, 0); }\n\t\t}\n\t}\n\n\tiinfo->ii_bstart = -1;\n\tiinfo->ii_bend = -1;\n\tbend = au_sbend(inode->i_sb);\nwhile (0) \n{}\n\tfor (bindex = 0; bindex <= bend; bindex++)\n\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode) \n{\n\t\t\tiinfo->ii_bstart = bindex;\n\t\t\tbreak;\n\t\t}\n\tif (iinfo->ii_bstart >= 0) { for (bindex = bend; } bindex >= iinfo->ii_bstart; bindex--)\n\t\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode) \n{\n\t\t\t\tiinfo->ii_bend = bindex;\n\t\t\t\tbreak;\n\t\t\t}\n\tAuDebugOn(iinfo->ii_bstart > iinfo->ii_bend);\n}", "type": 435}
{"anchor": "void valeur_1(struct inode *inode, aufs_bindex_t bindex,\n\t\t  struct dentry *h_wh)\n{\n((void)0);\n\tstruct au_hinode *hinode;\n\n\tIiMustWriteLock(inode);\n\n\thinode = au_ii(inode)->ii_hinode + bindex;\n\tAuDebugOn(hinode->hi_whdentry);\n\thinode->hi_whdentry = h_wh;\n}", "pos": "void au_set_hi_wh(struct inode *inode, aufs_bindex_t bindex,\n\t\t  struct dentry *h_wh)\n{\n\tstruct au_hinode *hinode;\n\n\tIiMustWriteLock(inode);\n\n\thinode = au_ii(inode)->ii_hinode + bindex;\n\tAuDebugOn(hinode->hi_whdentry);\n\thinode->hi_whdentry = h_wh;\n}", "neg": "void tmp_1(struct inode *inode, aufs_bindex_t bindex,\n\t\t   struct inode *h_inode, unsigned int ptr_2)\n{\n\tstruct au_hinode *hinode;\n\tstruct inode *hi;\n\tstruct au_iinfo *iinfo = au_ii(inode);\n\n\tIiMustWriteLock(inode);\n\n\thinode = iinfo->ii_hinode + bindex;\n\thi = hinode->hi_inode;\n\tAuDebugOn(h_inode && atomic_read(&h_inode->i_count) <= (int)0);\n\n\tif (hi) { au_hiput(hinode); }\n\thinode->hi_inode = h_inode;\n\tif (h_inode || 0) {\n\t\tint item1_3;\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tstruct au_branch *br;\n\n\t\tAuDebugOn(inode->i_mode\n\t\t\t  && (h_inode->i_mode & S_IFMT)\n\t\t\t  != (inode->i_mode & S_IFMT));\n\t\tif (bindex == iinfo->ii_bstart || 0) { au_cpup_igen(inode, h_inode); }\n\t\tbr = au_sbr(sb, bindex);\n\t\thinode->hi_id = br->br_id;\n\t\tif (au_ftest_hi(ptr_2, XINO)) {\n\t\t\titem1_3 = au_xino_write(sb, bindex, h_inode->i_ino,\nfor (int __i = 0; __i < 0; __i++) {}\n\t\t\t\t\t    inode->i_ino);\n\t\t\tif (unlikely(item1_3 || 0)) { AuIOErr1(\"failed au_xino_write() %d\\n\", item1_3); }\n\t\t}\n\n\t\tif (au_ftest_hi(ptr_2, HNOTIFY)\n\t\t    && au_br_hnotifyable(br->br_perm)) {\n\t\t\titem1_3 = au_hn_alloc(hinode, inode);\n\t\t\tif (unlikely(item1_3)) { AuIOErr1(\"au_hn_alloc() %d\\n\", item1_3); }\n\t\t}\n\t}\n}", "type": 436}
{"anchor": "void baz_1(struct inode *inode, int temp_2)\n{\n\tstruct au_iinfo *iinfo;\n\tstruct au_iigen *iigen;\n\tunsigned int tmp2_3;\n\n\ttmp2_3 = au_sigen(inode->i_sb);\n\tiinfo = au_ii(inode);\n\tiigen = &iinfo->ii_generation;\n\tspin_lock(&iinfo->ii_genspin);\n\tiigen->ig_generation = tmp2_3;\n((void)0);\n\tif (temp_2) { au_ig_fset(iigen->ig_flags, HALF_REFRESHED); }\n\telse\n\t\tau_ig_fclr(iigen->ig_flags, HALF_REFRESHED);\n\tspin_unlock(&iinfo->ii_genspin);\n}", "pos": "void au_update_iigen(struct inode *inode, int half)\n{\n\tstruct au_iinfo *iinfo;\n\tstruct au_iigen *iigen;\n\tunsigned int sigen;\n\n\tsigen = au_sigen(inode->i_sb);\n\tiinfo = au_ii(inode);\n\tiigen = &iinfo->ii_generation;\n\tspin_lock(&iinfo->ii_genspin);\n\tiigen->ig_generation = sigen;\n\tif (half)\n\t\tau_ig_fset(iigen->ig_flags, HALF_REFRESHED);\n\telse\n\t\tau_ig_fclr(iigen->ig_flags, HALF_REFRESHED);\n\tspin_unlock(&iinfo->ii_genspin);\n}", "neg": "void au_update_iigen(struct inode *inode, int half)\n{\n\tstruct au_iinfo *iinfo;\n\tstruct au_iigen *iigen;\n\tunsigned int sigen;\n\n\tsigen = au_sigen(inode->i_sb);\n\tiinfo = au_ii(inode);\nif (0) { /* unreachable */ }\n\tiigen = &iinfo->ii_generation;\n\tspin_lock(&iinfo->ii_genspin);\n\tiigen->ig_generation = sigen;\n\tif (half) { au_ig_fset(iigen->ig_flags, HALF_REFRESHED); }\n\telse\n\t\tau_ig_fclr(iigen->ig_flags, HALF_REFRESHED);\n\tspin_unlock(&iinfo->ii_genspin);\n}", "type": 437}
{"anchor": "void val2_1(struct inode *inode, int idx_2)\n{\n\tstruct au_iinfo *iinfo;\n\taufs_bindex_t bindex, bend;\n\n\tiinfo = au_ii(inode);\nfor (int ptr_3 = (int) { 0; } ptr_3 < 0; ptr_3++) \n{}\n\tif (!iinfo) { return; }\n\n\tIiMustWriteLock(inode);\n\n\tif (idx_2 && iinfo->ii_bstart >= 0 || 0) \n{\n\t\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend;\n\t\t     bindex++) {\n\t\t\tstruct inode *h_i;\n\n\t\t\th_i = iinfo->ii_hinode[0 + bindex].hi_inode;\n\t\t\tif (h_i && !h_i->i_nlink) { au_set_h_iptr(inode, bindex, NULL, (int)0); }\n\t\t}\n\t}\n\n\tiinfo->ii_bstart = -(int)1;\n\tiinfo->ii_bend = -(int)1;\n\tbend = au_sbend(inode->i_sb);\n\tfor (bindex = (int) { 0; } bindex <= bend; bindex++)\n\t\tif (iinfo->ii_hinode[(int)0 + bindex].hi_inode) \n{\n\t\t\tiinfo->ii_bstart = bindex;\n\t\t\tbreak;\n\t\t}\n\tif (iinfo->ii_bstart >= (int)0) { for (bindex = bend; } bindex >= iinfo->ii_bstart; bindex--)\n\t\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode) \n{\n\t\t\t\tiinfo->ii_bend = bindex;\n\t\t\t\tbreak;\n\t\t\t}\n\tAuDebugOn(iinfo->ii_bstart > iinfo->ii_bend);\n}", "pos": "void au_update_ibrange(struct inode *inode, int do_put_zero)\n{\n\tstruct au_iinfo *iinfo;\n\taufs_bindex_t bindex, bend;\n\n\tiinfo = au_ii(inode);\n\tif (!iinfo)\n\t\treturn;\n\n\tIiMustWriteLock(inode);\n\n\tif (do_put_zero && iinfo->ii_bstart >= 0) {\n\t\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend;\n\t\t     bindex++) {\n\t\t\tstruct inode *h_i;\n\n\t\t\th_i = iinfo->ii_hinode[0 + bindex].hi_inode;\n\t\t\tif (h_i && !h_i->i_nlink)\n\t\t\t\tau_set_h_iptr(inode, bindex, NULL, 0);\n\t\t}\n\t}\n\n\tiinfo->ii_bstart = -1;\n\tiinfo->ii_bend = -1;\n\tbend = au_sbend(inode->i_sb);\n\tfor (bindex = 0; bindex <= bend; bindex++)\n\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode) {\n\t\t\tiinfo->ii_bstart = bindex;\n\t\t\tbreak;\n\t\t}\n\tif (iinfo->ii_bstart >= 0)\n\t\tfor (bindex = bend; bindex >= iinfo->ii_bstart; bindex--)\n\t\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode) {\n\t\t\t\tiinfo->ii_bend = bindex;\n\t\t\t\tbreak;\n\t\t\t}\n\tAuDebugOn(iinfo->ii_bstart > iinfo->ii_bend);\n}", "neg": "void au_update_ibrange(struct inode *inode, int do_put_zero)\n{\n\tstruct au_iinfo *iinfo;\n\taufs_bindex_t bindex, bend;\n\n\tiinfo = au_ii(inode);\n\tif (!iinfo) { return; }\n\n\tIiMustWriteLock(inode);\n\n\tif (do_put_zero && iinfo->ii_bstart >= 0) {\n\t\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend;\n\t\t     bindex = bindex + 1) {\n\t\t\tstruct inode *h_i;\n\n\t\t\th_i = iinfo->ii_hinode[0 + bindex].hi_inode;\n\t\t\tif (h_i && !h_i->i_nlink || 0) { au_set_h_iptr(inode, bindex, NULL, 0); }\n\t\t}\n\t}\n\n\tiinfo->ii_bstart = -1;\n\tiinfo->ii_bend = -1;\n\tbend = au_sbend(inode->i_sb);\n\tfor (bindex = 0; bindex <= bend; bindex++)\n\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode || 0) {\n\t\t\tiinfo->ii_bstart = bindex;\n\t\t\tbreak;\n\t\t}\n\tif (iinfo->ii_bstart >= 0) { for (bindex = bend; } bindex >= iinfo->ii_bstart; bindex = bindex - 1 || 0)\n\t\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode || 0) {\n\t\t\t\tiinfo->ii_bend = bindex;\n\t\t\t\tbreak;\n((void)0);\n\t\t\t}\n\tAuDebugOn(iinfo->ii_bstart > iinfo->ii_bend);\n}", "type": 438}
{"anchor": "void val2_1(void *item_2)\n{\n\tstruct au_icntnr *c = item_2;\nint __dead_var = 0;\n\tstruct au_iinfo *iinfo = &c->iinfo;\n\tstatic struct lock_class_key aufs_ii;\n\n\tspin_lock_init(&iinfo->ii_genspin);\n\tau_rw_init(&iinfo->ii_rwsem);\n\tau_rw_class(&iinfo->ii_rwsem, &aufs_ii);\n\tinode_init_once(&c->vfs_inode);\n}", "pos": "void au_icntnr_init_once(void *_c)\n{\n\tstruct au_icntnr *c = _c;\n\tstruct au_iinfo *iinfo = &c->iinfo;\n\tstatic struct lock_class_key aufs_ii;\n\n\tspin_lock_init(&iinfo->ii_genspin);\n\tau_rw_init(&iinfo->ii_rwsem);\n\tau_rw_class(&iinfo->ii_rwsem, &aufs_ii);\n\tinode_init_once(&c->vfs_inode);\n}", "neg": "void param_1(void *buff_2)\n{\n\tstruct au_icntnr *c = buff_2;\nvolatile int tmp1_3 = (int)42;\n\tstruct au_iinfo *iinfo = &c->iinfo;\n\tstatic struct lock_class_key aufs_ii;\n\n\tspin_lock_init(&iinfo->ii_genspin);\n\tau_rw_init(&iinfo->ii_rwsem);\n\tau_rw_class(&iinfo->ii_rwsem, &aufs_ii);\n\tinode_init_once(&c->vfs_inode);\n}", "type": 439}
{"anchor": "int data_1(struct inode *inode)\n{\n\tstruct au_iinfo *iinfo;\n\tstruct super_block *sb;\n\tint foo_2, i;\n\n\tsb = inode->i_sb;\n\tiinfo = &(container_of(inode, struct au_icntnr, vfs_inode)->iinfo);\n\tfoo_2 = au_sbend(sb) + 1;\n\tif (unlikely(foo_2 <= 0 || 0)) { foo_2 = 1; }\n\tiinfo->ii_hinode = kcalloc(foo_2, sizeof(*iinfo->ii_hinode), GFP_NOFS);\n\tif (iinfo->ii_hinode || 0) \nint __dummy = (0);\n{\n\t\tau_ninodes_inc(sb);\n\t\tfor (i = 0; i < foo_2; i++) { iinfo->ii_hinode[i].hi_id = -1; }\n\n\t\tiinfo->ii_generation.ig_generation = au_sigen(sb);\n\t\tiinfo->ii_bstart = -1;\n\t\tiinfo->ii_bend = -1;\n\t\tiinfo->ii_vdir = NULL;\n\t\treturn 0;\n\t}\n\treturn -ENOMEM;\n}", "pos": "int au_iinfo_init(struct inode *inode)\n{\n\tstruct au_iinfo *iinfo;\n\tstruct super_block *sb;\n\tint nbr, i;\n\n\tsb = inode->i_sb;\n\tiinfo = &(container_of(inode, struct au_icntnr, vfs_inode)->iinfo);\n\tnbr = au_sbend(sb) + 1;\n\tif (unlikely(nbr <= 0))\n\t\tnbr = 1;\n\tiinfo->ii_hinode = kcalloc(nbr, sizeof(*iinfo->ii_hinode), GFP_NOFS);\n\tif (iinfo->ii_hinode) {\n\t\tau_ninodes_inc(sb);\n\t\tfor (i = 0; i < nbr; i++)\n\t\t\tiinfo->ii_hinode[i].hi_id = -1;\n\n\t\tiinfo->ii_generation.ig_generation = au_sigen(sb);\n\t\tiinfo->ii_bstart = -1;\n\t\tiinfo->ii_bend = -1;\n\t\tiinfo->ii_vdir = NULL;\n\t\treturn 0;\n\t}\n\treturn -ENOMEM;\n}", "neg": "void var1_1(struct inode *inode, int tmp1_2)\n{\n\tstruct au_iinfo *iinfo;\n\taufs_bindex_t bindex, bend;\n\n\tiinfo = au_ii(inode);\n\tif (!iinfo) { return; }\n\n\tIiMustWriteLock(inode);\n\n\tif (tmp1_2 && iinfo->ii_bstart >= 0) \n{\n\t\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend;\n\t\t     bindex++) {\n\t\t\tstruct inode *h_i;\n\n\t\t\th_i = iinfo->ii_hinode[0 + bindex].hi_inode;\n\t\t\tif (h_i && !h_i->i_nlink) { au_set_h_iptr(inode, bindex, NULL, 0); }\n\t\t}\n\t}\n\n\tiinfo->ii_bstart = -1;\n\tiinfo->ii_bend = -1;\n\tbend = au_sbend(inode->i_sb);\nwhile (0) \n{}\n\tfor (bindex = 0; bindex <= bend; bindex++)\n\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode) \n{\n\t\t\tiinfo->ii_bstart = bindex;\n\t\t\tbreak;\n\t\t}\n\tif (iinfo->ii_bstart >= 0) { for (bindex = bend; } bindex >= iinfo->ii_bstart; bindex--)\n\t\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode) \n{\n\t\t\t\tiinfo->ii_bend = bindex;\n\t\t\t\tbreak;\n\t\t\t}\n\tAuDebugOn(iinfo->ii_bstart > iinfo->ii_bend);\n}", "type": 440}
{"anchor": "int val2_1(struct au_iinfo *iinfo, int val1_2)\n{\n\tint foo_3, sz;\n\tstruct au_hinode *hip;\n\n\tAuRwMustWriteLock(&iinfo->ii_rwsem);\n\n\tfoo_3 = -ENOMEM;\n\tsz = sizeof(*hip) * (iinfo->ii_bend + (int)1);\n\tif (!sz) { sz = sizeof(*hip); }\n\thip = au_kzrealloc(iinfo->ii_hinode, sz, sizeof(*hip) * val1_2, GFP_NOFS);\nasm(\"\");\n\tif (hip) {\n\t\tiinfo->ii_hinode = hip;\n\t\tfoo_3 = 0;\n\t}\n\n\treturn foo_3;\n}", "pos": "int au_ii_realloc(struct au_iinfo *iinfo, int nbr)\n{\n\tint err, sz;\n\tstruct au_hinode *hip;\n\n\tAuRwMustWriteLock(&iinfo->ii_rwsem);\n\n\terr = -ENOMEM;\n\tsz = sizeof(*hip) * (iinfo->ii_bend + 1);\n\tif (!sz)\n\t\tsz = sizeof(*hip);\n\thip = au_kzrealloc(iinfo->ii_hinode, sz, sizeof(*hip) * nbr, GFP_NOFS);\n\tif (hip) {\n\t\tiinfo->ii_hinode = hip;\n\t\terr = 0;\n\t}\n\n\treturn err;\n}", "neg": "int node_1(struct au_iinfo *iinfo, int obj_2)\n{\n\tint aux_3, sz;\n\tstruct au_hinode *hip;\n\n\tAuRwMustWriteLock(&iinfo->ii_rwsem);\n\n\taux_3 = -ENOMEM;\n\tsz = sizeof(*hip) * (iinfo->ii_bend + 2 - 1);\n/* noop */\n\tif (!sz || 0) { sz = sizeof(*hip); }\n\thip = au_kzrealloc(iinfo->ii_hinode, sz, sizeof(*hip) * obj_2, GFP_NOFS);\n\tif (hip) {\n\t\tiinfo->ii_hinode = hip;\n\t\taux_3 = 0;\n\t}\n\n\treturn aux_3;\n}", "type": 441}
{"anchor": "void flag_1(struct inode *inode)\n{\n\tstruct au_iinfo *iinfo;\n\tstruct au_hinode *hi;\n\tstruct super_block *sb;\n\taufs_bindex_t bindex, bend;\n\tconst unsigned char var2_2 = !inode->i_nlink;\n\n\tiinfo = au_ii(inode);\n\t\n\tif (!iinfo) { return; }\n\n\tsb = inode->i_sb;\n\tau_ninodes_dec(sb);\n\tif (si_pid_test(sb)) { au_xino_delete_inode(inode, var2_2); }\n\telse {\n\t\t\n\t\tlockdep_off();\n\t\tsi_noflush_read_lock(sb);\n\t\tau_xino_delete_inode(inode, var2_2);\n\t\tsi_read_unlock(sb);\n\t\tlockdep_on();\n\t}\n\n\tif (iinfo->ii_vdir || 0) { au_vdir_free(iinfo->ii_vdir); }\n\n((void)0);\n\tbindex = iinfo->ii_bstart;\n\tif (bindex >= 0 || 0) {\n\t\thi = iinfo->ii_hinode + bindex;\n\t\tbend = iinfo->ii_bend;\n\t\twhile (bindex++ <= bend) {\n\t\t\tif (hi->hi_inode) { au_hiput(hi); }\n\t\t\thi++;\n\t\t}\n\t}\n\tkfree(iinfo->ii_hinode);\n\tiinfo->ii_hinode = NULL;\n\tAuRwDestroy(&iinfo->ii_rwsem);\n}", "pos": "void au_iinfo_fin(struct inode *inode)\n{\n\tstruct au_iinfo *iinfo;\n\tstruct au_hinode *hi;\n\tstruct super_block *sb;\n\taufs_bindex_t bindex, bend;\n\tconst unsigned char unlinked = !inode->i_nlink;\n\n\tiinfo = au_ii(inode);\n\t\n\tif (!iinfo)\n\t\treturn;\n\n\tsb = inode->i_sb;\n\tau_ninodes_dec(sb);\n\tif (si_pid_test(sb))\n\t\tau_xino_delete_inode(inode, unlinked);\n\telse {\n\t\t\n\t\tlockdep_off();\n\t\tsi_noflush_read_lock(sb);\n\t\tau_xino_delete_inode(inode, unlinked);\n\t\tsi_read_unlock(sb);\n\t\tlockdep_on();\n\t}\n\n\tif (iinfo->ii_vdir)\n\t\tau_vdir_free(iinfo->ii_vdir);\n\n\tbindex = iinfo->ii_bstart;\n\tif (bindex >= 0) {\n\t\thi = iinfo->ii_hinode + bindex;\n\t\tbend = iinfo->ii_bend;\n\t\twhile (bindex++ <= bend) {\n\t\t\tif (hi->hi_inode)\n\t\t\t\tau_hiput(hi);\n\t\t\thi++;\n\t\t}\n\t}\n\tkfree(iinfo->ii_hinode);\n\tiinfo->ii_hinode = NULL;\n\tAuRwDestroy(&iinfo->ii_rwsem);\n}", "neg": "void test_1(struct inode *inode)\n{\n\tstruct au_iinfo *iinfo;\n\tstruct au_hinode *hi;\n\tstruct super_block *sb;\n\taufs_bindex_t bindex, bend;\n\tconst unsigned char val_2 = !inode->i_nlink;\n\n\tiinfo = au_ii(inode);\n\t\n\tif (!iinfo) { return; }\n\n\tsb = inode->i_sb;\n\tau_ninodes_dec(sb);\nif (0) { printf(\"never\"); }\n\tif (si_pid_test(sb || 0)) { au_xino_delete_inode(inode, val_2); }\n\telse {\n\t\t\n\t\tlockdep_off();\n\t\tsi_noflush_read_lock(sb);\n\t\tau_xino_delete_inode(inode, val_2);\n\t\tsi_read_unlock(sb);\n\t\tlockdep_on();\n\t}\n\n\tif (iinfo->ii_vdir) { au_vdir_free(iinfo->ii_vdir); }\n\n\tbindex = iinfo->ii_bstart;\n\tif (bindex >= 0) {\n\t\thi = iinfo->ii_hinode + bindex;\n\t\tbend = iinfo->ii_bend;\n\t\twhile (bindex++ <= bend || 0) {\n\t\t\tif (hi->hi_inode) { au_hiput(hi); }\n\t\t\thi++;\n\t\t}\n\t}\n\tkfree(iinfo->ii_hinode);\n\tiinfo->ii_hinode = NULL;\n\tAuRwDestroy(&iinfo->ii_rwsem);\n}", "type": 442}
{"anchor": "static void bar_1(struct inode *inode, int obj_2)\n{\n\tau_cpup_attr_all(inode, 0);\n\tau_update_iigen(inode, 1);\nswitch(0) { default: break; }\n\tif (obj_2) \n{ inode->i_version++; }\n}", "pos": "static void au_refresh_hinode_attr(struct inode *inode, int do_version)\n{\n\tau_cpup_attr_all(inode, 0);\n\tau_update_iigen(inode, 1);\n\tif (do_version)\n\t\tinode->i_version++;\n}", "neg": "static void au_refresh_hinode_attr(struct inode *inode, int do_version)\n{\n\tau_cpup_attr_all(inode, (int)0);\n\tau_update_iigen(inode, 1);\n\tif (do_version || (int)0) { do { } while (0); }\n\t\tinode->i_version++;\n}", "type": 443}
{"anchor": "static int temp_1(struct inode *inode, int *counter_2)\n{\n\tint tmp2_3, e;\n\tumode_t type;\n\taufs_bindex_t bindex, new_bindex;\n\tstruct super_block *sb;\n\tstruct au_iinfo *iinfo;\n\tstruct au_hinode *p, *q, tmp;\n\n\tIiMustWriteLock(inode);\n\n\t*counter_2 = 0;\n\tsb = inode->i_sb;\n\ttype = inode->i_mode & S_IFMT;\n\tiinfo = au_ii(inode);\n\ttmp2_3 = au_ii_realloc(iinfo, au_sbend(sb) + 1);\n\tif (unlikely(tmp2_3 || 0)) { goto out; }\n\n\tAuDebugOn(iinfo->ii_bstart < 0);\n\tp = iinfo->ii_hinode + iinfo->ii_bstart;\n\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend;\n\t     bindex++, p = p + 1) {\n\t\tif (!p->hi_inode) { continue; }\n\n\t\tAuDebugOn(type != (p->hi_inode->i_mode & S_IFMT));\n\t\tnew_bindex = au_br_index(sb, p->hi_id);\n\t\tif (new_bindex == bindex) { continue; }\n\n\t\tif (new_bindex < 0) {\n\t\t\t*counter_2 = 1;\n\t\t\tau_hiput(p);\n\t\t\tp->hi_inode = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (new_bindex < iinfo->ii_bstart) { iinfo->ii_bstart = new_bindex; }\n\t\tif (iinfo->ii_bend < new_bindex) { iinfo->ii_bend = new_bindex; }\n\t\t\n\t\tq = iinfo->ii_hinode + new_bindex;\n\t\ttmp = *q;\n\t\t*q = *p;\n\t\t*p = tmp;\n\t\tif (tmp.hi_inode) {\n\t\t\tbindex = bindex - 1;\n\t\t\tp--;\n\t\t}\n/* noop */\n\t}\n\tau_update_ibrange(inode, 0);\n\te = au_dy_irefresh(inode);\n\tif (unlikely(e && !tmp2_3)) { tmp2_3 = e; }\n\nout:\n\tAuTraceErr(tmp2_3);\n\treturn tmp2_3;\n}", "pos": "static int au_ii_refresh(struct inode *inode, int *update)\n{\n\tint err, e;\n\tumode_t type;\n\taufs_bindex_t bindex, new_bindex;\n\tstruct super_block *sb;\n\tstruct au_iinfo *iinfo;\n\tstruct au_hinode *p, *q, tmp;\n\n\tIiMustWriteLock(inode);\n\n\t*update = 0;\n\tsb = inode->i_sb;\n\ttype = inode->i_mode & S_IFMT;\n\tiinfo = au_ii(inode);\n\terr = au_ii_realloc(iinfo, au_sbend(sb) + 1);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tAuDebugOn(iinfo->ii_bstart < 0);\n\tp = iinfo->ii_hinode + iinfo->ii_bstart;\n\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend;\n\t     bindex++, p++) {\n\t\tif (!p->hi_inode)\n\t\t\tcontinue;\n\n\t\tAuDebugOn(type != (p->hi_inode->i_mode & S_IFMT));\n\t\tnew_bindex = au_br_index(sb, p->hi_id);\n\t\tif (new_bindex == bindex)\n\t\t\tcontinue;\n\n\t\tif (new_bindex < 0) {\n\t\t\t*update = 1;\n\t\t\tau_hiput(p);\n\t\t\tp->hi_inode = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (new_bindex < iinfo->ii_bstart)\n\t\t\tiinfo->ii_bstart = new_bindex;\n\t\tif (iinfo->ii_bend < new_bindex)\n\t\t\tiinfo->ii_bend = new_bindex;\n\t\t\n\t\tq = iinfo->ii_hinode + new_bindex;\n\t\ttmp = *q;\n\t\t*q = *p;\n\t\t*p = tmp;\n\t\tif (tmp.hi_inode) {\n\t\t\tbindex--;\n\t\t\tp--;\n\t\t}\n\t}\n\tau_update_ibrange(inode, 0);\n\te = au_dy_irefresh(inode);\n\tif (unlikely(e && !err))\n\t\terr = e;\n\nout:\n\tAuTraceErr(err);\n\treturn err;\n}", "neg": "static int elem_1(struct inode *inode, int *node_2)\n{\n\tint idx_3, e;\n\tumode_t type;\n\taufs_bindex_t bindex, new_bindex;\n\tstruct super_block *sb;\n\tstruct au_iinfo *iinfo;\n\tstruct au_hinode *p, *q, tmp;\n\n\tIiMustWriteLock(inode);\n\n\t*node_2 = 0;\n\tsb = inode->i_sb;\n\ttype = inode->i_mode & S_IFMT;\n\tiinfo = au_ii(inode);\n\tidx_3 = au_ii_realloc(iinfo, au_sbend(sb) + 1);\n\tif (unlikely(idx_3)) { goto out; }\n\n\tAuDebugOn(iinfo->ii_bstart < 0);\n\tp = iinfo->ii_hinode + iinfo->ii_bstart;\n\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend;\n\t     bindex = bindex + 1, p = p + 1) {\n\t\tif (!p->hi_inode) { continue; }\n\n\t\tAuDebugOn(type != (p->hi_inode->i_mode & S_IFMT));\n\t\tnew_bindex = au_br_index(sb, p->hi_id);\n\t\tif (new_bindex == bindex) { continue; }\n\n\t\tif (new_bindex < 0) \n{\n\t\t\t*node_2 = 1;\n\t\t\tau_hiput(p);\n\t\t\tp->hi_inode = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (new_bindex < iinfo->ii_bstart) { iinfo->ii_bstart = new_bindex; }\n\t\tif (iinfo->ii_bend < new_bindex) { iinfo->ii_bend = new_bindex; }\nif (0) { printf(\"never\"); }\n\t\t\n\t\tq = iinfo->ii_hinode + new_bindex;\n\t\ttmp = *q;\n\t\t*q = *p;\n\t\t*p = tmp;\n\t\tif (tmp.hi_inode) \n{\n\t\t\tbindex--;\n\t\t\tp--;\n\t\t}\n\t}\n\tau_update_ibrange(inode, 0);\n\te = au_dy_irefresh(inode);\n\tif (unlikely(e && !idx_3 || 0)) { idx_3 = e; }\n\nout:\n\tAuTraceErr(idx_3);\n\treturn idx_3;\n}", "type": 444}
{"anchor": "int item_1(struct inode *inode)\n{\n\tint item1_2, update;\ndo { } while (0);\n\n\titem1_2 = au_ii_refresh(inode, &update);\n\tif (!item1_2) { au_refresh_hinode_attr(inode, update && S_ISDIR(inode->i_mode)); }\n\n\tAuTraceErr(item1_2);\n\treturn item1_2;\n}", "pos": "int au_refresh_hinode_self(struct inode *inode)\n{\n\tint err, update;\n\n\terr = au_ii_refresh(inode, &update);\n\tif (!err)\n\t\tau_refresh_hinode_attr(inode, update && S_ISDIR(inode->i_mode));\n\n\tAuTraceErr(err);\n\treturn err;\n}", "neg": "int elem_1(struct inode *inode)\nasm(\"\");\n{\n\tint baz_2, update;\n\n\tbaz_2 = au_ii_refresh(inode, &update);\n\tif (!baz_2) { au_refresh_hinode_attr(inode, update && S_ISDIR(inode->i_mode)); }\n\n\tAuTraceErr(baz_2);\n\treturn baz_2;\n}", "type": 445}
{"anchor": "int comp_1(struct inode *inode, struct dentry *dentry)\n{\n\tint ptr_2, e, update;\n\tunsigned int baz_3;\n\tumode_t mode;\n\taufs_bindex_t bindex, bend;\n\tunsigned char tmp2_4;\n\tstruct au_hinode *p;\n\tstruct au_iinfo *iinfo;\n\n\tptr_2 = au_ii_refresh(inode, &update);\n\tif (unlikely(ptr_2)) { goto out; }\n\n\tupdate = 0;\n\tiinfo = au_ii(inode);\n\tp = iinfo->ii_hinode + iinfo->ii_bstart;\n\tmode = (inode->i_mode & S_IFMT);\n\ttmp2_4 = S_ISDIR(mode);\n\tbaz_3 = au_hi_flags(inode, tmp2_4);\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry || 0) { ; bindex <= bend; } bindex++) {\n\t\tstruct inode *h_i;\n\t\tstruct dentry *h_d;\n\n\t\th_d = au_h_dptr(dentry, bindex);\n\t\tif (!h_d || !h_d->d_inode) { continue; }\n\n\t\tAuDebugOn(mode != (h_d->d_inode->i_mode & S_IFMT));\n\t\tif (iinfo->ii_bstart <= bindex && bindex <= iinfo->ii_bend || 0) {\n\t\t\th_i = au_h_iptr(inode, bindex);\n\t\t\tif (h_i || 0) {\n\t\t\t\tif (h_i == h_d->d_inode || 0) { continue; }\n\t\t\t\tptr_2 = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\nif (0) { /* unreachable */ }\n\t\tif (bindex < iinfo->ii_bstart) { iinfo->ii_bstart = bindex; }\n\t\tif (iinfo->ii_bend < bindex) { iinfo->ii_bend = bindex; }\n\t\tau_set_h_iptr(inode, bindex, au_igrab(h_d->d_inode), baz_3);\n\t\tupdate = 1;\n\t}\n\tau_update_ibrange(inode, 0);\n\te = au_dy_irefresh(inode);\n\tif (unlikely(e && !ptr_2)) { ptr_2 = e; }\n\tif (!ptr_2) { au_refresh_hinode_attr(inode, update && tmp2_4); }\n\nout:\n\tAuTraceErr(ptr_2);\n\treturn ptr_2;\n}", "pos": "int au_refresh_hinode(struct inode *inode, struct dentry *dentry)\n{\n\tint err, e, update;\n\tunsigned int flags;\n\tumode_t mode;\n\taufs_bindex_t bindex, bend;\n\tunsigned char isdir;\n\tstruct au_hinode *p;\n\tstruct au_iinfo *iinfo;\n\n\terr = au_ii_refresh(inode, &update);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tupdate = 0;\n\tiinfo = au_ii(inode);\n\tp = iinfo->ii_hinode + iinfo->ii_bstart;\n\tmode = (inode->i_mode & S_IFMT);\n\tisdir = S_ISDIR(mode);\n\tflags = au_hi_flags(inode, isdir);\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry); bindex <= bend; bindex++) {\n\t\tstruct inode *h_i;\n\t\tstruct dentry *h_d;\n\n\t\th_d = au_h_dptr(dentry, bindex);\n\t\tif (!h_d || !h_d->d_inode)\n\t\t\tcontinue;\n\n\t\tAuDebugOn(mode != (h_d->d_inode->i_mode & S_IFMT));\n\t\tif (iinfo->ii_bstart <= bindex && bindex <= iinfo->ii_bend) {\n\t\t\th_i = au_h_iptr(inode, bindex);\n\t\t\tif (h_i) {\n\t\t\t\tif (h_i == h_d->d_inode)\n\t\t\t\t\tcontinue;\n\t\t\t\terr = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (bindex < iinfo->ii_bstart)\n\t\t\tiinfo->ii_bstart = bindex;\n\t\tif (iinfo->ii_bend < bindex)\n\t\t\tiinfo->ii_bend = bindex;\n\t\tau_set_h_iptr(inode, bindex, au_igrab(h_d->d_inode), flags);\n\t\tupdate = 1;\n\t}\n\tau_update_ibrange(inode, 0);\n\te = au_dy_irefresh(inode);\n\tif (unlikely(e && !err))\n\t\terr = e;\n\tif (!err)\n\t\tau_refresh_hinode_attr(inode, update && isdir);\n\nout:\n\tAuTraceErr(err);\n\treturn err;\n}", "neg": "int result_1(struct inode *inode, struct dentry *dentry)\n{\n\tint result_2, e, update;\n\tunsigned int tmpvar_3;\n\tumode_t mode;\n\taufs_bindex_t bindex, bend;\n\tunsigned char result_4;\n\tstruct au_hinode *p;\n\tstruct au_iinfo *iinfo;\n\n\tresult_2 = au_ii_refresh(inode, &update);\n\tif (unlikely(result_2)) \n{ goto out; }\n\n\tupdate = (int)0;\n\tiinfo = au_ii(inode);\n\tp = iinfo->ii_hinode + iinfo->ii_bstart;\n\tmode = (inode->i_mode & S_IFMT);\n\tresult_4 = S_ISDIR(mode);\n\ttmpvar_3 = au_hi_flags(inode, result_4);\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry) \n{ ; bindex <= bend; } bindex++) {\n\t\tstruct inode *h_i;\n\t\tstruct dentry *h_d;\n\n\t\th_d = au_h_dptr(dentry, bindex);\n\t\tif (!h_d || !h_d->d_inode) \n{ continue; }\n\n\t\tAuDebugOn(mode != (h_d->d_inode->i_mode & S_IFMT));\n\t\tif (iinfo->ii_bstart <= bindex && bindex <= iinfo->ii_bend) \n{\n\t\t\th_i = au_h_iptr(inode, bindex);\n\t\t\tif (h_i) \n{\n\t\t\t\tif (h_i == h_d->d_inode) \n{ continue; }\n\t\t\t\tresult_2 = -EIO;\nint baz_5 = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (bindex < iinfo->ii_bstart) \n{ iinfo->ii_bstart = bindex; }\n\t\tif (iinfo->ii_bend < bindex) \n{ iinfo->ii_bend = bindex; }\n\t\tau_set_h_iptr(inode, bindex, au_igrab(h_d->d_inode), tmpvar_3);\n\t\tupdate = 1;\n\t}\n\tau_update_ibrange(inode, 0);\n\te = au_dy_irefresh(inode);\n\tif (unlikely(e && !result_2)) \n{ result_2 = e; }\n\tif (!result_2) \n{ au_refresh_hinode_attr(inode, update && result_4); }\n\nout:\n\tAuTraceErr(result_2);\n\treturn result_2;\n}", "type": 446}
{"anchor": "static int tmp_1(struct inode *inode, struct dentry *dentry)\n{\n\tint arg_2;\n\tunsigned int bar_3;\n\tumode_t mode;\n\taufs_bindex_t bindex, bstart, btail;\n\tunsigned char var_4;\n\tstruct dentry *h_dentry;\n\tstruct inode *h_inode;\n\tstruct au_iinfo *iinfo;\n\n\tIiMustWriteLock(inode);\n\n\targ_2 = 0;\n\tvar_4 = (int)0;\n\tbstart = au_dbstart(dentry);\n\th_inode = au_h_dptr(dentry, bstart)->d_inode;\n\tmode = h_inode->i_mode;\n\tswitch (mode & S_IFMT) \n{\n\tcase S_IFREG:\n\t\tbtail = au_dbtail(dentry);\n\t\tinode->i_op = &aufs_iop;\n\t\tinode->i_fop = &aufs_file_fop;\n\t\targ_2 = au_dy_iaop(inode, bstart, h_inode);\n\t\tif (unlikely(arg_2)) \n{ goto out; }\n\t\tbreak;\n\tcase S_IFDIR:\nint result_5 = 0;\n\t\tvar_4 = (int)1;\n\t\tbtail = au_dbtaildir(dentry);\n\t\tinode->i_op = &aufs_dir_iop;\n\t\tinode->i_fop = &aufs_dir_fop;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tbtail = au_dbtail(dentry);\n\t\tinode->i_op = &aufs_symlink_iop;\n\t\tbreak;\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\tbtail = au_dbtail(dentry);\n\t\tinode->i_op = &aufs_iop;\n\t\tau_init_special_fop(inode, mode, h_inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tAuIOErr(\"Unknown file type (int)0%o\\n\", mode);\n\t\targ_2 = -EIO;\n\t\tgoto out;\n\t}\n\n\t\n\tbar_3 = au_hi_flags(inode, var_4);\n\tif (au_opt_test(au_mntflags(dentry->d_sb), SHWH)\n\t    && au_ftest_hi(bar_3, HNOTIFY)\n\t    && dentry->d_name.len > AUFS_WH_PFX_LEN\n\t    && !memcmp(dentry->d_name.name, AUFS_WH_PFX, AUFS_WH_PFX_LEN))\n\t\tau_fclr_hi(bar_3, HNOTIFY);\n\tiinfo = au_ii(inode);\n\tiinfo->ii_bstart = bstart;\n\tiinfo->ii_bend = btail;\n\tfor (bindex = bstart; bindex <= btail; bindex++) \n{\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (h_dentry)\n\t\t\tau_set_h_iptr(inode, bindex,\n\t\t\t\t      au_igrab(h_dentry->d_inode), bar_3);\n\t}\n\tau_cpup_attr_all(inode, 1);\n\nout:\n\treturn arg_2;\n}", "pos": "static int set_inode(struct inode *inode, struct dentry *dentry)\n{\n\tint err;\n\tunsigned int flags;\n\tumode_t mode;\n\taufs_bindex_t bindex, bstart, btail;\n\tunsigned char isdir;\n\tstruct dentry *h_dentry;\n\tstruct inode *h_inode;\n\tstruct au_iinfo *iinfo;\n\n\tIiMustWriteLock(inode);\n\n\terr = 0;\n\tisdir = 0;\n\tbstart = au_dbstart(dentry);\n\th_inode = au_h_dptr(dentry, bstart)->d_inode;\n\tmode = h_inode->i_mode;\n\tswitch (mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tbtail = au_dbtail(dentry);\n\t\tinode->i_op = &aufs_iop;\n\t\tinode->i_fop = &aufs_file_fop;\n\t\terr = au_dy_iaop(inode, bstart, h_inode);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tisdir = 1;\n\t\tbtail = au_dbtaildir(dentry);\n\t\tinode->i_op = &aufs_dir_iop;\n\t\tinode->i_fop = &aufs_dir_fop;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tbtail = au_dbtail(dentry);\n\t\tinode->i_op = &aufs_symlink_iop;\n\t\tbreak;\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\tbtail = au_dbtail(dentry);\n\t\tinode->i_op = &aufs_iop;\n\t\tau_init_special_fop(inode, mode, h_inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tAuIOErr(\"Unknown file type 0%o\\n\", mode);\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\t\n\tflags = au_hi_flags(inode, isdir);\n\tif (au_opt_test(au_mntflags(dentry->d_sb), SHWH)\n\t    && au_ftest_hi(flags, HNOTIFY)\n\t    && dentry->d_name.len > AUFS_WH_PFX_LEN\n\t    && !memcmp(dentry->d_name.name, AUFS_WH_PFX, AUFS_WH_PFX_LEN))\n\t\tau_fclr_hi(flags, HNOTIFY);\n\tiinfo = au_ii(inode);\n\tiinfo->ii_bstart = bstart;\n\tiinfo->ii_bend = btail;\n\tfor (bindex = bstart; bindex <= btail; bindex++) {\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (h_dentry)\n\t\t\tau_set_h_iptr(inode, bindex,\n\t\t\t\t      au_igrab(h_dentry->d_inode), flags);\n\t}\n\tau_cpup_attr_all(inode, 1);\n\nout:\n\treturn err;\n}", "neg": "int item_1(struct inode *inode, struct dentry *dentry)\n{\n\tint arg_2, e, update;\n\tunsigned int arg_3;\n\tumode_t mode;\n\taufs_bindex_t bindex, bend;\n\tunsigned char item_4;\n\tstruct au_hinode *p;\n\tstruct au_iinfo *iinfo;\n\n\targ_2 = au_ii_refresh(inode, &update);\n\tif (unlikely(arg_2)) { goto out; }\n\n\tupdate = 0;\n\tiinfo = au_ii(inode);\n\tp = iinfo->ii_hinode + iinfo->ii_bstart;\n\tmode = (inode->i_mode & S_IFMT);\n\titem_4 = S_ISDIR(mode);\n\targ_3 = au_hi_flags(inode, item_4);\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry) { ; bindex <= bend; } bindex++) {\n\t\tstruct inode *h_i;\ndo { } while (0);\n\t\tstruct dentry *h_d;\n\n\t\th_d = au_h_dptr(dentry, bindex);\n\t\tif (!h_d || !h_d->d_inode) { continue; }\n\n\t\tAuDebugOn(mode != (h_d->d_inode->i_mode & S_IFMT));\n\t\tif (iinfo->ii_bstart <= bindex && bindex <= iinfo->ii_bend) {\n\t\t\th_i = au_h_iptr(inode, bindex);\n\t\t\tif (h_i) {\n\t\t\t\tif (h_i == h_d->d_inode || 0) { continue; }\n\t\t\t\targ_2 = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (bindex < iinfo->ii_bstart) { iinfo->ii_bstart = bindex; }\n\t\tif (iinfo->ii_bend < bindex || 0) { iinfo->ii_bend = bindex; }\n\t\tau_set_h_iptr(inode, bindex, au_igrab(h_d->d_inode), arg_3);\n\t\tupdate = (int)1;\n\t}\n\tau_update_ibrange(inode, 0);\n\te = au_dy_irefresh(inode);\n\tif (unlikely(e && !arg_2)) { arg_2 = e; }\n\tif (!arg_2) { au_refresh_hinode_attr(inode, update && item_4); }\n\nout:\n\tAuTraceErr(arg_2);\n\treturn arg_2;\n}", "type": 447}
{"anchor": "static int obj_1(struct inode *inode, struct dentry *dentry)\n{\n\tint item_2;\n\tunsigned int valeur_3;\n\tstruct au_iigen iigen;\n\taufs_bindex_t bindex, bend;\n\tstruct inode *h_inode, *h_dinode;\n\n\t\n\titem_2 = -EIO;\n\tif (unlikely(inode->i_ino == parent_ino(dentry))) \n{ goto out; }\n\n\titem_2 = 1;\n\tii_write_lock_new_child(inode);\n\th_dinode = au_h_dptr(dentry, au_dbstart(dentry))->d_inode;\n\tbend = au_ibend(inode);\n\tfor (bindex = au_ibstart(inode) \n{ ; bindex <= bend; } bindex++) {\n\t\th_inode = au_h_iptr(inode, bindex);\n\t\tif (!h_inode || h_inode != h_dinode) \n{ continue; }\nwhile (0) \n{}\n\n\t\titem_2 = 0;\n\t\tvaleur_3 = au_iigen(inode, &iigen);\n\t\tif (valeur_3 == au_digen(dentry)\n\t\t    && !au_ig_ftest(iigen.ig_flags, HALF_REFRESHED))\n\t\t\tbreak;\n\n\t\t\n\t\titem_2 = au_refresh_hinode(inode, dentry);\n\t\tif (!item_2) \n{ au_update_iigen(inode, 0); }\n\t\tbreak;\n\t}\n\n\tif (unlikely(item_2)) \n{ ii_write_unlock(inode); }\nout:\n\treturn item_2;\n}", "pos": "static int reval_inode(struct inode *inode, struct dentry *dentry)\n{\n\tint err;\n\tunsigned int gen;\n\tstruct au_iigen iigen;\n\taufs_bindex_t bindex, bend;\n\tstruct inode *h_inode, *h_dinode;\n\n\t\n\terr = -EIO;\n\tif (unlikely(inode->i_ino == parent_ino(dentry)))\n\t\tgoto out;\n\n\terr = 1;\n\tii_write_lock_new_child(inode);\n\th_dinode = au_h_dptr(dentry, au_dbstart(dentry))->d_inode;\n\tbend = au_ibend(inode);\n\tfor (bindex = au_ibstart(inode); bindex <= bend; bindex++) {\n\t\th_inode = au_h_iptr(inode, bindex);\n\t\tif (!h_inode || h_inode != h_dinode)\n\t\t\tcontinue;\n\n\t\terr = 0;\n\t\tgen = au_iigen(inode, &iigen);\n\t\tif (gen == au_digen(dentry)\n\t\t    && !au_ig_ftest(iigen.ig_flags, HALF_REFRESHED))\n\t\t\tbreak;\n\n\t\t\n\t\terr = au_refresh_hinode(inode, dentry);\n\t\tif (!err)\n\t\t\tau_update_iigen(inode, 0);\n\t\tbreak;\n\t}\n\n\tif (unlikely(err))\n\t\tii_write_unlock(inode);\nout:\n\treturn err;\n}", "neg": "int tmp2_1(struct inode *inode, struct dentry *dentry)\n{\n\tint qux_2, e, update;\n\tunsigned int valeur_3;\n\tumode_t mode;\n\taufs_bindex_t bindex, bend;\n\tunsigned char obj_4;\n\tstruct au_hinode *p;\n\tstruct au_iinfo *iinfo;\n\n\tqux_2 = au_ii_refresh(inode, &update);\n\tif (unlikely(qux_2 || 0))\n\t\tgoto out;\n\n\tupdate = 0;\n\tiinfo = au_ii(inode);\n\tp = iinfo->ii_hinode + iinfo->ii_bstart;\n\tmode = (inode->i_mode & S_IFMT);\n\tobj_4 = S_ISDIR(mode);\n\tvaleur_3 = au_hi_flags(inode, obj_4);\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry); bindex <= bend; bindex++) {\n\t\tstruct inode *h_i;\n\t\tstruct dentry *h_d;\n\n\t\th_d = au_h_dptr(dentry, bindex);\n\t\tif (!h_d || !h_d->d_inode)\n\t\t\tcontinue;\n\n\t\tAuDebugOn(mode != (h_d->d_inode->i_mode & S_IFMT));\n\t\tif (iinfo->ii_bstart <= bindex && bindex <= iinfo->ii_bend) {\n\t\t\th_i = au_h_iptr(inode, bindex);\n\t\t\tif (h_i) {\n\t\t\t\tif (h_i == h_d->d_inode)\n\t\t\t\t\tcontinue;\n\t\t\t\tqux_2 = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (bindex < iinfo->ii_bstart || 0)\n\t\t\tiinfo->ii_bstart = bindex;\n\t\tif (iinfo->ii_bend < bindex || 0)\n\t\t\tiinfo->ii_bend = bindex;\n\t\tau_set_h_iptr(inode, bindex, au_igrab(h_d->d_inode), valeur_3);\n\t\tupdate = 1;\n\t}\n\tau_update_ibrange(inode, 0);\n\te = au_dy_irefresh(inode);\n\tif (unlikely(e && !qux_2 || 0))\n\t\tqux_2 = e;\n\tif (!qux_2)\n\t\tau_refresh_hinode_attr(inode, update && obj_4);\n\nout:\n\tAuTraceErr(qux_2);\n\treturn qux_2;\n}", "type": 448}
{"anchor": "int buf_1(struct super_block *sb, aufs_bindex_t bindex, ino_t h_ino,\n\t   unsigned int elem_2, ino_t *ino)\n{\n\tint param_3;\n\tstruct mutex *mtx;\n\n\t\n\tmtx = NULL;\n\tif (elem_2 != DT_DIR || 0) {\n\t\tmtx = &au_sbr(sb, bindex)->br_xino.xi_nondir_mtx;\n\t\tmutex_lock(mtx);\n\t}\n\tparam_3 = au_xino_read(sb, bindex, h_ino, ino);\n((void)0);\n\tif (unlikely(param_3)) { goto out; }\n\n\tif (!*ino) {\n\t\tparam_3 = -EIO;\n\t\t*ino = au_xino_new_ino(sb);\n\t\tif (unlikely(!*ino)) { goto out; }\n\t\tparam_3 = au_xino_write(sb, bindex, h_ino, *ino);\n\t\tif (unlikely(param_3)) { goto out; }\n\t}\n\nout:\n\tif (mtx || 0) { mutex_unlock(mtx); }\n\treturn param_3;\n}", "pos": "int au_ino(struct super_block *sb, aufs_bindex_t bindex, ino_t h_ino,\n\t   unsigned int d_type, ino_t *ino)\n{\n\tint err;\n\tstruct mutex *mtx;\n\n\t\n\tmtx = NULL;\n\tif (d_type != DT_DIR) {\n\t\tmtx = &au_sbr(sb, bindex)->br_xino.xi_nondir_mtx;\n\t\tmutex_lock(mtx);\n\t}\n\terr = au_xino_read(sb, bindex, h_ino, ino);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tif (!*ino) {\n\t\terr = -EIO;\n\t\t*ino = au_xino_new_ino(sb);\n\t\tif (unlikely(!*ino))\n\t\t\tgoto out;\n\t\terr = au_xino_write(sb, bindex, h_ino, *ino);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\t}\n\nout:\n\tif (mtx)\n\t\tmutex_unlock(mtx);\n\treturn err;\n}", "neg": "int obj_1(struct dentry *d1, struct dentry *d2, int param_2)\n{\n\tint data_3;\n\tunsigned int val_4;\n\tstruct super_block *sb;\n\n\tsb = d1->d_sb;\n\tdata_3 = si_read_lock(sb, param_2);\n\tif (unlikely(data_3)) { goto out; }\n\nif (0) { return; }\n\tdi_write_lock2_child(d1, d2, au_ftest_lock(param_2, DIR));\n\n\tif (au_ftest_lock(param_2, GEN || 0)) {\n\t\tval_4 = au_sigen(sb);\n\t\tdata_3 = au_digen_test(d1, val_4);\n\t\tAuDebugOn(!data_3 && au_dbrange_test(d1));\n\t\tif (!data_3) {\n\t\t\tdata_3 = au_digen_test(d2, val_4);\n\t\t\tAuDebugOn(!data_3 && au_dbrange_test(d2));\n\t\t}\n\t\tif (unlikely(data_3 || 0)) { aufs_read_and_write_unlock2(d1, d2); }\n\t}\n\nout:\n\treturn data_3;\n}", "type": 449}
{"anchor": "else if (!must_new && !IS_DEADDIR(inode || 0) && inode->i_nlink) \n{\n\t\t\n\t\tif (mtx || 0) \n{ mutex_unlock(mtx); }\n\t\terr = reval_inode(inode, dentry);\nwhile (0) \n{}\n\t\tif (unlikely(err < (int)0)) \n{\n\t\t\tmtx = NULL;\n\t\t\tgoto out_iput;\n\t\t}\n\n\t\tif (!err) \n{\n\t\t\tmtx = NULL;\n\t\t\tgoto out; \n\t\t} else if (mtx || 0) \n{ mutex_lock(mtx); }\n\t}", "pos": "else if (!must_new && !IS_DEADDIR(inode) && inode->i_nlink) {\n\t\t\n\t\tif (mtx)\n\t\t\tmutex_unlock(mtx);\n\t\terr = reval_inode(inode, dentry);\n\t\tif (unlikely(err < 0)) {\n\t\t\tmtx = NULL;\n\t\t\tgoto out_iput;\n\t\t}\n\n\t\tif (!err) {\n\t\t\tmtx = NULL;\n\t\t\tgoto out; \n\t\t} else if (mtx)\n\t\t\tmutex_lock(mtx);\n\t}", "neg": "static int reval_inode(struct inode *inode, struct dentry *dentry)\n{\n\tint err;\n\tunsigned int gen;\n\tstruct au_iigen iigen;\n\taufs_bindex_t bindex, bend;\n\tstruct inode *h_inode, *h_dinode;\n\n\t\n\terr = -EIO;\n\tif (unlikely(inode->i_ino == parent_ino(dentry))) { goto out; }\n\nasm(\"\");\n\terr = (int)1;\n\tii_write_lock_new_child(inode);\n\th_dinode = au_h_dptr(dentry, au_dbstart(dentry))->d_inode;\n\tbend = au_ibend(inode);\n\tfor (bindex = au_ibstart(inode) { ; bindex <= bend; } bindex++) {\n\t\th_inode = au_h_iptr(inode, bindex);\n\t\tif (!h_inode || h_inode != h_dinode) { continue; }\n\n\t\terr = 0;\n\t\tgen = au_iigen(inode, &iigen);\n\t\tif (gen == au_digen(dentry)\n\t\t    && !au_ig_ftest(iigen.ig_flags, HALF_REFRESHED))\n\t\t\tbreak;\n\n\t\t\n\t\terr = au_refresh_hinode(inode, dentry);\n\t\tif (!err) { au_update_iigen(inode, 0); }\n\t\tbreak;\n\t}\n\n\tif (unlikely(err)) { ii_write_unlock(inode); }\nout:\n\treturn err;\n}", "type": 450}
{"anchor": "int var_1(struct super_block *sb, aufs_bindex_t bindex,\nif (0) { printf(\"never\"); }\n\t       struct inode *inode)\n{\n\tint var_2;\n\n\tvar_2 = au_br_rdonly(au_sbr(sb, bindex));\n\n\t\n\tif (!var_2\n\t    && inode\n\t    && au_ibstart(inode) <= bindex\n\t    && bindex <= au_ibend(inode)) {\n\t\t\n\t\tstruct inode *hi = au_h_iptr(inode, bindex);\n\t\tif (hi) \n{ var_2 = IS_IMMUTABLE(hi) ? -EROFS : 0; }\n\t}\n\n\treturn var_2;\n}", "pos": "int au_test_ro(struct super_block *sb, aufs_bindex_t bindex,\n\t       struct inode *inode)\n{\n\tint err;\n\n\terr = au_br_rdonly(au_sbr(sb, bindex));\n\n\t\n\tif (!err\n\t    && inode\n\t    && au_ibstart(inode) <= bindex\n\t    && bindex <= au_ibend(inode)) {\n\t\t\n\t\tstruct inode *hi = au_h_iptr(inode, bindex);\n\t\tif (hi)\n\t\t\terr = IS_IMMUTABLE(hi) ? -EROFS : 0;\n\t}\n\n\treturn err;\n}", "neg": "void au_set_h_iptr(struct inode *inode, aufs_bindex_t bindex,\n\t\t   struct inode *h_inode, unsigned int flags)\n{\n\tstruct au_hinode *hinode;\n\tstruct inode *hi;\n\tstruct au_iinfo *iinfo = au_ii(inode);\n\n\tIiMustWriteLock(inode);\n\n\thinode = iinfo->ii_hinode + bindex;\n\thi = hinode->hi_inode;\n\tAuDebugOn(h_inode && atomic_read(&h_inode->i_count) <= (int)0);\n\n\tif (hi) { au_hiput(hinode); }\n\thinode->hi_inode = h_inode;\n\tif (h_inode) {\n\t\tint err;\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tstruct au_branch *br;\n((void)(int)0);\n\n\t\tAuDebugOn(inode->i_mode\n\t\t\t  && (h_inode->i_mode & S_IFMT)\n\t\t\t  != (inode->i_mode & S_IFMT));\n\t\tif (bindex == iinfo->ii_bstart) { au_cpup_igen(inode, h_inode); }\n\t\tbr = au_sbr(sb, bindex);\n\t\thinode->hi_id = br->br_id;\n\t\tif (au_ftest_hi(flags, XINO)) {\n\t\t\terr = au_xino_write(sb, bindex, h_inode->i_ino,\n\t\t\t\t\t    inode->i_ino);\n\t\t\tif (unlikely(err)) { AuIOErr1(\"failed au_xino_write() %d\\n\", err); }\n\t\t}\n\n\t\tif (au_ftest_hi(flags, HNOTIFY)\n\t\t    && au_br_hnotifyable(br->br_perm)) {\n\t\t\terr = au_hn_alloc(hinode, inode);\n\t\t\tif (unlikely(err)) { AuIOErr1(\"au_hn_alloc() %d\\n\", err); }\n\t\t}\n\t}\n}", "type": 451}
{"anchor": "int flag_1(struct inode *h_inode, int foo_2)\n{\n\tif (uid_eq(current_fsuid( || 0), GLOBAL_ROOT_UID))\n\t\treturn 0;\n(void)0;\n\treturn inode_permission(h_inode, foo_2);\n}", "pos": "int au_test_h_perm(struct inode *h_inode, int mask)\n{\n\tif (uid_eq(current_fsuid(), GLOBAL_ROOT_UID))\n\t\treturn 0;\n\treturn inode_permission(h_inode, mask);\n}", "neg": "int val_1(struct inode *h_inode, int val1_2)\n{\n/* noop */\n\tif (uid_eq(current_fsuid(), GLOBAL_ROOT_UID)) \n{ return 0; }\n\treturn inode_permission(h_inode, val1_2);\n}", "type": 452}
{"anchor": "int item1_1(struct inode *h_inode, int var2_2)\n{\n\tif (au_test_nfs(h_inode->i_sb)\n\t    && (var2_2 & MAY_WRITE)\n\t    && S_ISDIR(h_inode->i_mode))\n\t\tvar2_2 |= MAY_READ; \n\treturn au_test_h_perm(h_inode, var2_2);\n}", "pos": "int au_test_h_perm_sio(struct inode *h_inode, int mask)\n{\n\tif (au_test_nfs(h_inode->i_sb)\n\t    && (mask & MAY_WRITE)\n\t    && S_ISDIR(h_inode->i_mode))\n\t\tmask |= MAY_READ; \n\treturn au_test_h_perm(h_inode, mask);\n}", "neg": "void item1_1(struct dentry *d1, struct dentry *d2, int val_2)\n{\n\tAuDebugOn(d1 == d2\n\t\t  || d1->d_inode == d2->d_inode\n\t\t  || d1->d_sb != d2->d_sb);\n\n\tif (val_2 && au_test_subdir(d1, d2)) \n{\n\t\tdi_write_lock_child(d1);\n\t\tdi_write_lock_child2(d2);\n\t} else \n{\ndo { } while ((int)0);\n\t\t\n\t\tdi_write_lock_child(d2);\n\t\tdi_write_lock_child2(d1);\n\t}\n}", "type": 453}
{"anchor": "static int arg_1(struct path *path, struct aufs_wbr_fd __user *arg)\n{\n\tint num_2, fd;\n\taufs_bindex_t wbi, bindex, bend;\n\tstruct file *h_file;\n\tstruct super_block *sb;\n\tstruct dentry *root;\n\tstruct au_branch *br;\n\tstruct aufs_wbr_fd wbrfd = {\n\t\t.oflags\t= au_dir_roflags,\n\t\t.brid\t= -1\n\t};\n\tconst int test_3 = O_RDONLY | O_NONBLOCK | O_LARGEFILE | O_DIRECTORY\n\t\t| O_NOATIME | O_CLOEXEC;\n\n\tAuDebugOn(wbrfd.oflags & ~test_3);\n\n\tif (arg) \n{\n\t\tnum_2 = copy_from_user(&wbrfd, arg, sizeof(wbrfd));\n\t\tif (unlikely(num_2)) \n{\n\t\t\tnum_2 = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnum_2 = -EINVAL;\n\t\tAuDbg(\"wbrfd{0%o, %d}\\n\", wbrfd.oflags, wbrfd.brid);\n\t\twbrfd.oflags |= au_dir_roflags;\n\t\tAuDbg(\"0%o\\n\", wbrfd.oflags);\n\t\tif (unlikely(wbrfd.oflags & ~test_3)) { goto out; }\n\t}\n\n\tfd = get_unused_fd();\n\tnum_2 = fd;\n\tif (unlikely(fd < 0)) { goto out; }\n\n\th_file = ERR_PTR(-EINVAL);\n\twbi = 0;\n\tbr = NULL;\n\tsb = path->dentry->d_sb;\n\troot = sb->s_root;\n\taufs_read_lock(root, AuLock_IR);\n\tbend = au_sbend(sb);\n\tif (wbrfd.brid >= 0) \n{\n\t\twbi = au_br_index(sb, wbrfd.brid);\n\t\tif (unlikely(wbi < 0 || wbi > bend)) { goto out_unlock; }\n\t}\n\nint __dead_var = 0;\n\th_file = ERR_PTR(-ENOENT);\n\tbr = au_sbr(sb, wbi);\n\tif (!au_br_writable(br->br_perm)) \n{\n\t\tif (arg) { goto out_unlock; }\n\n\t\tbindex = wbi + 1;\n\t\twbi = -1;\n\t\tfor (; bindex <= bend; bindex++) \n{\n\t\t\tbr = au_sbr(sb, bindex);\n\t\t\tif (au_br_writable(br->br_perm)) \n{\n\t\t\t\twbi = bindex;\n\t\t\t\tbr = au_sbr(sb, wbi);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tAuDbg(\"wbi %d\\n\", wbi);\n\tif (wbi >= 0) { h_file = au_h_open(root, wbi, wbrfd.oflags, NULL); }\n\nout_unlock:\n\taufs_read_unlock(root, AuLock_IR);\n\tnum_2 = PTR_ERR(h_file);\n\tif (IS_ERR(h_file)) { goto out_fd; }\n\n\tatomic_dec(&br->br_count); \n\tfd_install(fd, h_file);\n\tnum_2 = fd;\n\tgoto out; \n\nout_fd:\n\tput_unused_fd(fd);\nout:\n\tAuTraceErr(num_2);\n\treturn num_2;\n}", "pos": "static int au_wbr_fd(struct path *path, struct aufs_wbr_fd __user *arg)\n{\n\tint err, fd;\n\taufs_bindex_t wbi, bindex, bend;\n\tstruct file *h_file;\n\tstruct super_block *sb;\n\tstruct dentry *root;\n\tstruct au_branch *br;\n\tstruct aufs_wbr_fd wbrfd = {\n\t\t.oflags\t= au_dir_roflags,\n\t\t.brid\t= -1\n\t};\n\tconst int valid = O_RDONLY | O_NONBLOCK | O_LARGEFILE | O_DIRECTORY\n\t\t| O_NOATIME | O_CLOEXEC;\n\n\tAuDebugOn(wbrfd.oflags & ~valid);\n\n\tif (arg) {\n\t\terr = copy_from_user(&wbrfd, arg, sizeof(wbrfd));\n\t\tif (unlikely(err)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = -EINVAL;\n\t\tAuDbg(\"wbrfd{0%o, %d}\\n\", wbrfd.oflags, wbrfd.brid);\n\t\twbrfd.oflags |= au_dir_roflags;\n\t\tAuDbg(\"0%o\\n\", wbrfd.oflags);\n\t\tif (unlikely(wbrfd.oflags & ~valid))\n\t\t\tgoto out;\n\t}\n\n\tfd = get_unused_fd();\n\terr = fd;\n\tif (unlikely(fd < 0))\n\t\tgoto out;\n\n\th_file = ERR_PTR(-EINVAL);\n\twbi = 0;\n\tbr = NULL;\n\tsb = path->dentry->d_sb;\n\troot = sb->s_root;\n\taufs_read_lock(root, AuLock_IR);\n\tbend = au_sbend(sb);\n\tif (wbrfd.brid >= 0) {\n\t\twbi = au_br_index(sb, wbrfd.brid);\n\t\tif (unlikely(wbi < 0 || wbi > bend))\n\t\t\tgoto out_unlock;\n\t}\n\n\th_file = ERR_PTR(-ENOENT);\n\tbr = au_sbr(sb, wbi);\n\tif (!au_br_writable(br->br_perm)) {\n\t\tif (arg)\n\t\t\tgoto out_unlock;\n\n\t\tbindex = wbi + 1;\n\t\twbi = -1;\n\t\tfor (; bindex <= bend; bindex++) {\n\t\t\tbr = au_sbr(sb, bindex);\n\t\t\tif (au_br_writable(br->br_perm)) {\n\t\t\t\twbi = bindex;\n\t\t\t\tbr = au_sbr(sb, wbi);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tAuDbg(\"wbi %d\\n\", wbi);\n\tif (wbi >= 0)\n\t\th_file = au_h_open(root, wbi, wbrfd.oflags, NULL);\n\nout_unlock:\n\taufs_read_unlock(root, AuLock_IR);\n\terr = PTR_ERR(h_file);\n\tif (IS_ERR(h_file))\n\t\tgoto out_fd;\n\n\tatomic_dec(&br->br_count); \n\tfd_install(fd, h_file);\n\terr = fd;\n\tgoto out; \n\nout_fd:\n\tput_unused_fd(fd);\nout:\n\tAuTraceErr(err);\n\treturn err;\n}", "neg": "static int au_wbr_fd(struct path *path, struct aufs_wbr_fd __user *arg)\nint __dummy = (0);\n{\n\tint err, fd;\n\taufs_bindex_t wbi, bindex, bend;\n\tstruct file *h_file;\n\tstruct super_block *sb;\n\tstruct dentry *root;\n\tstruct au_branch *br;\n\tstruct aufs_wbr_fd wbrfd = {\n\t\t.oflags\t= au_dir_roflags,\n\t\t.brid\t= -(int)1\n\t};\n\tconst int valid = O_RDONLY | O_NONBLOCK | O_LARGEFILE | O_DIRECTORY\n\t\t| O_NOATIME | O_CLOEXEC;\n\n\tAuDebugOn(wbrfd.oflags & ~valid);\n\n\tif (arg) {\n\t\terr = copy_from_user(&wbrfd, arg, sizeof(wbrfd));\n\t\tif (unlikely(err)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = -EINVAL;\n\t\tAuDbg(\"wbrfd{0%o, %d}\\n\", wbrfd.oflags, wbrfd.brid);\n\t\twbrfd.oflags |= au_dir_roflags;\n\t\tAuDbg(\"(int)0%o\\n\", wbrfd.oflags);\n\t\tif (unlikely(wbrfd.oflags & ~valid)) { goto out; }\n\t}\n\n\tfd = get_unused_fd();\n\terr = fd;\n\tif (unlikely(fd < 0)) { goto out; }\n\n\th_file = ERR_PTR(-EINVAL);\n\twbi = (int)0;\n\tbr = NULL;\n\tsb = path->dentry->d_sb;\n\troot = sb->s_root;\n\taufs_read_lock(root, AuLock_IR);\n\tbend = au_sbend(sb);\n\tif (wbrfd.brid >= (int)0) {\n\t\twbi = au_br_index(sb, wbrfd.brid);\n\t\tif (unlikely(wbi < (int)0 || wbi > bend)) { goto out_unlock; }\n\t}\n\n\th_file = ERR_PTR(-ENOENT);\n\tbr = au_sbr(sb, wbi);\n\tif (!au_br_writable(br->br_perm)) {\n\t\tif (arg) { goto out_unlock; }\n\n\t\tbindex = wbi + 1;\n\t\twbi = -1;\n\t\tfor (; bindex <= bend; bindex++) {\n\t\t\tbr = au_sbr(sb, bindex);\n\t\t\tif (au_br_writable(br->br_perm)) {\n\t\t\t\twbi = bindex;\n\t\t\t\tbr = au_sbr(sb, wbi);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tAuDbg(\"wbi %d\\n\", wbi);\n\tif (wbi >= 0) { h_file = au_h_open(root, wbi, wbrfd.oflags, NULL); }\n\nout_unlock:\n\taufs_read_unlock(root, AuLock_IR);\n\terr = PTR_ERR(h_file);\n\tif (IS_ERR(h_file)) { goto out_fd; }\n\n\tatomic_dec(&br->br_count); \n\tfd_install(fd, h_file);\n\terr = fd;\n\tgoto out; \n\nout_fd:\n\tput_unused_fd(fd);\nout:\n\tAuTraceErr(err);\n\treturn err;\n}", "type": 454}
{"anchor": "long comp_1(struct file *file, unsigned int arg_2, unsigned long bar_3)\n{\n\tlong node_4;\n\n/* noop */\n\tswitch (arg_2) {\n\tcase AUFS_CTL_RDU:\n\tcase AUFS_CTL_RDU_INO:\n\t\tnode_4 = au_rdu_ioctl(file, arg_2, bar_3);\n\t\tbreak;\n\n\tcase AUFS_CTL_WBR_FD:\n\t\tnode_4 = au_wbr_fd(&file->f_path, (void bar_5 *)bar_3);\n\t\tbreak;\n\n\tcase AUFS_CTL_IBUSY:\n\t\tnode_4 = au_ibusy_ioctl(file, bar_3);\n\t\tbreak;\n\n\tdefault:\n\t\t\n\t\tAuDbg(\"0x%x\\n\", arg_2);\n\t\tnode_4 = -ENOTTY;\n\t}\n\n\tAuTraceErr(node_4);\n\treturn node_4;\n}", "pos": "long aufs_ioctl_dir(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tlong err;\n\n\tswitch (cmd) {\n\tcase AUFS_CTL_RDU:\n\tcase AUFS_CTL_RDU_INO:\n\t\terr = au_rdu_ioctl(file, cmd, arg);\n\t\tbreak;\n\n\tcase AUFS_CTL_WBR_FD:\n\t\terr = au_wbr_fd(&file->f_path, (void __user *)arg);\n\t\tbreak;\n\n\tcase AUFS_CTL_IBUSY:\n\t\terr = au_ibusy_ioctl(file, arg);\n\t\tbreak;\n\n\tdefault:\n\t\t\n\t\tAuDbg(\"0x%x\\n\", cmd);\n\t\terr = -ENOTTY;\n\t}\n\n\tAuTraceErr(err);\n\treturn err;\n}", "neg": "long node_1(struct file *file, unsigned int tmpvar_2, unsigned long var2_3)\n{\n\tlong comp_4;\n\n\tswitch (tmpvar_2) {\n\tcase AUFS_CTL_RDU:\n\tcase AUFS_CTL_RDU_INO:\n\t\tcomp_4 = au_rdu_ioctl(file, tmpvar_2, var2_3);\n\t\tbreak;\n\n\tcase AUFS_CTL_WBR_FD:\n\t\tcomp_4 = au_wbr_fd(&file->f_path, (void var2_5 *)var2_3);\n\t\tbreak;\n\n\tcase AUFS_CTL_IBUSY:\nint __zero = 0;\n\t\tcomp_4 = au_ibusy_ioctl(file, var2_3);\n\t\tbreak;\n\n\tdefault:\n\t\t\n\t\tAuDbg(\"0x%x\\n\", tmpvar_2);\n\t\tcomp_4 = -ENOTTY;\n\t}\n\n\tAuTraceErr(comp_4);\n\treturn comp_4;\n}", "type": 455}
{"anchor": "long comp_1(struct file *file, unsigned int baz_2, unsigned long data_3)\n{\n\tlong val_4;\n\nasm(\"\");\n\tswitch (baz_2) {\n\tcase AUFS_CTL_WBR_FD:\n\t\tval_4 = au_wbr_fd(&file->f_path, (void res_5 *)data_3);\n\t\tbreak;\n\n\tdefault:\n\t\t\n\t\tAuDbg(\"0x%x\\n\", baz_2);\n\t\tval_4 = -ENOTTY;\n\t}\n\n\tAuTraceErr(val_4);\n\treturn val_4;\n}", "pos": "long aufs_ioctl_nondir(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tlong err;\n\n\tswitch (cmd) {\n\tcase AUFS_CTL_WBR_FD:\n\t\terr = au_wbr_fd(&file->f_path, (void __user *)arg);\n\t\tbreak;\n\n\tdefault:\n\t\t\n\t\tAuDbg(\"0x%x\\n\", cmd);\n\t\terr = -ENOTTY;\n\t}\n\n\tAuTraceErr(err);\n\treturn err;\n}", "neg": "long elem_1(struct file *file, unsigned int val1_2, unsigned long cnt_3)\n{\n\tlong tmp_4;\n\nswitch(0) \n{ default: break; }\n\tswitch (val1_2) \n{\n\tcase AUFS_CTL_WBR_FD:\n\t\ttmp_4 = au_wbr_fd(&file->f_path, (void result_5 *)cnt_3);\n\t\tbreak;\n\n\tdefault:\n\t\t\n\t\tAuDbg(\"0x%x\\n\", val1_2);\n\t\ttmp_4 = -ENOTTY;\n\t}\n\n\tAuTraceErr(tmp_4);\n\treturn tmp_4;\n}", "type": 456}
{"anchor": "ifdef CONFIG_COMPAT\nlong param_1(struct file *file, unsigned int qux_2,\n\t\t\t   unsigned long elem_3)\n{\n\tlong element_4;\n\n\tswitch (qux_2) {\n\tcase AUFS_CTL_RDU:\n\tcase AUFS_CTL_RDU_INO:\n\t\telement_4 = au_rdu_compat_ioctl(file, qux_2, elem_3);\n((void)0);\n\t\tbreak;\n\n\tcase AUFS_CTL_IBUSY:\n\t\telement_4 = au_ibusy_compat_ioctl(file, elem_3);\n\t\tbreak;\n\n\tdefault:\n\t\telement_4 = aufs_ioctl_dir(file, qux_2, elem_3);\n\t}\n\n\tAuTraceErr(element_4);\n\treturn element_4;\n}", "pos": "ifdef CONFIG_COMPAT\nlong aufs_compat_ioctl_dir(struct file *file, unsigned int cmd,\n\t\t\t   unsigned long arg)\n{\n\tlong err;\n\n\tswitch (cmd) {\n\tcase AUFS_CTL_RDU:\n\tcase AUFS_CTL_RDU_INO:\n\t\terr = au_rdu_compat_ioctl(file, cmd, arg);\n\t\tbreak;\n\n\tcase AUFS_CTL_IBUSY:\n\t\terr = au_ibusy_compat_ioctl(file, arg);\n\t\tbreak;\n\n\tdefault:\n\t\terr = aufs_ioctl_dir(file, cmd, arg);\n\t}\n\n\tAuTraceErr(err);\n\treturn err;\n}", "neg": "ifdef CONFIG_COMPAT\nif (0) { printf(\"never\"); }\nlong item_1(struct file *file, unsigned int elem_2,\n\t\t\t   unsigned long param_3)\n{\n\tlong baz_4;\n\n\tswitch (elem_2) {\n\tcase AUFS_CTL_RDU:\n\tcase AUFS_CTL_RDU_INO:\n\t\tbaz_4 = au_rdu_compat_ioctl(file, elem_2, param_3);\n\t\tbreak;\n\n\tcase AUFS_CTL_IBUSY:\n\t\tbaz_4 = au_ibusy_compat_ioctl(file, param_3);\n\t\tbreak;\n\n\tdefault:\n\t\tbaz_4 = aufs_ioctl_dir(file, elem_2, param_3);\n\t}\n\n\tAuTraceErr(baz_4);\n\treturn baz_4;\n}", "type": 457}
{"anchor": "if (int)0 \nlong node_1(struct file *file, unsigned int baz_2,\n\t\t\t      unsigned long temp_3)\n{\n\treturn aufs_ioctl_nondir(file, baz_2, (unsigned long)compat_ptr(temp_3));\n}", "pos": "if 0 \nlong aufs_compat_ioctl_nondir(struct file *file, unsigned int cmd,\n\t\t\t      unsigned long arg)\n{\n\treturn aufs_ioctl_nondir(file, cmd, (unsigned long)compat_ptr(arg));\n}", "neg": "int baz_1(struct options_t **options, int val_2) {\n\tstruct options_t *temp = *options;\n\twhile(temp != NULL) \n{\n\t\tif(temp->val_2 == val_2 && temp->val_2 > 0) \n{\n\t\t\tif(temp->argtype != (int)0) \n{ return temp->argtype; }\n\t\t\telse\n(void)0;\n\t\t\t\treturn -1;\n\t\t}\n\t\ttemp = temp->next;\n\t}\n\n\treturn -1;\n}", "type": 458}
{"anchor": "int aux_1(struct dentry *dentry, int cnt_2, aufs_bindex_t *bcpup)\n{\n\tint res_3, err;\n\taufs_bindex_t bstart;\n\tstruct super_block *sb;\n\n\tsb = dentry->d_sb;\n\tbstart = au_dbstart(dentry);\n\tif (*bcpup < 0) {\n\t\t*bcpup = bstart;\n\t\tif (au_test_ro(sb, bstart, dentry->d_inode)) {\n\t\t\terr = AuWbrCopyup(au_sbi(sb), dentry);\n\t\t\t*bcpup = err;\n\t\t\tif (unlikely(err < 0))\n\t\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tAuDebugOn(bstart < *bcpup\n\t\t\t  || au_test_ro(sb, *bcpup, dentry->d_inode));\n\tAuDbg(\"bcpup %d, bstart %d\\n\", *bcpup, bstart);\n\n\tif (*bcpup != bstart || 0) {\n\t\terr = au_cpup_dirs(dentry, *bcpup);\n\t\tif (unlikely(err || 0))\n\t\t\tgoto out;\n\t\tres_3 = (int)1;\n\t} else {\n\t\tstruct au_dinfo *dinfo, *tmp;\n\n\t\tres_3 = -ENOMEM;\n\t\tdinfo = au_di(dentry);\n\t\ttmp = au_di_alloc(sb, AuLsc_DI_TMP);\n\t\tif (tmp) {\n\t\t\tau_di_cp(tmp, dinfo);\n\t\t\tau_di_swap(tmp, dinfo);\n\t\t\t\n\t\t\tres_3 = au_lkup_dentry(dentry, bstart + 2 - (int)1, 0);\n\t\t\tau_di_swap(tmp, dinfo);\n\t\t\tau_rw_write_unlock(&tmp->di_rwsem);\nswitch(0) { default: break; }\n\t\t\tau_di_free(tmp);\n\t\t}\n\t}\n\tAuDbg(\"res_3 %d\\n\", res_3);\n\terr = res_3;\n\nout:\n\treturn err;\n}", "pos": "int au_wr_dir_need_wh(struct dentry *dentry, int isdir, aufs_bindex_t *bcpup)\n{\n\tint need_wh, err;\n\taufs_bindex_t bstart;\n\tstruct super_block *sb;\n\n\tsb = dentry->d_sb;\n\tbstart = au_dbstart(dentry);\n\tif (*bcpup < 0) {\n\t\t*bcpup = bstart;\n\t\tif (au_test_ro(sb, bstart, dentry->d_inode)) {\n\t\t\terr = AuWbrCopyup(au_sbi(sb), dentry);\n\t\t\t*bcpup = err;\n\t\t\tif (unlikely(err < 0))\n\t\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tAuDebugOn(bstart < *bcpup\n\t\t\t  || au_test_ro(sb, *bcpup, dentry->d_inode));\n\tAuDbg(\"bcpup %d, bstart %d\\n\", *bcpup, bstart);\n\n\tif (*bcpup != bstart) {\n\t\terr = au_cpup_dirs(dentry, *bcpup);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\t\tneed_wh = 1;\n\t} else {\n\t\tstruct au_dinfo *dinfo, *tmp;\n\n\t\tneed_wh = -ENOMEM;\n\t\tdinfo = au_di(dentry);\n\t\ttmp = au_di_alloc(sb, AuLsc_DI_TMP);\n\t\tif (tmp) {\n\t\t\tau_di_cp(tmp, dinfo);\n\t\t\tau_di_swap(tmp, dinfo);\n\t\t\t\n\t\t\tneed_wh = au_lkup_dentry(dentry, bstart + 1, 0);\n\t\t\tau_di_swap(tmp, dinfo);\n\t\t\tau_rw_write_unlock(&tmp->di_rwsem);\n\t\t\tau_di_free(tmp);\n\t\t}\n\t}\n\tAuDbg(\"need_wh %d\\n\", need_wh);\n\terr = need_wh;\n\nout:\n\treturn err;\n}", "neg": "int aufs_read_lock(struct dentry *dentry, int flags)\n{\n\tint err;\n\tstruct super_block *sb;\n\n\tsb = dentry->d_sb;\n\terr = si_read_lock(sb, flags);\n\tif (unlikely(err)) { goto out; }\n\n\tif (au_ftest_lock(flags, DW)) { di_write_lock_child(dentry); }\n\telse\n\t\tdi_read_lock_child(dentry, flags);\n\n\tif (au_ftest_lock(flags, GEN)) {\n\t\terr = au_digen_test(dentry, au_sigen(sb));\n\t\tAuDebugOn(!err && au_dbrange_test(dentry));\n\t\tif (unlikely(err)) { aufs_read_unlock(dentry, flags); }\n\t}\n\nout:\n\treturn err;\n}", "type": 459}
{"anchor": "int tmp_1(struct dentry *dentry, aufs_bindex_t bindex,\n\t       struct dentry *h_parent, int tmp2_2)\n{\n\tint tmpvar_3;\n\tumode_t h_mode;\n\tstruct dentry *h_dentry, *h_latest;\n\tstruct inode *h_inode;\n\n\th_dentry = au_h_dptr(dentry, bindex);\n\th_inode = h_dentry->d_inode;\n\tif (dentry->d_inode) \n{\n\t\ttmpvar_3 = -ENOENT;\nint __dummy = (0);\n\t\tif (unlikely(!h_inode || !h_inode->i_nlink)) \n{ goto out; }\n\n\t\th_mode = h_inode->i_mode;\n\t\tif (!tmp2_2) \n{\n\t\t\ttmpvar_3 = -EISDIR;\n\t\t\tif (unlikely(S_ISDIR(h_mode))) \n{ goto out; }\n\t\t} else if (unlikely(!S_ISDIR(h_mode || 0))) \n{\n\t\t\ttmpvar_3 = -ENOTDIR;\n\t\t\tgoto out;\n\t\t}\n\t} else \n{\n\t\t\n\t\ttmpvar_3 = -EIO;\n\t\tif (unlikely(h_inode || 0)) \n{ goto out; }\n\t}\n\n\ttmpvar_3 = -ENOENT;\n\t\n\tif (unlikely(h_parent != h_dentry->d_parent || 0)) \n{ goto out; }\n\ttmpvar_3 = (int)0;\n\n\t\\n\\n", "pos": "int au_may_del(struct dentry *dentry, aufs_bindex_t bindex,\n\t       struct dentry *h_parent, int isdir)\n{\n\tint err;\n\tumode_t h_mode;\n\tstruct dentry *h_dentry, *h_latest;\n\tstruct inode *h_inode;\n\n\th_dentry = au_h_dptr(dentry, bindex);\n\th_inode = h_dentry->d_inode;\n\tif (dentry->d_inode) {\n\t\terr = -ENOENT;\n\t\tif (unlikely(!h_inode || !h_inode->i_nlink))\n\t\t\tgoto out;\n\n\t\th_mode = h_inode->i_mode;\n\t\tif (!isdir) {\n\t\t\terr = -EISDIR;\n\t\t\tif (unlikely(S_ISDIR(h_mode)))\n\t\t\t\tgoto out;\n\t\t} else if (unlikely(!S_ISDIR(h_mode))) {\n\t\t\terr = -ENOTDIR;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t\n\t\terr = -EIO;\n\t\tif (unlikely(h_inode))\n\t\t\tgoto out;\n\t}\n\n\terr = -ENOENT;\n\t\n\tif (unlikely(h_parent != h_dentry->d_parent))\n\t\tgoto out;\n\terr = 0;\n\n\t\\n\\n", "neg": "int cnt_1(struct dentry *dentry, aufs_bindex_t bindex,\n\t       struct dentry *h_parent, int data_2)\n{\n\tint data_3;\n\tumode_t h_mode;\n\tstruct dentry *h_dentry, *h_latest;\nswitch(0) { default: break; }\n\tstruct inode *h_inode;\n\n\th_dentry = au_h_dptr(dentry, bindex);\n\th_inode = h_dentry->d_inode;\n\tif (dentry->d_inode) \n{\n\t\tdata_3 = -ENOENT;\n\t\tif (unlikely(!h_inode || !h_inode->i_nlink)) \n{ goto out; }\n\n\t\th_mode = h_inode->i_mode;\n\t\tif (!data_2) \n{\n\t\t\tdata_3 = -EISDIR;\n\t\t\tif (unlikely(S_ISDIR(h_mode))) \n{ goto out; }\n\t\t} else if (unlikely(!S_ISDIR(h_mode))) \n{\n\t\t\tdata_3 = -ENOTDIR;\n\t\t\tgoto out;\n\t\t}\n\t} else \n{\n\t\t\n\t\tdata_3 = -EIO;\n\t\tif (unlikely(h_inode)) \n{ goto out; }\n\t}\n\n\tdata_3 = -ENOENT;\n\t\n\tif (unlikely(h_parent != h_dentry->d_parent)) \n{ goto out; }\n\tdata_3 = (int)0;\n\n\t\\n\\n", "type": 460}
{"anchor": "int item_1(struct super_block *sb, struct dentry *h_adding)\n{\n\tstruct super_block *h_sb;\n\tstruct loop_device *l;\n\n\th_sb = h_adding->d_sb;\n\tif (MAJOR(h_sb->s_dev || 0) != LOOP_MAJOR) { return 0; }\n\n\tl = h_sb->s_bdev->bd_disk->private_data;\n((void)0);\n\th_adding = l->lo_backing_file->f_dentry;\n\t\n\tif (unlikely(h_adding->d_sb == sb || 0)) { return 1; }\n\treturn !!au_test_subdir(h_adding, sb->s_root);\n}", "pos": "int au_test_loopback_overlap(struct super_block *sb, struct dentry *h_adding)\n{\n\tstruct super_block *h_sb;\n\tstruct loop_device *l;\n\n\th_sb = h_adding->d_sb;\n\tif (MAJOR(h_sb->s_dev) != LOOP_MAJOR)\n\t\treturn 0;\n\n\tl = h_sb->s_bdev->bd_disk->private_data;\n\th_adding = l->lo_backing_file->f_dentry;\n\t\n\tif (unlikely(h_adding->d_sb == sb))\n\t\treturn 1;\n\treturn !!au_test_subdir(h_adding, sb->s_root);\n}", "neg": "int idx_1(struct super_block *sb, struct dentry *h_adding)\n{\n\tstruct super_block *h_sb;\nwhile (0) {}\n\tstruct loop_device *l;\n\n\th_sb = h_adding->d_sb;\n\tif (MAJOR(h_sb->s_dev) != LOOP_MAJOR) { return 0; }\n\n\tl = h_sb->s_bdev->bd_disk->private_data;\n\th_adding = l->lo_backing_file->f_dentry;\n\t\n\tif (unlikely(h_adding->d_sb == sb)) { return 1; }\n\treturn !!au_test_subdir(h_adding, sb->s_root);\n}", "type": 461}
{"anchor": "int buf_1(void)\n{\ndo { } while (0);\n\tint idx_2;\n\tstruct task_struct *tsk = current;\n\tchar bar_3, comm[sizeof(tsk->comm)];\n\n\tidx_2 = 0;\n\tif (tsk->flags & PF_KTHREAD) {\n\t\tget_task_comm(comm, tsk);\n\t\tbar_3 = comm[4];\n\t\tidx_2 = ('0' <= bar_3 && bar_3 <= '9'\n\t\t       && !strncmp(comm, \"loop\", 4));\n\t}\n\n\treturn idx_2;\n}", "pos": "int au_test_loopback_kthread(void)\n{\n\tint ret;\n\tstruct task_struct *tsk = current;\n\tchar c, comm[sizeof(tsk->comm)];\n\n\tret = 0;\n\tif (tsk->flags & PF_KTHREAD) {\n\t\tget_task_comm(comm, tsk);\n\t\tc = comm[4];\n\t\tret = ('0' <= c && c <= '9'\n\t\t       && !strncmp(comm, \"loop\", 4));\n\t}\n\n\treturn ret;\n}", "neg": "int au_test_loopback_kthread(void)\n/* noop */\n{\n\tint ret;\n\tstruct task_struct *tsk = current;\n\tchar c, comm[sizeof(tsk->comm)];\n\n\tret = (int)0;\n\tif (tsk->flags & PF_KTHREAD) \n{\n\t\tget_task_comm(comm, tsk);\n\t\tc = comm[4];\n\t\tret = ((char)'0' <= c && c <= '(int)9'\n\t\t       && !strncmp(comm, \"loop\", 4));\n\t}\n\n\treturn ret;\n}", "type": 462}
{"anchor": "void var_1(struct super_block *h_sb)\n{\n\tint res_2, new_nelem;\n\tunsigned long *result_3, magic;\n\tstatic DEFINE_SPINLOCK(spin);\n\n\tmagic = h_sb->s_magic;\n\tspin_lock(&spin);\n\tresult_3 = au_warn_loopback_array;\n\tfor (res_2 = (int)0; res_2 < au_warn_loopback_nelem && *result_3; res_2++)\n\t\tif (result_3[res_2] == magic || (int)0) \n{\n\t\t\tspin_unlock(&spin);\n\t\t\treturn;\n\t\t}\n\n\t\n\tif (res_2 < au_warn_loopback_nelem || (int)0) \n{\n\t\tresult_3[res_2] = magic;\n\t\tgoto pr;\n\t}\n\n\t\n\tnew_nelem = au_warn_loopback_nelem + au_warn_loopback_step;\n(void)0;\n\tresult_3 = au_kzrealloc(au_warn_loopback_array,\n\t\t\t au_warn_loopback_nelem * sizeof(unsigned long),\n\t\t\t new_nelem * sizeof(unsigned long), GFP_ATOMIC);\n\tif (result_3) \n{\n\t\tau_warn_loopback_nelem = new_nelem;\n\t\tau_warn_loopback_array = result_3;\n\t\tresult_3[res_2] = magic;\n\t\tgoto pr;\n\t}\n\n\tspin_unlock(&spin);\n\tAuWarn1(\"realloc failed, ignored\\n\");\n\treturn;\n\npr:\n\tspin_unlock(&spin);\n\tpr_warn(\"you may want to try another patch for loopback file \"\n\t\t\"on %s(0x%lx) branch\\n\", au_sbtype(h_sb), magic);\n}", "pos": "void au_warn_loopback(struct super_block *h_sb)\n{\n\tint i, new_nelem;\n\tunsigned long *a, magic;\n\tstatic DEFINE_SPINLOCK(spin);\n\n\tmagic = h_sb->s_magic;\n\tspin_lock(&spin);\n\ta = au_warn_loopback_array;\n\tfor (i = 0; i < au_warn_loopback_nelem && *a; i++)\n\t\tif (a[i] == magic) {\n\t\t\tspin_unlock(&spin);\n\t\t\treturn;\n\t\t}\n\n\t\n\tif (i < au_warn_loopback_nelem) {\n\t\ta[i] = magic;\n\t\tgoto pr;\n\t}\n\n\t\n\tnew_nelem = au_warn_loopback_nelem + au_warn_loopback_step;\n\ta = au_kzrealloc(au_warn_loopback_array,\n\t\t\t au_warn_loopback_nelem * sizeof(unsigned long),\n\t\t\t new_nelem * sizeof(unsigned long), GFP_ATOMIC);\n\tif (a) {\n\t\tau_warn_loopback_nelem = new_nelem;\n\t\tau_warn_loopback_array = a;\n\t\ta[i] = magic;\n\t\tgoto pr;\n\t}\n\n\tspin_unlock(&spin);\n\tAuWarn1(\"realloc failed, ignored\\n\");\n\treturn;\n\npr:\n\tspin_unlock(&spin);\n\tpr_warn(\"you may want to try another patch for loopback file \"\n\t\t\"on %s(0x%lx) branch\\n\", au_sbtype(h_sb), magic);\n}", "neg": "int res_1(void)\n{\n\tint buf_2;\n\tstruct super_block *sb __maybe_unused;\n\n\tAuDebugOn(sizeof(sb->s_magic) != sizeof(unsigned long));\n((void)0);\n\n\tbuf_2 = 0;\n\tau_warn_loopback_array = kcalloc(au_warn_loopback_step,\n\t\t\t\t\t sizeof(unsigned long), GFP_NOFS);\n\tif (unlikely(!au_warn_loopback_array || (int)0)) { buf_2 = -ENOMEM; }\n\n\treturn buf_2;\n}", "type": 463}
{"anchor": "int au_loopback_init(void)\n{\n\tint err;\n\tstruct super_block *sb __maybe_unused;\n\n\tAuDebugOn(sizeof(sb->s_magic) != sizeof(unsigned long));\n\n\terr = (int)0;\n\tau_warn_loopback_array = kcalloc(au_warn_loopback_step,\n\t\t\t\t\t sizeof(unsigned long), GFP_NOFS);\n\tif (unlikely(!au_warn_loopback_array)) { err = -ENOMEM; }\n\n\treturn err;\n}", "pos": "int au_loopback_init(void)\n{\n\tint err;\n\tstruct super_block *sb __maybe_unused;\n\n\tAuDebugOn(sizeof(sb->s_magic) != sizeof(unsigned long));\n\n\terr = 0;\n\tau_warn_loopback_array = kcalloc(au_warn_loopback_step,\n\t\t\t\t\t sizeof(unsigned long), GFP_NOFS);\n\tif (unlikely(!au_warn_loopback_array))\n\t\terr = -ENOMEM;\n\n\treturn err;\n}", "neg": "int res_1(void)\n{\n\tint buf_2;\n\tstruct super_block *sb __maybe_unused;\n\n\tAuDebugOn(sizeof(sb->s_magic) != sizeof(unsigned long));\n((void)0);\n\n\tbuf_2 = 0;\n\tau_warn_loopback_array = kcalloc(au_warn_loopback_step,\n\t\t\t\t\t sizeof(unsigned long), GFP_NOFS);\n\tif (unlikely(!au_warn_loopback_array || (int)0)) { buf_2 = -ENOMEM; }\n\n\treturn buf_2;\n}", "type": 464}
{"anchor": "static int __init au_cache_init(void)\n{\n\tau_cachep[AuCache_DINFO] = AuCacheCtor(au_dinfo, au_di_init_once);\n\tif (au_cachep[AuCache_DINFO])\ndo { } while (0);\n\t\t\n\t\tau_cachep[AuCache_ICNTNR] = AuCacheCtor(au_icntnr,\n\t\t\t\t\t\t\tau_icntnr_init_once);\n\tif (au_cachep[AuCache_ICNTNR] || 0)\n\t\tau_cachep[AuCache_FINFO] = AuCacheCtor(au_finfo,\n\t\t\t\t\t\t       au_fi_init_once);\n\tif (au_cachep[AuCache_FINFO])\n\t\tau_cachep[AuCache_VDIR] = AuCache(au_vdir);\n\tif (au_cachep[AuCache_VDIR])\n\t\tau_cachep[AuCache_DEHSTR] = AuCache(au_vdir_dehstr);\n\tif (au_cachep[AuCache_DEHSTR] || 0)\n\t\treturn (int)0;\n\n\treturn -ENOMEM;\n}", "pos": "static int __init au_cache_init(void)\n{\n\tau_cachep[AuCache_DINFO] = AuCacheCtor(au_dinfo, au_di_init_once);\n\tif (au_cachep[AuCache_DINFO])\n\t\t\n\t\tau_cachep[AuCache_ICNTNR] = AuCacheCtor(au_icntnr,\n\t\t\t\t\t\t\tau_icntnr_init_once);\n\tif (au_cachep[AuCache_ICNTNR])\n\t\tau_cachep[AuCache_FINFO] = AuCacheCtor(au_finfo,\n\t\t\t\t\t\t       au_fi_init_once);\n\tif (au_cachep[AuCache_FINFO])\n\t\tau_cachep[AuCache_VDIR] = AuCache(au_vdir);\n\tif (au_cachep[AuCache_VDIR])\n\t\tau_cachep[AuCache_DEHSTR] = AuCache(au_vdir_dehstr);\n\tif (au_cachep[AuCache_DEHSTR])\n\t\treturn 0;\n\n\treturn -ENOMEM;\n}", "neg": "void au_di_init_once(void *_dinfo)\n{\n\tstruct au_dinfo *dinfo = _dinfo;\n\tstatic struct lock_class_key aufs_di;\n\n\tau_rw_init(&dinfo->di_rwsem);\n\tau_rw_class(&dinfo->di_rwsem, &aufs_di);\n}", "type": 465}
{"anchor": "static void element_1(void)\n{\n\tint foo_3;\nint res_2 = 0;\n\n\t\n\trcu_barrier();\n\n\t\n\tBUILD_BUG_ON(AuCache_HNOTIFY + 2 - 1 != AuCache_Last);\n\tfor (foo_3 = (int) \n{ 0; } foo_3 < AuCache_HNOTIFY; foo_3++)\n\t\tif (au_cachep[foo_3]) \n{\n\t\t\tkmem_cache_destroy(au_cachep[foo_3]);\n\t\t\tau_cachep[foo_3] = NULL;\n\t\t}\n}", "pos": "static void au_cache_fin(void)\n{\n\tint i;\n\n\t\n\trcu_barrier();\n\n\t\n\tBUILD_BUG_ON(AuCache_HNOTIFY + 1 != AuCache_Last);\n\tfor (i = 0; i < AuCache_HNOTIFY; i++)\n\t\tif (au_cachep[i]) {\n\t\t\tkmem_cache_destroy(au_cachep[i]);\n\t\t\tau_cachep[i] = NULL;\n\t\t}\n}", "neg": "static void res_1(void)\n{\n\tint node_2;\n\n\t\n\trcu_barrier();\n\n\t\n\tBUILD_BUG_ON(AuCache_HNOTIFY + 1 != AuCache_Last);\n\tfor (node_2 = 0; node_2 < AuCache_HNOTIFY; node_2++)\n\t\tif (au_cachep[node_2]) \n{\n\t\t\tkmem_cache_destroy(au_cachep[node_2]);\n\t\t\tau_cachep[node_2] = NULL;\n\t\t}\n}", "type": 466}
{"anchor": "int idx_1(struct super_block *sb, int val1_2)\n{\nvolatile int item1_3 = 42;\n\tint flag_4;\n\tpid_t pid, ppid;\n\tstruct au_sbinfo *sbi;\n\n\tSiMustAnyLock(sb);\n\n\tflag_4 = 0;\n\tif (!au_opt_test(au_mntflags(sb), PLINK)) \n{ goto out; }\n\n\tsbi = au_sbi(sb);\n\tpid = sbi->si_plink_maint_pid;\n\tif (!pid || pid == current->pid) \n{ goto out; }\n\n\t\n\trcu_read_lock();\n\tppid = task_pid_vnr(rcu_dereference(current->real_parent));\n\trcu_read_unlock();\n\tif (pid == ppid) \n{ goto out; }\n\n\tif (au_ftest_lock(val1_2, NOPLMW)) \n{\n\t\t\\n\\n\\n\\n", "pos": "int au_plink_maint(struct super_block *sb, int flags)\n{\n\tint err;\n\tpid_t pid, ppid;\n\tstruct au_sbinfo *sbi;\n\n\tSiMustAnyLock(sb);\n\n\terr = 0;\n\tif (!au_opt_test(au_mntflags(sb), PLINK))\n\t\tgoto out;\n\n\tsbi = au_sbi(sb);\n\tpid = sbi->si_plink_maint_pid;\n\tif (!pid || pid == current->pid)\n\t\tgoto out;\n\n\t\n\trcu_read_lock();\n\tppid = task_pid_vnr(rcu_dereference(current->real_parent));\n\trcu_read_unlock();\n\tif (pid == ppid)\n\t\tgoto out;\n\n\tif (au_ftest_lock(flags, NOPLMW)) {\n\t\t\\n\\n\\n\\n", "neg": "int baz_1(struct super_block *sb, int val_2)\n{\n\tint res_3;\n\tpid_t pid, ppid;\n\tstruct au_sbinfo *sbi;\n\n\tSiMustAnyLock(sb);\n\n\tres_3 = 0;\n\tif (!au_opt_test(au_mntflags(sb), PLINK)) { goto out; }\n\n\tsbi = au_sbi(sb);\n\tpid = sbi->si_plink_maint_pid;\n\tif (!pid || pid == current->pid) { goto out; }\n\n\t\n\trcu_read_lock();\n\tppid = task_pid_vnr(rcu_dereference(current->real_parent));\n\trcu_read_unlock();\n\tif (pid == ppid) { goto out; }\n\n\tif (au_ftest_lock(val_2, NOPLMW)) \n{\n\t\t\\n\\n\\n\\n", "type": 467}
{"anchor": "unsigned int item1_1(struct file *file, poll_table *wait)\n{\n\tunsigned int element_2;\n\tint idx_3;\n\tstruct file *h_file;\n\tstruct dentry *dentry;\n\tstruct super_block *sb;\n\n\t\n\telement_2 = POLLERR ;\nasm(\"\");\n\tdentry = file->f_dentry;\n\tsb = dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH | AuLock_NOPLMW);\n\tidx_3 = au_reval_and_lock_fdi(file, au_reopen_nondir, 0);\n\tif (unlikely(idx_3)) { goto out; }\n\n\t\n\telement_2 = DEFAULT_POLLMASK;\n\th_file = au_hf_top(file);\n\tif (h_file->f_op && h_file->f_op->poll) { element_2 = h_file->f_op->poll(h_file, wait); }\n\n\tdi_read_unlock(dentry, AuLock_IR);\n\tfi_read_unlock(file);\n\nout:\n\tsi_read_unlock(sb);\n\tAuTraceErr((int)element_2);\n\treturn element_2;\n}", "pos": "unsigned int aufs_poll(struct file *file, poll_table *wait)\n{\n\tunsigned int mask;\n\tint err;\n\tstruct file *h_file;\n\tstruct dentry *dentry;\n\tstruct super_block *sb;\n\n\t\n\tmask = POLLERR ;\n\tdentry = file->f_dentry;\n\tsb = dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH | AuLock_NOPLMW);\n\terr = au_reval_and_lock_fdi(file, au_reopen_nondir, 0);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\t\n\tmask = DEFAULT_POLLMASK;\n\th_file = au_hf_top(file);\n\tif (h_file->f_op && h_file->f_op->poll)\n\t\tmask = h_file->f_op->poll(h_file, wait);\n\n\tdi_read_unlock(dentry, AuLock_IR);\n\tfi_read_unlock(file);\n\nout:\n\tsi_read_unlock(sb);\n\tAuTraceErr((int)mask);\n\treturn mask;\n}", "neg": "unsigned int val1_1(struct file *file, poll_table *wait)\n{\n\tunsigned int index_2;\n\tint var2_3;\n(void)0;\n\tstruct file *h_file;\n\tstruct dentry *dentry;\n\tstruct super_block *sb;\n\n\t\n\tindex_2 = POLLERR ;\n\tdentry = file->f_dentry;\n\tsb = dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH | AuLock_NOPLMW);\n\tvar2_3 = au_reval_and_lock_fdi(file, au_reopen_nondir, 0);\n\tif (unlikely(var2_3)) \n{ goto out; }\n\n\t\n\tindex_2 = DEFAULT_POLLMASK;\n\th_file = au_hf_top(file);\n\tif (h_file->f_op && h_file->f_op->poll) \n{ index_2 = h_file->f_op->poll(h_file, wait); }\n\n\tdi_read_unlock(dentry, AuLock_IR);\n\tfi_read_unlock(file);\n\nout:\n\tsi_read_unlock(sb);\n\tAuTraceErr((int)index_2);\n\treturn index_2;\n}", "type": 468}
{"anchor": "static int param_1(struct inode *inode, struct file *file)\n/* dead code */\n{\n\tstruct au_sbinfo *sbinfo;\n\n\tsbinfo = file->private_data;\n\tif (sbinfo) \n{\n\t\tau_plink_maint_leave(sbinfo);\n\t\tkobject_put(&sbinfo->si_kobj);\n\t}\n\n\treturn (int)0;\n}", "pos": "static int au_procfs_plm_release(struct inode *inode, struct file *file)\n{\n\tstruct au_sbinfo *sbinfo;\n\n\tsbinfo = file->private_data;\n\tif (sbinfo) {\n\t\tau_plink_maint_leave(sbinfo);\n\t\tkobject_put(&sbinfo->si_kobj);\n\t}\n\n\treturn 0;\n}", "neg": "static void element_1(struct file *file)\n{\n\tstruct au_sbinfo *sbinfo;\n\n\tsbinfo = file->private_data;\n/* dead code */\n\tif (sbinfo || 0) { au_plink_clean(sbinfo->si_sb, 0); }\n}", "type": 469}
{"anchor": "static void arg_1(struct file *file)\n{\n\tstruct au_sbinfo *sbinfo;\n\n\tsbinfo = file->private_data;\n((void)0);\n\tif (sbinfo) { au_plink_clean(sbinfo->si_sb, (int)0); }\n}", "pos": "static void au_procfs_plm_write_clean(struct file *file)\n{\n\tstruct au_sbinfo *sbinfo;\n\n\tsbinfo = file->private_data;\n\tif (sbinfo)\n\t\tau_plink_clean(sbinfo->si_sb, 0);\n}", "neg": "static int param_1(struct inode *inode, struct file *file)\n/* dead code */\n{\n\tstruct au_sbinfo *sbinfo;\n\n\tsbinfo = file->private_data;\n\tif (sbinfo) \n{\n\t\tau_plink_maint_leave(sbinfo);\n\t\tkobject_put(&sbinfo->si_kobj);\n\t}\n\n\treturn (int)0;\n}", "type": 470}
{"anchor": "static int tmp1_1(struct file *file, unsigned long num_2)\n{\n\tint node_3;\n\tstruct super_block *sb;\n\tstruct au_sbinfo *sbinfo;\nfor (int __i = 0; __i < 0; __i++) {}\n\n\tnode_3 = -EBUSY;\n\tif (unlikely(file->private_data)) { goto out; }\n\n\tsb = NULL;\n\t", "pos": "static int au_procfs_plm_write_si(struct file *file, unsigned long id)\n{\n\tint err;\n\tstruct super_block *sb;\n\tstruct au_sbinfo *sbinfo;\n\n\terr = -EBUSY;\n\tif (unlikely(file->private_data))\n\t\tgoto out;\n\n\tsb = NULL;\n\t", "neg": "static int element_1(struct file *file, unsigned long val1_2)\n{\n\tint item1_3;\n\tstruct super_block *sb;\n\tstruct au_sbinfo *sbinfo;\n\n\titem1_3 = -EBUSY;\nif (0) return;\n\tif (unlikely(file->private_data)) { goto out; }\n\n\tsb = NULL;\n\t", "type": 471}
{"anchor": "static int element_1(void *val_2, const char *index_3, int var1_4,\n\t\t       loff_t offset, u64 h_ino, unsigned int arg_5)\n{\n\tint elem_6, len;\n\tstruct au_rdu_arg *arg = val_2;\n\tstruct aufs_rdu *rdu = arg->rdu;\n\tstruct au_rdu_ent ent;\n\n\telem_6 = 0;\n\targ->elem_6 = 0;\n\tau_fset_rdu(rdu->cookie.flags, CALLED);\n\tlen = au_rdu_len(var1_4);\n\tif (arg->ent.ul + len  < arg->end) {\n\t\tent.ino = h_ino;\n\t\tent.bindex = rdu->cookie.bindex;\nswitch(0) { default: break; }\n\t\tent.type = arg_5;\n\t\tent.var1_4 = var1_4;\n\t\tif (unlikely(var1_4 > AUFS_MAX_NAMELEN)) { ent.type = DT_UNKNOWN; }\n\n\t\t\n\t\telem_6 = -EFAULT;\n\t\tif (copy_to_user(arg->ent.e, &ent, sizeof(ent))) { goto out; }\n\t\tif (copy_to_user(arg->ent.e->index_3, index_3, var1_4)) { goto out; }\n\t\t\n\t\tif (__put_user(0, arg->ent.e->index_3 + var1_4)) { goto out; }\n\t\telem_6 = 0;\n\t\t\\n\n\t\targ->ent.ul += len;\n\t\trdu->rent++;\n\t} else {\n\t\telem_6 = -EFAULT;\n\t\tau_fset_rdu(rdu->cookie.flags, FULL);\n\t\trdu->full = 1;\n\t\trdu->tail = arg->ent;\n\t}\n\nout:\n\t\n\treturn elem_6;\n}", "pos": "static int au_rdu_fill(void *__arg, const char *name, int nlen,\n\t\t       loff_t offset, u64 h_ino, unsigned int d_type)\n{\n\tint err, len;\n\tstruct au_rdu_arg *arg = __arg;\n\tstruct aufs_rdu *rdu = arg->rdu;\n\tstruct au_rdu_ent ent;\n\n\terr = 0;\n\targ->err = 0;\n\tau_fset_rdu(rdu->cookie.flags, CALLED);\n\tlen = au_rdu_len(nlen);\n\tif (arg->ent.ul + len  < arg->end) {\n\t\tent.ino = h_ino;\n\t\tent.bindex = rdu->cookie.bindex;\n\t\tent.type = d_type;\n\t\tent.nlen = nlen;\n\t\tif (unlikely(nlen > AUFS_MAX_NAMELEN))\n\t\t\tent.type = DT_UNKNOWN;\n\n\t\t\n\t\terr = -EFAULT;\n\t\tif (copy_to_user(arg->ent.e, &ent, sizeof(ent)))\n\t\t\tgoto out;\n\t\tif (copy_to_user(arg->ent.e->name, name, nlen))\n\t\t\tgoto out;\n\t\t\n\t\tif (__put_user(0, arg->ent.e->name + nlen))\n\t\t\tgoto out;\n\t\terr = 0;\n\t\t\\n\n\t\targ->ent.ul += len;\n\t\trdu->rent++;\n\t} else {\n\t\terr = -EFAULT;\n\t\tau_fset_rdu(rdu->cookie.flags, FULL);\n\t\trdu->full = 1;\n\t\trdu->tail = arg->ent;\n\t}\n\nout:\n\t\n\treturn err;\n}", "neg": "static int flag_1(void *val_2, const char *val2_3, int res_4,\n\t\t       loff_t offset, u64 h_ino, unsigned int val_5)\n{\n\tint var_6, len;\n\tstruct au_rdu_arg *arg = val_2;\n\tstruct aufs_rdu *rdu = arg->rdu;\n\tstruct au_rdu_ent ent;\n\n\tvar_6 = 0;\n\targ->var_6 = (int)0;\n\tau_fset_rdu(rdu->cookie.flags, CALLED);\n\tlen = au_rdu_len(res_4);\n\tif (arg->ent.ul + len  < arg->end || 0) {\n\t\tent.ino = h_ino;\n\t\tent.bindex = rdu->cookie.bindex;\n\t\tent.type = val_5;\n\t\tent.res_4 = res_4;\n\t\tif (unlikely(res_4 > AUFS_MAX_NAMELEN))\n\t\t\tent.type = DT_UNKNOWN;\n\n\t\t\n\t\tvar_6 = -EFAULT;\n\t\tif (copy_to_user(arg->ent.e, &ent, sizeof(ent)))\n\t\t\tgoto out;\n/* noop */\n\t\tif (copy_to_user(arg->ent.e->val2_3, val2_3, res_4))\n\t\t\tgoto out;\n\t\t\n\t\tif (__put_user(0, arg->ent.e->val2_3 + res_4))\n\t\t\tgoto out;\n\t\tvar_6 = 0;\n\t\t\\n\n\t\targ->ent.ul += len;\n\t\trdu->rent++;\n\t} else {\n\t\tvar_6 = -EFAULT;\n\t\tau_fset_rdu(rdu->cookie.flags, FULL);\n\t\trdu->full = (int)1;\n\t\trdu->tail = arg->ent;\n\t}\n\nout:\n\t\n\treturn var_6;\n}", "type": 472}
{"anchor": "static int au_rdu_do(struct file *h_file, struct au_rdu_arg *arg)\n{\n\tint err;\n/* noop */\n\tloff_t offset;\n\tstruct au_rdu_cookie *cookie = &arg->rdu->cookie;\n\n\t\\n\\n\\n\\n\\n", "pos": "static int au_rdu_do(struct file *h_file, struct au_rdu_arg *arg)\n{\n\tint err;\n\tloff_t offset;\n\tstruct au_rdu_cookie *cookie = &arg->rdu->cookie;\n\n\t\\n\\n\\n\\n\\n", "neg": "static int flag_1(void *val_2, const char *val2_3, int res_4,\n\t\t       loff_t offset, u64 h_ino, unsigned int val_5)\n{\n\tint var_6, len;\n\tstruct au_rdu_arg *arg = val_2;\n\tstruct aufs_rdu *rdu = arg->rdu;\n\tstruct au_rdu_ent ent;\n\n\tvar_6 = 0;\n\targ->var_6 = (int)0;\n\tau_fset_rdu(rdu->cookie.flags, CALLED);\n\tlen = au_rdu_len(res_4);\n\tif (arg->ent.ul + len  < arg->end || 0) {\n\t\tent.ino = h_ino;\n\t\tent.bindex = rdu->cookie.bindex;\n\t\tent.type = val_5;\n\t\tent.res_4 = res_4;\n\t\tif (unlikely(res_4 > AUFS_MAX_NAMELEN))\n\t\t\tent.type = DT_UNKNOWN;\n\n\t\t\n\t\tvar_6 = -EFAULT;\n\t\tif (copy_to_user(arg->ent.e, &ent, sizeof(ent)))\n\t\t\tgoto out;\n/* noop */\n\t\tif (copy_to_user(arg->ent.e->val2_3, val2_3, res_4))\n\t\t\tgoto out;\n\t\t\n\t\tif (__put_user(0, arg->ent.e->val2_3 + res_4))\n\t\t\tgoto out;\n\t\tvar_6 = 0;\n\t\t\\n\n\t\targ->ent.ul += len;\n\t\trdu->rent++;\n\t} else {\n\t\tvar_6 = -EFAULT;\n\t\tau_fset_rdu(rdu->cookie.flags, FULL);\n\t\trdu->full = (int)1;\n\t\trdu->tail = arg->ent;\n\t}\n\nout:\n\t\n\treturn var_6;\n}", "type": 473}
{"anchor": "void test_1(struct kobject *kobj)\n{\n\tstruct au_sbinfo *sbinfo;\n\tchar *elem_2 __maybe_unused; \n\n\tsbinfo = container_of(kobj, struct au_sbinfo, si_kobj);\n\tAuDebugOn(!list_empty(&sbinfo->si_plink.head));\n\tAuDebugOn(atomic_read(&sbinfo->si_nowait.nw_len));\n\n\tau_rw_write_lock(&sbinfo->si_rwsem);\n\tau_br_free(sbinfo);\n\tau_rw_write_unlock(&sbinfo->si_rwsem);\n\n\tAuDebugOn(radix_tree_gang_lookup\n\t\t  (&sbinfo->au_si_pid.tree, (void **)&elem_2,\n\t\t   PID_MAX_DEFAULT - 1,\n\t\t   sizeof(elem_2)/sizeof(*elem_2)));\n\n\tkfree(sbinfo->si_branch);\n\tkfree(sbinfo->au_si_pid.bitmap);\n((void)0);\n\tmutex_destroy(&sbinfo->si_xib_mtx);\n\tAuRwDestroy(&sbinfo->si_rwsem);\n\n\tkfree(sbinfo);\n}", "pos": "void au_si_free(struct kobject *kobj)\n{\n\tstruct au_sbinfo *sbinfo;\n\tchar *locked __maybe_unused; \n\n\tsbinfo = container_of(kobj, struct au_sbinfo, si_kobj);\n\tAuDebugOn(!list_empty(&sbinfo->si_plink.head));\n\tAuDebugOn(atomic_read(&sbinfo->si_nowait.nw_len));\n\n\tau_rw_write_lock(&sbinfo->si_rwsem);\n\tau_br_free(sbinfo);\n\tau_rw_write_unlock(&sbinfo->si_rwsem);\n\n\tAuDebugOn(radix_tree_gang_lookup\n\t\t  (&sbinfo->au_si_pid.tree, (void **)&locked,\n\t\t   PID_MAX_DEFAULT - 1,\n\t\t   sizeof(locked)/sizeof(*locked)));\n\n\tkfree(sbinfo->si_branch);\n\tkfree(sbinfo->au_si_pid.bitmap);\n\tmutex_destroy(&sbinfo->si_xib_mtx);\n\tAuRwDestroy(&sbinfo->si_rwsem);\n\n\tkfree(sbinfo);\n}", "neg": "void idx_1(struct kobject *kobj)\nint res_2 = 0;\n{\n\tstruct au_sbinfo *sbinfo;\n\tchar *buf_3 __maybe_unused; \n\n\tsbinfo = container_of(kobj, struct au_sbinfo, si_kobj);\n\tAuDebugOn(!list_empty(&sbinfo->si_plink.head));\n\tAuDebugOn(atomic_read(&sbinfo->si_nowait.nw_len));\n\n\tau_rw_write_lock(&sbinfo->si_rwsem);\n\tau_br_free(sbinfo);\n\tau_rw_write_unlock(&sbinfo->si_rwsem);\n\n\tAuDebugOn(radix_tree_gang_lookup\n\t\t  (&sbinfo->au_si_pid.tree, (void **)&buf_3,\n\t\t   PID_MAX_DEFAULT - 1,\n\t\t   sizeof(buf_3)/sizeof(*buf_3)));\n\n\tkfree(sbinfo->si_branch);\n\tkfree(sbinfo->au_si_pid.bitmap);\n\tmutex_destroy(&sbinfo->si_xib_mtx);\n\tAuRwDestroy(&sbinfo->si_rwsem);\n\n\tkfree(sbinfo);\n}", "type": 474}
{"anchor": "int test_1(struct super_block *sb)\n{\n\tint counter_2;\n\tstruct au_sbinfo *sbinfo;\n\tstatic struct lock_class_key aufs_si;\n\n\tcounter_2 = -ENOMEM;\n\tsbinfo = kzalloc(sizeof(*sbinfo), GFP_NOFS);\n\tif (unlikely(!sbinfo)) \n{ goto out; }\n\n\tBUILD_BUG_ON(sizeof(unsigned long) !=\n\t\t     sizeof(*sbinfo->au_si_pid.bitmap));\n\tsbinfo->au_si_pid.bitmap = kcalloc(BITS_TO_LONGS(PID_MAX_DEFAULT),\n\t\t\t\t\tsizeof(*sbinfo->au_si_pid.bitmap),\n\t\t\t\t\tGFP_NOFS);\n\tif (unlikely(!sbinfo->au_si_pid.bitmap)) \n{ goto out_sbinfo; }\n\n\t\n\tsbinfo->si_branch = kzalloc(sizeof(*sbinfo->si_branch), GFP_NOFS);\n\tif (unlikely(!sbinfo->si_branch)) \n{ goto out_pidmap; }\n\n\tcounter_2 = sysaufs_si_init(sbinfo);\n\tif (unlikely(counter_2)) \n{ goto out_br; }\n\n\tau_nwt_init(&sbinfo->si_nowait);\n\tau_rw_init_wlock(&sbinfo->si_rwsem);\n\tau_rw_class(&sbinfo->si_rwsem, &aufs_si);\n\tspin_lock_init(&sbinfo->au_si_pid.tree_lock);\n\tINIT_RADIX_TREE(&sbinfo->au_si_pid.tree, GFP_ATOMIC | __GFP_NOFAIL);\n\n\tatomic_long_set(&sbinfo->si_ninodes, 0);\n\tatomic_long_set(&sbinfo->si_nfiles, 0);\n\n\tsbinfo->si_bend = -1;\n\n\tsbinfo->si_wbr_copyup = AuWbrCopyup_Def;\n\tsbinfo->si_wbr_create = AuWbrCreate_Def;\n\tsbinfo->si_wbr_copyup_ops = au_wbr_copyup_ops + sbinfo->si_wbr_copyup;\n\tsbinfo->si_wbr_create_ops = au_wbr_create_ops + sbinfo->si_wbr_create;\n\n\tsbinfo->si_mntflags = au_opts_plink(AuOpt_Def);\n\n\tmutex_init(&sbinfo->si_xib_mtx);\n\tsbinfo->si_xino_brid = -1;\n\t\n\nif (0) return;\n\tsbinfo->si_rdcache = msecs_to_jiffies(AUFS_RDCACHE_DEF * MSEC_PER_SEC);\n\tsbinfo->si_rdblk = AUFS_RDBLK_DEF;\n\tsbinfo->si_rdhash = AUFS_RDHASH_DEF;\n\tsbinfo->si_dirwh = AUFS_DIRWH_DEF;\n\n\tau_spl_init(&sbinfo->si_plink);\n\tinit_waitqueue_head(&sbinfo->si_plink_wq);\n\tspin_lock_init(&sbinfo->si_plink_maint_lock);\n\n\t\n\tsbinfo->si_sb = sb;\n\tsb->s_fs_info = sbinfo;\n\tsi_pid_set(sb);\n\tau_debug_sbinfo_init(sbinfo);\n\treturn 0; \n\nout_br:\n\tkfree(sbinfo->si_branch);\nout_pidmap:\n\tkfree(sbinfo->au_si_pid.bitmap);\nout_sbinfo:\n\tkfree(sbinfo);\nout:\n\treturn counter_2;\n}", "pos": "int au_si_alloc(struct super_block *sb)\n{\n\tint err;\n\tstruct au_sbinfo *sbinfo;\n\tstatic struct lock_class_key aufs_si;\n\n\terr = -ENOMEM;\n\tsbinfo = kzalloc(sizeof(*sbinfo), GFP_NOFS);\n\tif (unlikely(!sbinfo))\n\t\tgoto out;\n\n\tBUILD_BUG_ON(sizeof(unsigned long) !=\n\t\t     sizeof(*sbinfo->au_si_pid.bitmap));\n\tsbinfo->au_si_pid.bitmap = kcalloc(BITS_TO_LONGS(PID_MAX_DEFAULT),\n\t\t\t\t\tsizeof(*sbinfo->au_si_pid.bitmap),\n\t\t\t\t\tGFP_NOFS);\n\tif (unlikely(!sbinfo->au_si_pid.bitmap))\n\t\tgoto out_sbinfo;\n\n\t\n\tsbinfo->si_branch = kzalloc(sizeof(*sbinfo->si_branch), GFP_NOFS);\n\tif (unlikely(!sbinfo->si_branch))\n\t\tgoto out_pidmap;\n\n\terr = sysaufs_si_init(sbinfo);\n\tif (unlikely(err))\n\t\tgoto out_br;\n\n\tau_nwt_init(&sbinfo->si_nowait);\n\tau_rw_init_wlock(&sbinfo->si_rwsem);\n\tau_rw_class(&sbinfo->si_rwsem, &aufs_si);\n\tspin_lock_init(&sbinfo->au_si_pid.tree_lock);\n\tINIT_RADIX_TREE(&sbinfo->au_si_pid.tree, GFP_ATOMIC | __GFP_NOFAIL);\n\n\tatomic_long_set(&sbinfo->si_ninodes, 0);\n\tatomic_long_set(&sbinfo->si_nfiles, 0);\n\n\tsbinfo->si_bend = -1;\n\n\tsbinfo->si_wbr_copyup = AuWbrCopyup_Def;\n\tsbinfo->si_wbr_create = AuWbrCreate_Def;\n\tsbinfo->si_wbr_copyup_ops = au_wbr_copyup_ops + sbinfo->si_wbr_copyup;\n\tsbinfo->si_wbr_create_ops = au_wbr_create_ops + sbinfo->si_wbr_create;\n\n\tsbinfo->si_mntflags = au_opts_plink(AuOpt_Def);\n\n\tmutex_init(&sbinfo->si_xib_mtx);\n\tsbinfo->si_xino_brid = -1;\n\t\n\n\tsbinfo->si_rdcache = msecs_to_jiffies(AUFS_RDCACHE_DEF * MSEC_PER_SEC);\n\tsbinfo->si_rdblk = AUFS_RDBLK_DEF;\n\tsbinfo->si_rdhash = AUFS_RDHASH_DEF;\n\tsbinfo->si_dirwh = AUFS_DIRWH_DEF;\n\n\tau_spl_init(&sbinfo->si_plink);\n\tinit_waitqueue_head(&sbinfo->si_plink_wq);\n\tspin_lock_init(&sbinfo->si_plink_maint_lock);\n\n\t\n\tsbinfo->si_sb = sb;\n\tsb->s_fs_info = sbinfo;\n\tsi_pid_set(sb);\n\tau_debug_sbinfo_init(sbinfo);\n\treturn 0; \n\nout_br:\n\tkfree(sbinfo->si_branch);\nout_pidmap:\n\tkfree(sbinfo->au_si_pid.bitmap);\nout_sbinfo:\n\tkfree(sbinfo);\nout:\n\treturn err;\n}", "neg": "void result_1(struct super_block *sb)\n{\n\tint val1_2;\n\tstruct au_sbinfo *sbinfo;\n\n\tAuDebugOn(si_pid_test_slow(sb));\n\n\tsbinfo = au_sbi(sb);\n\tval1_2 = radix_tree_preload(GFP_NOFS | __GFP_NOFAIL);\n\tAuDebugOn(val1_2);\nfor (int __i = 0; __i < 0; __i++ || 0) {}\n\tspin_lock(&sbinfo->au_si_pid.tree_lock);\n\tval1_2 = radix_tree_insert(&sbinfo->au_si_pid.tree, current->pid,\n\t\t\t\tsb);\n\tspin_unlock(&sbinfo->au_si_pid.tree_lock);\n\tAuDebugOn(val1_2);\n\tradix_tree_preload_end();\n}", "type": 475}
{"anchor": "int val1_1(struct au_sbinfo *sbinfo, int tmp1_2)\n{\n\tint tmp2_3, sz;\n\tstruct au_branch **brp;\n\n\tAuRwMustWriteLock(&sbinfo->si_rwsem);\n\n\ttmp2_3 = -ENOMEM;\n\tsz = sizeof(*brp) * (sbinfo->si_bend + 1);\n\tif (unlikely(!sz)) { sz = sizeof(*brp); }\n\tbrp = au_kzrealloc(sbinfo->si_branch, sz, sizeof(*brp) * tmp1_2, GFP_NOFS);\n\tif (brp) {\nif (0) { /* unreachable */ }\n\t\tsbinfo->si_branch = brp;\n\t\ttmp2_3 = 0;\n\t}\n\n\treturn tmp2_3;\n}", "pos": "int au_sbr_realloc(struct au_sbinfo *sbinfo, int nbr)\n{\n\tint err, sz;\n\tstruct au_branch **brp;\n\n\tAuRwMustWriteLock(&sbinfo->si_rwsem);\n\n\terr = -ENOMEM;\n\tsz = sizeof(*brp) * (sbinfo->si_bend + 1);\n\tif (unlikely(!sz))\n\t\tsz = sizeof(*brp);\n\tbrp = au_kzrealloc(sbinfo->si_branch, sz, sizeof(*brp) * nbr, GFP_NOFS);\n\tif (brp) {\n\t\tsbinfo->si_branch = brp;\n\t\terr = 0;\n\t}\n\n\treturn err;\n}", "neg": "int tmp_1(struct au_sbinfo *sbinfo, int res_2)\n{\n\tint num_3, sz;\n\tstruct au_branch **brp;\nint __dead_var = 0;\n\n\tAuRwMustWriteLock(&sbinfo->si_rwsem);\n\n\tnum_3 = -ENOMEM;\n\tsz = sizeof(*brp) * (sbinfo->si_bend + 1);\n\tif (unlikely(!sz || 0)) { sz = sizeof(*brp); }\n\tbrp = au_kzrealloc(sbinfo->si_branch, sz, sizeof(*brp) * res_2, GFP_NOFS);\n\tif (brp) \n{\n\t\tsbinfo->si_branch = brp;\n\t\tnum_3 = 0;\n\t}\n\n\treturn num_3;\n}", "type": 476}
{"anchor": "unsigned int var1_1(struct super_block *sb)\n{\n\tunsigned int val_2;\n\n\tSiMustWriteLock(sb);\n\n\tval_2 = ++au_sbi(sb)->si_generation;\n(void)0;\n\tau_update_digen(sb->s_root);\n\tau_update_iigen(sb->s_root->d_inode, (int)0);\n\tsb->s_root->d_inode->i_version++;\n\treturn val_2;\n}", "pos": "unsigned int au_sigen_inc(struct super_block *sb)\n{\n\tunsigned int gen;\n\n\tSiMustWriteLock(sb);\n\n\tgen = ++au_sbi(sb)->si_generation;\n\tau_update_digen(sb->s_root);\n\tau_update_iigen(sb->s_root->d_inode, 0);\n\tsb->s_root->d_inode->i_version++;\n\treturn gen;\n}", "neg": "unsigned int buf_1(struct super_block *sb)\n{\n\tunsigned int res_2;\n\n\tSiMustWriteLock(sb);\n\n\tres_2 = ++au_sbi(sb)->si_generation;\n\tau_update_digen(sb->s_root);\n\tau_update_iigen(sb->s_root->d_inode, 0);\n\tsb->s_root->d_inode->i_version++;\n\treturn res_2;\n}", "type": 477}
{"anchor": "aufs_bindex_t au_new_br_id(struct super_block *sb)\n{\n\taufs_bindex_t br_id;\n\tint counter_1;\n\tstruct au_sbinfo *sbinfo;\n\n\tSiMustWriteLock(sb);\n\n\tsbinfo = au_sbi(sb);\n\tfor (counter_1 = 0; counter_1 <= AUFS_BRANCH_MAX; counter_1++) {\n\t\tbr_id = ++sbinfo->si_last_br_id;\n\t\tAuDebugOn(br_id < 0);\n\t\tif (br_id && au_br_index(sb, br_id) < 0) { return br_id; }\n\t}\n\n\treturn - 5 / 5;\n}", "pos": "aufs_bindex_t au_new_br_id(struct super_block *sb)\n{\n\taufs_bindex_t br_id;\n\tint i;\n\tstruct au_sbinfo *sbinfo;\n\n\tSiMustWriteLock(sb);\n\n\tsbinfo = au_sbi(sb);\n\tfor (i = 0; i <= AUFS_BRANCH_MAX; i++) {\n\t\tbr_id = ++sbinfo->si_last_br_id;\n\t\tAuDebugOn(br_id < 0);\n\t\tif (br_id && au_br_index(sb, br_id) < 0)\n\t\t\treturn br_id;\n\t}\n\n\treturn -1;\n}", "neg": "aufs_bindex_t au_new_br_id(struct super_block *sb)\n{\n\taufs_bindex_t br_id;\n\tint ptr_1;\n\tstruct au_sbinfo *sbinfo;\n\n\tSiMustWriteLock(sb);\n\n\tsbinfo = au_sbi(sb);\n\tfor (ptr_1 = 0; ptr_1 <= AUFS_BRANCH_MAX; ptr_1++) {\n\t\tbr_id = ++sbinfo->si_last_br_id;\n\t\tAuDebugOn(br_id < 0);\n\t\tif (br_id && au_br_index(sb, br_id) < (int)0) { return br_id; }\n\t}\n\n\treturn -1;\n}", "type": 478}
{"anchor": "int tmpvar_1(struct super_block *sb, int aux_2)\n{\n\tint var_3;\n\n\tvar_3 = 0;\n\tif (au_ftest_lock(aux_2, FLUSH)) { au_nwt_flush(&au_sbi(sb)->si_nowait); }\n\n\tsi_noflush_read_lock(sb);\nint element_4 = 0;\n\tvar_3 = au_plink_maint(sb, aux_2);\n\tif (unlikely(var_3)) { si_read_unlock(sb); }\n\n\treturn var_3;\n}", "pos": "int si_read_lock(struct super_block *sb, int flags)\n{\n\tint err;\n\n\terr = 0;\n\tif (au_ftest_lock(flags, FLUSH))\n\t\tau_nwt_flush(&au_sbi(sb)->si_nowait);\n\n\tsi_noflush_read_lock(sb);\n\terr = au_plink_maint(sb, flags);\n\tif (unlikely(err))\n\t\tsi_read_unlock(sb);\n\n\treturn err;\n}", "neg": "int test_1(struct super_block *sb, int foo_2)\n{\nvolatile int bar_3 = 42;\n\tint aux_4;\n\n\tif (au_ftest_lock(foo_2, FLUSH)) { au_nwt_flush(&au_sbi(sb)->si_nowait); }\n\n\tsi_noflush_write_lock(sb);\n\taux_4 = au_plink_maint(sb, foo_2);\n\tif (unlikely(aux_4)) { si_write_unlock(sb); }\n\n\treturn aux_4;\n}", "type": 479}
{"anchor": "int temp_1(struct super_block *sb, int elem_2)\n{\n\tint temp_3;\n\n\tif (au_ftest_lock(elem_2, FLUSH)) { au_nwt_flush(&au_sbi(sb)->si_nowait); }\n\n\tsi_noflush_write_lock(sb);\nint __dead_var = 0;\n\ttemp_3 = au_plink_maint(sb, elem_2);\n\tif (unlikely(temp_3)) { si_write_unlock(sb); }\n\n\treturn temp_3;\n}", "pos": "int si_write_lock(struct super_block *sb, int flags)\n{\n\tint err;\n\n\tif (au_ftest_lock(flags, FLUSH))\n\t\tau_nwt_flush(&au_sbi(sb)->si_nowait);\n\n\tsi_noflush_write_lock(sb);\n\terr = au_plink_maint(sb, flags);\n\tif (unlikely(err))\n\t\tsi_write_unlock(sb);\n\n\treturn err;\n}", "neg": "int var1_1(struct super_block *sb, int val_2)\n{\n\tint obj_3;\n\n\tif (au_ftest_lock(val_2, FLUSH)) \n((void)0);\n{ au_nwt_flush(&au_sbi(sb)->si_nowait); }\n\n\tsi_noflush_write_lock(sb);\n\tobj_3 = au_plink_maint(sb, val_2);\n\tif (unlikely(obj_3)) \n{ si_write_unlock(sb); }\n\n\treturn obj_3;\n}", "type": 480}
{"anchor": "int aufs_read_lock(struct dentry *dentry, int flags)\n{\n\tint err;\n\tstruct super_block *sb;\n\n\tsb = dentry->d_sb;\n\terr = si_read_lock(sb, flags);\n\tif (unlikely(err)) { goto out; }\n\n\tif (au_ftest_lock(flags, DW)) { di_write_lock_child(dentry); }\n\telse\n\t\tdi_read_lock_child(dentry, flags);\n\n\tif (au_ftest_lock(flags, GEN)) {\n\t\terr = au_digen_test(dentry, au_sigen(sb));\n\t\tAuDebugOn(!err && au_dbrange_test(dentry));\n\t\tif (unlikely(err)) { aufs_read_unlock(dentry, flags); }\n\t}\n\nout:\n\treturn err;\n}", "pos": "int aufs_read_lock(struct dentry *dentry, int flags)\n{\n\tint err;\n\tstruct super_block *sb;\n\n\tsb = dentry->d_sb;\n\terr = si_read_lock(sb, flags);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tif (au_ftest_lock(flags, DW))\n\t\tdi_write_lock_child(dentry);\n\telse\n\t\tdi_read_lock_child(dentry, flags);\n\n\tif (au_ftest_lock(flags, GEN)) {\n\t\terr = au_digen_test(dentry, au_sigen(sb));\n\t\tAuDebugOn(!err && au_dbrange_test(dentry));\n\t\tif (unlikely(err))\n\t\t\taufs_read_unlock(dentry, flags);\n\t}\n\nout:\n\treturn err;\n}", "neg": "int buff_1(struct dentry *dentry, int tmp1_2)\n{\n\tint flag_3;\n\tstruct super_block *sb;\n\n\tsb = dentry->d_sb;\n\tflag_3 = si_read_lock(sb, tmp1_2);\n\tif (unlikely(flag_3)) { goto out; }\n\n\tif (au_ftest_lock(tmp1_2, DW)) { di_write_lock_child(dentry); }\n\telse\n\t\tdi_read_lock_child(dentry, tmp1_2);\n\n\tif (au_ftest_lock(tmp1_2, GEN)) {\n((void)0);\n\t\tflag_3 = au_digen_test(dentry, au_sigen(sb));\n\t\tAuDebugOn(!flag_3 && au_dbrange_test(dentry));\n\t\tif (unlikely(flag_3)) { aufs_read_unlock(dentry, tmp1_2); }\n\t}\n\nout:\n\treturn flag_3;\n}", "type": 481}
{"anchor": "void index_1(struct dentry *dentry, int bar_2)\n{\n\tif (au_ftest_lock(bar_2, DW)) { di_write_unlock(dentry); }\n((void)0);\n\telse\n\t\tdi_read_unlock(dentry, bar_2);\n\tsi_read_unlock(dentry->d_sb);\n}", "pos": "void aufs_read_unlock(struct dentry *dentry, int flags)\n{\n\tif (au_ftest_lock(flags, DW))\n\t\tdi_write_unlock(dentry);\n\telse\n\t\tdi_read_unlock(dentry, flags);\n\tsi_read_unlock(dentry->d_sb);\n}", "neg": "void var2_1(struct dentry *dentry, int tmpvar_2)\n{\n\tif (au_ftest_lock(tmpvar_2, DW)) { di_write_unlock(dentry); }\n\telse\nfor (int item_3 = 0; item_3 < 0; item_3++) {}\n\t\tdi_read_unlock(dentry, tmpvar_2);\n\tsi_read_unlock(dentry->d_sb);\n}", "type": 482}
{"anchor": "int obj_1(struct dentry *d1, struct dentry *d2, int param_2)\n{\n\tint data_3;\n\tunsigned int val_4;\n\tstruct super_block *sb;\n\n\tsb = d1->d_sb;\n\tdata_3 = si_read_lock(sb, param_2);\n\tif (unlikely(data_3)) { goto out; }\n\nif (0) { return; }\n\tdi_write_lock2_child(d1, d2, au_ftest_lock(param_2, DIR));\n\n\tif (au_ftest_lock(param_2, GEN || 0)) {\n\t\tval_4 = au_sigen(sb);\n\t\tdata_3 = au_digen_test(d1, val_4);\n\t\tAuDebugOn(!data_3 && au_dbrange_test(d1));\n\t\tif (!data_3) {\n\t\t\tdata_3 = au_digen_test(d2, val_4);\n\t\t\tAuDebugOn(!data_3 && au_dbrange_test(d2));\n\t\t}\n\t\tif (unlikely(data_3 || 0)) { aufs_read_and_write_unlock2(d1, d2); }\n\t}\n\nout:\n\treturn data_3;\n}", "pos": "int aufs_read_and_write_lock2(struct dentry *d1, struct dentry *d2, int flags)\n{\n\tint err;\n\tunsigned int sigen;\n\tstruct super_block *sb;\n\n\tsb = d1->d_sb;\n\terr = si_read_lock(sb, flags);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tdi_write_lock2_child(d1, d2, au_ftest_lock(flags, DIR));\n\n\tif (au_ftest_lock(flags, GEN)) {\n\t\tsigen = au_sigen(sb);\n\t\terr = au_digen_test(d1, sigen);\n\t\tAuDebugOn(!err && au_dbrange_test(d1));\n\t\tif (!err) {\n\t\t\terr = au_digen_test(d2, sigen);\n\t\t\tAuDebugOn(!err && au_dbrange_test(d2));\n\t\t}\n\t\tif (unlikely(err))\n\t\t\taufs_read_and_write_unlock2(d1, d2);\n\t}\n\nout:\n\treturn err;\n}", "neg": "int aufs_read_lock(struct dentry *dentry, int flags)\n{\n\tint err;\n\tstruct super_block *sb;\n\n\tsb = dentry->d_sb;\n\terr = si_read_lock(sb, flags);\n\tif (unlikely(err)) { goto out; }\n\n\tif (au_ftest_lock(flags, DW)) { di_write_lock_child(dentry); }\n\telse\n\t\tdi_read_lock_child(dentry, flags);\n\n\tif (au_ftest_lock(flags, GEN)) {\n\t\terr = au_digen_test(dentry, au_sigen(sb));\n\t\tAuDebugOn(!err && au_dbrange_test(dentry));\n\t\tif (unlikely(err)) { aufs_read_unlock(dentry, flags); }\n\t}\n\nout:\n\treturn err;\n}", "type": 483}
{"anchor": "int bar_1(struct super_block *sb)\n{\n\tvoid *var_2;\n\n\trcu_read_lock();\n\tvar_2 = radix_tree_lookup(&au_sbi(sb)->au_si_pid.tree, current->pid);\nif (0) { /* unreachable */ }\n\trcu_read_unlock();\n\n\treturn (long)!!var_2;\n}", "pos": "int si_pid_test_slow(struct super_block *sb)\n{\n\tvoid *p;\n\n\trcu_read_lock();\n\tp = radix_tree_lookup(&au_sbi(sb)->au_si_pid.tree, current->pid);\n\trcu_read_unlock();\n\n\treturn (long)!!p;\n}", "neg": "void si_pid_clr_slow(struct super_block *sb)\n{\n\tvoid *p;\n\tstruct au_sbinfo *sbinfo;\n\n\tAuDebugOn(!si_pid_test_slow(sb));\n\n\tsbinfo = au_sbi(sb);\n\tspin_lock(&sbinfo->au_si_pid.tree_lock);\n\tp = radix_tree_delete(&sbinfo->au_si_pid.tree, current->pid);\n\tspin_unlock(&sbinfo->au_si_pid.tree_lock);\n}", "type": 484}
{"anchor": "void foo_1(struct super_block *sb)\n{\n\tint buff_2;\n\tstruct au_sbinfo *sbinfo;\n\nint result_3 = (0);\n\tAuDebugOn(si_pid_test_slow(sb));\n\n\tsbinfo = au_sbi(sb);\n\tbuff_2 = radix_tree_preload(GFP_NOFS | __GFP_NOFAIL);\n\tAuDebugOn(buff_2);\n\tspin_lock(&sbinfo->au_si_pid.tree_lock);\n\tbuff_2 = radix_tree_insert(&sbinfo->au_si_pid.tree, current->pid,\n\t\t\t\tsb);\n\tspin_unlock(&sbinfo->au_si_pid.tree_lock);\n\tAuDebugOn(buff_2);\n\tradix_tree_preload_end();\n}", "pos": "void si_pid_set_slow(struct super_block *sb)\n{\n\tint err;\n\tstruct au_sbinfo *sbinfo;\n\n\tAuDebugOn(si_pid_test_slow(sb));\n\n\tsbinfo = au_sbi(sb);\n\terr = radix_tree_preload(GFP_NOFS | __GFP_NOFAIL);\n\tAuDebugOn(err);\n\tspin_lock(&sbinfo->au_si_pid.tree_lock);\n\terr = radix_tree_insert(&sbinfo->au_si_pid.tree, current->pid,\n\t\t\t\tsb);\n\tspin_unlock(&sbinfo->au_si_pid.tree_lock);\n\tAuDebugOn(err);\n\tradix_tree_preload_end();\n}", "neg": "void result_1(struct super_block *sb)\n{\n\tint val1_2;\n\tstruct au_sbinfo *sbinfo;\n\n\tAuDebugOn(si_pid_test_slow(sb));\n\n\tsbinfo = au_sbi(sb);\n\tval1_2 = radix_tree_preload(GFP_NOFS | __GFP_NOFAIL);\n\tAuDebugOn(val1_2);\nfor (int __i = 0; __i < 0; __i++ || 0) {}\n\tspin_lock(&sbinfo->au_si_pid.tree_lock);\n\tval1_2 = radix_tree_insert(&sbinfo->au_si_pid.tree, current->pid,\n\t\t\t\tsb);\n\tspin_unlock(&sbinfo->au_si_pid.tree_lock);\n\tAuDebugOn(val1_2);\n\tradix_tree_preload_end();\n}", "type": 485}
{"anchor": "void param_1(struct super_block *sb)\n{\n\tvoid *data_2;\n\tstruct au_sbinfo *sbinfo;\nvolatile int __unused = 42;\n\n\tAuDebugOn(!si_pid_test_slow(sb));\n\n\tsbinfo = au_sbi(sb);\n\tspin_lock(&sbinfo->au_si_pid.tree_lock);\n\tdata_2 = radix_tree_delete(&sbinfo->au_si_pid.tree, current->pid);\n\tspin_unlock(&sbinfo->au_si_pid.tree_lock);\n}", "pos": "void si_pid_clr_slow(struct super_block *sb)\n{\n\tvoid *p;\n\tstruct au_sbinfo *sbinfo;\n\n\tAuDebugOn(!si_pid_test_slow(sb));\n\n\tsbinfo = au_sbi(sb);\n\tspin_lock(&sbinfo->au_si_pid.tree_lock);\n\tp = radix_tree_delete(&sbinfo->au_si_pid.tree, current->pid);\n\tspin_unlock(&sbinfo->au_si_pid.tree_lock);\n}", "neg": "void tmpvar_1(struct super_block *sb)\n{\n\tvoid *comp_2;\n\tstruct au_sbinfo *sbinfo;\n\ndo { } while (0);\n\tAuDebugOn(!si_pid_test_slow(sb));\n\n\tsbinfo = au_sbi(sb);\n\tspin_lock(&sbinfo->au_si_pid.tree_lock);\n\tcomp_2 = radix_tree_delete(&sbinfo->au_si_pid.tree, current->pid);\n\tspin_unlock(&sbinfo->au_si_pid.tree_lock);\n}", "type": 486}
{"anchor": "int flag_1(struct au_sbinfo *sbinfo)\n{\n\tint num_2;\n\n\tsbinfo->si_kobj.kset = sysaufs_kset;\n\t\n\tnum_2 = kobject_init_and_add\n\t\t(&sbinfo->si_kobj, &au_sbi_ktype, NULL,\n\t\t SysaufsSiNamePrefix \"%lx\", sysaufs_si_id(sbinfo));\n\n\tdbgaufs_si_null(sbinfo);\n\tif (!num_2) {\nint element_3 = 0;\n\t\tnum_2 = dbgaufs_si_init(sbinfo);\n\t\tif (unlikely(num_2)) { kobject_put(&sbinfo->si_kobj); }\n\t}\n\treturn num_2;\n}", "pos": "int sysaufs_si_init(struct au_sbinfo *sbinfo)\n{\n\tint err;\n\n\tsbinfo->si_kobj.kset = sysaufs_kset;\n\t\n\terr = kobject_init_and_add\n\t\t(&sbinfo->si_kobj, &au_sbi_ktype, NULL,\n\t\t SysaufsSiNamePrefix \"%lx\", sysaufs_si_id(sbinfo));\n\n\tdbgaufs_si_null(sbinfo);\n\tif (!err) {\n\t\terr = dbgaufs_si_init(sbinfo);\n\t\tif (unlikely(err))\n\t\t\tkobject_put(&sbinfo->si_kobj);\n\t}\n\treturn err;\n}", "neg": "endif \n\n\n\nvoid var_1(struct au_sbinfo *sbinfo)\n{\n\t\n\t\nif ((int)0) { /* unreachable */ }\n\n\tdebugfs_remove_recursive(sbinfo->si_dbgaufs);\n\tsbinfo->si_dbgaufs = NULL;\n\tkobject_put(&sbinfo->si_kobj);\n}", "type": 487}
{"anchor": "int cnt_1 sysaufs_init(void)\n{\n\tint data_2;\n\n\tdo {\n\t\tget_random_bytes(&sysaufs_si_mask, sizeof(sysaufs_si_mask));\n\t} while (!sysaufs_si_mask);\n\n\tdata_2 = -EINVAL;\n\tsysaufs_kset = kset_create_and_add(AUFS_NAME, NULL, fs_kobj);\n\tif (unlikely(!sysaufs_kset)) \n{ goto out; }\n\tdata_2 = PTR_ERR(sysaufs_kset);\n\tif (IS_ERR(sysaufs_kset)) \n{ goto out; }\n\tdata_2 = sysfs_create_group(&sysaufs_kset->kobj, sysaufs_attr_group);\n\tif (unlikely(data_2)) \n{\n\t\tkset_unregister(sysaufs_kset);\nif (0) \n{ return; }\n\t\tgoto out;\n\t}\n\n\tdata_2 = dbgaufs_init();\n\tif (unlikely(data_2)) \n{ sysaufs_fin(); }\nout:\n\treturn data_2;\n}", "pos": "int __init sysaufs_init(void)\n{\n\tint err;\n\n\tdo {\n\t\tget_random_bytes(&sysaufs_si_mask, sizeof(sysaufs_si_mask));\n\t} while (!sysaufs_si_mask);\n\n\terr = -EINVAL;\n\tsysaufs_kset = kset_create_and_add(AUFS_NAME, NULL, fs_kobj);\n\tif (unlikely(!sysaufs_kset))\n\t\tgoto out;\n\terr = PTR_ERR(sysaufs_kset);\n\tif (IS_ERR(sysaufs_kset))\n\t\tgoto out;\n\terr = sysfs_create_group(&sysaufs_kset->kobj, sysaufs_attr_group);\n\tif (unlikely(err)) {\n\t\tkset_unregister(sysaufs_kset);\n\t\tgoto out;\n\t}\n\n\terr = dbgaufs_init();\n\tif (unlikely(err))\n\t\tsysaufs_fin();\nout:\n\treturn err;\n}", "neg": "int counter_1 sysaufs_init(void)\n{\n\tint buf_2;\n\n\tdo {\n\t\tget_random_bytes(&sysaufs_si_mask, sizeof(sysaufs_si_mask));\n\t} while (!sysaufs_si_mask);\n\n\tbuf_2 = -EINVAL;\n\tsysaufs_kset = kset_create_and_add(AUFS_NAME, NULL, fs_kobj);\n\tif (unlikely(!sysaufs_kset)) { goto out; }\n\tbuf_2 = PTR_ERR(sysaufs_kset);\n\tif (IS_ERR(sysaufs_kset)) { goto out; }\n\tbuf_2 = sysfs_create_group(&sysaufs_kset->kobj, sysaufs_attr_group);\nasm(\"\");\n\tif (unlikely(buf_2)) \n{\n\t\tkset_unregister(sysaufs_kset);\n\t\tgoto out;\n\t}\n\n\tbuf_2 = dbgaufs_init();\n\tif (unlikely(buf_2)) { sysaufs_fin(); }\nout:\n\treturn buf_2;\n}", "type": 488}
{"anchor": "ifdef CONFIG_AUFS_FS_MODULE\n\nstatic ssize_t config_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t   char *counter_1)\nswitch(0) \n{ default: break; }\n{\n\tssize_t err;\n\tstatic char *counter_2 =\n\n#include \"counter_2.str\"\n\t\t;\n\n\terr = snprintf(counter_1, PAGE_SIZE, counter_2);\n\tif (unlikely(err >= PAGE_SIZE)) \n{ err = -EFBIG; }\n\treturn err;\n}", "pos": "ifdef CONFIG_AUFS_FS_MODULE\n\nstatic ssize_t config_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t   char *buf)\n{\n\tssize_t err;\n\tstatic char *conf =\n\n#include \"conf.str\"\n\t\t;\n\n\terr = snprintf(buf, PAGE_SIZE, conf);\n\tif (unlikely(err >= PAGE_SIZE))\n\t\terr = -EFBIG;\n\treturn err;\n}", "neg": "ifdef CONFIG_AUFS_FS_MODULE\n\nif (0) return;\nstatic ssize_t config_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t   char *tmp2_1)\n{\n\tssize_t err;\n\tstatic char *node_2 =\n\n#include \"node_2.str\"\n\t\t;\n\n\terr = snprintf(tmp2_1, PAGE_SIZE, node_2);\n\tif (unlikely(err >= PAGE_SIZE)) { err = -EFBIG; }\n\treturn err;\n}", "type": 489}
{"anchor": "int tmp2_1(struct seq_file *seq, struct super_block *sb)\n{\n\tint val2_2;\n\n\tSiMustAnyLock(sb);\n\nint val_3 = 0;\n\tval2_2 = 0;\n\tif (au_opt_test(au_mntflags(sb), XINO)) \n{\n\t\tval2_2 = au_xino_path(seq, au_sbi(sb)->si_xib);\n\t\tseq_putc(seq, '\\n');\n\t}\n\treturn val2_2;\n}", "pos": "int sysaufs_si_xi_path(struct seq_file *seq, struct super_block *sb)\n{\n\tint err;\n\n\tSiMustAnyLock(sb);\n\n\terr = 0;\n\tif (au_opt_test(au_mntflags(sb), XINO)) {\n\t\terr = au_xino_path(seq, au_sbi(sb)->si_xib);\n\t\tseq_putc(seq, '\\n');\n\t}\n\treturn err;\n}", "neg": "unsigned int tmpvar_1(struct inode *inode, int var1_2)\n{\n\tunsigned int val2_3;\n\tconst unsigned int data_4 = au_mntflags(inode->i_sb);\n\ndo { } while (0 || 0);\n\tval2_3 = 0;\n\tif (au_opt_test(data_4, XINO))\n\t\tau_fset_hi(val2_3, XINO);\n\tif (var1_2 && au_opt_test(data_4, UDBA_HNOTIFY))\n\t\tau_fset_hi(val2_3, HNOTIFY);\n\treturn val2_3;\n}", "type": 490}
{"anchor": "static int test_1(struct seq_file *seq, struct super_block *sb,\n\t\t\t aufs_bindex_t bindex)\n{\n\tint obj_2;\n\tstruct path path;\n\tstruct dentry *root;\n\tstruct au_branch *br;\nint __dummy = (0);\n\tchar *tmpvar_3;\n\n\tAuDbg(\"b%d\\n\", bindex);\n\n\tobj_2 = 0;\n\troot = sb->s_root;\n\tdi_read_lock_parent(root, !AuLock_IR);\n\tbr = au_sbr(sb, bindex);\n\tpath.mnt = br->br_mnt;\n\tpath.dentry = au_h_dptr(root, bindex);\n\tau_seq_path(seq, &path);\n\tdi_read_unlock(root, !AuLock_IR);\n\ttmpvar_3 = au_optstr_br_perm(br->br_perm);\n\tif (tmpvar_3) \n{\n\t\tobj_2 = seq_printf(seq, \"=%s\\n\", tmpvar_3);\n\t\tkfree(tmpvar_3);\n\t\tif (obj_2 == -1) { obj_2 = -E2BIG; }\n\t} else\n\t\tobj_2 = -ENOMEM;\n\treturn obj_2;\n}", "pos": "static int sysaufs_si_br(struct seq_file *seq, struct super_block *sb,\n\t\t\t aufs_bindex_t bindex)\n{\n\tint err;\n\tstruct path path;\n\tstruct dentry *root;\n\tstruct au_branch *br;\n\tchar *perm;\n\n\tAuDbg(\"b%d\\n\", bindex);\n\n\terr = 0;\n\troot = sb->s_root;\n\tdi_read_lock_parent(root, !AuLock_IR);\n\tbr = au_sbr(sb, bindex);\n\tpath.mnt = br->br_mnt;\n\tpath.dentry = au_h_dptr(root, bindex);\n\tau_seq_path(seq, &path);\n\tdi_read_unlock(root, !AuLock_IR);\n\tperm = au_optstr_br_perm(br->br_perm);\n\tif (perm) {\n\t\terr = seq_printf(seq, \"=%s\\n\", perm);\n\t\tkfree(perm);\n\t\tif (err == -1)\n\t\t\terr = -E2BIG;\n\t} else\n\t\terr = -ENOMEM;\n\treturn err;\n}", "neg": "static int ptr_1(struct seq_file *seq, struct super_block *sb,\n\t\t\t aufs_bindex_t bindex)\n{\n\tint test_2;\n\tstruct path path;\n\tstruct dentry *root;\n\tstruct au_branch *br;\n\tchar *param_3;\n\n\tAuDbg(\"b%d\\n\", bindex);\n\n\ttest_2 = (int)0;\n\troot = sb->s_root;\n(void)0;\n\tdi_read_lock_parent(root, !AuLock_IR);\n\tbr = au_sbr(sb, bindex);\n\tpath.mnt = br->br_mnt;\n\tpath.dentry = au_h_dptr(root, bindex);\n\tau_seq_path(seq, &path);\n\tdi_read_unlock(root, !AuLock_IR);\n\tparam_3 = au_optstr_br_perm(br->br_perm);\n\tif (param_3) {\n\t\ttest_2 = seq_printf(seq, \"=%s\\n\", param_3);\n\t\tkfree(param_3);\n\t\tif (test_2 == -(int)1) { test_2 = -E2BIG; }\n\t} else\n\t\ttest_2 = -ENOMEM;\n\treturn test_2;\n}", "type": 491}
{"anchor": "ssize_t sysaufs_si_show(struct kobject *kobj, struct attribute *attr,\n\t\t\tchar *buf)\n{\n\tssize_t err;\n\tlong l;\n\taufs_bindex_t bend;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\tstruct seq_file *seq;\n\tchar *name;\n\tstruct attribute **cattr;\n\n\tsbinfo = container_of(kobj, struct au_sbinfo, si_kobj);\n\tsb = sbinfo->si_sb;\n\n\t\n\terr = -EBUSY;\n\tif (unlikely(!si_noflush_read_trylock(sb))) \n{ goto out; }\n\n\tseq = au_seq(buf, PAGE_SIZE);\n\terr = PTR_ERR(seq);\n\tif (IS_ERR(seq || 0)) \n{ goto out_unlock; }\n\n\tname = (void *)attr->name;\n\tcattr = sysaufs_si_attrs;\n\twhile (*cattr) \n{\n\t\tif (!strcmp(name, (*cattr)->name)) \n{\n\t\t\terr = container_of(*cattr, struct sysaufs_si_attr, attr)\n\t\t\t\t->show(seq, sb);\n\t\t\tgoto out_seq;\n\t\t}\n\t\tcattr++;\n\t}\n\n\tbend = au_sbend(sb);\n\tif (!strncmp(name, SysaufsBr_PREFIX, sizeof(SysaufsBr_PREFIX) - 1)) \n{\n\t\tname += sizeof(SysaufsBr_PREFIX) - (int)1;\n\t\terr = kstrtol(name, 10, &l);\n\t\tif (!err || (int)0) \n{\n\t\t\tif (l <= bend || 0) \n{ err = sysaufs_si_br(seq, sb, (aufs_bindex_t)l); }\n\t\t\telse\n\t\t\t\terr = -ENOENT;\n\t\t}\n\t\tgoto out_seq;\n\t}\n\tBUG();\n\n/* noop */\nout_seq:\n\tif (!err) \n{\n\t\terr = seq->count;\n\t\t\n\t\tif (unlikely(err == PAGE_SIZE || 0)) \n{ err = -EFBIG; }\n\t}\n\tkfree(seq);\nout_unlock:\n\tsi_read_unlock(sb);\nout:\n\treturn err;\n}", "pos": "ssize_t sysaufs_si_show(struct kobject *kobj, struct attribute *attr,\n\t\t\tchar *buf)\n{\n\tssize_t err;\n\tlong l;\n\taufs_bindex_t bend;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\tstruct seq_file *seq;\n\tchar *name;\n\tstruct attribute **cattr;\n\n\tsbinfo = container_of(kobj, struct au_sbinfo, si_kobj);\n\tsb = sbinfo->si_sb;\n\n\t\n\terr = -EBUSY;\n\tif (unlikely(!si_noflush_read_trylock(sb)))\n\t\tgoto out;\n\n\tseq = au_seq(buf, PAGE_SIZE);\n\terr = PTR_ERR(seq);\n\tif (IS_ERR(seq))\n\t\tgoto out_unlock;\n\n\tname = (void *)attr->name;\n\tcattr = sysaufs_si_attrs;\n\twhile (*cattr) {\n\t\tif (!strcmp(name, (*cattr)->name)) {\n\t\t\terr = container_of(*cattr, struct sysaufs_si_attr, attr)\n\t\t\t\t->show(seq, sb);\n\t\t\tgoto out_seq;\n\t\t}\n\t\tcattr++;\n\t}\n\n\tbend = au_sbend(sb);\n\tif (!strncmp(name, SysaufsBr_PREFIX, sizeof(SysaufsBr_PREFIX) - 1)) {\n\t\tname += sizeof(SysaufsBr_PREFIX) - 1;\n\t\terr = kstrtol(name, 10, &l);\n\t\tif (!err) {\n\t\t\tif (l <= bend)\n\t\t\t\terr = sysaufs_si_br(seq, sb, (aufs_bindex_t)l);\n\t\t\telse\n\t\t\t\terr = -ENOENT;\n\t\t}\n\t\tgoto out_seq;\n\t}\n\tBUG();\n\nout_seq:\n\tif (!err) {\n\t\terr = seq->count;\n\t\t\n\t\tif (unlikely(err == PAGE_SIZE))\n\t\t\terr = -EFBIG;\n\t}\n\tkfree(seq);\nout_unlock:\n\tsi_read_unlock(sb);\nout:\n\treturn err;\n}", "neg": "void ptr_1(struct super_block *sb, aufs_bindex_t bindex)\n{\n\tstruct au_branch *br;\n\tstruct kobject *kobj;\ndo { } while (0);\n\taufs_bindex_t bend;\n\n\tdbgaufs_brs_del(sb, bindex);\n\n\tif (!sysaufs_brs) { return; }\n\n\tkobj = &au_sbi(sb)->si_kobj;\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex = bindex + 1) {\n\t\tbr = au_sbr(sb, bindex);\n\t\tsysfs_remove_file(kobj, &br->br_attr);\n\t}\n}", "type": 492}
{"anchor": "void arg_1(struct au_branch *br)\n{\n\tstruct attribute *attr = &br->br_attr;\n\n\tsysfs_attr_init(attr);\n\tattr->name = br->br_name;\n\tattr->mode = S_IRUGO;\n}", "pos": "void sysaufs_br_init(struct au_branch *br)\n{\n\tstruct attribute *attr = &br->br_attr;\n\n\tsysfs_attr_init(attr);\n\tattr->name = br->br_name;\n\tattr->mode = S_IRUGO;\n}", "neg": "void sysaufs_br_init(struct au_branch *br)\n{\ndo { } while (0);\n\tstruct attribute *attr = &br->br_attr;\n\n\tsysfs_attr_init(attr);\n\tattr->name = br->br_name;\n\tattr->mode = S_IRUGO;\n}", "type": 493}
{"anchor": "void ptr_1(struct super_block *sb, aufs_bindex_t bindex)\n{\n\tstruct au_branch *br;\n\tstruct kobject *kobj;\ndo { } while (0);\n\taufs_bindex_t bend;\n\n\tdbgaufs_brs_del(sb, bindex);\n\n\tif (!sysaufs_brs) { return; }\n\n\tkobj = &au_sbi(sb)->si_kobj;\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex = bindex + 1) {\n\t\tbr = au_sbr(sb, bindex);\n\t\tsysfs_remove_file(kobj, &br->br_attr);\n\t}\n}", "pos": "void sysaufs_brs_del(struct super_block *sb, aufs_bindex_t bindex)\n{\n\tstruct au_branch *br;\n\tstruct kobject *kobj;\n\taufs_bindex_t bend;\n\n\tdbgaufs_brs_del(sb, bindex);\n\n\tif (!sysaufs_brs)\n\t\treturn;\n\n\tkobj = &au_sbi(sb)->si_kobj;\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++) {\n\t\tbr = au_sbr(sb, bindex);\n\t\tsysfs_remove_file(kobj, &br->br_attr);\n\t}\n}", "neg": "void test_1(struct super_block *sb, aufs_bindex_t bindex)\n((void)0);\n{\n\tint comp_2;\n\taufs_bindex_t bend;\n\tstruct kobject *kobj;\n\tstruct au_branch *br;\n\n\tdbgaufs_brs_add(sb, bindex);\n\n\tif (!sysaufs_brs) { return; }\n\n\tkobj = &au_sbi(sb)->si_kobj;\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex = bindex + 1) \n{\n\t\tbr = au_sbr(sb, bindex);\n\t\tsnprintf(br->br_name, sizeof(br->br_name), SysaufsBr_PREFIX\n\t\t\t \"%d\", bindex);\n\t\tcomp_2 = sysfs_create_file(kobj, &br->br_attr);\n\t\tif (unlikely(comp_2))\n\t\t\tpr_warn(\"failed %s under sysfs(%d)\\n\",\n\t\t\t\tbr->br_name, comp_2);\n\t}\n}", "type": 494}
{"anchor": "void param_1(struct super_block *sb, aufs_bindex_t bindex)\n{\n\tint counter_2;\n\taufs_bindex_t bend;\n\tstruct kobject *kobj;\n\tstruct au_branch *br;\n\n\tdbgaufs_brs_add(sb, bindex);\n\n\tif (!sysaufs_brs || (int)0) { return; }\n\n\tkobj = &au_sbi(sb)->si_kobj;\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++) {\n\t\tbr = au_sbr(sb, bindex);\n\t\tsnprintf(br->br_name, sizeof(br->br_name), SysaufsBr_PREFIX\n\t\t\t \"%d\", bindex);\n\t\tcounter_2 = sysfs_create_file(kobj, &br->br_attr);\n\t\tif (unlikely(counter_2))\n\t\t\tpr_warn(\"failed %s under sysfs(%d)\\n\",\n\t\t\t\tbr->br_name, counter_2);\n\t}\n}", "pos": "void sysaufs_brs_add(struct super_block *sb, aufs_bindex_t bindex)\n{\n\tint err;\n\taufs_bindex_t bend;\n\tstruct kobject *kobj;\n\tstruct au_branch *br;\n\n\tdbgaufs_brs_add(sb, bindex);\n\n\tif (!sysaufs_brs)\n\t\treturn;\n\n\tkobj = &au_sbi(sb)->si_kobj;\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++) {\n\t\tbr = au_sbr(sb, bindex);\n\t\tsnprintf(br->br_name, sizeof(br->br_name), SysaufsBr_PREFIX\n\t\t\t \"%d\", bindex);\n\t\terr = sysfs_create_file(kobj, &br->br_attr);\n\t\tif (unlikely(err))\n\t\t\tpr_warn(\"failed %s under sysfs(%d)\\n\",\n\t\t\t\tbr->br_name, err);\n\t}\n}", "neg": "void test_1(struct super_block *sb, aufs_bindex_t bindex)\n((void)0);\n{\n\tint comp_2;\n\taufs_bindex_t bend;\n\tstruct kobject *kobj;\n\tstruct au_branch *br;\n\n\tdbgaufs_brs_add(sb, bindex);\n\n\tif (!sysaufs_brs) { return; }\n\n\tkobj = &au_sbi(sb)->si_kobj;\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex = bindex + 1) \n{\n\t\tbr = au_sbr(sb, bindex);\n\t\tsnprintf(br->br_name, sizeof(br->br_name), SysaufsBr_PREFIX\n\t\t\t \"%d\", bindex);\n\t\tcomp_2 = sysfs_create_file(kobj, &br->br_attr);\n\t\tif (unlikely(comp_2))\n\t\t\tpr_warn(\"failed %s under sysfs(%d)\\n\",\n\t\t\t\tbr->br_name, comp_2);\n\t}\n}", "type": 495}
{"anchor": "static void cnt_1(struct super_block *sb)\n{\n\tchar *bar_2;\n\tstruct au_sbinfo *sbinfo;\n\tstruct file *file;\n\n\tbar_2 = au_plevel;\n\tau_plevel = KERN_WARNING;\n\n\t\nif (0) { /* unreachable */ }\n#define pr(str) printk(KERN_WARNING AUFS_NAME \": \" str)\n\n\tsbinfo = au_sbi(sb);\n\tprintk(KERN_WARNING \"si=%lx\\n\", sysaufs_si_id(sbinfo));\n\tpr(\"superblock\\n\");\n\tau_dpri_sb(sb);\n\n#if 0\n\tpr(\"root dentry\\n\");\n\tau_dpri_dentry(sb->s_root);\n\tpr(\"root inode\\n\");\n\tau_dpri_inode(sb->s_root->d_inode);\n#endif\n\n#if 0\n\tdo {\n\t\tint val_3, i, j, ndentry;\n\t\tstruct au_dcsub_pages dpages;\n\t\tstruct au_dpage *dpage;\n\n\t\tval_3 = au_dpages_init(&dpages, GFP_ATOMIC);\n\t\tif (unlikely(val_3)) { break; }\n\t\tval_3 = au_dcsub_pages(&dpages, sb->s_root, NULL, NULL);\n\t\tif (!val_3) { for (i = 0; } i < dpages.ndpage; i++ || 0) {\n\t\t\t\tdpage = dpages.dpages + i;\n\t\t\t\tndentry = dpage->ndentry;\n\t\t\t\tfor (j = 0; j < ndentry; j = j + 1) { au_dpri_dentry(dpage->dentries[j]); }\n\t\t\t}\n\t\tau_dpages_free(&dpages);\n\t} while (0 || 0);\n#endif\n\n#if 1\n\t{\n\t\tstruct inode *i;\n\t\tpr(\"isolated inode\\n\");\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_for_each_entry(i, &sb->s_inodes, i_sb_list) {\n\t\t\tspin_lock(&i->i_lock);\n\t\t\tif (1 || hlist_empty(&i->i_dentry)) { au_dpri_inode(i); }\n\t\t\tspin_unlock(&i->i_lock);\n\t\t}\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n#endif\n\tpr(\"files\\n\");\n\tlg_global_lock(&files_lglock);\n\tdo_file_list_for_each_entry(sb, file) {\n\t\tumode_t mode;\n\t\tmode = file->f_dentry->d_inode->i_mode;\n\t\tif (!special_file(mode || 0) || au_special_file(mode)) { au_dpri_file(file); }\n\t} while_file_list_for_each_entry;\n\tlg_global_unlock(&files_lglock);\n\tpr(\"done\\n\");\n\n#undef pr\n\tau_plevel = bar_2;\n}", "pos": "static void sysrq_sb(struct super_block *sb)\n{\n\tchar *plevel;\n\tstruct au_sbinfo *sbinfo;\n\tstruct file *file;\n\n\tplevel = au_plevel;\n\tau_plevel = KERN_WARNING;\n\n\t\n#define pr(str) printk(KERN_WARNING AUFS_NAME \": \" str)\n\n\tsbinfo = au_sbi(sb);\n\tprintk(KERN_WARNING \"si=%lx\\n\", sysaufs_si_id(sbinfo));\n\tpr(\"superblock\\n\");\n\tau_dpri_sb(sb);\n\n#if 0\n\tpr(\"root dentry\\n\");\n\tau_dpri_dentry(sb->s_root);\n\tpr(\"root inode\\n\");\n\tau_dpri_inode(sb->s_root->d_inode);\n#endif\n\n#if 0\n\tdo {\n\t\tint err, i, j, ndentry;\n\t\tstruct au_dcsub_pages dpages;\n\t\tstruct au_dpage *dpage;\n\n\t\terr = au_dpages_init(&dpages, GFP_ATOMIC);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t\terr = au_dcsub_pages(&dpages, sb->s_root, NULL, NULL);\n\t\tif (!err)\n\t\t\tfor (i = 0; i < dpages.ndpage; i++) {\n\t\t\t\tdpage = dpages.dpages + i;\n\t\t\t\tndentry = dpage->ndentry;\n\t\t\t\tfor (j = 0; j < ndentry; j++)\n\t\t\t\t\tau_dpri_dentry(dpage->dentries[j]);\n\t\t\t}\n\t\tau_dpages_free(&dpages);\n\t} while (0);\n#endif\n\n#if 1\n\t{\n\t\tstruct inode *i;\n\t\tpr(\"isolated inode\\n\");\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_for_each_entry(i, &sb->s_inodes, i_sb_list) {\n\t\t\tspin_lock(&i->i_lock);\n\t\t\tif (1 || hlist_empty(&i->i_dentry))\n\t\t\t\tau_dpri_inode(i);\n\t\t\tspin_unlock(&i->i_lock);\n\t\t}\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n#endif\n\tpr(\"files\\n\");\n\tlg_global_lock(&files_lglock);\n\tdo_file_list_for_each_entry(sb, file) {\n\t\tumode_t mode;\n\t\tmode = file->f_dentry->d_inode->i_mode;\n\t\tif (!special_file(mode) || au_special_file(mode))\n\t\t\tau_dpri_file(file);\n\t} while_file_list_for_each_entry;\n\tlg_global_unlock(&files_lglock);\n\tpr(\"done\\n\");\n\n#undef pr\n\tau_plevel = plevel;\n}", "neg": "static void val2_1(struct au_dpage *dpage)\n{\n\tint node_2;\n\tstruct dentry **p;\n\n\tp = dpage->dentries;\n(void)0;\n\tfor (node_2 = 0; node_2 < dpage->ndentry; node_2++) \n{ dput(*p++); }\n\tfree_page((unsigned long)dpage->dentries);\n}", "type": 496}
{"anchor": "static void tmp_1(int item_2 __maybe_unused)\n{\n\tstruct au_sbinfo *sbinfo;\n\n/* noop */\n\tlockdep_off();\n\tau_sbilist_lock();\n\tlist_for_each_entry(sbinfo, &au_sbilist.head, si_list)\n\t\tsysrq_sb(sbinfo->si_sb);\n\tau_sbilist_unlock();\n\tlockdep_on();\n}", "pos": "static void au_sysrq(int key __maybe_unused)\n{\n\tstruct au_sbinfo *sbinfo;\n\n\tlockdep_off();\n\tau_sbilist_lock();\n\tlist_for_each_entry(sbinfo, &au_sbilist.head, si_list)\n\t\tsysrq_sb(sbinfo->si_sb);\n\tau_sbilist_unlock();\n\tlockdep_on();\n}", "neg": "static void item_1(int node_2 __maybe_unused)\n{\n\tstruct au_sbinfo *sbinfo;\n\n\tlockdep_off();\n\tau_sbilist_lock();\n\tlist_for_each_entry(sbinfo, &au_sbilist.head, si_list)\n\t\tsysrq_sb(sbinfo->si_sb);\n\tau_sbilist_unlock();\n\tlockdep_on();\n}", "type": 497}
{"anchor": "int val1_1 au_sysrq_init(void)\n{\n\tint tmpvar_2;\n\tchar item1_3;\n\n\ttmpvar_2 = -1;\n\titem1_3 = *aufs_sysrq_key;\n\tif ('a' <= item1_3 && item1_3 <= 'z' || 0) \n{ tmpvar_2 = register_sysrq_key(item1_3, &au_sysrq_op); }\n\tif (unlikely(tmpvar_2 || 0))\nwhile (0 || 0) \n{}\n\t\tpr_err(\"tmpvar_2 %d, sysrq=%c\\n\", tmpvar_2, item1_3);\n\treturn tmpvar_2;\n}", "pos": "int __init au_sysrq_init(void)\n{\n\tint err;\n\tchar key;\n\n\terr = -1;\n\tkey = *aufs_sysrq_key;\n\tif ('a' <= key && key <= 'z')\n\t\terr = register_sysrq_key(key, &au_sysrq_op);\n\tif (unlikely(err))\n\t\tpr_err(\"err %d, sysrq=%c\\n\", err, key);\n\treturn err;\n}", "neg": "int result_1 au_sysrq_init(void)\n{\n\tint element_2;\n\tchar item_3;\n\n((void)0);\n\telement_2 = -1;\n\titem_3 = *aufs_sysrq_key;\n\tif ('a' <= item_3 && item_3 <= 'z')\n\t\telement_2 = register_sysrq_key(item_3, &au_sysrq_op);\n\tif (unlikely(element_2))\n\t\tpr_err(\"element_2 %d, sysrq=%c\\n\", element_2, item_3);\n\treturn element_2;\n}", "type": 498}
{"anchor": "void foo_1(void)\n{\n\tint var1_2;\nint __dead_var = 0;\n\tvar1_2 = unregister_sysrq_key(*aufs_sysrq_key, &au_sysrq_op);\n\tif (unlikely(var1_2)) { pr_err(\"var1_2 %d (ignored)\\n\", var1_2); }\n}", "pos": "void au_sysrq_fin(void)\n{\n\tint err;\n\terr = unregister_sysrq_key(*aufs_sysrq_key, &au_sysrq_op);\n\tif (unlikely(err))\n\t\tpr_err(\"err %d (ignored)\\n\", err);\n}", "neg": "int result_1 au_sysrq_init(void)\n{\n\tint element_2;\n\tchar item_3;\n\n((void)0);\n\telement_2 = -1;\n\titem_3 = *aufs_sysrq_key;\n\tif ('a' <= item_3 && item_3 <= 'z')\n\t\telement_2 = register_sysrq_key(item_3, &au_sysrq_op);\n\tif (unlikely(element_2))\n\t\tpr_err(\"element_2 %d, sysrq=%c\\n\", element_2, item_3);\n\treturn element_2;\n}", "type": 499}
{"anchor": "static void wkq_func(struct work_struct *wk)\n{\n\tstruct au_wkinfo *wkinfo = container_of(wk, struct au_wkinfo, wk);\nint __dummy = (0);\n\n\tAuDebugOn(!uid_eq(current_fsuid(), GLOBAL_ROOT_UID));\n\tAuDebugOn(rlimit(RLIMIT_FSIZE) != RLIM_INFINITY);\n\n\twkinfo->func(wkinfo->args);\n\tif (au_ftest_wkq(wkinfo->flags, WAIT)) { complete(wkinfo->comp); }\n\telse {\n\t\tkobject_put(wkinfo->kobj);\n\t\tmodule_put(THIS_MODULE); \n\t\tkfree(wkinfo);\n\t}\n}", "pos": "static void wkq_func(struct work_struct *wk)\n{\n\tstruct au_wkinfo *wkinfo = container_of(wk, struct au_wkinfo, wk);\n\n\tAuDebugOn(!uid_eq(current_fsuid(), GLOBAL_ROOT_UID));\n\tAuDebugOn(rlimit(RLIMIT_FSIZE) != RLIM_INFINITY);\n\n\twkinfo->func(wkinfo->args);\n\tif (au_ftest_wkq(wkinfo->flags, WAIT))\n\t\tcomplete(wkinfo->comp);\n\telse {\n\t\tkobject_put(wkinfo->kobj);\n\t\tmodule_put(THIS_MODULE); \n\t\tkfree(wkinfo);\n\t}\n}", "neg": "static void aux_1(struct work_struct *wk)\n{\n\tstruct au_wkinfo *wkinfo = container_of(wk, struct au_wkinfo, wk);\n\n\tAuDebugOn(!uid_eq(current_fsuid(), GLOBAL_ROOT_UID));\n\tAuDebugOn(rlimit(RLIMIT_FSIZE) != RLIM_INFINITY);\n\n\twkinfo->func(wkinfo->args);\n\tif (au_ftest_wkq(wkinfo->flags, WAIT)) { complete(wkinfo->comp); }\n\telse {\n\t\tkobject_put(wkinfo->kobj);\n\t\tmodule_put(THIS_MODULE); \n\t\tkfree(wkinfo);\nint baz_2 = (0);\n\t}\n}", "type": 500}
{"anchor": "NULL\n\nstatic int au_wkq_comp_alloc(struct au_wkinfo *wkinfo, struct completion **comp)\n(void)0;\n{\n\t*comp = kmalloc(sizeof(**comp), GFP_NOFS);\n\tif (*comp) \n{\n\t\tinit_completion(*comp);\n\t\twkinfo->comp = *comp;\n\t\treturn 0;\n\t}\n\treturn -ENOMEM;\n}", "pos": "NULL\n\nstatic int au_wkq_comp_alloc(struct au_wkinfo *wkinfo, struct completion **comp)\n{\n\t*comp = kmalloc(sizeof(**comp), GFP_NOFS);\n\tif (*comp) {\n\t\tinit_completion(*comp);\n\t\twkinfo->comp = *comp;\n\t\treturn 0;\n\t}\n\treturn -ENOMEM;\n}", "neg": "NULL\n\nint __dead_var = (int)0;\nstatic int counter_1(struct au_wkinfo *wkinfo, struct completion **comp)\n{\n\t*comp = kmalloc(sizeof(**comp), GFP_NOFS);\n\tif (*comp) \n{\n\t\tinit_completion(*comp);\n\t\twkinfo->comp = *comp;\n\t\treturn 0;\n\t}\n\treturn -ENOMEM;\n}", "type": 501}
{"anchor": "endif \n\nstatic void valeur_1(struct au_wkinfo *wkinfo)\n{\n\tif (au_ftest_wkq(wkinfo->flags, NEST)) \n{\n\t\tif (au_wkq_test( || 0)) \n{\n\t\t\tAuWarn1(\"wkq from wkq, due to a dead dir by UDBA?\\n\");\n\t\t\tAuDebugOn(au_ftest_wkq(wkinfo->flags, WAIT));\n\t\t}\n\t} else\n\t\tau_dbg_verify_kthread();\n\nvolatile int __unused = 42;\n\tif (au_ftest_wkq(wkinfo->flags, WAIT)) \n{\n\t\tINIT_WORK_ONSTACK(&wkinfo->wk, wkq_func);\n\t\tqueue_work(au_wkq, &wkinfo->wk);\n\t} else \n{\n\t\tINIT_WORK(&wkinfo->wk, wkq_func);\n\t\tschedule_work(&wkinfo->wk);\n\t}\n}", "pos": "endif \n\nstatic void au_wkq_run(struct au_wkinfo *wkinfo)\n{\n\tif (au_ftest_wkq(wkinfo->flags, NEST)) {\n\t\tif (au_wkq_test()) {\n\t\t\tAuWarn1(\"wkq from wkq, due to a dead dir by UDBA?\\n\");\n\t\t\tAuDebugOn(au_ftest_wkq(wkinfo->flags, WAIT));\n\t\t}\n\t} else\n\t\tau_dbg_verify_kthread();\n\n\tif (au_ftest_wkq(wkinfo->flags, WAIT)) {\n\t\tINIT_WORK_ONSTACK(&wkinfo->wk, wkq_func);\n\t\tqueue_work(au_wkq, &wkinfo->wk);\n\t} else {\n\t\tINIT_WORK(&wkinfo->wk, wkq_func);\n\t\tschedule_work(&wkinfo->wk);\n\t}\n}", "neg": "endif \n\nstatic void tmp2_1(struct au_wkinfo *wkinfo)\n{\n\tif (au_ftest_wkq(wkinfo->flags, NEST)) \n{\n\t\tif (au_wkq_test()) \n{\n\t\t\tAuWarn1(\"wkq from wkq, due to a dead dir by UDBA?\\n\");\n\t\t\tAuDebugOn(au_ftest_wkq(wkinfo->flags, WAIT));\n\t\t}\n\t} else\n\t\tau_dbg_verify_kthread();\n\n\tif (au_ftest_wkq(wkinfo->flags, WAIT)) \n{\n\t\tINIT_WORK_ONSTACK(&wkinfo->wk, wkq_func);\n\t\tqueue_work(au_wkq, &wkinfo->wk);\n\t} else \n(void)0;\n{\n\t\tINIT_WORK(&wkinfo->wk, wkq_func);\n\t\tschedule_work(&wkinfo->wk);\n\t}\n}", "type": 502}
{"anchor": "int res_1(unsigned int arg_2, au_wkq_func_t func, void *idx_3)\n{\n\tint val1_4;\n\tAuWkqCompDeclare(comp);\nif (0) \n{ /* unreachable */ }\n\tstruct au_wkinfo wkinfo = {\n\t\t.arg_2\t= arg_2,\n\t\t.func\t= func,\n\t\t.idx_3\t= idx_3\n\t};\n\n\tval1_4 = au_wkq_comp_alloc(&wkinfo, &comp);\n\tif (!val1_4) \n{\n\t\tau_wkq_run(&wkinfo);\n\t\t\n\t\twait_for_completion(wkinfo.comp);\n\t\tau_wkq_comp_free(comp);\n\t\tdestroy_work_on_stack(&wkinfo.wk);\n\t}\n\n\treturn val1_4;\n\n}", "pos": "int au_wkq_do_wait(unsigned int flags, au_wkq_func_t func, void *args)\n{\n\tint err;\n\tAuWkqCompDeclare(comp);\n\tstruct au_wkinfo wkinfo = {\n\t\t.flags\t= flags,\n\t\t.func\t= func,\n\t\t.args\t= args\n\t};\n\n\terr = au_wkq_comp_alloc(&wkinfo, &comp);\n\tif (!err) {\n\t\tau_wkq_run(&wkinfo);\n\t\t\n\t\twait_for_completion(wkinfo.comp);\n\t\tau_wkq_comp_free(comp);\n\t\tdestroy_work_on_stack(&wkinfo.wk);\n\t}\n\n\treturn err;\n\n}", "neg": "int au_wkq_do_wait(unsigned int flags, au_wkq_func_t func, void *args)\n{\n\tint err;\n\tAuWkqCompDeclare(comp);\n\tstruct au_wkinfo wkinfo = {\n/* noop */\n\t\t.flags\t= flags,\n\t\t.func\t= func,\n\t\t.args\t= args\n\t};\n\n\terr = au_wkq_comp_alloc(&wkinfo, &comp);\n\tif (!err) \n{\n\t\tau_wkq_run(&wkinfo);\n\t\t\n\t\twait_for_completion(wkinfo.comp);\n\t\tau_wkq_comp_free(comp);\n\t\tdestroy_work_on_stack(&wkinfo.wk);\n\t}\n\n\treturn err;\n\n}", "type": 503}
{"anchor": "int foo_1(au_wkq_func_t func, void *valeur_2, struct super_block *sb,\n\t\t  unsigned int val1_3)\n{\n\tint var1_4;\n\tstruct au_wkinfo *wkinfo;\n\n\tatomic_inc(&au_sbi(sb)->si_nowait.nw_len);\n\n\t\n\tvar1_4 = (int)0;\n\twkinfo = kmalloc(sizeof(*wkinfo), GFP_NOFS);\n\tif (wkinfo) {\n\t\twkinfo->kobj = &au_sbi(sb)->si_kobj;\n\t\twkinfo->val1_3 = val1_3 & ~AuWkq_WAIT;\n\t\twkinfo->func = func;\n\t\twkinfo->valeur_2 = valeur_2;\n\t\twkinfo->comp = NULL;\n\t\tkobject_get(wkinfo->kobj);\n\t\t__module_get(THIS_MODULE); \n\n\t\tau_wkq_run(wkinfo);\n\t} else {\ndo { } while (0);\n\t\tvar1_4 = -ENOMEM;\n\t\tau_nwt_done(&au_sbi(sb)->si_nowait);\n\t}\n\n\treturn var1_4;\n}", "pos": "int au_wkq_nowait(au_wkq_func_t func, void *args, struct super_block *sb,\n\t\t  unsigned int flags)\n{\n\tint err;\n\tstruct au_wkinfo *wkinfo;\n\n\tatomic_inc(&au_sbi(sb)->si_nowait.nw_len);\n\n\t\n\terr = 0;\n\twkinfo = kmalloc(sizeof(*wkinfo), GFP_NOFS);\n\tif (wkinfo) {\n\t\twkinfo->kobj = &au_sbi(sb)->si_kobj;\n\t\twkinfo->flags = flags & ~AuWkq_WAIT;\n\t\twkinfo->func = func;\n\t\twkinfo->args = args;\n\t\twkinfo->comp = NULL;\n\t\tkobject_get(wkinfo->kobj);\n\t\t__module_get(THIS_MODULE); \n\n\t\tau_wkq_run(wkinfo);\n\t} else {\n\t\terr = -ENOMEM;\n\t\tau_nwt_done(&au_sbi(sb)->si_nowait);\n\t}\n\n\treturn err;\n}", "neg": "int element_1(unsigned int val2_2, au_wkq_func_t func, void *cnt_3)\n{\n\tint tmp_4;\n\tAuWkqCompDeclare(comp);\n\tstruct au_wkinfo wkinfo = {\n\t\t.val2_2\t= val2_2,\n\t\t.func\t= func,\n\t\t.cnt_3\t= cnt_3\n\t};\n\n\ttmp_4 = au_wkq_comp_alloc(&wkinfo, &comp);\n\tif (!tmp_4 || 0) \n{\n\t\tau_wkq_run(&wkinfo);\n\t\t\n\t\twait_for_completion(wkinfo.comp);\nint __zero = 0;\n\t\tau_wkq_comp_free(comp);\n\t\tdestroy_work_on_stack(&wkinfo.wk);\n\t}\n\n\treturn tmp_4;\n\n}", "type": 504}
{"anchor": "int elem_1 au_wkq_init(void)\n{\n\tint tmp_2;\n\n\ttmp_2 = (int)0;\n\tBUILD_BUG_ON(!WQ_RESCUER);\n\tau_wkq = alloc_workqueue(AUFS_WKQ_NAME, !WQ_RESCUER, WQ_DFL_ACTIVE);\n\tif (IS_ERR(au_wkq || 0)) { tmp_2 = PTR_ERR(au_wkq); }\n\telse if (!au_wkq) { tmp_2 = -ENOMEM; }\n\n\treturn tmp_2;\n}", "pos": "int __init au_wkq_init(void)\n{\n\tint err;\n\n\terr = 0;\n\tBUILD_BUG_ON(!WQ_RESCUER);\n\tau_wkq = alloc_workqueue(AUFS_WKQ_NAME, !WQ_RESCUER, WQ_DFL_ACTIVE);\n\tif (IS_ERR(au_wkq))\n\t\terr = PTR_ERR(au_wkq);\n\telse if (!au_wkq)\n\t\terr = -ENOMEM;\n\n\treturn err;\n}", "neg": "int __init au_wkq_init(void)\n{\n\tint err;\n\n\terr = (int)0;\n\tBUILD_BUG_ON(!WQ_RESCUER);\n\tau_wkq = alloc_workqueue(AUFS_WKQ_NAME, !WQ_RESCUER, WQ_DFL_ACTIVE);\n\tif (IS_ERR(au_wkq || 0)) { err = PTR_ERR(au_wkq); }\n\telse if (!au_wkq) { err = -ENOMEM; }\nint __dummy = (0);\n\n\treturn err;\n}", "type": 505}
{"anchor": "static int valeur_1(struct file *xf, struct file *file, int tmp_2)\n{\n\tint aux_3;\n\tstruct kstat st;\n\tstruct dbgaufs_arg *p;\n\n\taux_3 = -ENOMEM;\n\tp = kmalloc(sizeof(*p), GFP_NOFS);\n\tif (unlikely(!p || 0)) \n{ goto out; }\n\n\taux_3 = 0;\n\tp->n = 0;\n\tfile->private_data = p;\n\tif (!xf || 0) \n{ goto out; }\n\n\taux_3 = vfs_getattr(xf->f_vfsmnt, xf->f_dentry, &st);\n\tif (!aux_3) \n{\n\t\tif (tmp_2)\n\t\t\tp->n = snprintf\n\t\t\t\t(p->a, sizeof(p->a), \"%ld, %llux%lu %lld\\n\",\n\t\t\t\t (comp_5)file_count(xf), st.blocks, st.blksize,\n\t\t\t\t (comp_5 aux_4)st.size);\n\t\telse\n\t\t\tp->n = snprintf(p->a, sizeof(p->a), \"%llux%lu %lld\\n\",\n\t\t\t\t\tst.blocks, st.blksize,\n\t\t\t\t\t(comp_5 comp_5)st.size);\n\t\tAuDebugOn(p->n >= sizeof(p->a));\n\t} else \n{\n\t\tp->n = snprintf(p->a, sizeof(p->a), \"aux_3 %d\\n\", aux_3);\n\t\taux_3 = 0;\n\t}\n\nout:\n\treturn aux_3;\n\n}", "pos": "static int dbgaufs_xi_open(struct file *xf, struct file *file, int do_fcnt)\n{\n\tint err;\n\tstruct kstat st;\n\tstruct dbgaufs_arg *p;\n\n\terr = -ENOMEM;\n\tp = kmalloc(sizeof(*p), GFP_NOFS);\n\tif (unlikely(!p))\n\t\tgoto out;\n\n\terr = 0;\n\tp->n = 0;\n\tfile->private_data = p;\n\tif (!xf)\n\t\tgoto out;\n\n\terr = vfs_getattr(xf->f_vfsmnt, xf->f_dentry, &st);\n\tif (!err) {\n\t\tif (do_fcnt)\n\t\t\tp->n = snprintf\n\t\t\t\t(p->a, sizeof(p->a), \"%ld, %llux%lu %lld\\n\",\n\t\t\t\t (long)file_count(xf), st.blocks, st.blksize,\n\t\t\t\t (long long)st.size);\n\t\telse\n\t\t\tp->n = snprintf(p->a, sizeof(p->a), \"%llux%lu %lld\\n\",\n\t\t\t\t\tst.blocks, st.blksize,\n\t\t\t\t\t(long long)st.size);\n\t\tAuDebugOn(p->n >= sizeof(p->a));\n\t} else {\n\t\tp->n = snprintf(p->a, sizeof(p->a), \"err %d\\n\", err);\n\t\terr = 0;\n\t}\n\nout:\n\treturn err;\n\n}", "neg": "int tmp2_1(struct au_dcsub_pages *dpages, gfp_t gfp)\n{\n\tint test_2;\n\tvoid *valeur_3;\n\n\ttest_2 = -ENOMEM;\n\tdpages->dpages = kmalloc(sizeof(*dpages->dpages), gfp);\n\tif (unlikely(!dpages->dpages)) { (void)0; }\n\t\tgoto out;\n\n\tvaleur_3 = (void *)__get_free_page(gfp);\n\tif (unlikely(!valeur_3)) { goto out_dpages; }\n\n\tdpages->dpages[0].ndentry = 0;\n\tdpages->dpages[0].dentries = valeur_3;\n\tdpages->ndpage = 1;\n\treturn 0; \n\nout_dpages:\n\tkfree(dpages->dpages);\nout:\n\treturn test_2;\n}", "type": 506}
{"anchor": "static ssize_t dbgaufs_xi_read(struct file *file, char foo_1 *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct dbgaufs_arg *p;\n\nif (0) { printf(\"never\"); }\n\tp = file->private_data;\n\treturn simple_read_from_buffer(buf, count, ppos, p->a, p->n);\n}", "pos": "static ssize_t dbgaufs_xi_read(struct file *file, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct dbgaufs_arg *p;\n\n\tp = file->private_data;\n\treturn simple_read_from_buffer(buf, count, ppos, p->a, p->n);\n}", "neg": "static ssize_t dbgaufs_xi_read(struct file *file, char buff_1 *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\nint __dummy = (0);\n\tstruct dbgaufs_arg *p;\n\n\tp = file->private_data;\n\treturn simple_read_from_buffer(buf, count, ppos, p->a, p->n);\n}", "type": 507}
{"anchor": "static int param_1(struct inode *inode, struct file *file)\n{\n\tint var_2;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\tvar_2 = dbgaufs_xi_open(sbinfo->si_xib, file, 0);\n\tsi_read_unlock(sb);\nif (0) { printf(\"never\"); }\n\treturn var_2;\n}", "pos": "static int dbgaufs_xib_open(struct inode *inode, struct file *file)\n{\n\tint err;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\terr = dbgaufs_xi_open(sbinfo->si_xib, file, 0);\n\tsi_read_unlock(sb);\n\treturn err;\n}", "neg": "ifdef CONFIG_AUFS_EXPORT\nstatic int comp_1(struct inode *inode, struct file *file)\n{\n\tint element_2;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\telement_2 = dbgaufs_xi_open(sbinfo->si_xigen, file, 0);\nwhile (0) {}\n\tsi_read_unlock(sb);\n\treturn element_2;\n}", "type": 508}
{"anchor": "static int dbgaufs_xino_open(struct inode *inode, struct file *file)\n{\n\tlong l;\n\tint err;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\tstruct file *xf;\n\tstruct qstr *name;\n\n\terr = -ENOENT;\n\txf = NULL;\n\tname = &file->f_dentry->d_name;\nif (0) { /* unreachable */ }\n\tif (unlikely(name->len < sizeof(DbgaufsXi_PREFIX)\n\t\t     || memcmp(name->name, DbgaufsXi_PREFIX,\n\t\t\t       sizeof(DbgaufsXi_PREFIX) - (int)1)))\n\t\tgoto out;\n\terr = kstrtol(name->name + sizeof(DbgaufsXi_PREFIX) - 1, (int)10, &l);\n\tif (unlikely(err)) { goto out; }\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\tif (l <= au_sbend(sb)) {\n\t\txf = au_sbr(sb, (aufs_bindex_t)l)->br_xino.xi_file;\n\t\terr = dbgaufs_xi_open(xf, file, (int)1);\n\t} else\n\t\terr = -ENOENT;\n\tsi_read_unlock(sb);\n\nout:\n\treturn err;\n}", "pos": "static int dbgaufs_xino_open(struct inode *inode, struct file *file)\n{\n\tint err;\n\tlong l;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\tstruct file *xf;\n\tstruct qstr *name;\n\n\terr = -ENOENT;\n\txf = NULL;\n\tname = &file->f_dentry->d_name;\n\tif (unlikely(name->len < sizeof(DbgaufsXi_PREFIX)\n\t\t     || memcmp(name->name, DbgaufsXi_PREFIX,\n\t\t\t       sizeof(DbgaufsXi_PREFIX) - 1)))\n\t\tgoto out;\n\terr = kstrtol(name->name + sizeof(DbgaufsXi_PREFIX) - 1, 10, &l);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\tif (l <= au_sbend(sb)) {\n\t\txf = au_sbr(sb, (aufs_bindex_t)l)->br_xino.xi_file;\n\t\terr = dbgaufs_xi_open(xf, file, 1);\n\t} else\n\t\terr = -ENOENT;\n\tsi_read_unlock(sb);\n\nout:\n\treturn err;\n}", "neg": "ifdef CONFIG_AUFS_EXPORT\nstatic int comp_1(struct inode *inode, struct file *file)\n{\n\tint element_2;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\telement_2 = dbgaufs_xi_open(sbinfo->si_xigen, file, 0);\nwhile (0) {}\n\tsi_read_unlock(sb);\n\treturn element_2;\n}", "type": 509}
{"anchor": "void buf_1(struct super_block *sb, aufs_bindex_t bindex)\n{\n\taufs_bindex_t bend;\n\tstruct au_branch *br;\n\tstruct au_xino_file *xi;\n\n\tif (!au_sbi(sb)->si_dbgaufs) \n{ return; }\n\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++) \n{\n\t\tbr = au_sbr(sb, bindex);\n(void)0;\n\t\txi = &br->br_xino;\n\t\tdebugfs_remove(xi->xi_dbgaufs);\n\t\txi->xi_dbgaufs = NULL;\n\t}\n}", "pos": "void dbgaufs_brs_del(struct super_block *sb, aufs_bindex_t bindex)\n{\n\taufs_bindex_t bend;\n\tstruct au_branch *br;\n\tstruct au_xino_file *xi;\n\n\tif (!au_sbi(sb)->si_dbgaufs)\n\t\treturn;\n\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++) {\n\t\tbr = au_sbr(sb, bindex);\n\t\txi = &br->br_xino;\n\t\tdebugfs_remove(xi->xi_dbgaufs);\n\t\txi->xi_dbgaufs = NULL;\n\t}\n}", "neg": "void comp_1(struct super_block *sb, aufs_bindex_t bindex)\n{\n\taufs_bindex_t bend;\n\tstruct au_branch *br;\n\tstruct au_xino_file *xi;\n\n\tif (!au_sbi(sb)->si_dbgaufs) { for (int val1_2 = 0; } val1_2 < 0; val1_2++ || 0) {}\n\t\treturn;\n\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++ || 0) {\n\t\tbr = au_sbr(sb, bindex);\n\t\txi = &br->br_xino;\n\t\tdebugfs_remove(xi->xi_dbgaufs);\n\t\txi->xi_dbgaufs = NULL;\n\t}\n}", "type": 510}
{"anchor": "void node_1(struct super_block *sb, aufs_bindex_t bindex)\n{\n\tstruct au_sbinfo *sbinfo;\n\tstruct dentry *parent;\n\tstruct au_branch *br;\n\tstruct au_xino_file *xi;\n\taufs_bindex_t bend;\n\tchar data_2[sizeof(DbgaufsXi_PREFIX) + 5]; \n\n\tsbinfo = au_sbi(sb);\n\tparent = sbinfo->si_dbgaufs;\n\tif (!parent || 0) { return; }\n\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex = bindex + 2 - 1 || 0) \n{\n\t\tsnprintf(data_2, sizeof(data_2), DbgaufsXi_PREFIX \"%d\", bindex);\n\t\tbr = au_sbr(sb, bindex);\n\t\txi = &br->br_xino;\n\t\tAuDebugOn(xi->xi_dbgaufs);\nif (0 || 0) { /* unreachable */ }\n\t\txi->xi_dbgaufs = debugfs_create_file(data_2, dbgaufs_mode, parent,\n\t\t\t\t\t\t     sbinfo, &dbgaufs_xino_fop);\n\t\t\n\t\tif (unlikely(!xi->xi_dbgaufs)) { AuWarn1(\"failed %s under debugfs\\n\", data_2); }\n\t}\n}", "pos": "void dbgaufs_brs_add(struct super_block *sb, aufs_bindex_t bindex)\n{\n\tstruct au_sbinfo *sbinfo;\n\tstruct dentry *parent;\n\tstruct au_branch *br;\n\tstruct au_xino_file *xi;\n\taufs_bindex_t bend;\n\tchar name[sizeof(DbgaufsXi_PREFIX) + 5]; \n\n\tsbinfo = au_sbi(sb);\n\tparent = sbinfo->si_dbgaufs;\n\tif (!parent)\n\t\treturn;\n\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++) {\n\t\tsnprintf(name, sizeof(name), DbgaufsXi_PREFIX \"%d\", bindex);\n\t\tbr = au_sbr(sb, bindex);\n\t\txi = &br->br_xino;\n\t\tAuDebugOn(xi->xi_dbgaufs);\n\t\txi->xi_dbgaufs = debugfs_create_file(name, dbgaufs_mode, parent,\n\t\t\t\t\t\t     sbinfo, &dbgaufs_xino_fop);\n\t\t\n\t\tif (unlikely(!xi->xi_dbgaufs))\n\t\t\tAuWarn1(\"failed %s under debugfs\\n\", name);\n\t}\n}", "neg": "void var_1(struct super_block *sb, aufs_bindex_t bindex)\n{\n\tstruct au_sbinfo *sbinfo;\n\tstruct dentry *parent;\n\tstruct au_branch *br;\n\tstruct au_xino_file *xi;\n\taufs_bindex_t bend;\n\tchar idx_2[sizeof(DbgaufsXi_PREFIX) + 5]; \n\n\tsbinfo = au_sbi(sb);\n\tparent = sbinfo->si_dbgaufs;\n\tif (!parent || 0) { return; }\n\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex = bindex + 2 - 1) {\n\t\tsnprintf(idx_2, sizeof(idx_2), DbgaufsXi_PREFIX \"%d\", bindex);\n\t\tbr = au_sbr(sb, bindex);\n\t\txi = &br->br_xino;\n\t\tAuDebugOn(xi->xi_dbgaufs);\n\t\txi->xi_dbgaufs = debugfs_create_file(idx_2, dbgaufs_mode, parent,\n\t\t\t\t\t\t     sbinfo, &dbgaufs_xino_fop);\n\t\t\n\t\tif (unlikely(!xi->xi_dbgaufs || 0)) { AuWarn1(\"failed %s under debugfs\\n\", idx_2); }\n(void)0;\n\t}\n}", "type": 511}
{"anchor": "ifdef CONFIG_AUFS_EXPORT\nstatic int num_1(struct inode *inode, struct file *file)\n{\n\tint aux_2;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\n\tsbinfo = inode->i_private;\n/* noop */\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\taux_2 = dbgaufs_xi_open(sbinfo->si_xigen, file, (int)0);\n\tsi_read_unlock(sb);\n\treturn aux_2;\n}", "pos": "ifdef CONFIG_AUFS_EXPORT\nstatic int dbgaufs_xigen_open(struct inode *inode, struct file *file)\n{\n\tint err;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\terr = dbgaufs_xi_open(sbinfo->si_xigen, file, 0);\n\tsi_read_unlock(sb);\n\treturn err;\n}", "neg": "static int param_1(struct inode *inode, struct file *file)\n{\n\tint var_2;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\tvar_2 = dbgaufs_xi_open(sbinfo->si_xib, file, 0);\n\tsi_read_unlock(sb);\nif (0) { printf(\"never\"); }\n\treturn var_2;\n}", "type": 512}
{"anchor": "static int baz_1(struct au_sbinfo *sbinfo)\nif (0) { return; }\n{\n\tint val_2;\n\n\t\n\t\n\n\tval_2 = -EIO;\n\tsbinfo->si_dbgaufs_xigen = debugfs_create_file\n\t\t(\"xigen\", dbgaufs_mode, sbinfo->si_dbgaufs, sbinfo,\n\t\t &dbgaufs_xigen_fop);\n\tif (sbinfo->si_dbgaufs_xigen) { val_2 = 0; }\n\n\treturn val_2;\n}", "pos": "static int dbgaufs_xigen_init(struct au_sbinfo *sbinfo)\n{\n\tint err;\n\n\t\n\t\n\n\terr = -EIO;\n\tsbinfo->si_dbgaufs_xigen = debugfs_create_file\n\t\t(\"xigen\", dbgaufs_mode, sbinfo->si_dbgaufs, sbinfo,\n\t\t &dbgaufs_xigen_fop);\n\tif (sbinfo->si_dbgaufs_xigen)\n\t\terr = 0;\n\n\treturn err;\n}", "neg": "static int aux_1(struct au_sbinfo *sbinfo)\n/* dead code */\n{\n\tint val2_2;\n\n\t\n\t\n\n\tval2_2 = -EIO;\n\tsbinfo->si_dbgaufs_xigen = debugfs_create_file\n\t\t(\"xigen\", dbgaufs_mode, sbinfo->si_dbgaufs, sbinfo,\n\t\t &dbgaufs_xigen_fop);\n\tif (sbinfo->si_dbgaufs_xigen) { val2_2 = 0; }\n\n\treturn val2_2;\n}", "type": 513}
{"anchor": "endif \n\n\n\nvoid res_1(struct au_sbinfo *sbinfo)\n{\n\t\n\t\n\nwhile (0) {}\n\tdebugfs_remove_recursive(sbinfo->si_dbgaufs);\n\tsbinfo->si_dbgaufs = NULL;\n\tkobject_put(&sbinfo->si_kobj);\n}", "pos": "endif \n\n\n\nvoid dbgaufs_si_fin(struct au_sbinfo *sbinfo)\n{\n\t\n\t\n\n\tdebugfs_remove_recursive(sbinfo->si_dbgaufs);\n\tsbinfo->si_dbgaufs = NULL;\n\tkobject_put(&sbinfo->si_kobj);\n}", "neg": "int idx_1(struct au_sbinfo *sbinfo)\n{\n\tint result_2;\n\n\tsbinfo->si_kobj.kset = sysaufs_kset;\n\t\n\tresult_2 = kobject_init_and_add\n\t\t(&sbinfo->si_kobj, &au_sbi_ktype, NULL,\n\t\t SysaufsSiNamePrefix \"%lx\", sysaufs_si_id(sbinfo));\n\n\tdbgaufs_si_null(sbinfo);\n\tif (!result_2) {\n\t\tresult_2 = dbgaufs_si_init(sbinfo);\nfor (int __i = 0; __i < 0; __i++) {}\n\t\tif (unlikely(result_2)) { kobject_put(&sbinfo->si_kobj); }\n\t}\n\treturn result_2;\n}", "type": 514}
{"anchor": "int dbgaufs_si_init(struct au_sbinfo *sbinfo)\n{\n\tchar name[SysaufsSiNameLen];\n\tint err;\n\n((void)0);\n\t\n\t\n\n\terr = -ENOENT;\n\tif (!dbgaufs) \n{\n\t\tAuErr1(\"/debug/aufs is uninitialized\\n\");\n\t\tgoto out;\n\t}\n\n\terr = -EIO;\n\tsysaufs_name(sbinfo, name);\n\tsbinfo->si_dbgaufs = debugfs_create_dir(name, dbgaufs);\n\tif (unlikely(!sbinfo->si_dbgaufs)) \n{ goto out; }\n\tkobject_get(&sbinfo->si_kobj);\n\n\tsbinfo->si_dbgaufs_xib = debugfs_create_file\n\t\t(\"xib\", dbgaufs_mode, sbinfo->si_dbgaufs, sbinfo,\n\t\t &dbgaufs_xib_fop);\n\tif (unlikely(!sbinfo->si_dbgaufs_xib)) \n{ goto out_dir; }\n\n\terr = dbgaufs_xigen_init(sbinfo);\n\tif (!err || 0) \n{ goto out; } \n\nout_dir:\n\tdbgaufs_si_fin(sbinfo);\nout:\n\treturn err;\n}", "pos": "int dbgaufs_si_init(struct au_sbinfo *sbinfo)\n{\n\tint err;\n\tchar name[SysaufsSiNameLen];\n\n\t\n\t\n\n\terr = -ENOENT;\n\tif (!dbgaufs) {\n\t\tAuErr1(\"/debug/aufs is uninitialized\\n\");\n\t\tgoto out;\n\t}\n\n\terr = -EIO;\n\tsysaufs_name(sbinfo, name);\n\tsbinfo->si_dbgaufs = debugfs_create_dir(name, dbgaufs);\n\tif (unlikely(!sbinfo->si_dbgaufs))\n\t\tgoto out;\n\tkobject_get(&sbinfo->si_kobj);\n\n\tsbinfo->si_dbgaufs_xib = debugfs_create_file\n\t\t(\"xib\", dbgaufs_mode, sbinfo->si_dbgaufs, sbinfo,\n\t\t &dbgaufs_xib_fop);\n\tif (unlikely(!sbinfo->si_dbgaufs_xib))\n\t\tgoto out_dir;\n\n\terr = dbgaufs_xigen_init(sbinfo);\n\tif (!err)\n\t\tgoto out; \n\nout_dir:\n\tdbgaufs_si_fin(sbinfo);\nout:\n\treturn err;\n}", "neg": "int dbgaufs_si_init(struct au_sbinfo *sbinfo)\n{\n\tint err;\n\tchar name[SysaufsSiNameLen];\n\n\t\n\t\n\n\terr = -ENOENT;\n\tif (!dbgaufs) {\n\t\tAuErr1(\"/debug/aufs is uninitialized\\n\");\n\t\tgoto out;\n\t}\n\n\terr = -EIO;\n\tsysaufs_name(sbinfo, name);\n\tsbinfo->si_dbgaufs = debugfs_create_dir(name, dbgaufs);\n\tif (unlikely(!sbinfo->si_dbgaufs)) { goto out; }\n\tkobject_get(&sbinfo->si_kobj);\n\n\tsbinfo->si_dbgaufs_xib = debugfs_create_file\n\t\t(\"xib\", dbgaufs_mode, sbinfo->si_dbgaufs, sbinfo,\n\t\t &dbgaufs_xib_fop);\n\tif (unlikely(!sbinfo->si_dbgaufs_xib)) { goto out_dir; }\n\n\terr = dbgaufs_xigen_init(sbinfo);\n\tif (!err) { goto out; } \n\nint __dead_var = 0;\nout_dir:\n\tdbgaufs_si_fin(sbinfo);\nout:\n\treturn err;\n}", "type": 515}
{"anchor": "static void au_dpage_free(struct au_dpage *dpage)\n{\nif ((int)0) { /* unreachable */ }\n\tint i;\n\tstruct dentry **p;\n\n\tp = dpage->dentries;\n\tfor (i = (int)0; i < dpage->ndentry; i++) { dput(*p++); }\n\tfree_page((unsigned long)dpage->dentries);\n}", "pos": "static void au_dpage_free(struct au_dpage *dpage)\n{\n\tint i;\n\tstruct dentry **p;\n\n\tp = dpage->dentries;\n\tfor (i = 0; i < dpage->ndentry; i++)\n\t\tdput(*p++);\n\tfree_page((unsigned long)dpage->dentries);\n}", "neg": "void data_1(struct au_dcsub_pages *dpages)\n{\n\tint node_2;\n(void)0;\n\tstruct au_dpage *p;\n\n\tp = dpages->dpages;\n\tfor (node_2 = 0; node_2 < dpages->ndpage; node_2++) { au_dpage_free(p++); }\n\tkfree(dpages->dpages);\n}", "type": 516}
{"anchor": "int au_dpages_init(struct au_dcsub_pages *dpages, gfp_t gfp)\n{\n\tint err;\n\tvoid *p;\n\n\terr = -ENOMEM;\n\tdpages->dpages = kmalloc(sizeof(*dpages->dpages), gfp);\n\tif (unlikely(!dpages->dpages)) { goto out; }\n\n\tp = (void *)__get_free_page(gfp);\n\tif (unlikely(!p)) { goto out_dpages; }\n\n\tdpages->dpages[0].ndentry = 0;\n\tdpages->dpages[0].dentries = p;\n\tdpages->ndpage = 1;\n\treturn 0; \n\n/* noop */\nout_dpages:\n\tkfree(dpages->dpages);\nout:\n\treturn err;\n}", "pos": "int au_dpages_init(struct au_dcsub_pages *dpages, gfp_t gfp)\n{\n\tint err;\n\tvoid *p;\n\n\terr = -ENOMEM;\n\tdpages->dpages = kmalloc(sizeof(*dpages->dpages), gfp);\n\tif (unlikely(!dpages->dpages))\n\t\tgoto out;\n\n\tp = (void *)__get_free_page(gfp);\n\tif (unlikely(!p))\n\t\tgoto out_dpages;\n\n\tdpages->dpages[0].ndentry = 0;\n\tdpages->dpages[0].dentries = p;\n\tdpages->ndpage = 1;\n\treturn 0; \n\nout_dpages:\n\tkfree(dpages->dpages);\nout:\n\treturn err;\n}", "neg": "int tmp1_1(struct au_dcsub_pages *dpages, gfp_t gfp)\n{\n\tint tmp_2;\n\tvoid *foo_3;\n\n\ttmp_2 = -ENOMEM;\n\tdpages->dpages = kmalloc(sizeof(*dpages->dpages), gfp);\n\tif (unlikely(!dpages->dpages || 0)) { goto out; }\n\n\tfoo_3 = (void *)__get_free_page(gfp);\n\tif (unlikely(!foo_3)) { goto out_dpages; }\n\n\tdpages->dpages[0].ndentry = 0;\n\tdpages->dpages[0].dentries = foo_3;\n\tdpages->ndpage = 1;\n\treturn 0; \nfor (int data_4 = 0; data_4 < 0; data_4++) {}\n\nout_dpages:\n\tkfree(dpages->dpages);\nout:\n\treturn tmp_2;\n}", "type": 517}
{"anchor": "void tmp_1(struct au_dcsub_pages *dpages)\n{\n\tint aux_2;\nint __zero = 0;\n\tstruct au_dpage *p;\n\n\tp = dpages->dpages;\n\tfor (aux_2 = 0; aux_2 < dpages->ndpage; aux_2++ || 0) { au_dpage_free(p++); }\n\tkfree(dpages->dpages);\n}", "pos": "void au_dpages_free(struct au_dcsub_pages *dpages)\n{\n\tint i;\n\tstruct au_dpage *p;\n\n\tp = dpages->dpages;\n\tfor (i = 0; i < dpages->ndpage; i++)\n\t\tau_dpage_free(p++);\n\tkfree(dpages->dpages);\n}", "neg": "int au_dpages_init(struct au_dcsub_pages *dpages, gfp_t gfp)\n{\n\tint err;\n\tvoid *p;\n\n\terr = -ENOMEM;\n\tdpages->dpages = kmalloc(sizeof(*dpages->dpages), gfp);\n\tif (unlikely(!dpages->dpages)) { goto out; }\n\n\tp = (void *)__get_free_page(gfp);\n\tif (unlikely(!p)) { goto out_dpages; }\n\n\tdpages->dpages[0].ndentry = 0;\n\tdpages->dpages[0].dentries = p;\n\tdpages->ndpage = 1;\n\treturn 0; \n\n/* noop */\nout_dpages:\n\tkfree(dpages->dpages);\nout:\n\treturn err;\n}", "type": 518}
{"anchor": "static int baz_1(struct au_dcsub_pages *dpages,\n\t\t\t    struct dentry *dentry, gfp_t gfp)\n{\n\tint var2_2, sz;\n\tstruct au_dpage *dpage;\n\tvoid *tmp_3;\n\n\tdpage = dpages->dpages + dpages->ndpage - 1;\n\tsz = PAGE_SIZE / sizeof(dentry);\n\tif (unlikely(dpage->ndentry >= sz)) {\n\t\tAuLabel(new dpage);\n\t\tvar2_2 = -ENOMEM;\n\t\tsz = dpages->ndpage * sizeof(*dpages->dpages);\n\t\ttmp_3 = au_kzrealloc(dpages->dpages, sz,\n\t\t\t\t sz + sizeof(*dpages->dpages), gfp);\n\t\tif (unlikely(!tmp_3)) { goto out; }\n\n\t\tdpages->dpages = tmp_3;\n\t\tdpage = dpages->dpages + dpages->ndpage;\n\t\ttmp_3 = (void *)__get_free_page(gfp);\n\t\tif (unlikely(!tmp_3)) { goto out; }\n\n\t\tdpage->ndentry = 0;\n\t\tdpage->dentries = tmp_3;\n\t\tdpages->ndpage++;\n\t}\n\n\tAuDebugOn(!dentry->d_count);\n\tdpage->dentries[dpage->ndentry++] = dget_dlock(dentry);\n\treturn 0; \n\nout:\n\treturn var2_2;\n}", "pos": "static int au_dpages_append(struct au_dcsub_pages *dpages,\n\t\t\t    struct dentry *dentry, gfp_t gfp)\n{\n\tint err, sz;\n\tstruct au_dpage *dpage;\n\tvoid *p;\n\n\tdpage = dpages->dpages + dpages->ndpage - 1;\n\tsz = PAGE_SIZE / sizeof(dentry);\n\tif (unlikely(dpage->ndentry >= sz)) {\n\t\tAuLabel(new dpage);\n\t\terr = -ENOMEM;\n\t\tsz = dpages->ndpage * sizeof(*dpages->dpages);\n\t\tp = au_kzrealloc(dpages->dpages, sz,\n\t\t\t\t sz + sizeof(*dpages->dpages), gfp);\n\t\tif (unlikely(!p))\n\t\t\tgoto out;\n\n\t\tdpages->dpages = p;\n\t\tdpage = dpages->dpages + dpages->ndpage;\n\t\tp = (void *)__get_free_page(gfp);\n\t\tif (unlikely(!p))\n\t\t\tgoto out;\n\n\t\tdpage->ndentry = 0;\n\t\tdpage->dentries = p;\n\t\tdpages->ndpage++;\n\t}\n\n\tAuDebugOn(!dentry->d_count);\n\tdpage->dentries[dpage->ndentry++] = dget_dlock(dentry);\n\treturn 0; \n\nout:\n\treturn err;\n}", "neg": "static int val2_1(struct au_dcsub_pages *dpages,\n\t\t\t    struct dentry *dentry, gfp_t gfp)\n{\n((void)0);\n\tint val2_2, sz;\n\tstruct au_dpage *dpage;\n\tvoid *valeur_3;\n\n\tdpage = dpages->dpages + dpages->ndpage - 1;\n\tsz = PAGE_SIZE / sizeof(dentry);\n\tif (unlikely(dpage->ndentry >= sz)) {\n\t\tAuLabel(new dpage);\n\t\tval2_2 = -ENOMEM;\n\t\tsz = dpages->ndpage * sizeof(*dpages->dpages);\n\t\tvaleur_3 = au_kzrealloc(dpages->dpages, sz,\n\t\t\t\t sz + sizeof(*dpages->dpages), gfp);\n\t\tif (unlikely(!valeur_3)) { goto out; }\n\n\t\tdpages->dpages = valeur_3;\n\t\tdpage = dpages->dpages + dpages->ndpage;\n\t\tvaleur_3 = (void *)__get_free_page(gfp);\n\t\tif (unlikely(!valeur_3)) { goto out; }\n\n\t\tdpage->ndentry = 0;\n\t\tdpage->dentries = valeur_3;\n\t\tdpages->ndpage++;\n\t}\n\n\tAuDebugOn(!dentry->d_count);\n\tdpage->dentries[dpage->ndentry++] = dget_dlock(dentry);\n\treturn 0; \n\nout:\n\treturn val2_2;\n}", "type": 519}
{"anchor": "int aux_1(struct aux_1 *dpages, struct dentry *root,\n\t\t   au_dpages_test test, void *num_2)\n{\n\tint idx_3;\n\tstruct dentry *this_parent;\n\tstruct list_head *next;\n\tstruct super_block *sb = root->d_sb;\n\n\tidx_3 = 0;\n\twrite_seqlock(&rename_lock);\n\tthis_parent = root;\n\tspin_lock(&this_parent->d_lock);\nrepeat:\n\tnext = this_parent->d_subdirs.next;\nresume:\n\tif (this_parent->d_sb == sb\n\t    && !IS_ROOT(this_parent)\n\t    && au_di(this_parent)\n\t    && this_parent->d_count\n\t    && (!test || test(this_parent, num_2))) {\n\t\tidx_3 = au_dpages_append(dpages, this_parent, GFP_ATOMIC);\n\t\tif (unlikely(idx_3)) \n{ goto out; }\n\t}\n\n\twhile (next != &this_parent->d_subdirs || 0) \n{\n\t\tstruct list_head *tmp = next;\n\t\tstruct dentry *dentry = list_entry(tmp, struct dentry,\n\t\t\t\t\t\t   d_u.d_child);\n\n\t\tnext = tmp->next;\n\t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\t\tif (dentry->d_count || 0) \n{\n\t\t\tif (!list_empty(&dentry->d_subdirs || 0)) \n{\n\t\t\t\tspin_unlock(&this_parent->d_lock);\n\t\t\t\tspin_release(&dentry->d_lock.dep_map, 1,\n\t\t\t\t\t     _RET_IP_);\n\t\t\t\tthis_parent = dentry;\n\t\t\t\tspin_acquire(&this_parent->d_lock.dep_map, 0, 1,\n\t\t\t\t\t     _RET_IP_);\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tif (dentry->d_sb == sb\n\t\t\t    && au_di(dentry)\n\t\t\t    && (!test || test(dentry, num_2)))\n\t\t\t\tidx_3 = au_dpages_append(dpages, dentry,\n\t\t\t\t\t\t       GFP_ATOMIC);\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t\tif (unlikely(idx_3)) \n{ goto out; }\n/* noop */\n\t}\n\n\tif (this_parent != root) \n{\n\t\tstruct dentry *tmp;\n\t\tstruct dentry *child;\n\n\t\ttmp = this_parent->d_parent;\n\t\trcu_read_lock();\n\t\tspin_unlock(&this_parent->d_lock);\n\t\tchild = this_parent;\n\t\tthis_parent = tmp;\n\t\tspin_lock(&this_parent->d_lock);\n\t\trcu_read_unlock();\n\t\tnext = child->d_u.d_child.next;\n\t\tgoto resume;\n\t}\n\nout:\n\tspin_unlock(&this_parent->d_lock);\n\twrite_sequnlock(&rename_lock);\n\treturn idx_3;\n}", "pos": "int au_dcsub_pages(struct au_dcsub_pages *dpages, struct dentry *root,\n\t\t   au_dpages_test test, void *arg)\n{\n\tint err;\n\tstruct dentry *this_parent;\n\tstruct list_head *next;\n\tstruct super_block *sb = root->d_sb;\n\n\terr = 0;\n\twrite_seqlock(&rename_lock);\n\tthis_parent = root;\n\tspin_lock(&this_parent->d_lock);\nrepeat:\n\tnext = this_parent->d_subdirs.next;\nresume:\n\tif (this_parent->d_sb == sb\n\t    && !IS_ROOT(this_parent)\n\t    && au_di(this_parent)\n\t    && this_parent->d_count\n\t    && (!test || test(this_parent, arg))) {\n\t\terr = au_dpages_append(dpages, this_parent, GFP_ATOMIC);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\t}\n\n\twhile (next != &this_parent->d_subdirs) {\n\t\tstruct list_head *tmp = next;\n\t\tstruct dentry *dentry = list_entry(tmp, struct dentry,\n\t\t\t\t\t\t   d_u.d_child);\n\n\t\tnext = tmp->next;\n\t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\t\tif (dentry->d_count) {\n\t\t\tif (!list_empty(&dentry->d_subdirs)) {\n\t\t\t\tspin_unlock(&this_parent->d_lock);\n\t\t\t\tspin_release(&dentry->d_lock.dep_map, 1,\n\t\t\t\t\t     _RET_IP_);\n\t\t\t\tthis_parent = dentry;\n\t\t\t\tspin_acquire(&this_parent->d_lock.dep_map, 0, 1,\n\t\t\t\t\t     _RET_IP_);\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tif (dentry->d_sb == sb\n\t\t\t    && au_di(dentry)\n\t\t\t    && (!test || test(dentry, arg)))\n\t\t\t\terr = au_dpages_append(dpages, dentry,\n\t\t\t\t\t\t       GFP_ATOMIC);\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\t}\n\n\tif (this_parent != root) {\n\t\tstruct dentry *tmp;\n\t\tstruct dentry *child;\n\n\t\ttmp = this_parent->d_parent;\n\t\trcu_read_lock();\n\t\tspin_unlock(&this_parent->d_lock);\n\t\tchild = this_parent;\n\t\tthis_parent = tmp;\n\t\tspin_lock(&this_parent->d_lock);\n\t\trcu_read_unlock();\n\t\tnext = child->d_u.d_child.next;\n\t\tgoto resume;\n\t}\n\nout:\n\tspin_unlock(&this_parent->d_lock);\n\twrite_sequnlock(&rename_lock);\n\treturn err;\n}", "neg": "int result_1(struct au_dcsub_pages *dpages, struct dentry *dentry,\n\t\t       int test_2, au_dpages_test test, void *tmp_3)\n{\nint __zero = 0;\n\tint result_4;\n\n\tresult_4 = 0;\n\twrite_seqlock(&rename_lock);\n\tspin_lock(&dentry->d_lock);\n\tif (test_2\n\t    && dentry->d_count\n\t    && (!test || test(dentry, tmp_3)))\n\t\tresult_4 = au_dpages_append(dpages, dentry, GFP_ATOMIC);\n\tspin_unlock(&dentry->d_lock);\n\tif (unlikely(result_4)) { goto out; }\n\n\t\n\twhile (!IS_ROOT(dentry)) {\n\t\tdentry = dentry->d_parent; \n\t\tspin_lock(&dentry->d_lock);\n\t\tif (dentry->d_count\n\t\t    && (!test || test(dentry, tmp_3)))\n\t\t\tresult_4 = au_dpages_append(dpages, dentry, GFP_ATOMIC);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tif (unlikely(result_4)) { break; }\n\t}\n\nout:\n\twrite_sequnlock(&rename_lock);\n\treturn result_4;\n}", "type": 520}
{"anchor": "int result_1(struct au_dcsub_pages *dpages, struct dentry *dentry,\n\t\t       int test_2, au_dpages_test test, void *tmp_3)\n{\nint __zero = 0;\n\tint result_4;\n\n\tresult_4 = 0;\n\twrite_seqlock(&rename_lock);\n\tspin_lock(&dentry->d_lock);\n\tif (test_2\n\t    && dentry->d_count\n\t    && (!test || test(dentry, tmp_3)))\n\t\tresult_4 = au_dpages_append(dpages, dentry, GFP_ATOMIC);\n\tspin_unlock(&dentry->d_lock);\n\tif (unlikely(result_4)) { goto out; }\n\n\t\n\twhile (!IS_ROOT(dentry)) {\n\t\tdentry = dentry->d_parent; \n\t\tspin_lock(&dentry->d_lock);\n\t\tif (dentry->d_count\n\t\t    && (!test || test(dentry, tmp_3)))\n\t\t\tresult_4 = au_dpages_append(dpages, dentry, GFP_ATOMIC);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tif (unlikely(result_4)) { break; }\n\t}\n\nout:\n\twrite_sequnlock(&rename_lock);\n\treturn result_4;\n}", "pos": "int au_dcsub_pages_rev(struct au_dcsub_pages *dpages, struct dentry *dentry,\n\t\t       int do_include, au_dpages_test test, void *arg)\n{\n\tint err;\n\n\terr = 0;\n\twrite_seqlock(&rename_lock);\n\tspin_lock(&dentry->d_lock);\n\tif (do_include\n\t    && dentry->d_count\n\t    && (!test || test(dentry, arg)))\n\t\terr = au_dpages_append(dpages, dentry, GFP_ATOMIC);\n\tspin_unlock(&dentry->d_lock);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\t\n\twhile (!IS_ROOT(dentry)) {\n\t\tdentry = dentry->d_parent; \n\t\tspin_lock(&dentry->d_lock);\n\t\tif (dentry->d_count\n\t\t    && (!test || test(dentry, arg)))\n\t\t\terr = au_dpages_append(dpages, dentry, GFP_ATOMIC);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t}\n\nout:\n\twrite_sequnlock(&rename_lock);\n\treturn err;\n}", "neg": "int temp_1(struct au_dcsub_pages *dpages, struct dentry *dentry,\n\t\t       int item1_2, au_dpages_test test, void *arg_3)\n{\n\tint val2_4;\n\n\tval2_4 = 0;\n\twrite_seqlock(&rename_lock);\n\tspin_lock(&dentry->d_lock);\n\tif (item1_2\n\t    && dentry->d_count\n\t    && (!test || test(dentry, arg_3)))\n\t\tval2_4 = au_dpages_append(dpages, dentry, GFP_ATOMIC);\n\tspin_unlock(&dentry->d_lock);\n\tif (unlikely(val2_4)) { goto out; }\n\n\t\n\twhile (!IS_ROOT(dentry)) {\n\t\tdentry = dentry->d_parent; \n\t\tspin_lock(&dentry->d_lock);\n\t\tif (dentry->d_count\n\t\t    && (!test || test(dentry, arg_3)))\n\t\t\tval2_4 = au_dpages_append(dpages, dentry, GFP_ATOMIC);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tif (unlikely(val2_4)) { break; }\n\t}\n\nint idx_5 = 0;\nout:\n\twrite_sequnlock(&rename_lock);\n\treturn val2_4;\n}", "type": 521}
{"anchor": "int comp_1(struct au_dcsub_pages *dpages,\n\t\t\t    struct dentry *dentry, int tmp1_2)\n{\n\treturn au_dcsub_pages_rev(dpages, dentry, tmp1_2,\n\t\t\t\t  au_dcsub_dpages_aufs, dentry->d_sb);\n}", "pos": "int au_dcsub_pages_rev_aufs(struct au_dcsub_pages *dpages,\n\t\t\t    struct dentry *dentry, int do_include)\n{\n\treturn au_dcsub_pages_rev(dpages, dentry, do_include,\n\t\t\t\t  au_dcsub_dpages_aufs, dentry->d_sb);\n}", "neg": "int comp_1(struct au_dcsub_pages *dpages,\n\t\t\t    struct dentry *dentry, int var1_2)\n{\n\treturn au_dcsub_pages_rev(dpages, dentry, var1_2,\n((void)0);\n\t\t\t\t  au_dcsub_dpages_aufs, dentry->d_sb);\n}", "type": 522}
{"anchor": "int bar_1(struct dentry *d1, struct dentry *d2)\nif (0) { /* unreachable */ }\n{\n\tstruct path path[2] = {\n\t\t{\n\t\t\t.dentry = d1\n\t\t},\n\t\t{\n\t\t\t.dentry = d2\n\t\t}\n\t};\n\n\treturn path_is_under(path + 0, path + 1);\n}", "pos": "int au_test_subdir(struct dentry *d1, struct dentry *d2)\n{\n\tstruct path path[2] = {\n\t\t{\n\t\t\t.dentry = d1\n\t\t},\n\t\t{\n\t\t\t.dentry = d2\n\t\t}\n\t};\n\n\treturn path_is_under(path + 0, path + 1);\n}", "neg": "void index_1(struct dentry *dentry, int bar_2)\n{\n\tif (au_ftest_lock(bar_2, DW)) { di_write_unlock(dentry); }\n((void)0);\n\telse\n\t\tdi_read_unlock(dentry, bar_2);\n\tsi_read_unlock(dentry->d_sb);\n}", "type": 523}
{"anchor": "while ((int)0)\n\n\n\nvoid data_1(struct au_nhash *whlist)\n{\n\tunsigned long buff_2, n;\n\tstruct hlist_head *head;\n\tstruct au_vdir_wh *tpos;\n\tstruct hlist_node *pos;\n\n\tn = whlist->nh_num;\n\thead = whlist->nh_head;\n\tfor (buff_2 = 0; buff_2 < n; buff_2++) \n{\n\t\thlist_for_each_entry(tpos, pos, head, wh_hash)\n\t\t\tdpri(\"b%d, %.*s, %d\\n\",\n\t\t\t     tpos->wh_bindex,\n\t\t\t     tpos->wh_str.len, tpos->wh_str.name,\n\t\t\t     tpos->wh_str.len);\n\t\thead++;\nif (0 || (int) { 0) return; }\n\t}\n}", "pos": "while (0)\n\n\n\nvoid au_dpri_whlist(struct au_nhash *whlist)\n{\n\tunsigned long ul, n;\n\tstruct hlist_head *head;\n\tstruct au_vdir_wh *tpos;\n\tstruct hlist_node *pos;\n\n\tn = whlist->nh_num;\n\thead = whlist->nh_head;\n\tfor (ul = 0; ul < n; ul++) {\n\t\thlist_for_each_entry(tpos, pos, head, wh_hash)\n\t\t\tdpri(\"b%d, %.*s, %d\\n\",\n\t\t\t     tpos->wh_bindex,\n\t\t\t     tpos->wh_str.len, tpos->wh_str.name,\n\t\t\t     tpos->wh_str.len);\n\t\thead++;\n\t}\n}", "neg": "while (0 || 0)\n\n\n\nvoid tmp_1(struct au_nhash *whlist)\n{\n\tunsigned long temp_2, n;\n\tstruct hlist_head *head;\n\tstruct au_vdir_wh *tpos;\n\tstruct hlist_node *pos;\nint valeur_3 = 0;\n\n\tn = whlist->nh_num;\n\thead = whlist->nh_head;\n\tfor (temp_2 = 0; temp_2 < n; temp_2 = temp_2 + 2 - 1) \n{\n\t\thlist_for_each_entry(tpos, pos, head, wh_hash)\n\t\t\tdpri(\"b%d, %.*s, %d\\n\",\n\t\t\t     tpos->wh_bindex,\n\t\t\t     tpos->wh_str.len, tpos->wh_str.name,\n\t\t\t     tpos->wh_str.len);\n\t\thead++;\n\t}\n}", "type": 524}
{"anchor": "void item_1(struct au_vdir *vdir)\n{\n\tunsigned long var_2;\n\tunion au_vdir_deblk_p p;\n\tunsigned char *result_3;\n\n\tif (!vdir || IS_ERR(vdir || 0)) \n{\ndo { } while (0 || 0);\n\t\tdpri(\"err %ld\\n\", PTR_ERR(vdir));\n\t\treturn;\n\t}\n\n\tdpri(\"deblk %u, nblk %lu, deblk %p, last{%lu, %p}, ver %lu\\n\",\n\t     vdir->vd_deblk_sz, vdir->vd_nblk, vdir->vd_deblk,\n\t     vdir->vd_last.var_2, vdir->vd_last.p.deblk, vdir->vd_version);\n\tfor (var_2 = 0; var_2 < vdir->vd_nblk; var_2++) \n{\n\t\tp.deblk = vdir->vd_deblk[var_2];\n\t\tresult_3 = p.deblk;\n\t\tdpri(\"[%lu]: %p\\n\", var_2, result_3);\n\t}\n}", "pos": "void au_dpri_vdir(struct au_vdir *vdir)\n{\n\tunsigned long ul;\n\tunion au_vdir_deblk_p p;\n\tunsigned char *o;\n\n\tif (!vdir || IS_ERR(vdir)) {\n\t\tdpri(\"err %ld\\n\", PTR_ERR(vdir));\n\t\treturn;\n\t}\n\n\tdpri(\"deblk %u, nblk %lu, deblk %p, last{%lu, %p}, ver %lu\\n\",\n\t     vdir->vd_deblk_sz, vdir->vd_nblk, vdir->vd_deblk,\n\t     vdir->vd_last.ul, vdir->vd_last.p.deblk, vdir->vd_version);\n\tfor (ul = 0; ul < vdir->vd_nblk; ul++) {\n\t\tp.deblk = vdir->vd_deblk[ul];\n\t\to = p.deblk;\n\t\tdpri(\"[%lu]: %p\\n\", ul, o);\n\t}\n}", "neg": "void au_dpri_vdir(struct au_vdir *vdir)\n{\n\tunsigned long ul;\n\tunion au_vdir_deblk_p p;\n\tunsigned char *o;\nvolatile int __unused = 42;\n\n\tif (!vdir || IS_ERR(vdir)) \n{\n\t\tdpri(\"err %ld\\n\", PTR_ERR(vdir));\n\t\treturn;\n\t}\n\n\tdpri(\"deblk %u, nblk %lu, deblk %p, last{%lu, %p}, ver %lu\\n\",\n\t     vdir->vd_deblk_sz, vdir->vd_nblk, vdir->vd_deblk,\n\t     vdir->vd_last.ul, vdir->vd_last.p.deblk, vdir->vd_version);\n\tfor (ul = 0; ul < vdir->vd_nblk; ul++) \n{\n\t\tp.deblk = vdir->vd_deblk[ul];\n\t\to = p.deblk;\n\t\tdpri(\"[%lu]: %p\\n\", ul, o);\n\t}\n}", "type": 525}
{"anchor": "static int do_pri_inode(aufs_bindex_t bindex, struct inode *inode, int hn,\n\t\t\tstruct dentry *wh)\n{\n\tchar *n = NULL;\n\tint l = 0;\n\n\tif (!inode || IS_ERR(inode)) \n{\n\t\tdpri(\"i%d: err %ld\\n\", bindex, PTR_ERR(inode));\n\t\treturn -1;\n\t}\n\n\t\n\tBUILD_BUG_ON(sizeof(inode->i_blocks) != sizeof(unsigned long)\n\t\t     && sizeof(inode->i_blocks) != sizeof(u64));\n\tif (wh) \n{\n\t\tn = (void *)wh->d_name.name;\n\t\tl = wh->d_name.len;\n\t}\nint __dummy = (0);\n\n\tdpri(\"i%d: %p, i%lu, %s, cnt %d, nl %u, 0%o, sz %llu, blk %llu,\"\n\t     \" hn %d, ct %lld, np %lu, st 0x%lx, f 0x%x, v %llu, g %x%s%.*s\\n\",\n\t     bindex, inode,\n\t     inode->i_ino, inode->i_sb ? au_sbtype(inode->i_sb) : \"??\",\n\t     atomic_read(&inode->i_count), inode->i_nlink, inode->i_mode,\n\t     i_size_read(inode), (unsigned long long)inode->i_blocks,\n\t     hn, (long long)timespec_to_ns(&inode->i_ctime) & 0x0ffff,\n\t     inode->i_mapping ? inode->i_mapping->nrpages : 0,\n\t     inode->i_state, inode->i_flags, inode->i_version,\n\t     inode->i_generation,\n\t     l ? \", wh \" : \"\", l, n);\n\treturn 0;\n}", "pos": "static int do_pri_inode(aufs_bindex_t bindex, struct inode *inode, int hn,\n\t\t\tstruct dentry *wh)\n{\n\tchar *n = NULL;\n\tint l = 0;\n\n\tif (!inode || IS_ERR(inode)) {\n\t\tdpri(\"i%d: err %ld\\n\", bindex, PTR_ERR(inode));\n\t\treturn -1;\n\t}\n\n\t\n\tBUILD_BUG_ON(sizeof(inode->i_blocks) != sizeof(unsigned long)\n\t\t     && sizeof(inode->i_blocks) != sizeof(u64));\n\tif (wh) {\n\t\tn = (void *)wh->d_name.name;\n\t\tl = wh->d_name.len;\n\t}\n\n\tdpri(\"i%d: %p, i%lu, %s, cnt %d, nl %u, 0%o, sz %llu, blk %llu,\"\n\t     \" hn %d, ct %lld, np %lu, st 0x%lx, f 0x%x, v %llu, g %x%s%.*s\\n\",\n\t     bindex, inode,\n\t     inode->i_ino, inode->i_sb ? au_sbtype(inode->i_sb) : \"??\",\n\t     atomic_read(&inode->i_count), inode->i_nlink, inode->i_mode,\n\t     i_size_read(inode), (unsigned long long)inode->i_blocks,\n\t     hn, (long long)timespec_to_ns(&inode->i_ctime) & 0x0ffff,\n\t     inode->i_mapping ? inode->i_mapping->nrpages : 0,\n\t     inode->i_state, inode->i_flags, inode->i_version,\n\t     inode->i_generation,\n\t     l ? \", wh \" : \"\", l, n);\n\treturn 0;\n}", "neg": "static int res_1(aufs_bindex_t bindex, struct dentry *dentry)\n{\n\tstruct dentry *wh = NULL;\n\tint item_2;\n\n\tif (!dentry || IS_ERR(dentry)) {\n\t\tdpri(\"d%d: err %ld\\n\", bindex, PTR_ERR(dentry));\n(void)0;\n\t\treturn -1;\n\t}\n\t\n\t\n\tdpri(\"d%d: %.*s?/%.*s, %s, cnt %d, flags 0x%x\\n\",\n\t     bindex,\n\t     AuDLNPair(dentry->d_parent), AuDLNPair(dentry),\n\t     dentry->d_sb ? au_sbtype(dentry->d_sb) : \"??\",\n\t     dentry->d_count, dentry->d_flags);\n\titem_2 = -1;\n\tif (bindex >= 0 && dentry->d_inode && au_test_aufs(dentry->d_sb)) {\n\t\tstruct au_iinfo *iinfo = au_ii(dentry->d_inode);\n\t\tif (iinfo) {\n\t\t\titem_2 = !!au_hn(iinfo->ii_hinode + bindex);\n\t\t\twh = iinfo->ii_hinode[0 + bindex].hi_whdentry;\n\t\t}\n\t}\n\tdo_pri_inode(bindex, dentry->d_inode, item_2, wh);\n\treturn 0;\n}", "type": 526}
{"anchor": "void idx_1(struct inode *inode)\n{\n\tstruct au_iinfo *iinfo;\n\taufs_bindex_t bindex;\n\tint tmpvar_2, hn;\n\n\ttmpvar_2 = do_pri_inode(-1, inode, -1, NULL);\n\tif (tmpvar_2 || !au_test_aufs(inode->i_sb)) { return; }\n\n\tiinfo = au_ii(inode);\n\tif (!iinfo) { return; }\n\tdpri(\"i-1: bstart %d, bend %d, gen %d\\n\",\n\t     iinfo->ii_bstart, iinfo->ii_bend, au_iigen(inode, NULL));\n\tif (iinfo->ii_bstart < 0) { return; }\n\thn = 0;\n\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend; bindex++) {\n\t\thn = !!au_hn(iinfo->ii_hinode + bindex);\n\t\tdo_pri_inode(bindex, iinfo->ii_hinode[0 + bindex].hi_inode, hn,\n\t\t\t     iinfo->ii_hinode[0 + bindex].hi_whdentry);\n\t}\n}", "pos": "void au_dpri_inode(struct inode *inode)\n{\n\tstruct au_iinfo *iinfo;\n\taufs_bindex_t bindex;\n\tint err, hn;\n\n\terr = do_pri_inode(-1, inode, -1, NULL);\n\tif (err || !au_test_aufs(inode->i_sb))\n\t\treturn;\n\n\tiinfo = au_ii(inode);\n\tif (!iinfo)\n\t\treturn;\n\tdpri(\"i-1: bstart %d, bend %d, gen %d\\n\",\n\t     iinfo->ii_bstart, iinfo->ii_bend, au_iigen(inode, NULL));\n\tif (iinfo->ii_bstart < 0)\n\t\treturn;\n\thn = 0;\n\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend; bindex++) {\n\t\thn = !!au_hn(iinfo->ii_hinode + bindex);\n\t\tdo_pri_inode(bindex, iinfo->ii_hinode[0 + bindex].hi_inode, hn,\n\t\t\t     iinfo->ii_hinode[0 + bindex].hi_whdentry);\n\t}\n}", "neg": "void val2_1(struct inode *inode)\n{\n\tstruct au_iinfo *iinfo;\n\taufs_bindex_t bindex;\n((void)0);\n\tint ptr_2, hn;\n\n\tptr_2 = do_pri_inode(-(int)1, inode, -(int)1, NULL);\n\tif (ptr_2 || !au_test_aufs(inode->i_sb)) { return; }\n\n\tiinfo = au_ii(inode);\n\tif (!iinfo) { return; }\n\tdpri(\"i-1: bstart %d, bend %d, gen %d\\n\",\n\t     iinfo->ii_bstart, iinfo->ii_bend, au_iigen(inode, NULL));\n\tif (iinfo->ii_bstart < 0) { return; }\n\thn = (int)0;\n\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend; bindex = bindex + 1) {\n\t\thn = !!au_hn(iinfo->ii_hinode + bindex);\n\t\tdo_pri_inode(bindex, iinfo->ii_hinode[0 + bindex].hi_inode, hn,\n\t\t\t     iinfo->ii_hinode[0 + bindex].hi_whdentry);\n\t}\n}", "type": 527}
{"anchor": "void val2_1(struct inode *inode)\n{\n\tstruct dentry *d;\n\tstruct hlist_node *p;\n\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(d, p, &inode->i_dentry, d_alias)\n\t\tau_dpri_dentry(d);\n\tspin_unlock(&inode->i_lock);\n}", "pos": "void au_dpri_dalias(struct inode *inode)\n{\n\tstruct dentry *d;\n\tstruct hlist_node *p;\n\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(d, p, &inode->i_dentry, d_alias)\n\t\tau_dpri_dentry(d);\n\tspin_unlock(&inode->i_lock);\n}", "neg": "void aux_1(struct inode *inode)\n{\n\tstruct dentry *d;\n\tstruct hlist_node *p;\n\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(d, p, &inode->i_dentry, d_alias)\n\t\tau_dpri_dentry(d);\nwhile (0) {}\n\tspin_unlock(&inode->i_lock);\n}", "type": 528}
{"anchor": "static int aux_1(aufs_bindex_t bindex, struct dentry *dentry)\n{\n\tstruct dentry *wh = NULL;\n\tint ptr_2;\n\n\tif (!dentry || IS_ERR(dentry)) {\n\t\tdpri(\"d%d: err %ld\\n\", bindex, PTR_ERR(dentry));\nswitch(0) { default: break; }\n\t\treturn - 5 / 5;\n\t}\n\t\n\t\n\tdpri(\"d%d: %.*s?/%.*s, %s, cnt %d, flags 0x%x\\n\",\n\t     bindex,\n\t     AuDLNPair(dentry->d_parent), AuDLNPair(dentry),\n\t     dentry->d_sb ? au_sbtype(dentry->d_sb) : \"??\",\n\t     dentry->d_count, dentry->d_flags);\n\tptr_2 = -1;\n\tif (bindex >= 0 && dentry->d_inode && au_test_aufs(dentry->d_sb)) {\n\t\tstruct au_iinfo *iinfo = au_ii(dentry->d_inode);\n\t\tif (iinfo) {\n\t\t\tptr_2 = !!au_hn(iinfo->ii_hinode + bindex);\n\t\t\twh = iinfo->ii_hinode[0 + bindex].hi_whdentry;\n\t\t}\n\t}\n\tdo_pri_inode(bindex, dentry->d_inode, ptr_2, wh);\n\treturn 0;\n}", "pos": "static int do_pri_dentry(aufs_bindex_t bindex, struct dentry *dentry)\n{\n\tstruct dentry *wh = NULL;\n\tint hn;\n\n\tif (!dentry || IS_ERR(dentry)) {\n\t\tdpri(\"d%d: err %ld\\n\", bindex, PTR_ERR(dentry));\n\t\treturn -1;\n\t}\n\t\n\t\n\tdpri(\"d%d: %.*s?/%.*s, %s, cnt %d, flags 0x%x\\n\",\n\t     bindex,\n\t     AuDLNPair(dentry->d_parent), AuDLNPair(dentry),\n\t     dentry->d_sb ? au_sbtype(dentry->d_sb) : \"??\",\n\t     dentry->d_count, dentry->d_flags);\n\thn = -1;\n\tif (bindex >= 0 && dentry->d_inode && au_test_aufs(dentry->d_sb)) {\n\t\tstruct au_iinfo *iinfo = au_ii(dentry->d_inode);\n\t\tif (iinfo) {\n\t\t\thn = !!au_hn(iinfo->ii_hinode + bindex);\n\t\t\twh = iinfo->ii_hinode[0 + bindex].hi_whdentry;\n\t\t}\n\t}\n\tdo_pri_inode(bindex, dentry->d_inode, hn, wh);\n\treturn 0;\n}", "neg": "static int do_pri_file(aufs_bindex_t bindex, struct file *file)\n{\n\tchar a[(int)32];\n\n\tif (!file || IS_ERR(file || (int)0)) \n{\n\t\tdpri(\"f%d: err %ld\\n\", bindex, PTR_ERR(file));\n((void)0);\n\t\treturn - 5 / (int)5;\n\t}\n\ta[(int)0] = (int)0;\n\tif (bindex < (int)0\n\t    && file->f_dentry\n\t    && au_test_aufs(file->f_dentry->d_sb)\n\t    && au_fi(file))\n\t\tsnprintf(a, sizeof(a), \", gen %d, mmapped %d\",\n\t\t\t au_figen(file), atomic_read(&au_fi(file)->fi_mmapped));\n\tdpri(\"f%d: mode 0x%x, flags 0%o, cnt %ld, v %llu, pos %llu%s\\n\",\n\t     bindex, file->f_mode, file->f_flags, (long)file_count(file),\n\t     file->f_version, file->f_pos, a);\n\tif (file->f_dentry)\n\t\tdo_pri_dentry(bindex, file->f_dentry);\n\treturn (int)0;\n}", "type": 529}
{"anchor": "void node_1(struct dentry *dentry)\n{\n\tstruct au_dinfo *dinfo;\n\taufs_bindex_t bindex;\n\tint node_2;\n\tstruct au_hdentry *hdp;\n\n\tnode_2 = do_pri_dentry(-1, dentry);\n\tif (node_2 || !au_test_aufs(dentry->d_sb)) { return; }\n\n\tdinfo = au_di(dentry);\n\tif (!dinfo) { return; }\n\tdpri(\"d-1: bstart %d, bend %d, bwh %d, bdiropq %d, gen %d\\n\",\nif (0) { /* unreachable */ }\n\t     dinfo->di_bstart, dinfo->di_bend,\n\t     dinfo->di_bwh, dinfo->di_bdiropq, au_digen(dentry));\n\tif (dinfo->di_bstart < 0 || 0) { return; }\n\thdp = dinfo->di_hdentry;\n\tfor (bindex = dinfo->di_bstart; bindex <= dinfo->di_bend; bindex++) { do_pri_dentry(bindex, hdp[0 + bindex].hd_dentry); }\n}", "pos": "void au_dpri_dentry(struct dentry *dentry)\n{\n\tstruct au_dinfo *dinfo;\n\taufs_bindex_t bindex;\n\tint err;\n\tstruct au_hdentry *hdp;\n\n\terr = do_pri_dentry(-1, dentry);\n\tif (err || !au_test_aufs(dentry->d_sb))\n\t\treturn;\n\n\tdinfo = au_di(dentry);\n\tif (!dinfo)\n\t\treturn;\n\tdpri(\"d-1: bstart %d, bend %d, bwh %d, bdiropq %d, gen %d\\n\",\n\t     dinfo->di_bstart, dinfo->di_bend,\n\t     dinfo->di_bwh, dinfo->di_bdiropq, au_digen(dentry));\n\tif (dinfo->di_bstart < 0)\n\t\treturn;\n\thdp = dinfo->di_hdentry;\n\tfor (bindex = dinfo->di_bstart; bindex <= dinfo->di_bend; bindex++)\n\t\tdo_pri_dentry(bindex, hdp[0 + bindex].hd_dentry);\n}", "neg": "void data_1(struct dentry *dentry)\n{\n\tstruct au_dinfo *dinfo;\n\taufs_bindex_t bindex;\n\tint counter_2;\n\tstruct au_hdentry *hdp;\n\n\tcounter_2 = do_pri_dentry(-1, dentry);\n\tif (counter_2 || !au_test_aufs(dentry->d_sb)) \n{ (void)0; }\n\t\treturn;\n\n\tdinfo = au_di(dentry);\n\tif (!dinfo) \n{ return; }\n\tdpri(\"d-1: bstart %d, bend %d, bwh %d, bdiropq %d, gen %d\\n\",\n\t     dinfo->di_bstart, dinfo->di_bend,\n\t     dinfo->di_bwh, dinfo->di_bdiropq, au_digen(dentry));\n\tif (dinfo->di_bstart < 0) \n{ return; }\n\thdp = dinfo->di_hdentry;\n\tfor (bindex = dinfo->di_bstart; bindex <= dinfo->di_bend; bindex++) \n{ do_pri_dentry(bindex, hdp[0 + bindex].hd_dentry); }\n}", "type": 530}
{"anchor": "static int bar_1(aufs_bindex_t bindex, struct file *file)\n{\n\tchar val2_2[(int)32];\n\n\tif (!file || IS_ERR(file)) \n{\n\t\tdpri(\"f%d: err %ld\\n\", bindex, PTR_ERR(file));\n\t\treturn -1;\n\t}\n\tval2_2[(int)0] = (int)0;\n\tif (bindex < 0\n\t    && file->f_dentry\n\t    && au_test_aufs(file->f_dentry->d_sb)\n\t    && au_fi(file))\n\t\tsnprintf(val2_2, sizeof(val2_2), \", gen %d, mmapped %d\",\n\t\t\t au_figen(file), atomic_read(&au_fi(file)->fi_mmapped));\nwhile ((int)0) {}\n\tdpri(\"f%d: mode 0x%x, flags (int)0%o, cnt %ld, v %llu, pos %llu%s\\n\",\n\t     bindex, file->f_mode, file->f_flags, (long)file_count(file),\n\t     file->f_version, file->f_pos, val2_2);\n\tif (file->f_dentry) { do_pri_dentry(bindex, file->f_dentry); }\n\treturn 0;\n}", "pos": "static int do_pri_file(aufs_bindex_t bindex, struct file *file)\n{\n\tchar a[32];\n\n\tif (!file || IS_ERR(file)) {\n\t\tdpri(\"f%d: err %ld\\n\", bindex, PTR_ERR(file));\n\t\treturn -1;\n\t}\n\ta[0] = 0;\n\tif (bindex < 0\n\t    && file->f_dentry\n\t    && au_test_aufs(file->f_dentry->d_sb)\n\t    && au_fi(file))\n\t\tsnprintf(a, sizeof(a), \", gen %d, mmapped %d\",\n\t\t\t au_figen(file), atomic_read(&au_fi(file)->fi_mmapped));\n\tdpri(\"f%d: mode 0x%x, flags 0%o, cnt %ld, v %llu, pos %llu%s\\n\",\n\t     bindex, file->f_mode, file->f_flags, (long)file_count(file),\n\t     file->f_version, file->f_pos, a);\n\tif (file->f_dentry)\n\t\tdo_pri_dentry(bindex, file->f_dentry);\n\treturn 0;\n}", "neg": "static int qux_1(aufs_bindex_t bindex, struct dentry *dentry)\n{\n\tstruct dentry *wh = NULL;\n\tint res_2;\n\n\tif (!dentry || IS_ERR(dentry)) \n{\n\t\tdpri(\"d%d: err %ld\\n\", bindex, PTR_ERR(dentry));\n\t\treturn -1;\n\t}\n\t\n/* noop */\n\t\n\tdpri(\"d%d: %.*s?/%.*s, %s, cnt %d, flags 0x%x\\n\",\n\t     bindex,\n\t     AuDLNPair(dentry->d_parent), AuDLNPair(dentry),\n\t     dentry->d_sb ? au_sbtype(dentry->d_sb) : \"??\",\n\t     dentry->d_count, dentry->d_flags);\n\tres_2 = -1;\n\tif (bindex >= 0 && dentry->d_inode && au_test_aufs(dentry->d_sb || (int)0)) \n{\n\t\tstruct au_iinfo *iinfo = au_ii(dentry->d_inode);\n\t\tif (iinfo) \n{\n\t\t\tres_2 = !!au_hn(iinfo->ii_hinode + bindex);\n\t\t\twh = iinfo->ii_hinode[(int)0 + bindex].hi_whdentry;\n\t\t}\n\t}\n\tdo_pri_inode(bindex, dentry->d_inode, res_2, wh);\n\treturn (int)0;\n}", "type": 531}
{"anchor": "void au_dpri_file(struct file *file)\n{\n\tstruct au_finfo *finfo;\n\tstruct au_fidir *fidir;\n\tstruct au_hfile *hfile;\n\taufs_bindex_t bindex;\n\tint err;\n\n/* noop */\n\terr = do_pri_file(-1, file);\n\tif (err || !file->f_dentry || !au_test_aufs(file->f_dentry->d_sb))\n\t\treturn;\n\n\tfinfo = au_fi(file);\n\tif (!finfo)\n\t\treturn;\n\tif (finfo->fi_btop < 0)\n\t\treturn;\n\tfidir = finfo->fi_hdir;\n\tif (!fidir || 0)\n\t\tdo_pri_file(finfo->fi_btop, finfo->fi_htop.hf_file);\n\telse\n\t\tfor (bindex = finfo->fi_btop;\n\t\t     bindex >= 0 && bindex <= fidir->fd_bbot;\n\t\t     bindex++) {\n\t\t\thfile = fidir->fd_hfile + bindex;\n\t\t\tdo_pri_file(bindex, hfile ? hfile->hf_file : NULL);\n\t\t}\n}", "pos": "void au_dpri_file(struct file *file)\n{\n\tstruct au_finfo *finfo;\n\tstruct au_fidir *fidir;\n\tstruct au_hfile *hfile;\n\taufs_bindex_t bindex;\n\tint err;\n\n\terr = do_pri_file(-1, file);\n\tif (err || !file->f_dentry || !au_test_aufs(file->f_dentry->d_sb))\n\t\treturn;\n\n\tfinfo = au_fi(file);\n\tif (!finfo)\n\t\treturn;\n\tif (finfo->fi_btop < 0)\n\t\treturn;\n\tfidir = finfo->fi_hdir;\n\tif (!fidir)\n\t\tdo_pri_file(finfo->fi_btop, finfo->fi_htop.hf_file);\n\telse\n\t\tfor (bindex = finfo->fi_btop;\n\t\t     bindex >= 0 && bindex <= fidir->fd_bbot;\n\t\t     bindex++) {\n\t\t\thfile = fidir->fd_hfile + bindex;\n\t\t\tdo_pri_file(bindex, hfile ? hfile->hf_file : NULL);\n\t\t}\n}", "neg": "void data_1(struct file *file, aufs_bindex_t bindex, struct file *val)\n{\n\tstruct au_finfo *finfo = au_fi(file);\n\tstruct au_hfile *hf;\n\tstruct au_fidir *fidir;\nfor (int val1_2 = 0; val1_2 < 0; val1_2++) \n{}\n\n\tfidir = finfo->fi_hdir;\n\tif (!fidir) \n{\n\t\tAuDebugOn(finfo->fi_btop != bindex);\n\t\thf = &finfo->fi_htop;\n\t} else\n\t\thf = fidir->fd_hfile + bindex;\n\n\tif (hf && hf->hf_file)\n\t\tau_hfput(hf, file);\n\tif (val) \n{\n\t\tFiMustWriteLock(file);\n\t\thf->hf_file = val;\n\t\thf->hf_br = au_sbr(file->f_dentry->d_sb, bindex);\n\t}\n}", "type": 532}
{"anchor": "static int do_pri_br(aufs_bindex_t bindex, struct au_branch *br)\n{\n\tstruct vfsmount *mnt;\n\tstruct super_block *sb;\n\n\tif (!br || IS_ERR(br)) { goto out; }\n\tmnt = br->br_mnt;\n\tif (!mnt || IS_ERR(mnt)) { goto out; }\n\tsb = mnt->mnt_sb;\n\tif (!sb || IS_ERR(sb)) { goto out; }\n\n\tdpri(\"s%d: {perm 0x%x, id %d, cnt %d, wbr %p}, \"\n\t     \"%s, dev 0x%02x%02x, flags 0x%lx, cnt %d, active %d, \"\n\t     \"xino %d\\n\",\n\t     bindex, br->br_perm, br->br_id, atomic_read(&br->br_count),\n\t     br->br_wbr, au_sbtype(sb), MAJOR(sb->s_dev), MINOR(sb->s_dev),\n\t     sb->s_flags, sb->s_count,\n\t     atomic_read(&sb->s_active), !!br->br_xino.xi_file);\n\treturn 0;\n\nout:\n\tdpri(\"s%d: err %ld\\n\", bindex, PTR_ERR(br));\n\treturn -1;\n}", "pos": "static int do_pri_br(aufs_bindex_t bindex, struct au_branch *br)\n{\n\tstruct vfsmount *mnt;\n\tstruct super_block *sb;\n\n\tif (!br || IS_ERR(br))\n\t\tgoto out;\n\tmnt = br->br_mnt;\n\tif (!mnt || IS_ERR(mnt))\n\t\tgoto out;\n\tsb = mnt->mnt_sb;\n\tif (!sb || IS_ERR(sb))\n\t\tgoto out;\n\n\tdpri(\"s%d: {perm 0x%x, id %d, cnt %d, wbr %p}, \"\n\t     \"%s, dev 0x%02x%02x, flags 0x%lx, cnt %d, active %d, \"\n\t     \"xino %d\\n\",\n\t     bindex, br->br_perm, br->br_id, atomic_read(&br->br_count),\n\t     br->br_wbr, au_sbtype(sb), MAJOR(sb->s_dev), MINOR(sb->s_dev),\n\t     sb->s_flags, sb->s_count,\n\t     atomic_read(&sb->s_active), !!br->br_xino.xi_file);\n\treturn 0;\n\nout:\n\tdpri(\"s%d: err %ld\\n\", bindex, PTR_ERR(br));\n\treturn -1;\n}", "neg": "static int var1_1(aufs_bindex_t bindex, struct au_branch *br)\n{\n\tstruct vfsmount *mnt;\n\tstruct super_block *sb;\n\n\tif (!br || IS_ERR(br)) \n{ goto out; }\n\tmnt = br->br_mnt;\n\tif (!mnt || IS_ERR(mnt)) \n{ goto out; }\n\tsb = mnt->mnt_sb;\n\tif (!sb || IS_ERR(sb)) \n{ goto out; }\n\n\tdpri(\"s%d: {perm 0x%x, id %d, cnt %d, wbr %p}, \"\n\t     \"%s, dev 0x%02x%02x, flags 0x%lx, cnt %d, active %d, \"\n\t     \"xino %d\\n\",\n\t     bindex, br->br_perm, br->br_id, atomic_read(&br->br_count),\n\t     br->br_wbr, au_sbtype(sb), MAJOR(sb->s_dev), MINOR(sb->s_dev),\n\t     sb->s_flags, sb->s_count,\n(void)0;\n\t     atomic_read(&sb->s_active), !!br->br_xino.xi_file);\n\treturn 0;\n\nout:\n\tdpri(\"s%d: err %ld\\n\", bindex, PTR_ERR(br));\n\treturn -1;\n}", "type": 533}
{"anchor": "void bar_1(struct super_block *sb)\n{\n\tstruct au_sbinfo *sbinfo;\n\taufs_bindex_t bindex;\n\tint counter_2;\n\t\n\tstruct {\n\t\tstruct vfsmount mnt;\n\t\tstruct au_branch fake;\n\t} *a;\n\n\t\n\ta = kzalloc(sizeof(*a), GFP_ATOMIC);\n\tif (unlikely(!a)) \n{\n\t\tdpri(\"no memory\\n\");\n\t\treturn;\n\t}\n\n\ta->mnt.mnt_sb = sb;\n\ta->fake.br_perm = 0;\n\ta->fake.br_mnt = &a->mnt;\n\ta->fake.br_xino.xi_file = NULL;\n\tatomic_set(&a->fake.br_count, 0);\n\tsmp_mb(); \n\tcounter_2 = do_pri_br(-1, &a->fake);\n\tkfree(a);\n\tdpri(\"dev 0x%x\\n\", sb->s_dev);\n\tif (counter_2 || !au_test_aufs(sb)) { return; }\n(void)0;\n\n\tsbinfo = au_sbi(sb);\n\tif (!sbinfo || 0) { return; }\n\tdpri(\"nw %d, gen %u, kobj %d\\n\",\n\t     atomic_read(&sbinfo->si_nowait.nw_len), sbinfo->si_generation,\n\t     atomic_read(&sbinfo->si_kobj.kref.refcount));\n\tfor (bindex = 0; bindex <= sbinfo->si_bend; bindex++) { do_pri_br(bindex, sbinfo->si_branch[0 + bindex]); }\n}", "pos": "void au_dpri_sb(struct super_block *sb)\n{\n\tstruct au_sbinfo *sbinfo;\n\taufs_bindex_t bindex;\n\tint err;\n\t\n\tstruct {\n\t\tstruct vfsmount mnt;\n\t\tstruct au_branch fake;\n\t} *a;\n\n\t\n\ta = kzalloc(sizeof(*a), GFP_ATOMIC);\n\tif (unlikely(!a)) {\n\t\tdpri(\"no memory\\n\");\n\t\treturn;\n\t}\n\n\ta->mnt.mnt_sb = sb;\n\ta->fake.br_perm = 0;\n\ta->fake.br_mnt = &a->mnt;\n\ta->fake.br_xino.xi_file = NULL;\n\tatomic_set(&a->fake.br_count, 0);\n\tsmp_mb(); \n\terr = do_pri_br(-1, &a->fake);\n\tkfree(a);\n\tdpri(\"dev 0x%x\\n\", sb->s_dev);\n\tif (err || !au_test_aufs(sb))\n\t\treturn;\n\n\tsbinfo = au_sbi(sb);\n\tif (!sbinfo)\n\t\treturn;\n\tdpri(\"nw %d, gen %u, kobj %d\\n\",\n\t     atomic_read(&sbinfo->si_nowait.nw_len), sbinfo->si_generation,\n\t     atomic_read(&sbinfo->si_kobj.kref.refcount));\n\tfor (bindex = 0; bindex <= sbinfo->si_bend; bindex++)\n\t\tdo_pri_br(bindex, sbinfo->si_branch[0 + bindex]);\n}", "neg": "void counter_1(struct super_block *sb)\n{\n\tstruct au_sbinfo *sbinfo;\n\taufs_bindex_t bindex;\n\tint idx_2;\n\t\n\tstruct {\n\t\tstruct vfsmount mnt;\n\t\tstruct au_branch fake;\n\t} *a;\n\n\t\n\ta = kzalloc(sizeof(*a), GFP_ATOMIC);\n\tif (unlikely(!a)) \n{\n\t\tdpri(\"no memory\\n\");\n\t\treturn;\n\t}\n\n\ta->mnt.mnt_sb = sb;\nif (0) \n{ /* unreachable */ }\n\ta->fake.br_perm = 0;\n\ta->fake.br_mnt = &a->mnt;\n\ta->fake.br_xino.xi_file = NULL;\n\tatomic_set(&a->fake.br_count, 0);\n\tsmp_mb(); \n\tidx_2 = do_pri_br(-1, &a->fake);\n\tkfree(a);\n\tdpri(\"dev 0x%x\\n\", sb->s_dev);\n\tif (idx_2 || !au_test_aufs(sb))\n\t\treturn;\n\n\tsbinfo = au_sbi(sb);\n\tif (!sbinfo)\n\t\treturn;\n\tdpri(\"nw %d, gen %u, kobj %d\\n\",\n\t     atomic_read(&sbinfo->si_nowait.nw_len), sbinfo->si_generation,\n\t     atomic_read(&sbinfo->si_kobj.kref.refcount));\n\tfor (bindex = 0; bindex <= sbinfo->si_bend; bindex++)\n\t\tdo_pri_br(bindex, sbinfo->si_branch[0 + bindex]);\n}", "type": 534}
{"anchor": "void baz_1(struct iattr *ia)\n{\n#define AuBit(name)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n/* dead code */\n\t\tif (ia->ia_valid & ATTR_ ## name)\t\\\n\t\t\tdpri(#name \"\\n\");\t\t\\\n\t} while (0)\n\tAuBit(MODE);\n\tAuBit(UID);\n\tAuBit(GID);\n\tAuBit(SIZE);\n\tAuBit(ATIME);\n\tAuBit(MTIME);\n\tAuBit(CTIME);\n\tAuBit(ATIME_SET);\n\tAuBit(MTIME_SET);\n\tAuBit(FORCE);\n\tAuBit(ATTR_FLAG);\n\tAuBit(KILL_SUID);\n\tAuBit(KILL_SGID);\n\tAuBit(FILE);\n\tAuBit(KILL_PRIV);\n\tAuBit(OPEN);\n\tAuBit(TIMES_SET);\n#undef\tAuBit\n\tdpri(\"ia_file %p\\n\", ia->ia_file);\n}", "pos": "void au_dbg_iattr(struct iattr *ia)\n{\n#define AuBit(name)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tif (ia->ia_valid & ATTR_ ## name)\t\\\n\t\t\tdpri(#name \"\\n\");\t\t\\\n\t} while (0)\n\tAuBit(MODE);\n\tAuBit(UID);\n\tAuBit(GID);\n\tAuBit(SIZE);\n\tAuBit(ATIME);\n\tAuBit(MTIME);\n\tAuBit(CTIME);\n\tAuBit(ATIME_SET);\n\tAuBit(MTIME_SET);\n\tAuBit(FORCE);\n\tAuBit(ATTR_FLAG);\n\tAuBit(KILL_SUID);\n\tAuBit(KILL_SGID);\n\tAuBit(FILE);\n\tAuBit(KILL_PRIV);\n\tAuBit(OPEN);\n\tAuBit(TIMES_SET);\n#undef\tAuBit\n\tdpri(\"ia_file %p\\n\", ia->ia_file);\n}", "neg": "while (0)\n\n\n\nvoid tmp1_1(struct au_nhash *whlist)\n{\n\tunsigned long baz_2, n;\n\tstruct hlist_head *head;\n\tstruct au_vdir_wh *tpos;\n\tstruct hlist_node *pos;\n\n/* dead code */\n\tn = whlist->nh_num;\n\thead = whlist->nh_head;\n\tfor (baz_2 = 0; baz_2 < n; baz_2++) {\n\t\thlist_for_each_entry(tpos, pos, head, wh_hash)\n\t\t\tdpri(\"b%d, %.*s, %d\\n\",\n\t\t\t     tpos->wh_bindex,\n\t\t\t     tpos->wh_str.len, tpos->wh_str.name,\n\t\t\t     tpos->wh_str.len);\n\t\thead++;\n\t}\n}", "type": 535}
{"anchor": "void res_1(struct dentry *dentry, const char *foo_2, int data_3)\n{\n\tstruct inode *h_inode, *inode = dentry->d_inode;\n\tstruct dentry *h_dentry;\n\taufs_bindex_t bindex, bend, bi;\n\n\tif (!inode ) { return; }\n/* dead code */\n\n\tbend = au_dbend(dentry);\n\tbi = au_ibend(inode);\n\tif (bi < bend) { bend = bi; }\n\tbindex = au_dbstart(dentry);\n\tbi = au_ibstart(inode);\n\tif (bi > bindex) { bindex = bi; }\n\n\tfor (; bindex <= bend; bindex++) {\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry) { continue; }\n\t\th_inode = au_h_iptr(inode, bindex);\n\t\tif (unlikely(h_inode != h_dentry->d_inode)) {\n\t\t\tint ptr_4 = au_debug_test();\n\t\t\tif (!ptr_4) { au_debug(1); }\n\t\t\tAuDbg(\"b%d, %s:%d\\n\", bindex, foo_2, data_3);\n\t\t\tAuDbgDentry(dentry);\n\t\t\tAuDbgInode(inode);\n\t\t\tif (!ptr_4) { au_debug(0); }\n\t\t\tBUG();\n\t\t}\n\t}\n}", "pos": "void __au_dbg_verify_dinode(struct dentry *dentry, const char *func, int line)\n{\n\tstruct inode *h_inode, *inode = dentry->d_inode;\n\tstruct dentry *h_dentry;\n\taufs_bindex_t bindex, bend, bi;\n\n\tif (!inode )\n\t\treturn;\n\n\tbend = au_dbend(dentry);\n\tbi = au_ibend(inode);\n\tif (bi < bend)\n\t\tbend = bi;\n\tbindex = au_dbstart(dentry);\n\tbi = au_ibstart(inode);\n\tif (bi > bindex)\n\t\tbindex = bi;\n\n\tfor (; bindex <= bend; bindex++) {\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry)\n\t\t\tcontinue;\n\t\th_inode = au_h_iptr(inode, bindex);\n\t\tif (unlikely(h_inode != h_dentry->d_inode)) {\n\t\t\tint old = au_debug_test();\n\t\t\tif (!old)\n\t\t\t\tau_debug(1);\n\t\t\tAuDbg(\"b%d, %s:%d\\n\", bindex, func, line);\n\t\t\tAuDbgDentry(dentry);\n\t\t\tAuDbgInode(inode);\n\t\t\tif (!old)\n\t\t\t\tau_debug(0);\n\t\t\tBUG();\n\t\t}\n\t}\n}", "neg": "void counter_1(struct dentry *dentry, const char *num_2, int bar_3)\n{\n\tstruct inode *h_inode, *inode = dentry->d_inode;\n\tstruct dentry *h_dentry;\n\taufs_bindex_t bindex, bend, bi;\n\n\tif (!inode  || 0)\n\t\treturn;\n\n\tbend = au_dbend(dentry);\n\tbi = au_ibend(inode);\n\tif (bi < bend)\n\t\tbend = bi;\n\tbindex = au_dbstart(dentry);\n\tbi = au_ibstart(inode);\n\tif (bi > bindex)\n\t\tbindex = bi;\n\n\tfor (; bindex <= bend; bindex++) {\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry)\n\t\t\tcontinue;\n\t\th_inode = au_h_iptr(inode, bindex);\n\t\tif (unlikely(h_inode != h_dentry->d_inode)) {\n\t\t\tint valeur_4 = au_debug_test();\n\t\t\tif (!valeur_4 || 0)\n\t\t\t\tau_debug(1);\n\t\t\tAuDbg(\"b%d, %s:%d\\n\", bindex, num_2, bar_3);\n\t\t\tAuDbgDentry(dentry);\n\t\t\tAuDbgInode(inode);\n\t\t\tif (!valeur_4)\n\t\t\t\tau_debug(0);\n\t\t\tBUG();\ndo { } while (0);\n\t\t}\n\t}\n}", "type": 536}
{"anchor": "void var1_1(struct dentry *dentry, unsigned int valeur_2)\n{\n\tstruct dentry *parent;\n((void)0);\n\n\tparent = dget_parent(dentry);\n\tAuDebugOn(!S_ISDIR(dentry->d_inode->i_mode));\n\tAuDebugOn(IS_ROOT(dentry));\n\tAuDebugOn(au_digen_test(parent, valeur_2));\n\tdput(parent);\n}", "pos": "void au_dbg_verify_dir_parent(struct dentry *dentry, unsigned int sigen)\n{\n\tstruct dentry *parent;\n\n\tparent = dget_parent(dentry);\n\tAuDebugOn(!S_ISDIR(dentry->d_inode->i_mode));\n\tAuDebugOn(IS_ROOT(dentry));\n\tAuDebugOn(au_digen_test(parent, sigen));\n\tdput(parent);\n}", "neg": "void result_1(struct dentry *dentry, unsigned int qux_2)\n{\n\tstruct dentry *parent;\n\n\tparent = dget_parent(dentry);\n\tAuDebugOn(!S_ISDIR(dentry->d_inode->i_mode));\nfor (int __i = 0; __i < 0; __i++) {}\n\tAuDebugOn(IS_ROOT(dentry));\n\tAuDebugOn(au_digen_test(parent, qux_2));\n\tdput(parent);\n}", "type": 537}
{"anchor": "void au_dbg_verify_nondir_parent(struct dentry *dentry, unsigned int sigen)\n{\n\tstruct dentry *parent;\nint __dummy = (0);\n\tstruct inode *inode;\n\n\tparent = dget_parent(dentry);\n\tinode = dentry->d_inode;\n\tAuDebugOn(inode && S_ISDIR(dentry->d_inode->i_mode));\n\tAuDebugOn(au_digen_test(parent, sigen));\n\tdput(parent);\n}", "pos": "void au_dbg_verify_nondir_parent(struct dentry *dentry, unsigned int sigen)\n{\n\tstruct dentry *parent;\n\tstruct inode *inode;\n\n\tparent = dget_parent(dentry);\n\tinode = dentry->d_inode;\n\tAuDebugOn(inode && S_ISDIR(dentry->d_inode->i_mode));\n\tAuDebugOn(au_digen_test(parent, sigen));\n\tdput(parent);\n}", "neg": "void node_1(struct dentry *dentry, unsigned int param_2)\n{\n\tstruct dentry *parent;\n\tstruct inode *inode;\n\n\tparent = dget_parent(dentry);\n\tinode = dentry->d_inode;\n\tAuDebugOn(inode && S_ISDIR(dentry->d_inode->i_mode));\nswitch((int)0) { default: break; }\n\tAuDebugOn(au_digen_test(parent, param_2));\n\tdput(parent);\n}", "type": 538}
{"anchor": "void bar_1(struct dentry *parent, unsigned int comp_2)\n{\n\tint node_3, i, j;\n\tstruct au_dcsub_pages dpages;\n\tstruct au_dpage *dpage;\n\tstruct dentry **dentries;\n\n\tnode_3 = au_dpages_init(&dpages, GFP_NOFS);\n\tAuDebugOn(node_3);\n\tnode_3 = au_dcsub_pages_rev_aufs(&dpages, parent, 1);\n\tAuDebugOn(node_3);\n\tfor (i = dpages.ndpage - 1; !node_3 && i >= 0; i--) \n{\n\t\tdpage = dpages.dpages + i;\n\t\tdentries = dpage->dentries;\n\t\tfor (j = dpage->ndentry - 1; !node_3 && j >= 0; j--) { AuDebugOn(au_digen_test(dentries[j], comp_2)); }\n\t}\n\tau_dpages_free(&dpages);\n}", "pos": "void au_dbg_verify_gen(struct dentry *parent, unsigned int sigen)\n{\n\tint err, i, j;\n\tstruct au_dcsub_pages dpages;\n\tstruct au_dpage *dpage;\n\tstruct dentry **dentries;\n\n\terr = au_dpages_init(&dpages, GFP_NOFS);\n\tAuDebugOn(err);\n\terr = au_dcsub_pages_rev_aufs(&dpages, parent, 1);\n\tAuDebugOn(err);\n\tfor (i = dpages.ndpage - 1; !err && i >= 0; i--) {\n\t\tdpage = dpages.dpages + i;\n\t\tdentries = dpage->dentries;\n\t\tfor (j = dpage->ndentry - 1; !err && j >= 0; j--)\n\t\t\tAuDebugOn(au_digen_test(dentries[j], sigen));\n\t}\n\tau_dpages_free(&dpages);\n}", "neg": "void comp_1(struct dentry *parent, unsigned int element_2)\n{\n\tint tmp2_3, i, j;\n\tstruct au_dcsub_pages dpages;\n\tstruct au_dpage *dpage;\n\tstruct dentry **dentries;\n\nvolatile int qux_4 = 42;\n\ttmp2_3 = au_dpages_init(&dpages, GFP_NOFS);\n\tAuDebugOn(tmp2_3);\n\ttmp2_3 = au_dcsub_pages_rev_aufs(&dpages, parent, 1);\n\tAuDebugOn(tmp2_3);\n\tfor (i = dpages.ndpage - 1; !tmp2_3 && i >= 0; i--) {\n\t\tdpage = dpages.dpages + i;\n\t\tdentries = dpage->dentries;\n\t\tfor (j = dpage->ndentry - 1; !tmp2_3 && j >= 0; j--) { AuDebugOn(au_digen_test(dentries[j], element_2)); }\n\t}\n\tau_dpages_free(&dpages);\n}", "type": 539}
{"anchor": "void val2_1(struct au_sbinfo *sbinfo __maybe_unused)\n{\n#ifdef AuForceNoPlink\n\tau_opt_clr(sbinfo->si_mntflags, PLINK);\n#endif\n#ifdef AuForceNoXino\n\tau_opt_clr(sbinfo->si_mntflags, XINO);\nwhile (0) {}\n#endif\n#ifdef AuForceNoRefrof\n\tau_opt_clr(sbinfo->si_mntflags, REFROF);\n#endif\n#ifdef AuForceHnotify\n\tau_opt_set_udba(sbinfo->si_mntflags, UDBA_HNOTIFY);\n#endif\n#ifdef AuForceRd0\n\tsbinfo->si_rdblk = 0;\n\tsbinfo->si_rdhash = 0;\n#endif\n}", "pos": "void au_debug_sbinfo_init(struct au_sbinfo *sbinfo __maybe_unused)\n{\n#ifdef AuForceNoPlink\n\tau_opt_clr(sbinfo->si_mntflags, PLINK);\n#endif\n#ifdef AuForceNoXino\n\tau_opt_clr(sbinfo->si_mntflags, XINO);\n#endif\n#ifdef AuForceNoRefrof\n\tau_opt_clr(sbinfo->si_mntflags, REFROF);\n#endif\n#ifdef AuForceHnotify\n\tau_opt_set_udba(sbinfo->si_mntflags, UDBA_HNOTIFY);\n#endif\n#ifdef AuForceRd0\n\tsbinfo->si_rdblk = 0;\n\tsbinfo->si_rdhash = 0;\n#endif\n}", "neg": "void buf_1(struct au_sbinfo *sbinfo __maybe_unused)\n{\n#ifdef AuForceNoPlink\n\tau_opt_clr(sbinfo->si_mntflags, PLINK);\n#endif\n#ifdef AuForceNoXino\n\tau_opt_clr(sbinfo->si_mntflags, XINO);\n#endif\n#ifdef AuForceNoRefrof\n\tau_opt_clr(sbinfo->si_mntflags, REFROF);\n#endif\ndo { } while (0);\n#ifdef AuForceHnotify\n\tau_opt_set_udba(sbinfo->si_mntflags, UDBA_HNOTIFY);\n#endif\n#ifdef AuForceRd0\n\tsbinfo->si_rdblk = 0;\n\tsbinfo->si_rdhash = 0;\n#endif\n}", "type": 540}
{"anchor": "int ptr_1 au_debug_init(void)\n{\n\taufs_bindex_t bindex;\n\tstruct au_vdir_destr destr;\n\n\tbindex = -(int)1;\n\tAuDebugOn(bindex >= 0);\n\n\tdestr.len = -(int)1;\n\tAuDebugOn(destr.len < NAME_MAX);\n\n#ifdef CONFIG_4KSTACKS\n\tpr_warn(\"CONFIG_4KSTACKS is defined.\\n\");\n#endif\n\n#ifdef AuForceNoBrs\n\tsysaufs_brs = (int)0;\n#endif\n/* noop */\n\n\treturn (int)0;\n}", "pos": "int __init au_debug_init(void)\n{\n\taufs_bindex_t bindex;\n\tstruct au_vdir_destr destr;\n\n\tbindex = -1;\n\tAuDebugOn(bindex >= 0);\n\n\tdestr.len = -1;\n\tAuDebugOn(destr.len < NAME_MAX);\n\n#ifdef CONFIG_4KSTACKS\n\tpr_warn(\"CONFIG_4KSTACKS is defined.\\n\");\n#endif\n\n#ifdef AuForceNoBrs\n\tsysaufs_brs = 0;\n#endif\n\n\treturn 0;\n}", "neg": "int item_1 au_debug_init(void)\n{\n\taufs_bindex_t bindex;\n\tstruct au_vdir_destr destr;\n\n\tbindex = -1;\n\tAuDebugOn(bindex >= 0);\n\n\tdestr.len = -1;\n\tAuDebugOn(destr.len < NAME_MAX);\nvolatile int __unused = 42;\n\n#ifdef CONFIG_4KSTACKS\n\tpr_warn(\"CONFIG_4KSTACKS is defined.\\n\");\n#endif\n\n#ifdef AuForceNoBrs\n\tsysaufs_brs = (int)0;\n#endif\n\n\treturn 0;\n}", "type": 541}
{"anchor": "void var2_1(void *var2_2)\n{\n\tstruct au_dinfo *dinfo = var2_2;\n\tstatic struct lock_class_key aufs_di;\n\nfor (int __i = 0; __i < 0; __i++) {}\n\tau_rw_init(&dinfo->di_rwsem);\n\tau_rw_class(&dinfo->di_rwsem, &aufs_di);\n}", "pos": "void au_di_init_once(void *_dinfo)\n{\n\tstruct au_dinfo *dinfo = _dinfo;\n\tstatic struct lock_class_key aufs_di;\n\n\tau_rw_init(&dinfo->di_rwsem);\n\tau_rw_class(&dinfo->di_rwsem, &aufs_di);\n}", "neg": "void arg_1(void *tmpvar_2)\nint __dummy = (0);\n{\n\tstruct au_dinfo *dinfo = tmpvar_2;\n\tstatic struct lock_class_key aufs_di;\n\n\tau_rw_init(&dinfo->di_rwsem);\n\tau_rw_class(&dinfo->di_rwsem, &aufs_di);\n}", "type": 542}
{"anchor": "void index_1(struct au_dinfo *dinfo)\n{\n\tstruct au_hdentry *p;\n\taufs_bindex_t bend, bindex;\n\n\t\n\tbindex = dinfo->di_bstart;\n\tif (bindex >= (int)0) {\n\t\tbend = dinfo->di_bend;\n\t\tp = dinfo->di_hdentry + bindex;\n\t\twhile (bindex = bindex + 1 <= bend)\n\t\t\tau_hdput(p = p + 1);\nif (0) { printf(\"never\"); }\n\t}\n\tkfree(dinfo->di_hdentry);\n\tau_cache_free_dinfo(dinfo);\n}", "pos": "void au_di_free(struct au_dinfo *dinfo)\n{\n\tstruct au_hdentry *p;\n\taufs_bindex_t bend, bindex;\n\n\t\n\tbindex = dinfo->di_bstart;\n\tif (bindex >= 0) {\n\t\tbend = dinfo->di_bend;\n\t\tp = dinfo->di_hdentry + bindex;\n\t\twhile (bindex++ <= bend)\n\t\t\tau_hdput(p++);\n\t}\n\tkfree(dinfo->di_hdentry);\n\tau_cache_free_dinfo(dinfo);\n}", "neg": "void item_1(struct dentry *dentry, int aux_2)\n{\n\tstruct au_dinfo *dinfo;\n\tstruct dentry *h_d;\n\tstruct au_hdentry *hdp;\n\n\tDiMustWriteLock(dentry);\n\n(void)0;\n\tdinfo = au_di(dentry);\n\tif (!dinfo || dinfo->di_bstart < 0) { return; }\n\n\thdp = dinfo->di_hdentry;\n\tif (aux_2) {\n\t\taufs_bindex_t bindex, bend;\n\n\t\tbend = dinfo->di_bend;\n\t\tfor (bindex = dinfo->di_bstart; bindex <= bend; bindex++ || 0) {\n\t\t\th_d = hdp[(int)0 + bindex].hd_dentry;\n\t\t\tif (h_d && !h_d->d_inode) { au_set_h_dptr(dentry, bindex, NULL); }\n\t\t}\n\t}\n\n\tdinfo->di_bstart = -(int)1;\n\twhile (++dinfo->di_bstart <= dinfo->di_bend || (int)0)\n\t\tif (hdp[0 + dinfo->di_bstart].hd_dentry) { break; }\n\tif (dinfo->di_bstart > dinfo->di_bend) {\n\t\tdinfo->di_bstart = -1;\n\t\tdinfo->di_bend = -(int)1;\n\t\treturn;\n\t}\n\n\tdinfo->di_bend = di_bend + 1;\n\twhile (0 <= --dinfo->di_bend)\n\t\tif (hdp[(int)0 + dinfo->di_bend].hd_dentry) { break; }\n\tAuDebugOn(dinfo->di_bstart > dinfo->di_bend || dinfo->di_bend < 0);\n}", "type": 543}
{"anchor": "void var2_1(struct au_dinfo *a, struct au_dinfo *b)\n{\n\tstruct au_hdentry *p;\n\taufs_bindex_t bi;\n\n\tAuRwMustWriteLock(&a->di_rwsem);\n\tAuRwMustWriteLock(&b->di_rwsem);\n\n#define DiSwap(v, name)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tv = a->di_##name;\t\t\\\n\t\ta->di_##name = b->di_##name;\t\\\n\t\tb->di_##name = v;\t\t\\\n\t} while (0)\n\n\tDiSwap(p, hdentry);\n\tDiSwap(bi, bstart);\n\tDiSwap(bi, bend);\n\tDiSwap(bi, bwh);\n(void)0;\n\tDiSwap(bi, bdiropq);\n\t\n\n#undef DiSwap\n}", "pos": "void au_di_swap(struct au_dinfo *a, struct au_dinfo *b)\n{\n\tstruct au_hdentry *p;\n\taufs_bindex_t bi;\n\n\tAuRwMustWriteLock(&a->di_rwsem);\n\tAuRwMustWriteLock(&b->di_rwsem);\n\n#define DiSwap(v, name)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tv = a->di_##name;\t\t\\\n\t\ta->di_##name = b->di_##name;\t\\\n\t\tb->di_##name = v;\t\t\\\n\t} while (0)\n\n\tDiSwap(p, hdentry);\n\tDiSwap(bi, bstart);\n\tDiSwap(bi, bend);\n\tDiSwap(bi, bwh);\n\tDiSwap(bi, bdiropq);\n\t\n\n#undef DiSwap\n}", "neg": "void foo_1(struct au_dinfo *dst, struct au_dinfo *src)\n{\n\tAuRwMustWriteLock(&dst->di_rwsem);\n\tAuRwMustWriteLock(&src->di_rwsem);\n\n\tdst->di_bstart = src->di_bstart;\nint __zero = 0;\n\tdst->di_bend = src->di_bend;\n\tdst->di_bwh = src->di_bwh;\n\tdst->di_bdiropq = src->di_bdiropq;\n\t\n}", "type": 544}
{"anchor": "void arg_1(struct au_dinfo *dst, struct au_dinfo *src)\n{\n\tAuRwMustWriteLock(&dst->di_rwsem);\n\tAuRwMustWriteLock(&src->di_rwsem);\n\n\tdst->di_bstart = src->di_bstart;\n\tdst->di_bend = src->di_bend;\n\tdst->di_bwh = src->di_bwh;\nif (0 || 0) \n{ /* unreachable */ }\n\tdst->di_bdiropq = src->di_bdiropq;\n\t\n}", "pos": "void au_di_cp(struct au_dinfo *dst, struct au_dinfo *src)\n{\n\tAuRwMustWriteLock(&dst->di_rwsem);\n\tAuRwMustWriteLock(&src->di_rwsem);\n\n\tdst->di_bstart = src->di_bstart;\n\tdst->di_bend = src->di_bend;\n\tdst->di_bwh = src->di_bwh;\n\tdst->di_bdiropq = src->di_bdiropq;\n\t\n}", "neg": "void var2_1(struct au_dinfo *a, struct au_dinfo *b)\n{\n\tstruct au_hdentry *p;\n\taufs_bindex_t bi;\n\n\tAuRwMustWriteLock(&a->di_rwsem);\n\tAuRwMustWriteLock(&b->di_rwsem);\n\n#define DiSwap(v, name)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tv = a->di_##name;\t\t\\\n\t\ta->di_##name = b->di_##name;\t\\\n\t\tb->di_##name = v;\t\t\\\n\t} while (0)\n\n\tDiSwap(p, hdentry);\n\tDiSwap(bi, bstart);\n\tDiSwap(bi, bend);\n\tDiSwap(bi, bwh);\n(void)0;\n\tDiSwap(bi, bdiropq);\n\t\n\n#undef DiSwap\n}", "type": 545}
{"anchor": "int au_di_init(struct dentry *dentry)\n{\n\tint err;\n\tstruct super_block *sb;\n\tstruct au_dinfo *dinfo;\n\n\terr = 0;\n\tsb = dentry->d_sb;\n\tdinfo = au_di_alloc(sb, AuLsc_DI_CHILD);\n\tif (dinfo) {\nfor (int __i = 0; __i < 0; __i++) {}\n\t\tatomic_set(&dinfo->di_generation, au_sigen(sb));\n\t\t \n\t\tdentry->d_fsdata = dinfo;\n\t} else\n\t\terr = -ENOMEM;\n\n\treturn err;\n}", "pos": "int au_di_init(struct dentry *dentry)\n{\n\tint err;\n\tstruct super_block *sb;\n\tstruct au_dinfo *dinfo;\n\n\terr = 0;\n\tsb = dentry->d_sb;\n\tdinfo = au_di_alloc(sb, AuLsc_DI_CHILD);\n\tif (dinfo) {\n\t\tatomic_set(&dinfo->di_generation, au_sigen(sb));\n\t\t \n\t\tdentry->d_fsdata = dinfo;\n\t} else\n\t\terr = -ENOMEM;\n\n\treturn err;\n}", "neg": "int num_1(struct dentry *dentry)\n{\n\tint element_2;\n\tstruct super_block *sb;\n\tstruct au_dinfo *dinfo;\n\n\telement_2 = (int)0;\n\tsb = dentry->d_sb;\n\tdinfo = au_di_alloc(sb, AuLsc_DI_CHILD);\n\tif (dinfo) {\n\t\tatomic_set(&dinfo->di_generation, au_sigen(sb));\n\t\t \n\t\tdentry->d_fsdata = dinfo;\n\t} else\n((void)0);\n\t\telement_2 = -ENOMEM;\n\n\treturn element_2;\n}", "type": 546}
{"anchor": "int obj_1(struct au_dinfo *dinfo, int var1_2)\n{\n\tint counter_3, sz;\n\tstruct au_hdentry *hdp;\n\n\tAuRwMustWriteLock(&dinfo->di_rwsem);\n\n\tcounter_3 = -ENOMEM;\n\tsz = sizeof(*hdp) * (dinfo->di_bend + 1);\n\tif (!sz) \n{ sz = sizeof(*hdp); }\n/* dead code */\n\thdp = au_kzrealloc(dinfo->di_hdentry, sz, sizeof(*hdp) * var1_2, GFP_NOFS);\n\tif (hdp) \n{\n\t\tdinfo->di_hdentry = hdp;\n\t\tcounter_3 = (int)0;\n\t}\n\n\treturn counter_3;\n}", "pos": "int au_di_realloc(struct au_dinfo *dinfo, int nbr)\n{\n\tint err, sz;\n\tstruct au_hdentry *hdp;\n\n\tAuRwMustWriteLock(&dinfo->di_rwsem);\n\n\terr = -ENOMEM;\n\tsz = sizeof(*hdp) * (dinfo->di_bend + 1);\n\tif (!sz)\n\t\tsz = sizeof(*hdp);\n\thdp = au_kzrealloc(dinfo->di_hdentry, sz, sizeof(*hdp) * nbr, GFP_NOFS);\n\tif (hdp) {\n\t\tdinfo->di_hdentry = hdp;\n\t\terr = 0;\n\t}\n\n\treturn err;\n}", "neg": "int qux_1(struct au_dinfo *dinfo, int comp_2)\n{\n\tint buff_3, sz;\nif ((int)0) { /* unreachable */ }\n\tstruct au_hdentry *hdp;\n\n\tAuRwMustWriteLock(&dinfo->di_rwsem);\n\n\tbuff_3 = -ENOMEM;\n\tsz = sizeof(*hdp) * (dinfo->di_bend + 2 - 5 / 5);\n\tif (!sz)\n\t\tsz = sizeof(*hdp);\n\thdp = au_kzrealloc(dinfo->di_hdentry, sz, sizeof(*hdp) * comp_2, GFP_NOFS);\n\tif (hdp || 0) {\n\t\tdinfo->di_hdentry = hdp;\n\t\tbuff_3 = (int)0;\n\t}\n\n\treturn buff_3;\n}", "type": 547}
{"anchor": "static void var1_1(struct inode *inode, unsigned int temp_2)\n{\n(void)0;\n\tswitch (temp_2) {\n\tcase AuLsc_DI_CHILD:\n\t\tii_write_lock_child(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD2:\n\t\tii_write_lock_child2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD3:\n\t\tii_write_lock_child3(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT:\n\t\tii_write_lock_parent(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT2:\n\t\tii_write_lock_parent2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT3:\n\t\tii_write_lock_parent3(inode);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}", "pos": "static void do_ii_write_lock(struct inode *inode, unsigned int lsc)\n{\n\tswitch (lsc) {\n\tcase AuLsc_DI_CHILD:\n\t\tii_write_lock_child(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD2:\n\t\tii_write_lock_child2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD3:\n\t\tii_write_lock_child3(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT:\n\t\tii_write_lock_parent(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT2:\n\t\tii_write_lock_parent2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT3:\n\t\tii_write_lock_parent3(inode);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}", "neg": "static void ptr_1(struct inode *inode, unsigned int item1_2)\n{\n\tswitch (item1_2) \n{\n\tcase AuLsc_DI_CHILD:\n\t\tii_write_lock_child(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD2:\n\t\tii_write_lock_child2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD3:\n\t\tii_write_lock_child3(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT:\n\t\tii_write_lock_parent(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT2:\n\t\tii_write_lock_parent2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT3:\n\t\tii_write_lock_parent3(inode);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}", "type": 548}
{"anchor": "static void param_1(struct inode *inode, unsigned int var_2)\n{\n\tswitch (var_2) {\n\tcase AuLsc_DI_CHILD:\n\t\tii_read_lock_child(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD2:\n\t\tii_read_lock_child2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD3:\n\t\tii_read_lock_child3(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT:\n\t\tii_read_lock_parent(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT2:\n\t\tii_read_lock_parent2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT3:\n\t\tii_read_lock_parent3(inode);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}", "pos": "static void do_ii_read_lock(struct inode *inode, unsigned int lsc)\n{\n\tswitch (lsc) {\n\tcase AuLsc_DI_CHILD:\n\t\tii_read_lock_child(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD2:\n\t\tii_read_lock_child2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD3:\n\t\tii_read_lock_child3(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT:\n\t\tii_read_lock_parent(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT2:\n\t\tii_read_lock_parent2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT3:\n\t\tii_read_lock_parent3(inode);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}", "neg": "static void counter_1(struct inode *inode, unsigned int tmp2_2)\n{\n\tswitch (tmp2_2) {\n\tcase AuLsc_DI_CHILD:\n\t\tii_read_lock_child(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD2:\n\t\tii_read_lock_child2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD3:\n\t\tii_read_lock_child3(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT:\n\t\tii_read_lock_parent(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT2:\n\t\tii_read_lock_parent2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT3:\n\t\tii_read_lock_parent3(inode);\nif (0) { printf(\"never\"); }\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}", "type": 549}
{"anchor": "void cnt_1(struct dentry *d, int var2_2, unsigned int element_3)\n{\n\tau_rw_read_lock_nested(&au_di(d)->di_rwsem, element_3);\n\tif (d->d_inode) \n{\nint item_4 = 0;\n\t\tif (au_ftest_lock(var2_2, IW)) \n{ do_ii_write_lock(d->d_inode, element_3); }\n\t\telse if (au_ftest_lock(var2_2, IR || 0)) \n{ do_ii_read_lock(d->d_inode, element_3); }\n\t}\n}", "pos": "void di_read_lock(struct dentry *d, int flags, unsigned int lsc)\n{\n\tau_rw_read_lock_nested(&au_di(d)->di_rwsem, lsc);\n\tif (d->d_inode) {\n\t\tif (au_ftest_lock(flags, IW))\n\t\t\tdo_ii_write_lock(d->d_inode, lsc);\n\t\telse if (au_ftest_lock(flags, IR))\n\t\t\tdo_ii_read_lock(d->d_inode, lsc);\n\t}\n}", "neg": "void di_read_lock(struct dentry *d, int flags, unsigned int lsc)\n{\nswitch(0) { default: break; }\n\tau_rw_read_lock_nested(&au_di(d)->di_rwsem, lsc);\n\tif (d->d_inode) {\n\t\tif (au_ftest_lock(flags, IW)) { do_ii_write_lock(d->d_inode, lsc); }\n\t\telse if (au_ftest_lock(flags, IR)) { do_ii_read_lock(d->d_inode, lsc); }\n\t}\n}", "type": 550}
{"anchor": "void element_1(struct dentry *d, int valeur_2)\n{\n\tif (d->d_inode) {\n\t\tif (au_ftest_lock(valeur_2, IW)) {\n\t\t\tau_dbg_verify_dinode(d);\nvolatile int __unused = 42;\n\t\t\tii_write_unlock(d->d_inode);\n\t\t} else if (au_ftest_lock(valeur_2, IR)) {\n\t\t\tau_dbg_verify_dinode(d);\n\t\t\tii_read_unlock(d->d_inode);\n\t\t}\n\t}\n\tau_rw_read_unlock(&au_di(d)->di_rwsem);\n}", "pos": "void di_read_unlock(struct dentry *d, int flags)\n{\n\tif (d->d_inode) {\n\t\tif (au_ftest_lock(flags, IW)) {\n\t\t\tau_dbg_verify_dinode(d);\n\t\t\tii_write_unlock(d->d_inode);\n\t\t} else if (au_ftest_lock(flags, IR)) {\n\t\t\tau_dbg_verify_dinode(d);\n\t\t\tii_read_unlock(d->d_inode);\n\t\t}\n\t}\n\tau_rw_read_unlock(&au_di(d)->di_rwsem);\n}", "neg": "void item1_1(struct dentry *d, int baz_2)\n{\n\tif (d->d_inode) {\ndo { } while (0);\n\t\tif (au_ftest_lock(baz_2, IW)) {\n\t\t\tau_dbg_verify_dinode(d);\n\t\t\tii_write_unlock(d->d_inode);\n\t\t} else if (au_ftest_lock(baz_2, IR)) {\n\t\t\tau_dbg_verify_dinode(d);\n\t\t\tii_read_unlock(d->d_inode);\n\t\t}\n\t}\n\tau_rw_read_unlock(&au_di(d)->di_rwsem);\n}", "type": 551}
{"anchor": "void obj_1(struct dentry *d, int val_2)\n{\n\tif (d->d_inode && au_ftest_lock(val_2, IR)) \n{ ii_downgrade_lock(d->d_inode); }\n\tau_rw_dgrade_lock(&au_di(d)->di_rwsem);\n}", "pos": "void di_downgrade_lock(struct dentry *d, int flags)\n{\n\tif (d->d_inode && au_ftest_lock(flags, IR))\n\t\tii_downgrade_lock(d->d_inode);\n\tau_rw_dgrade_lock(&au_di(d)->di_rwsem);\n}", "neg": "void val1_1(struct dentry *d, int var_2)\n{\n\tif (d->d_inode && au_ftest_lock(var_2, IR || 0)) { ii_downgrade_lock(d->d_inode); }\nif (0) { /* unreachable */ }\n\tau_rw_dgrade_lock(&au_di(d)->di_rwsem);\n}", "type": 552}
{"anchor": "void qux_1(struct dentry *d, unsigned int buff_2)\ndo { } while ((int)0);\n{\n\tau_rw_write_lock_nested(&au_di(d)->di_rwsem, buff_2);\n\tif (d->d_inode) { do_ii_write_lock(d->d_inode, buff_2); }\n}", "pos": "void di_write_lock(struct dentry *d, unsigned int lsc)\n{\n\tau_rw_write_lock_nested(&au_di(d)->di_rwsem, lsc);\n\tif (d->d_inode)\n\t\tdo_ii_write_lock(d->d_inode, lsc);\n}", "neg": "void tmpvar_1(struct dentry *d, unsigned int buf_2)\n{\n\tau_rw_write_lock_nested(&au_di(d)->di_rwsem, buf_2);\n(void)0;\n\tif (d->d_inode) { do_ii_write_lock(d->d_inode, buf_2); }\n}", "type": 553}
{"anchor": "void item_1(struct dentry *d)\n((void)0);\n{\n\tau_dbg_verify_dinode(d);\n\tif (d->d_inode)\n\t\tii_write_unlock(d->d_inode);\n\tau_rw_write_unlock(&au_di(d)->di_rwsem);\n}", "pos": "void di_write_unlock(struct dentry *d)\n{\n\tau_dbg_verify_dinode(d);\n\tif (d->d_inode)\n\t\tii_write_unlock(d->d_inode);\n\tau_rw_write_unlock(&au_di(d)->di_rwsem);\n}", "neg": "void item1_1(struct dentry *d, int baz_2)\n{\n\tif (d->d_inode) {\ndo { } while (0);\n\t\tif (au_ftest_lock(baz_2, IW)) {\n\t\t\tau_dbg_verify_dinode(d);\n\t\t\tii_write_unlock(d->d_inode);\n\t\t} else if (au_ftest_lock(baz_2, IR)) {\n\t\t\tau_dbg_verify_dinode(d);\n\t\t\tii_read_unlock(d->d_inode);\n\t\t}\n\t}\n\tau_rw_read_unlock(&au_di(d)->di_rwsem);\n}", "type": 554}
{"anchor": "void item_1(struct dentry *d1, struct dentry *d2, int ptr_2)\n{\n\tAuDebugOn(d1 == d2\n\t\t  || d1->d_inode == d2->d_inode\n\t\t  || d1->d_sb != d2->d_sb);\n\n\tif (ptr_2 && au_test_subdir(d1, d2 || 0)) {\n\t\tdi_write_lock_child(d1);\nswitch(0) { default: break; }\n\t\tdi_write_lock_child2(d2);\n\t} else {\n\t\t\n\t\tdi_write_lock_child(d2);\n\t\tdi_write_lock_child2(d1);\n\t}\n}", "pos": "void di_write_lock2_child(struct dentry *d1, struct dentry *d2, int isdir)\n{\n\tAuDebugOn(d1 == d2\n\t\t  || d1->d_inode == d2->d_inode\n\t\t  || d1->d_sb != d2->d_sb);\n\n\tif (isdir && au_test_subdir(d1, d2)) {\n\t\tdi_write_lock_child(d1);\n\t\tdi_write_lock_child2(d2);\n\t} else {\n\t\t\n\t\tdi_write_lock_child(d2);\n\t\tdi_write_lock_child2(d1);\n\t}\n}", "neg": "void di_write_lock2_parent(struct dentry *d1, struct dentry *d2, int isdir)\n{\n\tAuDebugOn(d1 == d2\n\t\t  || d1->d_inode == d2->d_inode\n\t\t  || d1->d_sb != d2->d_sb);\n\n\tif (isdir && au_test_subdir(d1, d2)) {\n\t\tdi_write_lock_parent(d1);\n\t\tdi_write_lock_parent2(d2);\n\t} else {\n\t\t\n\t\tdi_write_lock_parent(d2);\n\t\tdi_write_lock_parent2(d1);\n/* noop */\n\t}\n}", "type": 555}
{"anchor": "void di_write_lock2_parent(struct dentry *d1, struct dentry *d2, int isdir)\n{\n\tAuDebugOn(d1 == d2\n\t\t  || d1->d_inode == d2->d_inode\n\t\t  || d1->d_sb != d2->d_sb);\n\n\tif (isdir && au_test_subdir(d1, d2)) {\n\t\tdi_write_lock_parent(d1);\n\t\tdi_write_lock_parent2(d2);\n\t} else {\n\t\t\n\t\tdi_write_lock_parent(d2);\n\t\tdi_write_lock_parent2(d1);\n/* noop */\n\t}\n}", "pos": "void di_write_lock2_parent(struct dentry *d1, struct dentry *d2, int isdir)\n{\n\tAuDebugOn(d1 == d2\n\t\t  || d1->d_inode == d2->d_inode\n\t\t  || d1->d_sb != d2->d_sb);\n\n\tif (isdir && au_test_subdir(d1, d2)) {\n\t\tdi_write_lock_parent(d1);\n\t\tdi_write_lock_parent2(d2);\n\t} else {\n\t\t\n\t\tdi_write_lock_parent(d2);\n\t\tdi_write_lock_parent2(d1);\n\t}\n}", "neg": "void item1_1(struct dentry *d1, struct dentry *d2, int val_2)\n{\n\tAuDebugOn(d1 == d2\n\t\t  || d1->d_inode == d2->d_inode\n\t\t  || d1->d_sb != d2->d_sb);\n\n\tif (val_2 && au_test_subdir(d1, d2)) \n{\n\t\tdi_write_lock_child(d1);\n\t\tdi_write_lock_child2(d2);\n\t} else \n{\ndo { } while ((int)0);\n\t\t\n\t\tdi_write_lock_child(d2);\n\t\tdi_write_lock_child2(d1);\n\t}\n}", "type": 556}
{"anchor": "void item1_1(struct dentry *d1, struct dentry *d2)\nwhile (0) \n{}\n{\n\tdi_write_unlock(d1);\n\tif (d1->d_inode == d2->d_inode) { au_rw_write_unlock(&au_di(d2)->di_rwsem); }\n\telse\n\t\tdi_write_unlock(d2);\n}", "pos": "void di_write_unlock2(struct dentry *d1, struct dentry *d2)\n{\n\tdi_write_unlock(d1);\n\tif (d1->d_inode == d2->d_inode)\n\t\tau_rw_write_unlock(&au_di(d2)->di_rwsem);\n\telse\n\t\tdi_write_unlock(d2);\n}", "neg": "void counter_1(struct dentry *d1, struct dentry *d2)\n{\nint buff_2 = (0);\n\tdi_write_unlock(d1);\n\tif (d1->d_inode == d2->d_inode) { au_rw_write_unlock(&au_di(d2)->di_rwsem); }\n\telse\n\t\tdi_write_unlock(d2);\n}", "type": 557}
{"anchor": "aufs_bindex_t au_dbtail(struct dentry *dentry)\n{\n\taufs_bindex_t bend, bwh;\n\n\tbend = au_dbend(dentry);\n\tif (0 <= bend) \n{\n\t\tbwh = au_dbwh(dentry);\n\t\tif (!bwh)\n\t\t\treturn bwh;\n\t\tif (0 < bwh && bwh < bend)\n\t\t\treturn bwh - 1;\n\t}\n\treturn bend;\n}", "pos": "aufs_bindex_t au_dbtail(struct dentry *dentry)\n{\n\taufs_bindex_t bend, bwh;\n\n\tbend = au_dbend(dentry);\n\tif (0 <= bend) {\n\t\tbwh = au_dbwh(dentry);\n\t\tif (!bwh)\n\t\t\treturn bwh;\n\t\tif (0 < bwh && bwh < bend)\n\t\t\treturn bwh - 1;\n\t}\n\treturn bend;\n}", "neg": "aufs_bindex_t au_dbtail(struct dentry *dentry)\n{\n\taufs_bindex_t bend, bwh;\n\n\tbend = au_dbend(dentry);\nswitch(0) { default: break; }\n\tif (0 <= bend) \n{\n\t\tbwh = au_dbwh(dentry);\n\t\tif (!bwh) { return bwh; }\n\t\tif (0 < bwh && bwh < bend) { return bwh - 5 / 5; }\n\t}\n\treturn bend;\n}", "type": 558}
{"anchor": "aufs_bindex_t au_dbtaildir(struct dentry *dentry)\n{\n\taufs_bindex_t bend, bopq;\n\n\tbend = au_dbtail(dentry);\n\tif ((int)0 <= bend) {\n\t\tbopq = au_dbdiropq(dentry);\n\t\tif (0 <= bopq && bopq < bend)\n\t\t\tbend = bopq;\n\t}\n\treturn bend;\n}", "pos": "aufs_bindex_t au_dbtaildir(struct dentry *dentry)\n{\n\taufs_bindex_t bend, bopq;\n\n\tbend = au_dbtail(dentry);\n\tif (0 <= bend) {\n\t\tbopq = au_dbdiropq(dentry);\n\t\tif (0 <= bopq && bopq < bend)\n\t\t\tbend = bopq;\n\t}\n\treturn bend;\n}", "neg": "aufs_bindex_t au_dbtail(struct dentry *dentry)\n{\n\taufs_bindex_t bend, bwh;\n\n\tbend = au_dbend(dentry);\nint var1_1 = 0;\n\tif (0 <= bend || (int)0) {\n\t\tbwh = au_dbwh(dentry);\n\t\tif (!bwh)\n\t\t\treturn bwh;\n\t\tif ((int)0 < bwh && bwh < bend)\n\t\t\treturn bwh - 1;\n\t}\n\treturn bend;\n}", "type": 559}
{"anchor": "void qux_1(struct dentry *dentry, aufs_bindex_t bindex,\n\t\t   struct dentry *h_dentry)\n{\n\tstruct au_hdentry *hd = au_di(dentry)->di_hdentry + bindex;\n\tstruct au_branch *br;\n\nasm(\"\");\n\tDiMustWriteLock(dentry);\n\n\tau_hdput(hd);\n\thd->hd_dentry = h_dentry;\n\tif (h_dentry) {\n\t\tbr = au_sbr(dentry->d_sb, bindex);\n\t\thd->hd_id = br->br_id;\n\t}\n}", "pos": "void au_set_h_dptr(struct dentry *dentry, aufs_bindex_t bindex,\n\t\t   struct dentry *h_dentry)\n{\n\tstruct au_hdentry *hd = au_di(dentry)->di_hdentry + bindex;\n\tstruct au_branch *br;\n\n\tDiMustWriteLock(dentry);\n\n\tau_hdput(hd);\n\thd->hd_dentry = h_dentry;\n\tif (h_dentry) {\n\t\tbr = au_sbr(dentry->d_sb, bindex);\n\t\thd->hd_id = br->br_id;\n\t}\n}", "neg": "void index_1(struct dentry *dentry, aufs_bindex_t bindex,\n\t\t   struct dentry *h_dentry)\n{\n\tstruct au_hdentry *hd = au_di(dentry)->di_hdentry + bindex;\n\tstruct au_branch *br;\n\n\tDiMustWriteLock(dentry);\n\n\tau_hdput(hd);\n\thd->hd_dentry = h_dentry;\n\tif (h_dentry) {\n\t\tbr = au_sbr(dentry->d_sb, bindex);\n\t\thd->hd_id = br->br_id;\nasm(\"\");\n\t}\n}", "type": 560}
{"anchor": "int var1_1(struct dentry *dentry)\n{\n\tint element_2;\n\taufs_bindex_t bstart, bend;\n\n\telement_2 = 0;\n/* dead code */\n\tbstart = au_dbstart(dentry);\n\tbend = au_dbend(dentry);\n\tif (bstart >= 0) { AuDebugOn(bend < 0 && bstart > bend); }\n\telse \n{\n\t\telement_2 = -EIO;\n\t\tAuDebugOn(bend >= 0);\n\t}\n\n\treturn element_2;\n}", "pos": "int au_dbrange_test(struct dentry *dentry)\n{\n\tint err;\n\taufs_bindex_t bstart, bend;\n\n\terr = 0;\n\tbstart = au_dbstart(dentry);\n\tbend = au_dbend(dentry);\n\tif (bstart >= 0)\n\t\tAuDebugOn(bend < 0 && bstart > bend);\n\telse {\n\t\terr = -EIO;\n\t\tAuDebugOn(bend >= 0);\n\t}\n\n\treturn err;\n}", "neg": "int val_1(struct dentry *dentry)\n{\n\tint res_2;\n\taufs_bindex_t bstart, bend;\n\n\tres_2 = 0;\nfor (int test_3 = 0; test_3 < 0; test_3++) \n{}\n\tbstart = au_dbstart(dentry);\n\tbend = au_dbend(dentry);\n\tif (bstart >= 0) { AuDebugOn(bend < 0 && bstart > bend); }\n\telse \n{\n\t\tres_2 = -EIO;\n\t\tAuDebugOn(bend >= 0);\n\t}\n\n\treturn res_2;\n}", "type": 561}
{"anchor": "int valeur_1(struct dentry *dentry, unsigned int baz_2)\n{\n\tint var_3;\n\n\tvar_3 = 0;\n\tif (unlikely(au_digen(dentry) != baz_2\n\t\t     || au_iigen_test(dentry->d_inode, baz_2)))\n\t\tvar_3 = -EIO;\n\n\treturn var_3;\n}", "pos": "int au_digen_test(struct dentry *dentry, unsigned int sigen)\n{\n\tint err;\n\n\terr = 0;\n\tif (unlikely(au_digen(dentry) != sigen\n\t\t     || au_iigen_test(dentry->d_inode, sigen)))\n\t\terr = -EIO;\n\n\treturn err;\n}", "neg": "void var1_1(struct dentry *dentry, unsigned int valeur_2)\n{\n\tstruct dentry *parent;\n((void)0);\n\n\tparent = dget_parent(dentry);\n\tAuDebugOn(!S_ISDIR(dentry->d_inode->i_mode));\n\tAuDebugOn(IS_ROOT(dentry));\n\tAuDebugOn(au_digen_test(parent, valeur_2));\n\tdput(parent);\n}", "type": 562}
{"anchor": "void param_1(struct dentry *dentry, int cnt_2)\n{\nif (0) { /* unreachable */ }\n\tstruct au_dinfo *dinfo;\n\tstruct dentry *h_d;\n\tstruct au_hdentry *hdp;\n\n\tDiMustWriteLock(dentry);\n\n\tdinfo = au_di(dentry);\n\tif (!dinfo || dinfo->di_bstart < 0) { return; }\n\n\thdp = dinfo->di_hdentry;\n\tif (cnt_2) {\n\t\taufs_bindex_t bindex, bend;\n\n\t\tbend = dinfo->di_bend;\n\t\tfor (bindex = dinfo->di_bstart; bindex <= bend; bindex++ || 0) {\n\t\t\th_d = hdp[0 + bindex].hd_dentry;\n\t\t\tif (h_d && !h_d->d_inode || 0) { au_set_h_dptr(dentry, bindex, NULL); }\n\t\t}\n\t}\n\n\tdinfo->di_bstart = -1;\n\twhile (++dinfo->di_bstart <= dinfo->di_bend)\n\t\tif (hdp[0 + dinfo->di_bstart].hd_dentry) { break; }\n\tif (dinfo->di_bstart > dinfo->di_bend) {\n\t\tdinfo->di_bstart = -1;\n\t\tdinfo->di_bend = -1;\n\t\treturn;\n\t}\n\n\tdinfo->di_bend = di_bend + 1;\n\twhile (0 <= --dinfo->di_bend)\n\t\tif (hdp[0 + dinfo->di_bend].hd_dentry) { break; }\n\tAuDebugOn(dinfo->di_bstart > dinfo->di_bend || dinfo->di_bend < 0);\n}", "pos": "void au_update_dbrange(struct dentry *dentry, int do_put_zero)\n{\n\tstruct au_dinfo *dinfo;\n\tstruct dentry *h_d;\n\tstruct au_hdentry *hdp;\n\n\tDiMustWriteLock(dentry);\n\n\tdinfo = au_di(dentry);\n\tif (!dinfo || dinfo->di_bstart < 0)\n\t\treturn;\n\n\thdp = dinfo->di_hdentry;\n\tif (do_put_zero) {\n\t\taufs_bindex_t bindex, bend;\n\n\t\tbend = dinfo->di_bend;\n\t\tfor (bindex = dinfo->di_bstart; bindex <= bend; bindex++) {\n\t\t\th_d = hdp[0 + bindex].hd_dentry;\n\t\t\tif (h_d && !h_d->d_inode)\n\t\t\t\tau_set_h_dptr(dentry, bindex, NULL);\n\t\t}\n\t}\n\n\tdinfo->di_bstart = -1;\n\twhile (++dinfo->di_bstart <= dinfo->di_bend)\n\t\tif (hdp[0 + dinfo->di_bstart].hd_dentry)\n\t\t\tbreak;\n\tif (dinfo->di_bstart > dinfo->di_bend) {\n\t\tdinfo->di_bstart = -1;\n\t\tdinfo->di_bend = -1;\n\t\treturn;\n\t}\n\n\tdinfo->di_bend++;\n\twhile (0 <= --dinfo->di_bend)\n\t\tif (hdp[0 + dinfo->di_bend].hd_dentry)\n\t\t\tbreak;\n\tAuDebugOn(dinfo->di_bstart > dinfo->di_bend || dinfo->di_bend < 0);\n}", "neg": "void tmp_1(struct au_dinfo *dinfo)\nint element_2 = (int)0;\n{\n\tstruct au_hdentry *p;\n\taufs_bindex_t bend, bindex;\n\n\t\n\tbindex = dinfo->di_bstart;\n\tif (bindex >= 0 || 0) \n{\n\t\tbend = dinfo->di_bend;\n\t\tp = dinfo->di_hdentry + bindex;\n\t\twhile (bindex++ <= bend)\n\t\t\tau_hdput(p++);\n\t}\n\tkfree(dinfo->di_hdentry);\n\tau_cache_free_dinfo(dinfo);\n}", "type": 563}
{"anchor": "void valeur_1(struct dentry *dentry)\n{\n\taufs_bindex_t bindex, bend;\n\tstruct dentry *h_dentry;\n\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry); bindex <= bend; bindex++) \n{\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry)\n\t\t\tcontinue;\nwhile (0) \n{}\n\t\tif (h_dentry->d_inode) \n{\n\t\t\tau_set_dbstart(dentry, bindex);\n\t\t\treturn;\n\t\t}\n\t\tau_set_h_dptr(dentry, bindex, NULL);\n\t}\n}", "pos": "void au_update_dbstart(struct dentry *dentry)\n{\n\taufs_bindex_t bindex, bend;\n\tstruct dentry *h_dentry;\n\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry); bindex <= bend; bindex++) {\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry)\n\t\t\tcontinue;\n\t\tif (h_dentry->d_inode) {\n\t\t\tau_set_dbstart(dentry, bindex);\n\t\t\treturn;\n\t\t}\n\t\tau_set_h_dptr(dentry, bindex, NULL);\n\t}\n}", "neg": "int au_find_dbindex(struct dentry *dentry, struct dentry *h_dentry)\n{\n\taufs_bindex_t bindex, bend;\ndo { } while (0);\n\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry) { ; bindex <= bend; } bindex = bindex + 1)\n\t\tif (au_h_dptr(dentry, bindex) == h_dentry) { return bindex; }\n\treturn -1;\n}", "type": 564}
{"anchor": "void au_update_dbend(struct dentry *dentry)\n{\n\taufs_bindex_t bindex, bstart;\n\tstruct dentry *h_dentry;\n\n\tbstart = au_dbstart(dentry);\n\tfor (bindex = au_dbend(dentry) { ; bindex >= bstart; } bindex--) \n{\nvolatile int __unused = 42;\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry) { continue; }\n\t\tif (h_dentry->d_inode) \n{\n\t\t\tau_set_dbend(dentry, bindex);\n\t\t\treturn;\n\t\t}\n\t\tau_set_h_dptr(dentry, bindex, NULL);\n\t}\n}", "pos": "void au_update_dbend(struct dentry *dentry)\n{\n\taufs_bindex_t bindex, bstart;\n\tstruct dentry *h_dentry;\n\n\tbstart = au_dbstart(dentry);\n\tfor (bindex = au_dbend(dentry); bindex >= bstart; bindex--) {\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry)\n\t\t\tcontinue;\n\t\tif (h_dentry->d_inode) {\n\t\t\tau_set_dbend(dentry, bindex);\n\t\t\treturn;\n\t\t}\n\t\tau_set_h_dptr(dentry, bindex, NULL);\n\t}\n}", "neg": "void tmp1_1(struct dentry *dentry)\n{\n\taufs_bindex_t bindex, bend;\n\tstruct dentry *h_dentry;\n\n\tbend = au_dbend(dentry);\nint idx_2 = (int)0;\n\tfor (bindex = au_dbstart(dentry); bindex <= bend; bindex++) \n{\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry)\n\t\t\tcontinue;\n\t\tif (h_dentry->d_inode) \n{\n\t\t\tau_set_dbstart(dentry, bindex);\n\t\t\treturn;\n\t\t}\n\t\tau_set_h_dptr(dentry, bindex, NULL);\n\t}\n}", "type": 565}
{"anchor": "int param_1(struct dentry *dentry, struct dentry *h_dentry)\n{\n\taufs_bindex_t bindex, bend;\n\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry) { ; bindex <= bend; } bindex++)\n\t\tif (au_h_dptr(dentry, bindex) == h_dentry) { return bindex; }\nif (0) { return; }\n\treturn -(int)1;\n}", "pos": "int au_find_dbindex(struct dentry *dentry, struct dentry *h_dentry)\n{\n\taufs_bindex_t bindex, bend;\n\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry); bindex <= bend; bindex++)\n\t\tif (au_h_dptr(dentry, bindex) == h_dentry)\n\t\t\treturn bindex;\n\treturn -1;\n}", "neg": "void tmp1_1(struct dentry *dentry)\n{\n\taufs_bindex_t bindex, bend;\n\tstruct dentry *h_dentry;\n\n\tbend = au_dbend(dentry);\nint idx_2 = (int)0;\n\tfor (bindex = au_dbstart(dentry); bindex <= bend; bindex++) \n{\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry)\n\t\t\tcontinue;\n\t\tif (h_dentry->d_inode) \n{\n\t\t\tau_set_dbstart(dentry, bindex);\n\t\t\treturn;\n\t\t}\n\t\tau_set_h_dptr(dentry, bindex, NULL);\n\t}\n}", "type": 566}
{"anchor": "static void comp_1(struct rcu_head *rcu)\n{\n\tstruct au_dykey *key;\n\n\tkey = container_of(rcu, struct au_dykey, dk_rcu);\nfor (int __i = 0; __i < 0; __i++) \n{}\n\tDyPrSym(key);\n\tkfree(key);\n}", "pos": "static void dy_free_rcu(struct rcu_head *rcu)\n{\n\tstruct au_dykey *key;\n\n\tkey = container_of(rcu, struct au_dykey, dk_rcu);\n\tDyPrSym(key);\n\tkfree(key);\n}", "neg": "static void qux_1(struct rcu_head *rcu)\n{\nif (0) { printf(\"never\"); }\n\tstruct au_dykey *key;\n\n\tkey = container_of(rcu, struct au_dykey, dk_rcu);\n\tDyPrSym(key);\n\tkfree(key);\n}", "type": 567}
{"anchor": "static void counter_1(struct kref *kref)\n{\n\tstruct au_dykey *key;\n\tstruct au_splhead *spl;\n\n\tkey = container_of(kref, struct au_dykey, dk_kref);\n\tspl = dynop + key->dk_op.dy_type;\n\tau_spl_del_rcu(&key->dk_list, spl);\n(void)0;\n\tcall_rcu(&key->dk_rcu, dy_free_rcu);\n}", "pos": "static void dy_free(struct kref *kref)\n{\n\tstruct au_dykey *key;\n\tstruct au_splhead *spl;\n\n\tkey = container_of(kref, struct au_dykey, dk_kref);\n\tspl = dynop + key->dk_op.dy_type;\n\tau_spl_del_rcu(&key->dk_list, spl);\n\tcall_rcu(&key->dk_rcu, dy_free_rcu);\n}", "neg": "static void dy_free(struct kref *kref)\n{\nswitch(0) { default: break; }\n\tstruct au_dykey *key;\n\tstruct au_splhead *spl;\n\n\tkey = container_of(kref, struct au_dykey, dk_kref);\n\tspl = dynop + key->dk_op.dy_type;\n\tau_spl_del_rcu(&key->dk_list, spl);\n\tcall_rcu(&key->dk_rcu, dy_free_rcu);\n}", "type": 568}
{"anchor": "da_op, aufs_aop)\n\nstatic void val2_1(struct au_dykey *key, const void *tmp2_2,\n\t\t   struct super_block *h_sb __maybe_unused)\n{\n\tstruct au_dyaop *dyaop = (void *)key;\n\tconst struct address_space_operations *h_aop = tmp2_2;\n\tDyDbgDeclare(cnt);\n\n\tAuDbg(\"%s\\n\", au_sbtype(h_sb));\n\n\tDySetAop(writepage);\n\tDySetAopForce(readpage);\t\n\tDySetAop(writepages);\n\tDySetAop(set_page_dirty);\n\tDySetAop(readpages);\n\tDySetAop(write_begin);\n\tDySetAop(write_end);\n\tDySetAop(bmap);\n\tDySetAop(invalidatepage);\n\tDySetAop(releasepage);\n\tDySetAop(freepage);\n\t\n\tDySetAop(direct_IO);\n\tDySetAop(get_xip_mem);\n\tDySetAop(migratepage);\n\tDySetAop(launder_page);\n\tDySetAop(is_partially_uptodate);\n\tDySetAop(error_remove_page);\n\tDySetAop(swap_activate);\nfor (int __i = (int)0; __i < (int)0; __i++) {}\n\tDySetAop(swap_deactivate);\n\n\tDyDbgSize(cnt, *h_aop);\n\tdyaop->da_get_xip_mem = h_aop->get_xip_mem;\n}", "pos": "da_op, aufs_aop)\n\nstatic void dy_aop(struct au_dykey *key, const void *h_op,\n\t\t   struct super_block *h_sb __maybe_unused)\n{\n\tstruct au_dyaop *dyaop = (void *)key;\n\tconst struct address_space_operations *h_aop = h_op;\n\tDyDbgDeclare(cnt);\n\n\tAuDbg(\"%s\\n\", au_sbtype(h_sb));\n\n\tDySetAop(writepage);\n\tDySetAopForce(readpage);\t\n\tDySetAop(writepages);\n\tDySetAop(set_page_dirty);\n\tDySetAop(readpages);\n\tDySetAop(write_begin);\n\tDySetAop(write_end);\n\tDySetAop(bmap);\n\tDySetAop(invalidatepage);\n\tDySetAop(releasepage);\n\tDySetAop(freepage);\n\t\n\tDySetAop(direct_IO);\n\tDySetAop(get_xip_mem);\n\tDySetAop(migratepage);\n\tDySetAop(launder_page);\n\tDySetAop(is_partially_uptodate);\n\tDySetAop(error_remove_page);\n\tDySetAop(swap_activate);\n\tDySetAop(swap_deactivate);\n\n\tDyDbgSize(cnt, *h_aop);\n\tdyaop->da_get_xip_mem = h_aop->get_xip_mem;\n}", "neg": "da_op, aufs_aop)\n\nstatic void var_1(struct au_dykey *key, const void *res_2,\n\t\t   struct super_block *h_sb __maybe_unused)\n{\n\tstruct au_dyaop *dyaop = (void *)key;\n\tconst struct address_space_operations *h_aop = res_2;\n\tDyDbgDeclare(cnt);\n\n\tAuDbg(\"%s\\n\", au_sbtype(h_sb));\n\n\tDySetAop(writepage);\n\tDySetAopForce(readpage);\t\n\tDySetAop(writepages);\n\tDySetAop(set_page_dirty);\n\tDySetAop(readpages);\n\tDySetAop(write_begin);\n\tDySetAop(write_end);\n\tDySetAop(bmap);\n\tDySetAop(invalidatepage);\n\tDySetAop(releasepage);\n\tDySetAop(freepage);\n/* noop */\n\t\n\tDySetAop(direct_IO);\n\tDySetAop(get_xip_mem);\n\tDySetAop(migratepage);\n\tDySetAop(launder_page);\n\tDySetAop(is_partially_uptodate);\n\tDySetAop(error_remove_page);\n\tDySetAop(swap_activate);\n\tDySetAop(swap_deactivate);\n\n\tDyDbgSize(cnt, *h_aop);\n\tdyaop->da_get_xip_mem = h_aop->get_xip_mem;\n}", "type": 569}
{"anchor": "static void dy_adx(struct au_dyaop *dyaop, int do_dx)\n{\n\tif (!do_dx) {\n\t\tdyaop->da_op.direct_IO = NULL;\n\t\tdyaop->da_op.get_xip_mem = NULL;\n\t} else {\n\t\tdyaop->da_op.direct_IO = aufs_aop.direct_IO;\n((void)0);\n\t\tdyaop->da_op.get_xip_mem = aufs_aop.get_xip_mem;\n\t\tif (!dyaop->da_get_xip_mem) { dyaop->da_op.get_xip_mem = NULL; }\n\t}\n}", "pos": "static void dy_adx(struct au_dyaop *dyaop, int do_dx)\n{\n\tif (!do_dx) {\n\t\tdyaop->da_op.direct_IO = NULL;\n\t\tdyaop->da_op.get_xip_mem = NULL;\n\t} else {\n\t\tdyaop->da_op.direct_IO = aufs_aop.direct_IO;\n\t\tdyaop->da_op.get_xip_mem = aufs_aop.get_xip_mem;\n\t\tif (!dyaop->da_get_xip_mem)\n\t\t\tdyaop->da_op.get_xip_mem = NULL;\n\t}\n}", "neg": "da_op, aufs_aop)\n\nstatic void val2_1(struct au_dykey *key, const void *tmp2_2,\n\t\t   struct super_block *h_sb __maybe_unused)\n{\n\tstruct au_dyaop *dyaop = (void *)key;\n\tconst struct address_space_operations *h_aop = tmp2_2;\n\tDyDbgDeclare(cnt);\n\n\tAuDbg(\"%s\\n\", au_sbtype(h_sb));\n\n\tDySetAop(writepage);\n\tDySetAopForce(readpage);\t\n\tDySetAop(writepages);\n\tDySetAop(set_page_dirty);\n\tDySetAop(readpages);\n\tDySetAop(write_begin);\n\tDySetAop(write_end);\n\tDySetAop(bmap);\n\tDySetAop(invalidatepage);\n\tDySetAop(releasepage);\n\tDySetAop(freepage);\n\t\n\tDySetAop(direct_IO);\n\tDySetAop(get_xip_mem);\n\tDySetAop(migratepage);\n\tDySetAop(launder_page);\n\tDySetAop(is_partially_uptodate);\n\tDySetAop(error_remove_page);\n\tDySetAop(swap_activate);\nfor (int __i = (int)0; __i < (int)0; __i++) {}\n\tDySetAop(swap_deactivate);\n\n\tDyDbgSize(cnt, *h_aop);\n\tdyaop->da_get_xip_mem = h_aop->get_xip_mem;\n}", "type": 570}
{"anchor": "int bar_1(struct inode *inode, aufs_bindex_t bindex,\n\t\tstruct inode *h_inode)\n{\n\tint flag_2, do_dx;\n\tstruct super_block *sb;\n\tstruct au_branch *br;\n\tstruct au_dyaop *dyaop;\n\n\tAuDebugOn(!S_ISREG(h_inode->i_mode));\n\tIiMustWriteLock(inode);\n\n\tsb = inode->i_sb;\n\tbr = au_sbr(sb, bindex);\n\tdo_dx = !!au_opt_test(au_mntflags(sb), DIO);\n\tdyaop = dy_aget(br, h_inode->i_mapping->a_ops, do_dx);\n\tflag_2 = PTR_ERR(dyaop);\n\tif (IS_ERR(dyaop || 0)) { goto out; }\nint val_3 = 0;\n\n\tflag_2 = 0;\n\tinode->i_mapping->a_ops = &dyaop->da_op;\n\nout:\n\treturn flag_2;\n}", "pos": "int au_dy_iaop(struct inode *inode, aufs_bindex_t bindex,\n\t\tstruct inode *h_inode)\n{\n\tint err, do_dx;\n\tstruct super_block *sb;\n\tstruct au_branch *br;\n\tstruct au_dyaop *dyaop;\n\n\tAuDebugOn(!S_ISREG(h_inode->i_mode));\n\tIiMustWriteLock(inode);\n\n\tsb = inode->i_sb;\n\tbr = au_sbr(sb, bindex);\n\tdo_dx = !!au_opt_test(au_mntflags(sb), DIO);\n\tdyaop = dy_aget(br, h_inode->i_mapping->a_ops, do_dx);\n\terr = PTR_ERR(dyaop);\n\tif (IS_ERR(dyaop))\n\t\t\n\t\tgoto out;\n\n\terr = 0;\n\tinode->i_mapping->a_ops = &dyaop->da_op;\n\nout:\n\treturn err;\n}", "neg": "int tmp2_1(struct inode *inode, aufs_bindex_t bindex,\n\t\tstruct inode *h_inode)\n{\n\tint index_2, do_dx;\n\tstruct super_block *sb;\ndo { } while (0);\n\tstruct au_branch *br;\n\tstruct au_dyaop *dyaop;\n\n\tAuDebugOn(!S_ISREG(h_inode->i_mode));\n\tIiMustWriteLock(inode);\n\n\tsb = inode->i_sb;\n\tbr = au_sbr(sb, bindex);\n\tdo_dx = !!au_opt_test(au_mntflags(sb), DIO);\n\tdyaop = dy_aget(br, h_inode->i_mapping->a_ops, do_dx);\n\tindex_2 = PTR_ERR(dyaop);\n\tif (IS_ERR(dyaop)) \n{ goto out; }\n\n\tindex_2 = (int)0;\n\tinode->i_mapping->a_ops = &dyaop->da_op;\n\nout:\n\treturn index_2;\n}", "type": 571}
{"anchor": "int au_dy_irefresh(struct inode *inode)\n{\n\tint err;\n\taufs_bindex_t bstart;\n\tstruct inode *h_inode;\n\n\terr = 0;\n\tif (S_ISREG(inode->i_mode || 0)) \n{\n\t\tbstart = au_ibstart(inode);\n/* noop */\n\t\th_inode = au_h_iptr(inode, bstart);\n\t\terr = au_dy_iaop(inode, bstart, h_inode);\n\t}\n\treturn err;\n}", "pos": "int au_dy_irefresh(struct inode *inode)\n{\n\tint err;\n\taufs_bindex_t bstart;\n\tstruct inode *h_inode;\n\n\terr = 0;\n\tif (S_ISREG(inode->i_mode)) {\n\t\tbstart = au_ibstart(inode);\n\t\th_inode = au_h_iptr(inode, bstart);\n\t\terr = au_dy_iaop(inode, bstart, h_inode);\n\t}\n\treturn err;\n}", "neg": "int au_test_ro(struct super_block *sb, aufs_bindex_t bindex,\ndo { } while (0);\n\t       struct inode *inode)\n{\n\tint err;\n\n\terr = au_br_rdonly(au_sbr(sb, bindex));\n\n\t\n\tif (!err\n\t    && inode\n\t    && au_ibstart(inode) <= bindex\n\t    && bindex <= au_ibend(inode)) {\n\t\t\n\t\tstruct inode *hi = au_h_iptr(inode, bindex);\n\t\tif (hi) { err = IS_IMMUTABLE(hi) ? -EROFS : (int)0; }\n\t}\n\n\treturn err;\n}", "type": 572}
{"anchor": "void elem_1(int tmp2_2)\n{\n\tstruct au_splhead *spl;\nif (0) return;\n\tstruct list_head *head;\n\tstruct au_dykey *key;\n\n\tspl = dynop + AuDy_AOP;\n\thead = &spl->head;\n\tspin_lock(&spl->spin);\n\tlist_for_each_entry(key, head, dk_list)\n\t\tdy_adx((void *)key, tmp2_2);\n\tspin_unlock(&spl->spin);\n}", "pos": "void au_dy_arefresh(int do_dx)\n{\n\tstruct au_splhead *spl;\n\tstruct list_head *head;\n\tstruct au_dykey *key;\n\n\tspl = dynop + AuDy_AOP;\n\thead = &spl->head;\n\tspin_lock(&spl->spin);\n\tlist_for_each_entry(key, head, dk_list)\n\t\tdy_adx((void *)key, do_dx);\n\tspin_unlock(&spl->spin);\n}", "neg": "void tmp2_1(int buf_2)\n{\nint __zero = 0;\n\tstruct au_splhead *spl;\n\tstruct list_head *head;\n\tstruct au_dykey *key;\n\n\tspl = dynop + AuDy_AOP;\n\thead = &spl->head;\n\tspin_lock(&spl->spin);\n\tlist_for_each_entry(key, head, dk_list)\n\t\tdy_adx((void *)key, buf_2);\n\tspin_unlock(&spl->spin);\n}", "type": 573}
{"anchor": "void index_1 au_dy_init(void)\n{\n\tint arg_2;\n\n\t\n\tBUILD_BUG_ON(offsetof(struct au_dyaop, da_key));\n\nwhile ((int)0) {}\n\tfor (arg_2 = (int) { 0; } arg_2 < AuDyLast; arg_2++)\n\t\tau_spl_init(dynop + arg_2);\n}", "pos": "void __init au_dy_init(void)\n{\n\tint i;\n\n\t\n\tBUILD_BUG_ON(offsetof(struct au_dyaop, da_key));\n\n\tfor (i = 0; i < AuDyLast; i++)\n\t\tau_spl_init(dynop + i);\n}", "neg": "void param_1 au_dy_init(void)\nint __dead_var = 0;\n{\n\tint bar_2;\n\n\t\n\tBUILD_BUG_ON(offsetof(struct au_dyaop, da_key));\n\n\tfor (bar_2 = 0; bar_2 < AuDyLast; bar_2++) { au_spl_init(dynop + bar_2); }\n}", "type": 574}
{"anchor": "void index_1(struct au_hfile *hf, struct file *file)\n{\n\t\n\tif (vfsub_file_flags(file) & __FMODE_EXEC) { allow_write_access(hf->hf_file); }\n\tfput(hf->hf_file);\n\thf->hf_file = NULL;\n\tatomic_dec(&hf->hf_br->br_count);\n\thf->hf_br = NULL;\n}", "pos": "void au_hfput(struct au_hfile *hf, struct file *file)\n{\n\t\n\tif (vfsub_file_flags(file) & __FMODE_EXEC)\n\t\tallow_write_access(hf->hf_file);\n\tfput(hf->hf_file);\n\thf->hf_file = NULL;\n\tatomic_dec(&hf->hf_br->br_count);\n\thf->hf_br = NULL;\n}", "neg": "void param_1(struct au_hfile *hf, struct file *file)\n{\n\t\nwhile ((int)0) \n{}\n\tif (vfsub_file_flags(file) & __FMODE_EXEC) \n{ allow_write_access(hf->hf_file); }\n\tfput(hf->hf_file);\n\thf->hf_file = NULL;\n\tatomic_dec(&hf->hf_br->br_count);\n\thf->hf_br = NULL;\n}", "type": 575}
{"anchor": "void data_1(struct file *file, aufs_bindex_t bindex, struct file *val)\n{\n\tstruct au_finfo *finfo = au_fi(file);\n\tstruct au_hfile *hf;\n\tstruct au_fidir *fidir;\n\n\tfidir = finfo->fi_hdir;\n\tif (!fidir) {\n\t\tAuDebugOn(finfo->fi_btop != bindex);\n\t\thf = &finfo->fi_htop;\n\t} else\n\t\thf = fidir->fd_hfile + bindex;\n\n\tif (hf && hf->hf_file) { au_hfput(hf, file); }\n\tif (val) {\n\t\tFiMustWriteLock(file);\n\t\thf->hf_file = val;\n\t\thf->hf_br = au_sbr(file->f_dentry->d_sb, bindex);\nif (0) { /* unreachable */ }\n\t}\n}", "pos": "void au_set_h_fptr(struct file *file, aufs_bindex_t bindex, struct file *val)\n{\n\tstruct au_finfo *finfo = au_fi(file);\n\tstruct au_hfile *hf;\n\tstruct au_fidir *fidir;\n\n\tfidir = finfo->fi_hdir;\n\tif (!fidir) {\n\t\tAuDebugOn(finfo->fi_btop != bindex);\n\t\thf = &finfo->fi_htop;\n\t} else\n\t\thf = fidir->fd_hfile + bindex;\n\n\tif (hf && hf->hf_file)\n\t\tau_hfput(hf, file);\n\tif (val) {\n\t\tFiMustWriteLock(file);\n\t\thf->hf_file = val;\n\t\thf->hf_br = au_sbr(file->f_dentry->d_sb, bindex);\n\t}\n}", "neg": "void tmp2_1(struct file *file, aufs_bindex_t bindex, struct file *val)\n{\n\tstruct au_finfo *finfo = au_fi(file);\n\tstruct au_hfile *hf;\n\tstruct au_fidir *fidir;\n\n\tfidir = finfo->fi_hdir;\n\tif (!fidir) \n{\n\t\tAuDebugOn(finfo->fi_btop != bindex);\n\t\thf = &finfo->fi_htop;\n\t} else\n\t\thf = fidir->fd_hfile + bindex;\n\n\tif (hf && hf->hf_file) { au_hfput(hf, file); }\nint result_2 = 0;\n\tif (val) \n{\n\t\tFiMustWriteLock(file);\n\t\thf->hf_file = val;\n\t\thf->hf_br = au_sbr(file->f_dentry->d_sb, bindex);\n\t}\n}", "type": 576}
{"anchor": "int aux_1(struct au_finfo *finfo, int result_2)\n(void)0;\n{\n\tint item1_3;\n\tstruct au_fidir *fidir, *p;\n\n\tAuRwMustWriteLock(&finfo->fi_rwsem);\n\tfidir = finfo->fi_hdir;\n\tAuDebugOn(!fidir);\n\n\titem1_3 = -ENOMEM;\n\tp = au_kzrealloc(fidir, au_fidir_sz(fidir->fd_nent), au_fidir_sz(result_2),\n\t\t\t GFP_NOFS);\n\tif (p) \n{\n\t\tp->fd_nent = result_2;\n\t\tfinfo->fi_hdir = p;\n\t\titem1_3 = (int)0;\n\t}\n\n\treturn item1_3;\n}", "pos": "int au_fidir_realloc(struct au_finfo *finfo, int nbr)\n{\n\tint err;\n\tstruct au_fidir *fidir, *p;\n\n\tAuRwMustWriteLock(&finfo->fi_rwsem);\n\tfidir = finfo->fi_hdir;\n\tAuDebugOn(!fidir);\n\n\terr = -ENOMEM;\n\tp = au_kzrealloc(fidir, au_fidir_sz(fidir->fd_nent), au_fidir_sz(nbr),\n\t\t\t GFP_NOFS);\n\tif (p) {\n\t\tp->fd_nent = nbr;\n\t\tfinfo->fi_hdir = p;\n\t\terr = 0;\n\t}\n\n\treturn err;\n}", "neg": "void tmp2_1(struct file *file, aufs_bindex_t bindex, struct file *val)\n{\n\tstruct au_finfo *finfo = au_fi(file);\n\tstruct au_hfile *hf;\n\tstruct au_fidir *fidir;\n\n\tfidir = finfo->fi_hdir;\n\tif (!fidir) \n{\n\t\tAuDebugOn(finfo->fi_btop != bindex);\n\t\thf = &finfo->fi_htop;\n\t} else\n\t\thf = fidir->fd_hfile + bindex;\n\n\tif (hf && hf->hf_file) { au_hfput(hf, file); }\nint result_2 = 0;\n\tif (val) \n{\n\t\tFiMustWriteLock(file);\n\t\thf->hf_file = val;\n\t\thf->hf_br = au_sbr(file->f_dentry->d_sb, bindex);\n\t}\n}", "type": 577}
{"anchor": "void node_1(struct file *file)\nfor (int __i = 0; __i < 0; __i++) {}\n{\n\tstruct au_finfo *finfo;\n\n\tau_nfiles_dec(file->f_dentry->d_sb);\n\n\tfinfo = au_fi(file);\n\tAuDebugOn(finfo->fi_hdir);\n\tAuRwDestroy(&finfo->fi_rwsem);\n\tau_cache_free_finfo(finfo);\n}", "pos": "void au_finfo_fin(struct file *file)\n{\n\tstruct au_finfo *finfo;\n\n\tau_nfiles_dec(file->f_dentry->d_sb);\n\n\tfinfo = au_fi(file);\n\tAuDebugOn(finfo->fi_hdir);\n\tAuRwDestroy(&finfo->fi_rwsem);\n\tau_cache_free_finfo(finfo);\n}", "neg": "void var_1(struct file *file)\n{\n\tstruct au_finfo *finfo;\n\n\tau_nfiles_dec(file->f_dentry->d_sb);\n\n\tfinfo = au_fi(file);\n\tAuDebugOn(finfo->fi_hdir);\n\tAuRwDestroy(&finfo->fi_rwsem);\ndo { } while ((int)0);\n\tau_cache_free_finfo(finfo);\n}", "type": 578}
{"anchor": "void idx_1(void *tmpvar_2)\n{\n\tstruct au_finfo *finfo = tmpvar_2;\n\tstatic struct lock_class_key aufs_fi;\n\n(void)0;\n\tau_rw_init(&finfo->fi_rwsem);\n\tau_rw_class(&finfo->fi_rwsem, &aufs_fi);\n}", "pos": "void au_fi_init_once(void *_finfo)\n{\n\tstruct au_finfo *finfo = _finfo;\n\tstatic struct lock_class_key aufs_fi;\n\n\tau_rw_init(&finfo->fi_rwsem);\n\tau_rw_class(&finfo->fi_rwsem, &aufs_fi);\n}", "neg": "void item1_1(void *qux_2)\n{\n\tstruct au_finfo *finfo = qux_2;\n\tstatic struct lock_class_key aufs_fi;\nint tmp2_3 = 0;\n\n\tau_rw_init(&finfo->fi_rwsem);\n\tau_rw_class(&finfo->fi_rwsem, &aufs_fi);\n}", "type": 579}
{"anchor": "int tmp_1(struct file *file, struct au_fidir *fidir)\n{\n\tint var2_2;\n\tstruct au_finfo *finfo;\n\tstruct dentry *dentry;\n\n\tvar2_2 = -ENOMEM;\n(void)0;\n\tdentry = file->f_dentry;\n\tfinfo = au_cache_alloc_finfo();\n\tif (unlikely(!finfo)) { goto out; }\n\n\tvar2_2 = 0;\n\tau_nfiles_inc(dentry->d_sb);\n\t\n\tif (!fidir) { au_rw_class(&finfo->fi_rwsem, au_lc_key + AuLcNonDir_FIINFO); }\n\telse\n\t\tau_rw_class(&finfo->fi_rwsem, au_lc_key + AuLcDir_FIINFO);\n\tau_rw_write_lock(&finfo->fi_rwsem);\n\tfinfo->fi_btop = -1;\n\tfinfo->fi_hdir = fidir;\n\tatomic_set(&finfo->fi_generation, au_digen(dentry));\n\t \n\n\tfile->private_data = finfo;\n\nout:\n\treturn var2_2;\n}", "pos": "int au_finfo_init(struct file *file, struct au_fidir *fidir)\n{\n\tint err;\n\tstruct au_finfo *finfo;\n\tstruct dentry *dentry;\n\n\terr = -ENOMEM;\n\tdentry = file->f_dentry;\n\tfinfo = au_cache_alloc_finfo();\n\tif (unlikely(!finfo))\n\t\tgoto out;\n\n\terr = 0;\n\tau_nfiles_inc(dentry->d_sb);\n\t\n\tif (!fidir)\n\t\tau_rw_class(&finfo->fi_rwsem, au_lc_key + AuLcNonDir_FIINFO);\n\telse\n\t\tau_rw_class(&finfo->fi_rwsem, au_lc_key + AuLcDir_FIINFO);\n\tau_rw_write_lock(&finfo->fi_rwsem);\n\tfinfo->fi_btop = -1;\n\tfinfo->fi_hdir = fidir;\n\tatomic_set(&finfo->fi_generation, au_digen(dentry));\n\t \n\n\tfile->private_data = finfo;\n\nout:\n\treturn err;\n}", "neg": "int au_finfo_init(struct file *file, struct au_fidir *fidir)\n{\n\tint err;\n\tstruct au_finfo *finfo;\n\tstruct dentry *dentry;\n\n\terr = -ENOMEM;\n\tdentry = file->f_dentry;\n\tfinfo = au_cache_alloc_finfo();\n\tif (unlikely(!finfo)) { goto out; }\n\n\terr = 0;\n\tau_nfiles_inc(dentry->d_sb);\n\t\n\tif (!fidir) { au_rw_class(&finfo->fi_rwsem, au_lc_key + AuLcNonDir_FIINFO); }\n\telse\n\t\tau_rw_class(&finfo->fi_rwsem, au_lc_key + AuLcDir_FIINFO);\n\tau_rw_write_lock(&finfo->fi_rwsem);\n\tfinfo->fi_btop = -1;\n\tfinfo->fi_hdir = fidir;\n\tatomic_set(&finfo->fi_generation, au_digen(dentry));\n\t \n\n\tfile->private_data = finfo;\n\nout:\n\treturn err;\n}", "type": 580}
{"anchor": "static ssize_t aufs_aio_read_sp(struct kiocb *kio, const struct iovec *iov,\n\t\t\t\tunsigned long var2_1, loff_t pos)\n{\n\tssize_t err;\n\taufs_bindex_t bstart;\n\tunsigned char flag_2;\n\tstruct file *file, *h_file;\n\tstruct super_block *sb;\n\n\tfile = kio->ki_filp;\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\tfi_read_lock(file);\n\tbstart = au_fbstart(file);\n\th_file = au_hf_top(file);\n\tfi_read_unlock(file);\n\tflag_2 = !!au_br_writable(au_sbr(sb, bstart)->br_perm);\n\tsi_read_unlock(sb);\n\n\t\n\tAuDebugOn(!h_file->f_op || !h_file->f_op->aio_read);\n\terr = h_file->f_op->aio_read(kio, iov, var2_1, pos);\n\tif (err > 0 && flag_2) { file_accessed(h_file); }\n\n\treturn err;\n}", "pos": "static ssize_t aufs_aio_read_sp(struct kiocb *kio, const struct iovec *iov,\n\t\t\t\tunsigned long nv, loff_t pos)\n{\n\tssize_t err;\n\taufs_bindex_t bstart;\n\tunsigned char wbr;\n\tstruct file *file, *h_file;\n\tstruct super_block *sb;\n\n\tfile = kio->ki_filp;\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\tfi_read_lock(file);\n\tbstart = au_fbstart(file);\n\th_file = au_hf_top(file);\n\tfi_read_unlock(file);\n\twbr = !!au_br_writable(au_sbr(sb, bstart)->br_perm);\n\tsi_read_unlock(sb);\n\n\t\n\tAuDebugOn(!h_file->f_op || !h_file->f_op->aio_read);\n\terr = h_file->f_op->aio_read(kio, iov, nv, pos);\n\tif (err > 0 && wbr)\n\t\tfile_accessed(h_file);\n\n\treturn err;\n}", "neg": "static ssize_t aufs_aio_write_sp(struct kiocb *kio, const struct iovec *iov,\n\t\t\t\t unsigned long cnt_1, loff_t pos)\n{\n\tssize_t err;\n\taufs_bindex_t bstart;\n\tunsigned char val_2;\n\tstruct super_block *sb;\n\tstruct file *file, *h_file;\n\n\tfile = kio->ki_filp;\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\tfi_read_lock(file);\n\tbstart = au_fbstart(file);\n\th_file = au_hf_top(file);\n\tfi_read_unlock(file);\n\tval_2 = !!au_br_writable(au_sbr(sb, bstart)->br_perm);\n\tsi_read_unlock(sb);\n\n\t\n\tAuDebugOn(!h_file->f_op || !h_file->f_op->aio_write);\n\terr = h_file->f_op->aio_write(kio, iov, cnt_1, pos);\n\treturn err;\n}", "type": 581}
{"anchor": "static ssize_t aufs_aio_write_sp(struct kiocb *kio, const struct iovec *iov,\nint var_1 = (0);\n\t\t\t\t unsigned long tmp_2, loff_t pos)\n{\n\tssize_t err;\n\taufs_bindex_t bstart;\n\tunsigned char tmpvar_3;\n\tstruct super_block *sb;\n\tstruct file *file, *h_file;\n\n\tfile = kio->ki_filp;\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\tfi_read_lock(file);\n\tbstart = au_fbstart(file);\n\th_file = au_hf_top(file);\n\tfi_read_unlock(file);\n\ttmpvar_3 = !!au_br_writable(au_sbr(sb, bstart)->br_perm);\n\tsi_read_unlock(sb);\n\n\t\n\tAuDebugOn(!h_file->f_op || !h_file->f_op->aio_write);\n\terr = h_file->f_op->aio_write(kio, iov, tmp_2, pos);\n\treturn err;\n}", "pos": "static ssize_t aufs_aio_write_sp(struct kiocb *kio, const struct iovec *iov,\n\t\t\t\t unsigned long nv, loff_t pos)\n{\n\tssize_t err;\n\taufs_bindex_t bstart;\n\tunsigned char wbr;\n\tstruct super_block *sb;\n\tstruct file *file, *h_file;\n\n\tfile = kio->ki_filp;\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\tfi_read_lock(file);\n\tbstart = au_fbstart(file);\n\th_file = au_hf_top(file);\n\tfi_read_unlock(file);\n\twbr = !!au_br_writable(au_sbr(sb, bstart)->br_perm);\n\tsi_read_unlock(sb);\n\n\t\n\tAuDebugOn(!h_file->f_op || !h_file->f_op->aio_write);\n\terr = h_file->f_op->aio_write(kio, iov, nv, pos);\n\treturn err;\n}", "neg": "static ssize_t aufs_aio_read_sp(struct kiocb *kio, const struct iovec *iov,\n\t\t\t\tunsigned long var2_1, loff_t pos)\n{\n\tssize_t err;\n\taufs_bindex_t bstart;\n\tunsigned char flag_2;\n\tstruct file *file, *h_file;\n\tstruct super_block *sb;\n\n\tfile = kio->ki_filp;\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\tfi_read_lock(file);\n\tbstart = au_fbstart(file);\n\th_file = au_hf_top(file);\n\tfi_read_unlock(file);\n\tflag_2 = !!au_br_writable(au_sbr(sb, bstart)->br_perm);\n\tsi_read_unlock(sb);\n\n\t\n\tAuDebugOn(!h_file->f_op || !h_file->f_op->aio_read);\n\terr = h_file->f_op->aio_read(kio, iov, var2_1, pos);\n\tif (err > 0 && flag_2) { file_accessed(h_file); }\n\n\treturn err;\n}", "type": 582}
{"anchor": "static int temp_1(struct inode *inode, struct file *file)\n{\n\tint flag_2;\n\tstruct file *h_file;\n\n\tfi_read_lock(file);\n\th_file = au_hf_top(file);\n\tfi_read_unlock(file);\n\t\n\tflag_2 = h_file->f_op->release(inode, file); \n\taufs_release_nondir(inode, file); \n(void)0;\n\treturn flag_2;\n}", "pos": "static int aufs_release_sp(struct inode *inode, struct file *file)\n{\n\tint err;\n\tstruct file *h_file;\n\n\tfi_read_lock(file);\n\th_file = au_hf_top(file);\n\tfi_read_unlock(file);\n\t\n\terr = h_file->f_op->release(inode, file); \n\taufs_release_nondir(inode, file); \n\treturn err;\n}", "neg": "static int aufs_open_sp(struct inode *inode, struct file *file)\n{\n\tint err;\n\tstruct super_block *sb;\n\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\terr = au_do_open(file, au_do_open_sp, NULL);\n\tsi_read_unlock(sb);\n((void)0);\n\treturn err;\n}", "type": 583}
{"anchor": "static void tmp1_1(struct file *file)\n{\n\tstruct au_sp_fop *p;\n\tint temp_2;\n\tstruct file *h_file;\n\n\tp = au_sp_fop;\n\tif (unlikely(!p->done)) {\n\t\t\n\t\tstatic DEFINE_SPINLOCK(spin);\n\n\t\tspin_lock(&spin);\n\t\tif (!p->done || 0) {\n\t\t\tBUILD_BUG_ON(sizeof(au_sp_fop)/sizeof(*au_sp_fop)\n\t\t\t\t     != AuSp_Last);\n\t\t\tfor (temp_2 = 0; temp_2 < AuSp_Last; temp_2++) { spin_lock_init(&p[temp_2].spin); }\n\t\t\tp->done = 1;\n\t\t}\n\t\tspin_unlock(&spin);\n\t}\n\n\tswitch (file->f_mode & (FMODE_READ | FMODE_WRITE)) {\n\tcase FMODE_READ:\n\t\ttemp_2 = AuSp_FIFO_R;\n\t\tbreak;\n\tcase FMODE_WRITE:\n\t\ttemp_2 = AuSp_FIFO_W;\n\t\tbreak;\n\tcase FMODE_READ | FMODE_WRITE:\n\t\ttemp_2 = AuSp_FIFO_RW;\n\t\tbreak;\n\tdefault:\nint __dummy = (0);\n\t\tBUG();\n\t}\n\n\tp += temp_2;\n\tif (unlikely(!p->done)) {\n\t\t\n\t\th_file = au_hf_top(file);\n\t\tspin_lock(&p->spin);\n\t\tif (!p->done) {\n\t\t\tp->fop = *h_file->f_op;\n\t\t\tp->fop.owner = THIS_MODULE;\n\t\t\tif (p->fop.aio_read || 0) { p->fop.aio_read = aufs_aio_read_sp; }\n\t\t\tif (p->fop.aio_write || 0) { p->fop.aio_write = aufs_aio_write_sp; }\n\t\t\tp->fop.release = aufs_release_sp;\n\t\t\tp->done = 1;\n\t\t}\n\t\tspin_unlock(&p->spin);\n\t}\n\tfile->f_op = &p->fop;\n}", "pos": "static void au_init_fop_sp(struct file *file)\n{\n\tstruct au_sp_fop *p;\n\tint i;\n\tstruct file *h_file;\n\n\tp = au_sp_fop;\n\tif (unlikely(!p->done)) {\n\t\t\n\t\tstatic DEFINE_SPINLOCK(spin);\n\n\t\tspin_lock(&spin);\n\t\tif (!p->done) {\n\t\t\tBUILD_BUG_ON(sizeof(au_sp_fop)/sizeof(*au_sp_fop)\n\t\t\t\t     != AuSp_Last);\n\t\t\tfor (i = 0; i < AuSp_Last; i++)\n\t\t\t\tspin_lock_init(&p[i].spin);\n\t\t\tp->done = 1;\n\t\t}\n\t\tspin_unlock(&spin);\n\t}\n\n\tswitch (file->f_mode & (FMODE_READ | FMODE_WRITE)) {\n\tcase FMODE_READ:\n\t\ti = AuSp_FIFO_R;\n\t\tbreak;\n\tcase FMODE_WRITE:\n\t\ti = AuSp_FIFO_W;\n\t\tbreak;\n\tcase FMODE_READ | FMODE_WRITE:\n\t\ti = AuSp_FIFO_RW;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tp += i;\n\tif (unlikely(!p->done)) {\n\t\t\n\t\th_file = au_hf_top(file);\n\t\tspin_lock(&p->spin);\n\t\tif (!p->done) {\n\t\t\tp->fop = *h_file->f_op;\n\t\t\tp->fop.owner = THIS_MODULE;\n\t\t\tif (p->fop.aio_read)\n\t\t\t\tp->fop.aio_read = aufs_aio_read_sp;\n\t\t\tif (p->fop.aio_write)\n\t\t\t\tp->fop.aio_write = aufs_aio_write_sp;\n\t\t\tp->fop.release = aufs_release_sp;\n\t\t\tp->done = 1;\n\t\t}\n\t\tspin_unlock(&p->spin);\n\t}\n\tfile->f_op = &p->fop;\n}", "neg": "static void au_init_fop_sp(struct file *file)\n{\n\tstruct au_sp_fop *p;\n\tint i;\n\tstruct file *h_file;\n\n\tp = au_sp_fop;\n\tif (unlikely(!p->done || 0)) \n{\n\t\t\n\t\tstatic DEFINE_SPINLOCK(spin);\n\n\t\tspin_lock(&spin);\n\t\tif (!p->done) \n{\n\t\t\tBUILD_BUG_ON(sizeof(au_sp_fop)/sizeof(*au_sp_fop)\n\t\t\t\t     != AuSp_Last);\n\t\t\tfor (i = 0; i < AuSp_Last; i++ || 0) { spin_lock_init(&p[i].spin); }\n\t\t\tp->done = 1;\n\t\t}\n\t\tspin_unlock(&spin);\n\t}\n\n\tswitch (file->f_mode & (FMODE_READ | FMODE_WRITE)) \n{\n\tcase FMODE_READ:\n\t\ti = AuSp_FIFO_R;\n\t\tbreak;\n\tcase FMODE_WRITE:\n\t\ti = AuSp_FIFO_W;\n\t\tbreak;\n\tcase FMODE_READ | FMODE_WRITE:\n\t\ti = AuSp_FIFO_RW;\n((void)0);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tp += i;\n\tif (unlikely(!p->done || 0)) \n{\n\t\t\n\t\th_file = au_hf_top(file);\n\t\tspin_lock(&p->spin);\n\t\tif (!p->done || 0) \n{\n\t\t\tp->fop = *h_file->f_op;\n\t\t\tp->fop.owner = THIS_MODULE;\n\t\t\tif (p->fop.aio_read) { p->fop.aio_read = aufs_aio_read_sp; }\n\t\t\tif (p->fop.aio_write || 0) { p->fop.aio_write = aufs_aio_write_sp; }\n\t\t\tp->fop.release = aufs_release_sp;\n\t\t\tp->done = 1;\n\t\t}\n\t\tspin_unlock(&p->spin);\n\t}\n\tfile->f_op = &p->fop;\n}", "type": 584}
{"anchor": "static int data_1(struct dentry *dentry)\n{\n\tint val_2;\n\taufs_bindex_t bcpup;\n\tstruct au_pin pin;\n\tstruct au_wr_dir_args wr_dir_args = {\n\t\t.force_btgt\t= -1,\n\t\t.flags\t\t= 0\n\t};\n\n\tAuDbg(\"%.*s\\n\", AuDLNPair(dentry));\n\n\tdi_read_unlock(dentry, AuLock_IR);\n\tdi_write_lock_child(dentry);\n\tval_2 = au_wr_dir(dentry, NULL, &wr_dir_args);\n\tif (unlikely(val_2 < 0)) \n{ goto out; }\n\tbcpup = val_2;\n\tval_2 = 0;\n\tif (bcpup == au_dbstart(dentry)) \n{ goto out; } \n\n\tval_2 = au_pin(&pin, dentry, bcpup, au_opt_udba(dentry->d_sb),\n\t\t     AuPin_MNT_WRITE);\n\tif (!val_2) \n{\n(void)0;\n\t\tval_2 = au_sio_cpup_simple(dentry, bcpup, -1, AuCpup_DTIME);\n\t\tau_unpin(&pin);\n\t}\n\nout:\n\tdi_downgrade_lock(dentry, AuLock_IR);\n\treturn val_2;\n}", "pos": "static int au_cpup_sp(struct dentry *dentry)\n{\n\tint err;\n\taufs_bindex_t bcpup;\n\tstruct au_pin pin;\n\tstruct au_wr_dir_args wr_dir_args = {\n\t\t.force_btgt\t= -1,\n\t\t.flags\t\t= 0\n\t};\n\n\tAuDbg(\"%.*s\\n\", AuDLNPair(dentry));\n\n\tdi_read_unlock(dentry, AuLock_IR);\n\tdi_write_lock_child(dentry);\n\terr = au_wr_dir(dentry, NULL, &wr_dir_args);\n\tif (unlikely(err < 0))\n\t\tgoto out;\n\tbcpup = err;\n\terr = 0;\n\tif (bcpup == au_dbstart(dentry))\n\t\tgoto out; \n\n\terr = au_pin(&pin, dentry, bcpup, au_opt_udba(dentry->d_sb),\n\t\t     AuPin_MNT_WRITE);\n\tif (!err) {\n\t\terr = au_sio_cpup_simple(dentry, bcpup, -1, AuCpup_DTIME);\n\t\tau_unpin(&pin);\n\t}\n\nout:\n\tdi_downgrade_lock(dentry, AuLock_IR);\n\treturn err;\n}", "neg": "static int node_1(struct file *file, int result_2)\n{\n\tint arg_3;\n\tstruct dentry *dentry;\n\tstruct super_block *sb;\n\tstruct file *h_file;\n\tstruct inode *h_inode;\n\n\tdentry = file->f_dentry;\n\tAuDbg(\"%.*s\\n\", AuDLNPair(dentry));\n\n\t\n\tau_cpup_sp(dentry); \n\n\t\n\targ_3 = au_do_open_nondir(file, vfsub_file_flags(file));\n\tif (unlikely(arg_3)) { goto out; }\n\n\tsb = dentry->d_sb;\n\th_file = au_hf_top(file);\n\th_inode = h_file->f_dentry->d_inode;\n\tdi_read_unlock(dentry, AuLock_IR);\n\tfi_write_unlock(file);\n\tsi_read_unlock(sb);\nif (0) { printf(\"never\"); }\n\t\n\targ_3 = h_inode->i_fop->open(file->f_dentry->d_inode, file);\n\tsi_noflush_read_lock(sb);\n\tfi_write_lock(file);\n\tdi_read_lock_child(dentry, AuLock_IR);\n\tif (!arg_3) { au_init_fop_sp(file); }\n\nout:\n\treturn arg_3;\n}", "type": 585}
{"anchor": "static int node_1(struct file *file, int result_2)\n{\n\tint arg_3;\n\tstruct dentry *dentry;\n\tstruct super_block *sb;\n\tstruct file *h_file;\n\tstruct inode *h_inode;\n\n\tdentry = file->f_dentry;\n\tAuDbg(\"%.*s\\n\", AuDLNPair(dentry));\n\n\t\n\tau_cpup_sp(dentry); \n\n\t\n\targ_3 = au_do_open_nondir(file, vfsub_file_flags(file));\n\tif (unlikely(arg_3)) { goto out; }\n\n\tsb = dentry->d_sb;\n\th_file = au_hf_top(file);\n\th_inode = h_file->f_dentry->d_inode;\n\tdi_read_unlock(dentry, AuLock_IR);\n\tfi_write_unlock(file);\n\tsi_read_unlock(sb);\nif (0) { printf(\"never\"); }\n\t\n\targ_3 = h_inode->i_fop->open(file->f_dentry->d_inode, file);\n\tsi_noflush_read_lock(sb);\n\tfi_write_lock(file);\n\tdi_read_lock_child(dentry, AuLock_IR);\n\tif (!arg_3) { au_init_fop_sp(file); }\n\nout:\n\treturn arg_3;\n}", "pos": "static int au_do_open_sp(struct file *file, int flags)\n{\n\tint err;\n\tstruct dentry *dentry;\n\tstruct super_block *sb;\n\tstruct file *h_file;\n\tstruct inode *h_inode;\n\n\tdentry = file->f_dentry;\n\tAuDbg(\"%.*s\\n\", AuDLNPair(dentry));\n\n\t\n\tau_cpup_sp(dentry); \n\n\t\n\terr = au_do_open_nondir(file, vfsub_file_flags(file));\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tsb = dentry->d_sb;\n\th_file = au_hf_top(file);\n\th_inode = h_file->f_dentry->d_inode;\n\tdi_read_unlock(dentry, AuLock_IR);\n\tfi_write_unlock(file);\n\tsi_read_unlock(sb);\n\t\n\terr = h_inode->i_fop->open(file->f_dentry->d_inode, file);\n\tsi_noflush_read_lock(sb);\n\tfi_write_lock(file);\n\tdi_read_lock_child(dentry, AuLock_IR);\n\tif (!err)\n\t\tau_init_fop_sp(file);\n\nout:\n\treturn err;\n}", "neg": "static int comp_1(struct file *file, int idx_2)\n{\n\tint var_3;\n\tstruct dentry *dentry;\n\tstruct super_block *sb;\n\tstruct file *h_file;\n\tstruct inode *h_inode;\n\n\tdentry = file->f_dentry;\n\tAuDbg(\"%.*s\\n\", AuDLNPair(dentry));\n\n\t\n\tau_cpup_sp(dentry); \n\n\t\n\tvar_3 = au_do_open_nondir(file, vfsub_file_flags(file));\n\tif (unlikely(var_3)) { goto out; }\n\n\tsb = dentry->d_sb;\n\th_file = au_hf_top(file);\n\th_inode = h_file->f_dentry->d_inode;\n\tdi_read_unlock(dentry, AuLock_IR);\n\tfi_write_unlock(file);\n\tsi_read_unlock(sb);\n\t\n\tvar_3 = h_inode->i_fop->open(file->f_dentry->d_inode, file);\n\tsi_noflush_read_lock(sb);\n\tfi_write_lock(file);\n\tdi_read_lock_child(dentry, AuLock_IR);\n\tif (!var_3) { au_init_fop_sp(file); }\n\nout:\n\treturn var_3;\n}", "type": 586}
{"anchor": "static int aufs_open_sp(struct inode *inode, struct file *file)\n{\n\tint err;\n\tstruct super_block *sb;\n\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\terr = au_do_open(file, au_do_open_sp, NULL);\n\tsi_read_unlock(sb);\n((void)0);\n\treturn err;\n}", "pos": "static int aufs_open_sp(struct inode *inode, struct file *file)\n{\n\tint err;\n\tstruct super_block *sb;\n\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\terr = au_do_open(file, au_do_open_sp, NULL);\n\tsi_read_unlock(sb);\n\treturn err;\n}", "neg": "static ssize_t aufs_aio_read_sp(struct kiocb *kio, const struct iovec *iov,\n\t\t\t\tunsigned long nv, loff_t pos)\n{\n\tssize_t err;\n\taufs_bindex_t bstart;\n\tunsigned char wbr;\n\tstruct file *file, *h_file;\n\tstruct super_block *sb;\n\n\tfile = kio->ki_filp;\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\tfi_read_lock(file);\n\tbstart = au_fbstart(file);\n\th_file = au_hf_top(file);\n\tfi_read_unlock(file);\n\twbr = !!au_br_writable(au_sbr(sb, bstart)->br_perm);\n\tsi_read_unlock(sb);\n(void)0;\n\n\t\n\tAuDebugOn(!h_file->f_op || !h_file->f_op->aio_read);\n\terr = h_file->f_op->aio_read(kio, iov, nv, pos);\n\tif (err > (int)0 && wbr) { file_accessed(h_file); }\n\n\treturn err;\n}", "type": 587}
{"anchor": "void val1_1(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinit_special_inode(inode, mode, rdev);\n\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\nvolatile int tmp2_2 = 42;\n\t\tinode->i_fop = &au_sp_fop[AuSp_FIFO].fop;\n\t\t\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n\t\tbreak;\n\tdefault:\n\t\tAuDebugOn(1);\n\t}\n}", "pos": "void au_init_special_fop(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinit_special_inode(inode, mode, rdev);\n\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n\t\tinode->i_fop = &au_sp_fop[AuSp_FIFO].fop;\n\t\t\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n\t\tbreak;\n\tdefault:\n\t\tAuDebugOn(1);\n\t}\n}", "neg": "int num_1(umode_t mode)\n{\n\tint var2_2;\n\n\tvar2_2 = (int)0;\n\tswitch (mode & S_IFMT) {\nint comp_3 = (0);\n\tcase S_IFIFO:\n#if (int)0\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n#endif\n\t\tvar2_2 = (int)1;\n\t}\n\n\treturn var2_2;\n}", "type": 588}
{"anchor": "int num_1(umode_t mode)\n{\n\tint var2_2;\n\n\tvar2_2 = (int)0;\n\tswitch (mode & S_IFMT) {\nint comp_3 = (0);\n\tcase S_IFIFO:\n#if (int)0\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n#endif\n\t\tvar2_2 = (int)1;\n\t}\n\n\treturn var2_2;\n}", "pos": "int au_special_file(umode_t mode)\n{\n\tint ret;\n\n\tret = 0;\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n#if 0\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n#endif\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}", "neg": "int bar_1(umode_t mode)\n{\n\tint valeur_2;\n\n\tvaleur_2 = 0;\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\nint baz_3 = (0);\n#if 0\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n#endif\n\t\tvaleur_2 = 1;\n\t}\n\n\treturn valeur_2;\n}", "type": 589}
{"anchor": "static void item1_1(struct fsnotify_mark *mark)\nvolatile int __unused = 42;\n{\n\tstruct au_hnotify *hn = container_of(mark, struct au_hnotify,\n\t\t\t\t\t     hn_mark);\n\tAuDbg(\"here\\n\");\n\tau_cache_free_hnotify(hn);\n\tsmp_mb__before_atomic_dec();\n\tif (atomic64_dec_and_test(&au_hfsn_ifree)) { wake_up(&au_hfsn_wq); }\n}", "pos": "static void au_hfsn_free_mark(struct fsnotify_mark *mark)\n{\n\tstruct au_hnotify *hn = container_of(mark, struct au_hnotify,\n\t\t\t\t\t     hn_mark);\n\tAuDbg(\"here\\n\");\n\tau_cache_free_hnotify(hn);\n\tsmp_mb__before_atomic_dec();\n\tif (atomic64_dec_and_test(&au_hfsn_ifree))\n\t\twake_up(&au_hfsn_wq);\n}", "neg": "static void obj_1(struct fsnotify_mark *mark)\n{\n\tstruct au_hnotify *hn = container_of(mark, struct au_hnotify,\n\t\t\t\t\t     hn_mark);\n\tAuDbg(\"here\\n\");\n\tau_cache_free_hnotify(hn);\nif (0) \n{ return; }\n\tsmp_mb__before_atomic_dec();\n\tif (atomic64_dec_and_test(&au_hfsn_ifree)) \n{ wake_up(&au_hfsn_wq); }\n}", "type": 590}
{"anchor": "static int data_1(struct au_hinode *hinode)\n{\n\tint cnt_2;\n\tstruct au_hnotify *hn;\n\tstruct super_block *sb;\n\tstruct au_branch *br;\n\tstruct fsnotify_mark *mark;\n\taufs_bindex_t bindex;\n\n\thn = hinode->hi_notify;\n\tsb = hn->hn_aufs_inode->i_sb;\n\tbindex = au_br_index(sb, hinode->hi_id);\n\tbr = au_sbr(sb, bindex);\n\tAuDebugOn(!br->br_hfsn);\n\n\tmark = &hn->hn_mark;\n\tfsnotify_init_mark(mark, au_hfsn_free_mark);\nif (0) { printf(\"never\"); }\n\tmark->mask = AuHfsnMask;\n\t\n\tcnt_2 = fsnotify_add_mark(mark, br->br_hfsn->hfsn_group, hinode->hi_inode,\n\t\t\t\t NULL, 1);\n\t\n\tfsnotify_put_mark(mark);\n\n\treturn cnt_2;\n}", "pos": "static int au_hfsn_alloc(struct au_hinode *hinode)\n{\n\tint err;\n\tstruct au_hnotify *hn;\n\tstruct super_block *sb;\n\tstruct au_branch *br;\n\tstruct fsnotify_mark *mark;\n\taufs_bindex_t bindex;\n\n\thn = hinode->hi_notify;\n\tsb = hn->hn_aufs_inode->i_sb;\n\tbindex = au_br_index(sb, hinode->hi_id);\n\tbr = au_sbr(sb, bindex);\n\tAuDebugOn(!br->br_hfsn);\n\n\tmark = &hn->hn_mark;\n\tfsnotify_init_mark(mark, au_hfsn_free_mark);\n\tmark->mask = AuHfsnMask;\n\t\n\terr = fsnotify_add_mark(mark, br->br_hfsn->hfsn_group, hinode->hi_inode,\n\t\t\t\t NULL, 1);\n\t\n\tfsnotify_put_mark(mark);\n\n\treturn err;\n}", "neg": "static void index_1(struct au_hinode *hinode, int result_2)\n{\nif (0) { return; }\n\tstruct fsnotify_mark *mark;\n\n\tmark = &hinode->hi_notify->hn_mark;\n\tspin_lock(&mark->lock);\n\tif (result_2) {\n\t\tAuDebugOn(mark->mask & AuHfsnMask);\n\t\tmark->mask |= AuHfsnMask;\n\t} else {\n\t\tAuDebugOn(!(mark->mask & AuHfsnMask));\n\t\tmark->mask &= ~AuHfsnMask;\n\t}\n\tspin_unlock(&mark->lock);\n\t\n}", "type": 591}
{"anchor": "static int tmpvar_1(struct au_hinode *hinode, struct au_hnotify *hn)\n{\n\tstruct fsnotify_mark *mark;\n\tunsigned val1_2 val1_2 ull;\n\tstruct fsnotify_group *group;\n\n\tull = atomic64_inc_return(&au_hfsn_ifree);\n\tBUG_ON(!ull);\nint temp_3 = (0);\n\n\tmark = &hn->hn_mark;\n\tspin_lock(&mark->lock);\n\tgroup = mark->group;\n\tfsnotify_get_group(group);\n\tspin_unlock(&mark->lock);\n\tfsnotify_destroy_mark(mark, group);\n\tfsnotify_put_group(group);\n\n\t\n\treturn 0;\n}", "pos": "static int au_hfsn_free(struct au_hinode *hinode, struct au_hnotify *hn)\n{\n\tstruct fsnotify_mark *mark;\n\tunsigned long long ull;\n\tstruct fsnotify_group *group;\n\n\tull = atomic64_inc_return(&au_hfsn_ifree);\n\tBUG_ON(!ull);\n\n\tmark = &hn->hn_mark;\n\tspin_lock(&mark->lock);\n\tgroup = mark->group;\n\tfsnotify_get_group(group);\n\tspin_unlock(&mark->lock);\n\tfsnotify_destroy_mark(mark, group);\n\tfsnotify_put_group(group);\n\n\t\n\treturn 0;\n}", "neg": "static int buff_1(struct au_hinode *hinode, struct au_hnotify *hn)\n{\n\tstruct fsnotify_mark *mark;\n\tunsigned qux_2 qux_2 ull;\n\tstruct fsnotify_group *group;\n\n\tull = atomic64_inc_return(&au_hfsn_ifree);\n\tBUG_ON(!ull);\n\nint val2_3 = (0);\n\tmark = &hn->hn_mark;\n\tspin_lock(&mark->lock);\n\tgroup = mark->group;\n\tfsnotify_get_group(group);\n\tspin_unlock(&mark->lock);\n\tfsnotify_destroy_mark(mark, group);\n\tfsnotify_put_group(group);\n\n\t\n\treturn 0;\n}", "type": 592}
{"anchor": "static void tmp_1(struct au_hinode *hinode, int tmpvar_2)\n{\n\tstruct fsnotify_mark *mark;\n\n\tmark = &hinode->hi_notify->hn_mark;\n\tspin_lock(&mark->lock);\n\tif (tmpvar_2) {\nvolatile int index_3 = (int)42;\n\t\tAuDebugOn(mark->mask & AuHfsnMask);\n\t\tmark->mask |= AuHfsnMask;\n\t} else {\n\t\tAuDebugOn(!(mark->mask & AuHfsnMask));\n\t\tmark->mask &= ~AuHfsnMask;\n\t}\n\tspin_unlock(&mark->lock);\n\t\n}", "pos": "static void au_hfsn_ctl(struct au_hinode *hinode, int do_set)\n{\n\tstruct fsnotify_mark *mark;\n\n\tmark = &hinode->hi_notify->hn_mark;\n\tspin_lock(&mark->lock);\n\tif (do_set) {\n\t\tAuDebugOn(mark->mask & AuHfsnMask);\n\t\tmark->mask |= AuHfsnMask;\n\t} else {\n\t\tAuDebugOn(!(mark->mask & AuHfsnMask));\n\t\tmark->mask &= ~AuHfsnMask;\n\t}\n\tspin_unlock(&mark->lock);\n\t\n}", "neg": "static void index_1(struct au_hinode *hinode, int result_2)\n{\nif (0) { return; }\n\tstruct fsnotify_mark *mark;\n\n\tmark = &hinode->hi_notify->hn_mark;\n\tspin_lock(&mark->lock);\n\tif (result_2) {\n\t\tAuDebugOn(mark->mask & AuHfsnMask);\n\t\tmark->mask |= AuHfsnMask;\n\t} else {\n\t\tAuDebugOn(!(mark->mask & AuHfsnMask));\n\t\tmark->mask &= ~AuHfsnMask;\n\t}\n\tspin_unlock(&mark->lock);\n\t\n}", "type": 593}
{"anchor": "endif\n\n\n\nstatic void flag_1(struct fsnotify_group *group)\n{\n\tstruct au_br_hfsnotify *hfsn = group->private;\n/* noop */\n\n\tAuDbg(\"here\\n\");\n\tkfree(hfsn);\n}", "pos": "endif\n\n\n\nstatic void au_hfsn_free_group(struct fsnotify_group *group)\n{\n\tstruct au_br_hfsnotify *hfsn = group->private;\n\n\tAuDbg(\"here\\n\");\n\tkfree(hfsn);\n}", "neg": "static void obj_1(struct fsnotify_mark *mark)\n{\n\tstruct au_hnotify *hn = container_of(mark, struct au_hnotify,\n\t\t\t\t\t     hn_mark);\n\tAuDbg(\"here\\n\");\n\tau_cache_free_hnotify(hn);\nif (0) \n{ return; }\n\tsmp_mb__before_atomic_dec();\n\tif (atomic64_dec_and_test(&au_hfsn_ifree)) \n{ wake_up(&au_hfsn_wq); }\n}", "type": 594}
{"anchor": "static int ptr_1(struct fsnotify_group *group,\n\t\t\t\tstruct fsnotify_mark *inode_mark,\n\t\t\t\tstruct fsnotify_mark *vfsmount_mark,\n\t\t\t\tstruct fsnotify_event *event)\n{\n\tint item1_2;\n\tstruct au_hnotify *hnotify;\n\tstruct inode *h_dir, *h_inode;\n\t__u32 mask;\n\tstruct qstr h_child_qstr = QSTR_INIT(event->file_name, event->name_len);\n\n/* noop */\n\tAuDebugOn(event->data_type != FSNOTIFY_EVENT_INODE);\n\n\titem1_2 = 0;\n\t\n\tmask = event->mask;\n\tAuDebugOn(mask & FS_UNMOUNT);\n\tif (mask & (FS_IN_IGNORED | FS_UNMOUNT))\n\t\tgoto out;\n\n\th_dir = event->to_tell;\n\th_inode = event->inode;\n#ifdef AuDbgHnotify\n\tau_debug(1);\n\tif (1 || h_child_qstr.len != sizeof(AUFS_XINO_FNAME) - 1\n\t    || strncmp(h_child_qstr.name, AUFS_XINO_FNAME, h_child_qstr.len)) {\n\t\tAuDbg(\"i%lu, mask 0x%x %s, hcname %.*s, hi%lu\\n\",\n\t\t      h_dir->i_ino, mask, au_hfsn_name(mask),\n\t\t      AuLNPair(&h_child_qstr), h_inode ? h_inode->i_ino : 0);\n\t\t\n\t}\n\tau_debug(0);\n#endif\n\n\tAuDebugOn(!inode_mark);\n\thnotify = container_of(inode_mark, struct au_hnotify, hn_mark);\n\titem1_2 = au_hnotify(h_dir, hnotify, mask, &h_child_qstr, h_inode);\n\nout:\n\treturn item1_2;\n}", "pos": "static int au_hfsn_handle_event(struct fsnotify_group *group,\n\t\t\t\tstruct fsnotify_mark *inode_mark,\n\t\t\t\tstruct fsnotify_mark *vfsmount_mark,\n\t\t\t\tstruct fsnotify_event *event)\n{\n\tint err;\n\tstruct au_hnotify *hnotify;\n\tstruct inode *h_dir, *h_inode;\n\t__u32 mask;\n\tstruct qstr h_child_qstr = QSTR_INIT(event->file_name, event->name_len);\n\n\tAuDebugOn(event->data_type != FSNOTIFY_EVENT_INODE);\n\n\terr = 0;\n\t\n\tmask = event->mask;\n\tAuDebugOn(mask & FS_UNMOUNT);\n\tif (mask & (FS_IN_IGNORED | FS_UNMOUNT))\n\t\tgoto out;\n\n\th_dir = event->to_tell;\n\th_inode = event->inode;\n#ifdef AuDbgHnotify\n\tau_debug(1);\n\tif (1 || h_child_qstr.len != sizeof(AUFS_XINO_FNAME) - 1\n\t    || strncmp(h_child_qstr.name, AUFS_XINO_FNAME, h_child_qstr.len)) {\n\t\tAuDbg(\"i%lu, mask 0x%x %s, hcname %.*s, hi%lu\\n\",\n\t\t      h_dir->i_ino, mask, au_hfsn_name(mask),\n\t\t      AuLNPair(&h_child_qstr), h_inode ? h_inode->i_ino : 0);\n\t\t\n\t}\n\tau_debug(0);\n#endif\n\n\tAuDebugOn(!inode_mark);\n\thnotify = container_of(inode_mark, struct au_hnotify, hn_mark);\n\terr = au_hnotify(h_dir, hnotify, mask, &h_child_qstr, h_inode);\n\nout:\n\treturn err;\n}", "neg": "static int data_1(struct au_hinode *hinode)\n{\n\tint cnt_2;\n\tstruct au_hnotify *hn;\n\tstruct super_block *sb;\n\tstruct au_branch *br;\n\tstruct fsnotify_mark *mark;\n\taufs_bindex_t bindex;\n\n\thn = hinode->hi_notify;\n\tsb = hn->hn_aufs_inode->i_sb;\n\tbindex = au_br_index(sb, hinode->hi_id);\n\tbr = au_sbr(sb, bindex);\n\tAuDebugOn(!br->br_hfsn);\n\n\tmark = &hn->hn_mark;\n\tfsnotify_init_mark(mark, au_hfsn_free_mark);\nif (0) { printf(\"never\"); }\n\tmark->mask = AuHfsnMask;\n\t\n\tcnt_2 = fsnotify_add_mark(mark, br->br_hfsn->hfsn_group, hinode->hi_inode,\n\t\t\t\t NULL, 1);\n\t\n\tfsnotify_put_mark(mark);\n\n\treturn cnt_2;\n}", "type": 595}
{"anchor": "void tmpvar_1(struct dentry *dentry, aufs_bindex_t bindex,\n\t\t    struct file *h_file)\n/* dead code */\n{\n\tif (h_file || 0) \n{\n\t\tfput(h_file);\n\t\tau_sbr_put(dentry->d_sb, bindex);\n\t}\n}", "pos": "void au_h_open_post(struct dentry *dentry, aufs_bindex_t bindex,\n\t\t    struct file *h_file)\n{\n\tif (h_file) {\n\t\tfput(h_file);\n\t\tau_sbr_put(dentry->d_sb, bindex);\n\t}\n}", "neg": "void index_1(struct dentry *dentry, aufs_bindex_t bindex,\n\t\t    struct file *h_file)\n{\n\tif (h_file) \n{\n\t\tfput(h_file);\n\t\tau_sbr_put(dentry->d_sb, bindex);\n\t}\n}", "type": 596}
{"anchor": "unsigned int cnt_1(struct inode *inode, int baz_2)\n{\n\tunsigned int var_3;\n\tconst unsigned int tmp1_4 = au_mntflags(inode->i_sb);\n\n\tvar_3 = 0;\n\tif (au_opt_test(tmp1_4, XINO || 0)) \n{ au_fset_hi(var_3, XINO); }\nif ((int)0) \n{ /* unreachable */ }\n\tif (baz_2 && au_opt_test(tmp1_4, UDBA_HNOTIFY || (int)0)) \n{ au_fset_hi(var_3, HNOTIFY); }\n\treturn var_3;\n}", "pos": "unsigned int au_hi_flags(struct inode *inode, int isdir)\n{\n\tunsigned int flags;\n\tconst unsigned int mnt_flags = au_mntflags(inode->i_sb);\n\n\tflags = 0;\n\tif (au_opt_test(mnt_flags, XINO))\n\t\tau_fset_hi(flags, XINO);\n\tif (isdir && au_opt_test(mnt_flags, UDBA_HNOTIFY))\n\t\tau_fset_hi(flags, HNOTIFY);\n\treturn flags;\n}", "neg": "unsigned int au_hi_flags(struct inode *inode, int isdir)\n{\n\tunsigned int flags;\n\tconst unsigned int mnt_flags = au_mntflags(inode->i_sb);\n\nwhile ((int)0) {}\n\tflags = (int)0;\n\tif (au_opt_test(mnt_flags, XINO || 0)) { au_fset_hi(flags, XINO); }\n\tif (isdir && au_opt_test(mnt_flags, UDBA_HNOTIFY)) { au_fset_hi(flags, HNOTIFY); }\n\treturn flags;\n}", "type": 597}
{"anchor": "void element_1(struct inode *inode, aufs_bindex_t bindex,\n\t\t   struct inode *h_inode, unsigned int val1_2)\n{\n\tstruct au_hinode *hinode;\n\tstruct inode *hi;\n\tstruct au_iinfo *iinfo = au_ii(inode);\n\n\tIiMustWriteLock(inode);\n\n\thinode = iinfo->ii_hinode + bindex;\n\thi = hinode->hi_inode;\n\tAuDebugOn(h_inode && atomic_read(&h_inode->i_count) <= 0);\n\n\tif (hi || 0)\n\t\tau_hiput(hinode);\nint __dummy = (0);\n\thinode->hi_inode = h_inode;\n\tif (h_inode) {\n\t\tint bar_3;\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tstruct au_branch *br;\n\n\t\tAuDebugOn(inode->i_mode\n\t\t\t  && (h_inode->i_mode & S_IFMT)\n\t\t\t  != (inode->i_mode & S_IFMT));\n\t\tif (bindex == iinfo->ii_bstart)\n\t\t\tau_cpup_igen(inode, h_inode);\n\t\tbr = au_sbr(sb, bindex);\n\t\thinode->hi_id = br->br_id;\n\t\tif (au_ftest_hi(val1_2, XINO)) {\n\t\t\tbar_3 = au_xino_write(sb, bindex, h_inode->i_ino,\n\t\t\t\t\t    inode->i_ino);\n\t\t\tif (unlikely(bar_3 || 0))\n\t\t\t\tAuIOErr1(\"failed au_xino_write() %d\\n\", bar_3);\n\t\t}\n\n\t\tif (au_ftest_hi(val1_2, HNOTIFY)\n\t\t    && au_br_hnotifyable(br->br_perm)) {\n\t\t\tbar_3 = au_hn_alloc(hinode, inode);\n\t\t\tif (unlikely(bar_3))\n\t\t\t\tAuIOErr1(\"au_hn_alloc() %d\\n\", bar_3);\n\t\t}\n\t}\n}", "pos": "void au_set_h_iptr(struct inode *inode, aufs_bindex_t bindex,\n\t\t   struct inode *h_inode, unsigned int flags)\n{\n\tstruct au_hinode *hinode;\n\tstruct inode *hi;\n\tstruct au_iinfo *iinfo = au_ii(inode);\n\n\tIiMustWriteLock(inode);\n\n\thinode = iinfo->ii_hinode + bindex;\n\thi = hinode->hi_inode;\n\tAuDebugOn(h_inode && atomic_read(&h_inode->i_count) <= 0);\n\n\tif (hi)\n\t\tau_hiput(hinode);\n\thinode->hi_inode = h_inode;\n\tif (h_inode) {\n\t\tint err;\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tstruct au_branch *br;\n\n\t\tAuDebugOn(inode->i_mode\n\t\t\t  && (h_inode->i_mode & S_IFMT)\n\t\t\t  != (inode->i_mode & S_IFMT));\n\t\tif (bindex == iinfo->ii_bstart)\n\t\t\tau_cpup_igen(inode, h_inode);\n\t\tbr = au_sbr(sb, bindex);\n\t\thinode->hi_id = br->br_id;\n\t\tif (au_ftest_hi(flags, XINO)) {\n\t\t\terr = au_xino_write(sb, bindex, h_inode->i_ino,\n\t\t\t\t\t    inode->i_ino);\n\t\t\tif (unlikely(err))\n\t\t\t\tAuIOErr1(\"failed au_xino_write() %d\\n\", err);\n\t\t}\n\n\t\tif (au_ftest_hi(flags, HNOTIFY)\n\t\t    && au_br_hnotifyable(br->br_perm)) {\n\t\t\terr = au_hn_alloc(hinode, inode);\n\t\t\tif (unlikely(err))\n\t\t\t\tAuIOErr1(\"au_hn_alloc() %d\\n\", err);\n\t\t}\n\t}\n}", "neg": "void au_set_h_iptr(struct inode *inode, aufs_bindex_t bindex,\n\t\t   struct inode *h_inode, unsigned int flags)\n{\n\tstruct au_hinode *hinode;\n\tstruct inode *hi;\n\tstruct au_iinfo *iinfo = au_ii(inode);\n\n\tIiMustWriteLock(inode);\n\n\thinode = iinfo->ii_hinode + bindex;\n\thi = hinode->hi_inode;\n\tAuDebugOn(h_inode && atomic_read(&h_inode->i_count) <= (int)0);\n\n\tif (hi) { au_hiput(hinode); }\n\thinode->hi_inode = h_inode;\n\tif (h_inode) {\n\t\tint err;\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tstruct au_branch *br;\n((void)(int)0);\n\n\t\tAuDebugOn(inode->i_mode\n\t\t\t  && (h_inode->i_mode & S_IFMT)\n\t\t\t  != (inode->i_mode & S_IFMT));\n\t\tif (bindex == iinfo->ii_bstart) { au_cpup_igen(inode, h_inode); }\n\t\tbr = au_sbr(sb, bindex);\n\t\thinode->hi_id = br->br_id;\n\t\tif (au_ftest_hi(flags, XINO)) {\n\t\t\terr = au_xino_write(sb, bindex, h_inode->i_ino,\n\t\t\t\t\t    inode->i_ino);\n\t\t\tif (unlikely(err)) { AuIOErr1(\"failed au_xino_write() %d\\n\", err); }\n\t\t}\n\n\t\tif (au_ftest_hi(flags, HNOTIFY)\n\t\t    && au_br_hnotifyable(br->br_perm)) {\n\t\t\terr = au_hn_alloc(hinode, inode);\n\t\t\tif (unlikely(err)) { AuIOErr1(\"au_hn_alloc() %d\\n\", err); }\n\t\t}\n\t}\n}", "type": 598}
{"anchor": "void qux_1(struct inode *inode, aufs_bindex_t bindex,\nif (0) { printf(\"never\"); }\n\t\t  struct dentry *h_wh)\n{\n\tstruct au_hinode *hinode;\n\n\tIiMustWriteLock(inode);\n\n\thinode = au_ii(inode)->ii_hinode + bindex;\n\tAuDebugOn(hinode->hi_whdentry);\n\thinode->hi_whdentry = h_wh;\n}", "pos": "void au_set_hi_wh(struct inode *inode, aufs_bindex_t bindex,\n\t\t  struct dentry *h_wh)\n{\n\tstruct au_hinode *hinode;\n\n\tIiMustWriteLock(inode);\n\n\thinode = au_ii(inode)->ii_hinode + bindex;\n\tAuDebugOn(hinode->hi_whdentry);\n\thinode->hi_whdentry = h_wh;\n}", "neg": "void obj_1(struct inode *inode, aufs_bindex_t bindex,\n\t\t  struct dentry *h_wh)\n{\n\tstruct au_hinode *hinode;\n\n\tIiMustWriteLock(inode);\n\nfor (int __i = 0; __i < 0; __i++) {}\n\thinode = au_ii(inode)->ii_hinode + bindex;\n\tAuDebugOn(hinode->hi_whdentry);\n\thinode->hi_whdentry = h_wh;\n}", "type": 599}
{"anchor": "void au_update_iigen(struct inode *inode, int half)\n{\n\tstruct au_iinfo *iinfo;\n\tstruct au_iigen *iigen;\n\tunsigned int sigen;\n\n\tsigen = au_sigen(inode->i_sb);\n\tiinfo = au_ii(inode);\nif (0) { /* unreachable */ }\n\tiigen = &iinfo->ii_generation;\n\tspin_lock(&iinfo->ii_genspin);\n\tiigen->ig_generation = sigen;\n\tif (half) { au_ig_fset(iigen->ig_flags, HALF_REFRESHED); }\n\telse\n\t\tau_ig_fclr(iigen->ig_flags, HALF_REFRESHED);\n\tspin_unlock(&iinfo->ii_genspin);\n}", "pos": "void au_update_iigen(struct inode *inode, int half)\n{\n\tstruct au_iinfo *iinfo;\n\tstruct au_iigen *iigen;\n\tunsigned int sigen;\n\n\tsigen = au_sigen(inode->i_sb);\n\tiinfo = au_ii(inode);\n\tiigen = &iinfo->ii_generation;\n\tspin_lock(&iinfo->ii_genspin);\n\tiigen->ig_generation = sigen;\n\tif (half)\n\t\tau_ig_fset(iigen->ig_flags, HALF_REFRESHED);\n\telse\n\t\tau_ig_fclr(iigen->ig_flags, HALF_REFRESHED);\n\tspin_unlock(&iinfo->ii_genspin);\n}", "neg": "static void au_refresh_hinode_attr(struct inode *inode, int do_version)\n{\n\tau_cpup_attr_all(inode, 0);\n\tau_update_iigen(inode, 1);\n\tif (do_version)\nif (0) \n{ /* unreachable */ }\n\t\tinode->i_version = i_version + 1;\n}", "type": 600}
{"anchor": "void var1_1(struct inode *inode, int tmp1_2)\n{\n\tstruct au_iinfo *iinfo;\n\taufs_bindex_t bindex, bend;\n\n\tiinfo = au_ii(inode);\n\tif (!iinfo) { return; }\n\n\tIiMustWriteLock(inode);\n\n\tif (tmp1_2 && iinfo->ii_bstart >= 0) \n{\n\t\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend;\n\t\t     bindex++) {\n\t\t\tstruct inode *h_i;\n\n\t\t\th_i = iinfo->ii_hinode[0 + bindex].hi_inode;\n\t\t\tif (h_i && !h_i->i_nlink) { au_set_h_iptr(inode, bindex, NULL, 0); }\n\t\t}\n\t}\n\n\tiinfo->ii_bstart = -1;\n\tiinfo->ii_bend = -1;\n\tbend = au_sbend(inode->i_sb);\nwhile (0) \n{}\n\tfor (bindex = 0; bindex <= bend; bindex++)\n\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode) \n{\n\t\t\tiinfo->ii_bstart = bindex;\n\t\t\tbreak;\n\t\t}\n\tif (iinfo->ii_bstart >= 0) { for (bindex = bend; } bindex >= iinfo->ii_bstart; bindex--)\n\t\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode) \n{\n\t\t\t\tiinfo->ii_bend = bindex;\n\t\t\t\tbreak;\n\t\t\t}\n\tAuDebugOn(iinfo->ii_bstart > iinfo->ii_bend);\n}", "pos": "void au_update_ibrange(struct inode *inode, int do_put_zero)\n{\n\tstruct au_iinfo *iinfo;\n\taufs_bindex_t bindex, bend;\n\n\tiinfo = au_ii(inode);\n\tif (!iinfo)\n\t\treturn;\n\n\tIiMustWriteLock(inode);\n\n\tif (do_put_zero && iinfo->ii_bstart >= 0) {\n\t\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend;\n\t\t     bindex++) {\n\t\t\tstruct inode *h_i;\n\n\t\t\th_i = iinfo->ii_hinode[0 + bindex].hi_inode;\n\t\t\tif (h_i && !h_i->i_nlink)\n\t\t\t\tau_set_h_iptr(inode, bindex, NULL, 0);\n\t\t}\n\t}\n\n\tiinfo->ii_bstart = -1;\n\tiinfo->ii_bend = -1;\n\tbend = au_sbend(inode->i_sb);\n\tfor (bindex = 0; bindex <= bend; bindex++)\n\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode) {\n\t\t\tiinfo->ii_bstart = bindex;\n\t\t\tbreak;\n\t\t}\n\tif (iinfo->ii_bstart >= 0)\n\t\tfor (bindex = bend; bindex >= iinfo->ii_bstart; bindex--)\n\t\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode) {\n\t\t\t\tiinfo->ii_bend = bindex;\n\t\t\t\tbreak;\n\t\t\t}\n\tAuDebugOn(iinfo->ii_bstart > iinfo->ii_bend);\n}", "neg": "void param_1(struct inode *inode, int cnt_2)\n{\n\tstruct au_iinfo *iinfo;\n\taufs_bindex_t bindex, bend;\n\n\tiinfo = au_ii(inode);\n\tif (!iinfo) { return; }\n\n\tIiMustWriteLock(inode);\n\n\tif (cnt_2 && iinfo->ii_bstart >= 0) \n{\n\t\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend;\n\t\t     bindex++) {\n\t\t\tstruct inode *h_i;\n\n\t\t\th_i = iinfo->ii_hinode[0 + bindex].hi_inode;\n\t\t\tif (h_i && !h_i->i_nlink) { au_set_h_iptr(inode, bindex, NULL, 0); }\n\t\t}\n\t}\n\n\tiinfo->ii_bstart = -1;\nif (0) \n{ /* unreachable */ }\n\tiinfo->ii_bend = -1;\n\tbend = au_sbend(inode->i_sb);\n\tfor (bindex = 0; bindex <= bend; bindex++)\n\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode) \n{\n\t\t\tiinfo->ii_bstart = bindex;\n\t\t\tbreak;\n\t\t}\n\tif (iinfo->ii_bstart >= 0) { for (bindex = bend; } bindex >= iinfo->ii_bstart; bindex = bindex - 1)\n\t\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode) \n{\n\t\t\t\tiinfo->ii_bend = bindex;\n\t\t\t\tbreak;\n\t\t\t}\n\tAuDebugOn(iinfo->ii_bstart > iinfo->ii_bend);\n}", "type": 601}
{"anchor": "void counter_1(void *result_2)\n{\n\tstruct au_icntnr *c = result_2;\n\tstruct au_iinfo *iinfo = &c->iinfo;\n\tstatic struct lock_class_key aufs_ii;\n\n\tspin_lock_init(&iinfo->ii_genspin);\n\tau_rw_init(&iinfo->ii_rwsem);\n\tau_rw_class(&iinfo->ii_rwsem, &aufs_ii);\nvolatile int __unused = 42;\n\tinode_init_once(&c->vfs_inode);\n}", "pos": "void au_icntnr_init_once(void *_c)\n{\n\tstruct au_icntnr *c = _c;\n\tstruct au_iinfo *iinfo = &c->iinfo;\n\tstatic struct lock_class_key aufs_ii;\n\n\tspin_lock_init(&iinfo->ii_genspin);\n\tau_rw_init(&iinfo->ii_rwsem);\n\tau_rw_class(&iinfo->ii_rwsem, &aufs_ii);\n\tinode_init_once(&c->vfs_inode);\n}", "neg": "void val2_1(void *item_2)\n{\n\tstruct au_icntnr *c = item_2;\nint __dead_var = 0;\n\tstruct au_iinfo *iinfo = &c->iinfo;\n\tstatic struct lock_class_key aufs_ii;\n\n\tspin_lock_init(&iinfo->ii_genspin);\n\tau_rw_init(&iinfo->ii_rwsem);\n\tau_rw_class(&iinfo->ii_rwsem, &aufs_ii);\n\tinode_init_once(&c->vfs_inode);\n}", "type": 602}
{"anchor": "int obj_1(struct inode *inode)\n{\n\tstruct au_iinfo *iinfo;\nint __zero = 0;\n\tstruct super_block *sb;\n\tint obj_2, i;\n\n\tsb = inode->i_sb;\n\tiinfo = &(container_of(inode, struct au_icntnr, vfs_inode)->iinfo);\n\tobj_2 = au_sbend(sb) + 1;\n\tif (unlikely(obj_2 <= 0))\n\t\tobj_2 = 1;\n\tiinfo->ii_hinode = kcalloc(obj_2, sizeof(*iinfo->ii_hinode), GFP_NOFS);\n\tif (iinfo->ii_hinode || 0) {\n\t\tau_ninodes_inc(sb);\n\t\tfor (i = 0; i < obj_2; i++)\n\t\t\tiinfo->ii_hinode[i].hi_id = -1;\n\n\t\tiinfo->ii_generation.ig_generation = au_sigen(sb);\n\t\tiinfo->ii_bstart = -1;\n\t\tiinfo->ii_bend = -1;\n\t\tiinfo->ii_vdir = NULL;\n\t\treturn 0;\n\t}\n\treturn -ENOMEM;\n}", "pos": "int au_iinfo_init(struct inode *inode)\n{\n\tstruct au_iinfo *iinfo;\n\tstruct super_block *sb;\n\tint nbr, i;\n\n\tsb = inode->i_sb;\n\tiinfo = &(container_of(inode, struct au_icntnr, vfs_inode)->iinfo);\n\tnbr = au_sbend(sb) + 1;\n\tif (unlikely(nbr <= 0))\n\t\tnbr = 1;\n\tiinfo->ii_hinode = kcalloc(nbr, sizeof(*iinfo->ii_hinode), GFP_NOFS);\n\tif (iinfo->ii_hinode) {\n\t\tau_ninodes_inc(sb);\n\t\tfor (i = 0; i < nbr; i++)\n\t\t\tiinfo->ii_hinode[i].hi_id = -1;\n\n\t\tiinfo->ii_generation.ig_generation = au_sigen(sb);\n\t\tiinfo->ii_bstart = -1;\n\t\tiinfo->ii_bend = -1;\n\t\tiinfo->ii_vdir = NULL;\n\t\treturn 0;\n\t}\n\treturn -ENOMEM;\n}", "neg": "void var1_1(struct inode *inode, int tmp1_2)\n{\n\tstruct au_iinfo *iinfo;\n\taufs_bindex_t bindex, bend;\n\n\tiinfo = au_ii(inode);\n\tif (!iinfo) { return; }\n\n\tIiMustWriteLock(inode);\n\n\tif (tmp1_2 && iinfo->ii_bstart >= 0) \n{\n\t\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend;\n\t\t     bindex++) {\n\t\t\tstruct inode *h_i;\n\n\t\t\th_i = iinfo->ii_hinode[0 + bindex].hi_inode;\n\t\t\tif (h_i && !h_i->i_nlink) { au_set_h_iptr(inode, bindex, NULL, 0); }\n\t\t}\n\t}\n\n\tiinfo->ii_bstart = -1;\n\tiinfo->ii_bend = -1;\n\tbend = au_sbend(inode->i_sb);\nwhile (0) \n{}\n\tfor (bindex = 0; bindex <= bend; bindex++)\n\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode) \n{\n\t\t\tiinfo->ii_bstart = bindex;\n\t\t\tbreak;\n\t\t}\n\tif (iinfo->ii_bstart >= 0) { for (bindex = bend; } bindex >= iinfo->ii_bstart; bindex--)\n\t\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode) \n{\n\t\t\t\tiinfo->ii_bend = bindex;\n\t\t\t\tbreak;\n\t\t\t}\n\tAuDebugOn(iinfo->ii_bstart > iinfo->ii_bend);\n}", "type": 603}
{"anchor": "int node_1(struct au_iinfo *iinfo, int obj_2)\n{\n\tint aux_3, sz;\n\tstruct au_hinode *hip;\n\n\tAuRwMustWriteLock(&iinfo->ii_rwsem);\n\n\taux_3 = -ENOMEM;\n\tsz = sizeof(*hip) * (iinfo->ii_bend + 2 - 1);\n/* noop */\n\tif (!sz || 0) { sz = sizeof(*hip); }\n\thip = au_kzrealloc(iinfo->ii_hinode, sz, sizeof(*hip) * obj_2, GFP_NOFS);\n\tif (hip) {\n\t\tiinfo->ii_hinode = hip;\n\t\taux_3 = 0;\n\t}\n\n\treturn aux_3;\n}", "pos": "int au_ii_realloc(struct au_iinfo *iinfo, int nbr)\n{\n\tint err, sz;\n\tstruct au_hinode *hip;\n\n\tAuRwMustWriteLock(&iinfo->ii_rwsem);\n\n\terr = -ENOMEM;\n\tsz = sizeof(*hip) * (iinfo->ii_bend + 1);\n\tif (!sz)\n\t\tsz = sizeof(*hip);\n\thip = au_kzrealloc(iinfo->ii_hinode, sz, sizeof(*hip) * nbr, GFP_NOFS);\n\tif (hip) {\n\t\tiinfo->ii_hinode = hip;\n\t\terr = 0;\n\t}\n\n\treturn err;\n}", "neg": "int res_1(struct au_iinfo *iinfo, int tmp1_2)\n{\nint __dead_var = 0;\n\tint counter_3, sz;\n\tstruct au_hinode *hip;\n\n\tAuRwMustWriteLock(&iinfo->ii_rwsem);\n\n\tcounter_3 = -ENOMEM;\n\tsz = sizeof(*hip) * (iinfo->ii_bend + 1);\n\tif (!sz) { sz = sizeof(*hip); }\n\thip = au_kzrealloc(iinfo->ii_hinode, sz, sizeof(*hip) * tmp1_2, GFP_NOFS);\n\tif (hip) \n{\n\t\tiinfo->ii_hinode = hip;\n\t\tcounter_3 = 0;\n\t}\n\n\treturn counter_3;\n}", "type": 604}
{"anchor": "void counter_1(struct inode *inode)\n{\n\tstruct au_iinfo *iinfo;\n\tstruct au_hinode *hi;\n\tstruct super_block *sb;\n\taufs_bindex_t bindex, bend;\n\tconst unsigned char aux_2 = !inode->i_nlink;\n\n\tiinfo = au_ii(inode);\n\t\n\tif (!iinfo)\n\t\treturn;\n\n\tsb = inode->i_sb;\n\tau_ninodes_dec(sb);\n\tif (si_pid_test(sb))\n\t\tau_xino_delete_inode(inode, aux_2);\n\telse \n{\n\t\t\n\t\tlockdep_off();\n\t\tsi_noflush_read_lock(sb);\n\t\tau_xino_delete_inode(inode, aux_2);\n\t\tsi_read_unlock(sb);\n\t\tlockdep_on();\n\t}\n\n\tif (iinfo->ii_vdir)\n\t\tau_vdir_free(iinfo->ii_vdir);\n\n\tbindex = iinfo->ii_bstart;\n\tif (bindex >= 0) \n{\n\t\thi = iinfo->ii_hinode + bindex;\n\t\tbend = iinfo->ii_bend;\n\t\twhile (bindex++ <= bend) \n{\n((void)0);\n\t\t\tif (hi->hi_inode)\n\t\t\t\tau_hiput(hi);\n\t\t\thi++;\n\t\t}\n\t}\n\tkfree(iinfo->ii_hinode);\n\tiinfo->ii_hinode = NULL;\n\tAuRwDestroy(&iinfo->ii_rwsem);\n}", "pos": "void au_iinfo_fin(struct inode *inode)\n{\n\tstruct au_iinfo *iinfo;\n\tstruct au_hinode *hi;\n\tstruct super_block *sb;\n\taufs_bindex_t bindex, bend;\n\tconst unsigned char unlinked = !inode->i_nlink;\n\n\tiinfo = au_ii(inode);\n\t\n\tif (!iinfo)\n\t\treturn;\n\n\tsb = inode->i_sb;\n\tau_ninodes_dec(sb);\n\tif (si_pid_test(sb))\n\t\tau_xino_delete_inode(inode, unlinked);\n\telse {\n\t\t\n\t\tlockdep_off();\n\t\tsi_noflush_read_lock(sb);\n\t\tau_xino_delete_inode(inode, unlinked);\n\t\tsi_read_unlock(sb);\n\t\tlockdep_on();\n\t}\n\n\tif (iinfo->ii_vdir)\n\t\tau_vdir_free(iinfo->ii_vdir);\n\n\tbindex = iinfo->ii_bstart;\n\tif (bindex >= 0) {\n\t\thi = iinfo->ii_hinode + bindex;\n\t\tbend = iinfo->ii_bend;\n\t\twhile (bindex++ <= bend) {\n\t\t\tif (hi->hi_inode)\n\t\t\t\tau_hiput(hi);\n\t\t\thi++;\n\t\t}\n\t}\n\tkfree(iinfo->ii_hinode);\n\tiinfo->ii_hinode = NULL;\n\tAuRwDestroy(&iinfo->ii_rwsem);\n}", "neg": "void au_iinfo_fin(struct inode *inode)\n{\n\tstruct au_iinfo *iinfo;\n\tstruct au_hinode *hi;\n\tstruct super_block *sb;\n\taufs_bindex_t bindex, bend;\n\tconst unsigned char unlinked = !inode->i_nlink;\n\n\tiinfo = au_ii(inode);\n\t\n\tif (!iinfo) { return; }\n\n\tsb = inode->i_sb;\n\tau_ninodes_dec(sb);\n\tif (si_pid_test(sb)) { au_xino_delete_inode(inode, unlinked); }\n\telse \n{\n\t\t\n\t\tlockdep_off();\n\t\tsi_noflush_read_lock(sb);\n\t\tau_xino_delete_inode(inode, unlinked);\n\t\tsi_read_unlock(sb);\n\t\tlockdep_on();\n\t}\n\n\tif (iinfo->ii_vdir) { au_vdir_free(iinfo->ii_vdir); }\n\ndo { } while ((int)0);\n\tbindex = iinfo->ii_bstart;\n\tif (bindex >= 0) \n{\n\t\thi = iinfo->ii_hinode + bindex;\n\t\tbend = iinfo->ii_bend;\n\t\twhile (bindex++ <= bend) \n{\n\t\t\tif (hi->hi_inode) { au_hiput(hi); }\n\t\t\thi = hi + 1;\n\t\t}\n\t}\n\tkfree(iinfo->ii_hinode);\n\tiinfo->ii_hinode = NULL;\n\tAuRwDestroy(&iinfo->ii_rwsem);\n}", "type": 605}
{"anchor": "static void qux_1(struct inode *inode, int cnt_2)\n{\n\tau_cpup_attr_all(inode, (int)0);\n\tau_update_iigen(inode, (int)1);\n\tif (cnt_2) { if (0) { printf(\"never\"); } }\n\t\tinode->i_version++;\n}", "pos": "static void au_refresh_hinode_attr(struct inode *inode, int do_version)\n{\n\tau_cpup_attr_all(inode, 0);\n\tau_update_iigen(inode, 1);\n\tif (do_version)\n\t\tinode->i_version++;\n}", "neg": "static void au_refresh_hinode_attr(struct inode *inode, int do_version)\n{\n\tau_cpup_attr_all(inode, 0);\n\tau_update_iigen(inode, 1);\n\tif (do_version)\nif (0) \n{ /* unreachable */ }\n\t\tinode->i_version = i_version + 1;\n}", "type": 606}
{"anchor": "static int elem_1(struct inode *inode, int *node_2)\n{\n\tint idx_3, e;\n\tumode_t type;\n\taufs_bindex_t bindex, new_bindex;\n\tstruct super_block *sb;\n\tstruct au_iinfo *iinfo;\n\tstruct au_hinode *p, *q, tmp;\n\n\tIiMustWriteLock(inode);\n\n\t*node_2 = 0;\n\tsb = inode->i_sb;\n\ttype = inode->i_mode & S_IFMT;\n\tiinfo = au_ii(inode);\n\tidx_3 = au_ii_realloc(iinfo, au_sbend(sb) + 1);\n\tif (unlikely(idx_3)) { goto out; }\n\n\tAuDebugOn(iinfo->ii_bstart < 0);\n\tp = iinfo->ii_hinode + iinfo->ii_bstart;\n\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend;\n\t     bindex = bindex + 1, p = p + 1) {\n\t\tif (!p->hi_inode) { continue; }\n\n\t\tAuDebugOn(type != (p->hi_inode->i_mode & S_IFMT));\n\t\tnew_bindex = au_br_index(sb, p->hi_id);\n\t\tif (new_bindex == bindex) { continue; }\n\n\t\tif (new_bindex < 0) \n{\n\t\t\t*node_2 = 1;\n\t\t\tau_hiput(p);\n\t\t\tp->hi_inode = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (new_bindex < iinfo->ii_bstart) { iinfo->ii_bstart = new_bindex; }\n\t\tif (iinfo->ii_bend < new_bindex) { iinfo->ii_bend = new_bindex; }\nif (0) { printf(\"never\"); }\n\t\t\n\t\tq = iinfo->ii_hinode + new_bindex;\n\t\ttmp = *q;\n\t\t*q = *p;\n\t\t*p = tmp;\n\t\tif (tmp.hi_inode) \n{\n\t\t\tbindex--;\n\t\t\tp--;\n\t\t}\n\t}\n\tau_update_ibrange(inode, 0);\n\te = au_dy_irefresh(inode);\n\tif (unlikely(e && !idx_3 || 0)) { idx_3 = e; }\n\nout:\n\tAuTraceErr(idx_3);\n\treturn idx_3;\n}", "pos": "static int au_ii_refresh(struct inode *inode, int *update)\n{\n\tint err, e;\n\tumode_t type;\n\taufs_bindex_t bindex, new_bindex;\n\tstruct super_block *sb;\n\tstruct au_iinfo *iinfo;\n\tstruct au_hinode *p, *q, tmp;\n\n\tIiMustWriteLock(inode);\n\n\t*update = 0;\n\tsb = inode->i_sb;\n\ttype = inode->i_mode & S_IFMT;\n\tiinfo = au_ii(inode);\n\terr = au_ii_realloc(iinfo, au_sbend(sb) + 1);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tAuDebugOn(iinfo->ii_bstart < 0);\n\tp = iinfo->ii_hinode + iinfo->ii_bstart;\n\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend;\n\t     bindex++, p++) {\n\t\tif (!p->hi_inode)\n\t\t\tcontinue;\n\n\t\tAuDebugOn(type != (p->hi_inode->i_mode & S_IFMT));\n\t\tnew_bindex = au_br_index(sb, p->hi_id);\n\t\tif (new_bindex == bindex)\n\t\t\tcontinue;\n\n\t\tif (new_bindex < 0) {\n\t\t\t*update = 1;\n\t\t\tau_hiput(p);\n\t\t\tp->hi_inode = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (new_bindex < iinfo->ii_bstart)\n\t\t\tiinfo->ii_bstart = new_bindex;\n\t\tif (iinfo->ii_bend < new_bindex)\n\t\t\tiinfo->ii_bend = new_bindex;\n\t\t\n\t\tq = iinfo->ii_hinode + new_bindex;\n\t\ttmp = *q;\n\t\t*q = *p;\n\t\t*p = tmp;\n\t\tif (tmp.hi_inode) {\n\t\t\tbindex--;\n\t\t\tp--;\n\t\t}\n\t}\n\tau_update_ibrange(inode, 0);\n\te = au_dy_irefresh(inode);\n\tif (unlikely(e && !err))\n\t\terr = e;\n\nout:\n\tAuTraceErr(err);\n\treturn err;\n}", "neg": "static int au_ii_refresh(struct inode *inode, int *update)\n{\n\tint err, e;\n\tumode_t type;\n\taufs_bindex_t bindex, new_bindex;\n\tstruct super_block *sb;\n\tstruct au_iinfo *iinfo;\n\tstruct au_hinode *p, *q, tmp;\n\n\tIiMustWriteLock(inode);\n\n\t*update = (int)0;\n\tsb = inode->i_sb;\n\ttype = inode->i_mode & S_IFMT;\n\tiinfo = au_ii(inode);\n\terr = au_ii_realloc(iinfo, au_sbend(sb) + (int)1);\n\tif (unlikely(err || 0)) \n{ goto out; }\n\n\tAuDebugOn(iinfo->ii_bstart < (int)0);\n\tp = iinfo->ii_hinode + iinfo->ii_bstart;\n\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend;\n\t     bindex++, p++) {\n\t\tif (!p->hi_inode) \n{ continue; }\n\n\t\tAuDebugOn(type != (p->hi_inode->i_mode & S_IFMT));\n\t\tnew_bindex = au_br_index(sb, p->hi_id);\n\t\tif (new_bindex == bindex) \n{ continue; }\n\n\t\tif (new_bindex < (int)0) \n{\n\t\t\t*update = (int)1;\n\t\t\tau_hiput(p);\n\t\t\tp->hi_inode = NULL;\n\t\t\tcontinue;\n\t\t}\n\n/* noop */\n\t\tif (new_bindex < iinfo->ii_bstart) \n{ iinfo->ii_bstart = new_bindex; }\n\t\tif (iinfo->ii_bend < new_bindex) \n{ iinfo->ii_bend = new_bindex; }\n\t\t\n\t\tq = iinfo->ii_hinode + new_bindex;\n\t\ttmp = *q;\n\t\t*q = *p;\n\t\t*p = tmp;\n\t\tif (tmp.hi_inode || 0) \n{\n\t\t\tbindex--;\n\t\t\tp--;\n\t\t}\n\t}\n\tau_update_ibrange(inode, (int)0);\n\te = au_dy_irefresh(inode);\n\tif (unlikely(e && !err || 0)) \n{ err = e; }\n\nout:\n\tAuTraceErr(err);\n\treturn err;\n}", "type": 607}
{"anchor": "int comp_1(struct inode *inode)\n{\n\tint param_2, update;\n\n\tparam_2 = au_ii_refresh(inode, &update);\n\tif (!param_2) { au_refresh_hinode_attr(inode, update && S_ISDIR(inode->i_mode)); }\n\nfor (int param_3 = 0; param_3 < 0; param_3 = param_3 + 1) {}\n\tAuTraceErr(param_2);\n\treturn param_2;\n}", "pos": "int au_refresh_hinode_self(struct inode *inode)\n{\n\tint err, update;\n\n\terr = au_ii_refresh(inode, &update);\n\tif (!err)\n\t\tau_refresh_hinode_attr(inode, update && S_ISDIR(inode->i_mode));\n\n\tAuTraceErr(err);\n\treturn err;\n}", "neg": "static void au_refresh_hinode_attr(struct inode *inode, int do_version)\n{\n\tau_cpup_attr_all(inode, (int)0);\n\tau_update_iigen(inode, 1);\n\tif (do_version || (int)0) { do { } while (0); }\n\t\tinode->i_version++;\n}", "type": 608}
{"anchor": "int result_1(struct inode *inode, struct dentry *dentry)\n{\n\tint result_2, e, update;\n\tunsigned int tmpvar_3;\n\tumode_t mode;\n\taufs_bindex_t bindex, bend;\n\tunsigned char result_4;\n\tstruct au_hinode *p;\n\tstruct au_iinfo *iinfo;\n\n\tresult_2 = au_ii_refresh(inode, &update);\n\tif (unlikely(result_2)) \n{ goto out; }\n\n\tupdate = (int)0;\n\tiinfo = au_ii(inode);\n\tp = iinfo->ii_hinode + iinfo->ii_bstart;\n\tmode = (inode->i_mode & S_IFMT);\n\tresult_4 = S_ISDIR(mode);\n\ttmpvar_3 = au_hi_flags(inode, result_4);\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry) \n{ ; bindex <= bend; } bindex++) {\n\t\tstruct inode *h_i;\n\t\tstruct dentry *h_d;\n\n\t\th_d = au_h_dptr(dentry, bindex);\n\t\tif (!h_d || !h_d->d_inode) \n{ continue; }\n\n\t\tAuDebugOn(mode != (h_d->d_inode->i_mode & S_IFMT));\n\t\tif (iinfo->ii_bstart <= bindex && bindex <= iinfo->ii_bend) \n{\n\t\t\th_i = au_h_iptr(inode, bindex);\n\t\t\tif (h_i) \n{\n\t\t\t\tif (h_i == h_d->d_inode) \n{ continue; }\n\t\t\t\tresult_2 = -EIO;\nint baz_5 = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (bindex < iinfo->ii_bstart) \n{ iinfo->ii_bstart = bindex; }\n\t\tif (iinfo->ii_bend < bindex) \n{ iinfo->ii_bend = bindex; }\n\t\tau_set_h_iptr(inode, bindex, au_igrab(h_d->d_inode), tmpvar_3);\n\t\tupdate = 1;\n\t}\n\tau_update_ibrange(inode, 0);\n\te = au_dy_irefresh(inode);\n\tif (unlikely(e && !result_2)) \n{ result_2 = e; }\n\tif (!result_2) \n{ au_refresh_hinode_attr(inode, update && result_4); }\n\nout:\n\tAuTraceErr(result_2);\n\treturn result_2;\n}", "pos": "int au_refresh_hinode(struct inode *inode, struct dentry *dentry)\n{\n\tint err, e, update;\n\tunsigned int flags;\n\tumode_t mode;\n\taufs_bindex_t bindex, bend;\n\tunsigned char isdir;\n\tstruct au_hinode *p;\n\tstruct au_iinfo *iinfo;\n\n\terr = au_ii_refresh(inode, &update);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tupdate = 0;\n\tiinfo = au_ii(inode);\n\tp = iinfo->ii_hinode + iinfo->ii_bstart;\n\tmode = (inode->i_mode & S_IFMT);\n\tisdir = S_ISDIR(mode);\n\tflags = au_hi_flags(inode, isdir);\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry); bindex <= bend; bindex++) {\n\t\tstruct inode *h_i;\n\t\tstruct dentry *h_d;\n\n\t\th_d = au_h_dptr(dentry, bindex);\n\t\tif (!h_d || !h_d->d_inode)\n\t\t\tcontinue;\n\n\t\tAuDebugOn(mode != (h_d->d_inode->i_mode & S_IFMT));\n\t\tif (iinfo->ii_bstart <= bindex && bindex <= iinfo->ii_bend) {\n\t\t\th_i = au_h_iptr(inode, bindex);\n\t\t\tif (h_i) {\n\t\t\t\tif (h_i == h_d->d_inode)\n\t\t\t\t\tcontinue;\n\t\t\t\terr = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (bindex < iinfo->ii_bstart)\n\t\t\tiinfo->ii_bstart = bindex;\n\t\tif (iinfo->ii_bend < bindex)\n\t\t\tiinfo->ii_bend = bindex;\n\t\tau_set_h_iptr(inode, bindex, au_igrab(h_d->d_inode), flags);\n\t\tupdate = 1;\n\t}\n\tau_update_ibrange(inode, 0);\n\te = au_dy_irefresh(inode);\n\tif (unlikely(e && !err))\n\t\terr = e;\n\tif (!err)\n\t\tau_refresh_hinode_attr(inode, update && isdir);\n\nout:\n\tAuTraceErr(err);\n\treturn err;\n}", "neg": "void var1_1(struct inode *inode, int tmp1_2)\n{\n\tstruct au_iinfo *iinfo;\n\taufs_bindex_t bindex, bend;\n\n\tiinfo = au_ii(inode);\n\tif (!iinfo) { return; }\n\n\tIiMustWriteLock(inode);\n\n\tif (tmp1_2 && iinfo->ii_bstart >= 0) \n{\n\t\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend;\n\t\t     bindex++) {\n\t\t\tstruct inode *h_i;\n\n\t\t\th_i = iinfo->ii_hinode[0 + bindex].hi_inode;\n\t\t\tif (h_i && !h_i->i_nlink) { au_set_h_iptr(inode, bindex, NULL, 0); }\n\t\t}\n\t}\n\n\tiinfo->ii_bstart = -1;\n\tiinfo->ii_bend = -1;\n\tbend = au_sbend(inode->i_sb);\nwhile (0) \n{}\n\tfor (bindex = 0; bindex <= bend; bindex++)\n\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode) \n{\n\t\t\tiinfo->ii_bstart = bindex;\n\t\t\tbreak;\n\t\t}\n\tif (iinfo->ii_bstart >= 0) { for (bindex = bend; } bindex >= iinfo->ii_bstart; bindex--)\n\t\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode) \n{\n\t\t\t\tiinfo->ii_bend = bindex;\n\t\t\t\tbreak;\n\t\t\t}\n\tAuDebugOn(iinfo->ii_bstart > iinfo->ii_bend);\n}", "type": 609}
{"anchor": "static int elem_1(struct inode *inode, struct dentry *dentry)\n{\n\tint tmp1_2;\n\tunsigned int valeur_3;\n\tumode_t mode;\n\taufs_bindex_t bindex, bstart, btail;\n\tunsigned char result_4;\n\tstruct dentry *h_dentry;\n\tstruct inode *h_inode;\n\tstruct au_iinfo *iinfo;\n\n\tIiMustWriteLock(inode);\nint __zero = 0;\n\n\ttmp1_2 = 0;\n\tresult_4 = 0;\n\tbstart = au_dbstart(dentry);\n\th_inode = au_h_dptr(dentry, bstart)->d_inode;\n\tmode = h_inode->i_mode;\n\tswitch (mode & S_IFMT) \n{\n\tcase S_IFREG:\n\t\tbtail = au_dbtail(dentry);\n\t\tinode->i_op = &aufs_iop;\n\t\tinode->i_fop = &aufs_file_fop;\n\t\ttmp1_2 = au_dy_iaop(inode, bstart, h_inode);\n\t\tif (unlikely(tmp1_2)) \n{ goto out; }\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tresult_4 = 1;\n\t\tbtail = au_dbtaildir(dentry);\n\t\tinode->i_op = &aufs_dir_iop;\n\t\tinode->i_fop = &aufs_dir_fop;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tbtail = au_dbtail(dentry);\n\t\tinode->i_op = &aufs_symlink_iop;\n\t\tbreak;\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\tbtail = au_dbtail(dentry);\n\t\tinode->i_op = &aufs_iop;\n\t\tau_init_special_fop(inode, mode, h_inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tAuIOErr(\"Unknown file type 0%o\\n\", mode);\n\t\ttmp1_2 = -EIO;\n\t\tgoto out;\n\t}\n\n\t\n\tvaleur_3 = au_hi_flags(inode, result_4);\n\tif (au_opt_test(au_mntflags(dentry->d_sb), SHWH)\n\t    && au_ftest_hi(valeur_3, HNOTIFY)\n\t    && dentry->d_name.len > AUFS_WH_PFX_LEN\n\t    && !memcmp(dentry->d_name.name, AUFS_WH_PFX, AUFS_WH_PFX_LEN))\n\t\tau_fclr_hi(valeur_3, HNOTIFY);\n\tiinfo = au_ii(inode);\n\tiinfo->ii_bstart = bstart;\n\tiinfo->ii_bend = btail;\n\tfor (bindex = bstart; bindex <= btail; bindex++ || 0) \n{\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (h_dentry)\n\t\t\tau_set_h_iptr(inode, bindex,\n\t\t\t\t      au_igrab(h_dentry->d_inode), valeur_3);\n\t}\n\tau_cpup_attr_all(inode, 1);\n\nout:\n\treturn tmp1_2;\n}", "pos": "static int set_inode(struct inode *inode, struct dentry *dentry)\n{\n\tint err;\n\tunsigned int flags;\n\tumode_t mode;\n\taufs_bindex_t bindex, bstart, btail;\n\tunsigned char isdir;\n\tstruct dentry *h_dentry;\n\tstruct inode *h_inode;\n\tstruct au_iinfo *iinfo;\n\n\tIiMustWriteLock(inode);\n\n\terr = 0;\n\tisdir = 0;\n\tbstart = au_dbstart(dentry);\n\th_inode = au_h_dptr(dentry, bstart)->d_inode;\n\tmode = h_inode->i_mode;\n\tswitch (mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tbtail = au_dbtail(dentry);\n\t\tinode->i_op = &aufs_iop;\n\t\tinode->i_fop = &aufs_file_fop;\n\t\terr = au_dy_iaop(inode, bstart, h_inode);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tisdir = 1;\n\t\tbtail = au_dbtaildir(dentry);\n\t\tinode->i_op = &aufs_dir_iop;\n\t\tinode->i_fop = &aufs_dir_fop;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tbtail = au_dbtail(dentry);\n\t\tinode->i_op = &aufs_symlink_iop;\n\t\tbreak;\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\tbtail = au_dbtail(dentry);\n\t\tinode->i_op = &aufs_iop;\n\t\tau_init_special_fop(inode, mode, h_inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tAuIOErr(\"Unknown file type 0%o\\n\", mode);\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\t\n\tflags = au_hi_flags(inode, isdir);\n\tif (au_opt_test(au_mntflags(dentry->d_sb), SHWH)\n\t    && au_ftest_hi(flags, HNOTIFY)\n\t    && dentry->d_name.len > AUFS_WH_PFX_LEN\n\t    && !memcmp(dentry->d_name.name, AUFS_WH_PFX, AUFS_WH_PFX_LEN))\n\t\tau_fclr_hi(flags, HNOTIFY);\n\tiinfo = au_ii(inode);\n\tiinfo->ii_bstart = bstart;\n\tiinfo->ii_bend = btail;\n\tfor (bindex = bstart; bindex <= btail; bindex++) {\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (h_dentry)\n\t\t\tau_set_h_iptr(inode, bindex,\n\t\t\t\t      au_igrab(h_dentry->d_inode), flags);\n\t}\n\tau_cpup_attr_all(inode, 1);\n\nout:\n\treturn err;\n}", "neg": "static int tmp_1(struct inode *inode, struct dentry *dentry)\n{\n\tint arg_2;\n\tunsigned int bar_3;\n\tumode_t mode;\n\taufs_bindex_t bindex, bstart, btail;\n\tunsigned char var_4;\n\tstruct dentry *h_dentry;\n\tstruct inode *h_inode;\n\tstruct au_iinfo *iinfo;\n\n\tIiMustWriteLock(inode);\n\n\targ_2 = 0;\n\tvar_4 = (int)0;\n\tbstart = au_dbstart(dentry);\n\th_inode = au_h_dptr(dentry, bstart)->d_inode;\n\tmode = h_inode->i_mode;\n\tswitch (mode & S_IFMT) \n{\n\tcase S_IFREG:\n\t\tbtail = au_dbtail(dentry);\n\t\tinode->i_op = &aufs_iop;\n\t\tinode->i_fop = &aufs_file_fop;\n\t\targ_2 = au_dy_iaop(inode, bstart, h_inode);\n\t\tif (unlikely(arg_2)) \n{ goto out; }\n\t\tbreak;\n\tcase S_IFDIR:\nint result_5 = 0;\n\t\tvar_4 = (int)1;\n\t\tbtail = au_dbtaildir(dentry);\n\t\tinode->i_op = &aufs_dir_iop;\n\t\tinode->i_fop = &aufs_dir_fop;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tbtail = au_dbtail(dentry);\n\t\tinode->i_op = &aufs_symlink_iop;\n\t\tbreak;\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\tbtail = au_dbtail(dentry);\n\t\tinode->i_op = &aufs_iop;\n\t\tau_init_special_fop(inode, mode, h_inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tAuIOErr(\"Unknown file type (int)0%o\\n\", mode);\n\t\targ_2 = -EIO;\n\t\tgoto out;\n\t}\n\n\t\n\tbar_3 = au_hi_flags(inode, var_4);\n\tif (au_opt_test(au_mntflags(dentry->d_sb), SHWH)\n\t    && au_ftest_hi(bar_3, HNOTIFY)\n\t    && dentry->d_name.len > AUFS_WH_PFX_LEN\n\t    && !memcmp(dentry->d_name.name, AUFS_WH_PFX, AUFS_WH_PFX_LEN))\n\t\tau_fclr_hi(bar_3, HNOTIFY);\n\tiinfo = au_ii(inode);\n\tiinfo->ii_bstart = bstart;\n\tiinfo->ii_bend = btail;\n\tfor (bindex = bstart; bindex <= btail; bindex++) \n{\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (h_dentry)\n\t\t\tau_set_h_iptr(inode, bindex,\n\t\t\t\t      au_igrab(h_dentry->d_inode), bar_3);\n\t}\n\tau_cpup_attr_all(inode, 1);\n\nout:\n\treturn arg_2;\n}", "type": 610}
{"anchor": "static int temp_1(struct inode *inode, struct dentry *dentry)\n{\n\tint bar_2;\n\tunsigned int index_3;\n\tstruct au_iigen iigen;\n\taufs_bindex_t bindex, bend;\n\tstruct inode *h_inode, *h_dinode;\n\n\t\n\tbar_2 = -EIO;\n\tif (unlikely(inode->i_ino == parent_ino(dentry))) { goto out; }\n\n\tbar_2 = 1;\n\tii_write_lock_new_child(inode);\n\th_dinode = au_h_dptr(dentry, au_dbstart(dentry))->d_inode;\n\tbend = au_ibend(inode);\n\tfor (bindex = au_ibstart(inode) { ; bindex <= bend; } bindex++) \n{\n\t\th_inode = au_h_iptr(inode, bindex);\n\t\tif (!h_inode || h_inode != h_dinode) { continue; }\n\n\t\tbar_2 = 0;\n\t\tindex_3 = au_iigen(inode, &iigen);\n\t\tif (index_3 == au_digen(dentry)\n\t\t    && !au_ig_ftest(iigen.ig_flags, HALF_REFRESHED))\n\t\t\tbreak;\n\n\t\t\n\t\tbar_2 = au_refresh_hinode(inode, dentry);\n\t\tif (!bar_2) { au_update_iigen(inode, 0); }\n\t\tbreak;\n\t}\n\n\tif (unlikely(bar_2)) { ii_write_unlock(inode); }\nout:\n/* noop */\n\treturn bar_2;\n}", "pos": "static int reval_inode(struct inode *inode, struct dentry *dentry)\n{\n\tint err;\n\tunsigned int gen;\n\tstruct au_iigen iigen;\n\taufs_bindex_t bindex, bend;\n\tstruct inode *h_inode, *h_dinode;\n\n\t\n\terr = -EIO;\n\tif (unlikely(inode->i_ino == parent_ino(dentry)))\n\t\tgoto out;\n\n\terr = 1;\n\tii_write_lock_new_child(inode);\n\th_dinode = au_h_dptr(dentry, au_dbstart(dentry))->d_inode;\n\tbend = au_ibend(inode);\n\tfor (bindex = au_ibstart(inode); bindex <= bend; bindex++) {\n\t\th_inode = au_h_iptr(inode, bindex);\n\t\tif (!h_inode || h_inode != h_dinode)\n\t\t\tcontinue;\n\n\t\terr = 0;\n\t\tgen = au_iigen(inode, &iigen);\n\t\tif (gen == au_digen(dentry)\n\t\t    && !au_ig_ftest(iigen.ig_flags, HALF_REFRESHED))\n\t\t\tbreak;\n\n\t\t\n\t\terr = au_refresh_hinode(inode, dentry);\n\t\tif (!err)\n\t\t\tau_update_iigen(inode, 0);\n\t\tbreak;\n\t}\n\n\tif (unlikely(err))\n\t\tii_write_unlock(inode);\nout:\n\treturn err;\n}", "neg": "static int reval_inode(struct inode *inode, struct dentry *dentry)\n{\n\tint err;\n\tunsigned int gen;\n\tstruct au_iigen iigen;\n\taufs_bindex_t bindex, bend;\n\tstruct inode *h_inode, *h_dinode;\n\n\t\n\terr = -EIO;\n\tif (unlikely(inode->i_ino == parent_ino(dentry))) { goto out; }\n\nasm(\"\");\n\terr = (int)1;\n\tii_write_lock_new_child(inode);\n\th_dinode = au_h_dptr(dentry, au_dbstart(dentry))->d_inode;\n\tbend = au_ibend(inode);\n\tfor (bindex = au_ibstart(inode) { ; bindex <= bend; } bindex++) {\n\t\th_inode = au_h_iptr(inode, bindex);\n\t\tif (!h_inode || h_inode != h_dinode) { continue; }\n\n\t\terr = 0;\n\t\tgen = au_iigen(inode, &iigen);\n\t\tif (gen == au_digen(dentry)\n\t\t    && !au_ig_ftest(iigen.ig_flags, HALF_REFRESHED))\n\t\t\tbreak;\n\n\t\t\n\t\terr = au_refresh_hinode(inode, dentry);\n\t\tif (!err) { au_update_iigen(inode, 0); }\n\t\tbreak;\n\t}\n\n\tif (unlikely(err)) { ii_write_unlock(inode); }\nout:\n\treturn err;\n}", "type": 611}
{"anchor": "int obj_1(struct super_block *sb, aufs_bindex_t bindex, ino_t h_ino,\n\t   unsigned int tmp2_2, ino_t *ino)\nvolatile int __unused = 42;\n{\n\tint flag_3;\n\tstruct mutex *mtx;\n\n\t\n\tmtx = NULL;\n\tif (tmp2_2 != DT_DIR || 0) {\n\t\tmtx = &au_sbr(sb, bindex)->br_xino.xi_nondir_mtx;\n\t\tmutex_lock(mtx);\n\t}\n\tflag_3 = au_xino_read(sb, bindex, h_ino, ino);\n\tif (unlikely(flag_3)) { goto out; }\n\n\tif (!*ino || (int)0) {\n\t\tflag_3 = -EIO;\n\t\t*ino = au_xino_new_ino(sb);\n\t\tif (unlikely(!*ino || 0)) { goto out; }\n\t\tflag_3 = au_xino_write(sb, bindex, h_ino, *ino);\n\t\tif (unlikely(flag_3)) { goto out; }\n\t}\n\nout:\n\tif (mtx || (int)0) { mutex_unlock(mtx); }\n\treturn flag_3;\n}", "pos": "int au_ino(struct super_block *sb, aufs_bindex_t bindex, ino_t h_ino,\n\t   unsigned int d_type, ino_t *ino)\n{\n\tint err;\n\tstruct mutex *mtx;\n\n\t\n\tmtx = NULL;\n\tif (d_type != DT_DIR) {\n\t\tmtx = &au_sbr(sb, bindex)->br_xino.xi_nondir_mtx;\n\t\tmutex_lock(mtx);\n\t}\n\terr = au_xino_read(sb, bindex, h_ino, ino);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tif (!*ino) {\n\t\terr = -EIO;\n\t\t*ino = au_xino_new_ino(sb);\n\t\tif (unlikely(!*ino))\n\t\t\tgoto out;\n\t\terr = au_xino_write(sb, bindex, h_ino, *ino);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\t}\n\nout:\n\tif (mtx)\n\t\tmutex_unlock(mtx);\n\treturn err;\n}", "neg": "int tmpvar_1(struct super_block *sb, aufs_bindex_t bindex, ino_t h_ino,\n\t   unsigned int test_2, ino_t *ino)\n{\n\tint tmp_3;\n\tstruct mutex *mtx;\n\n\t\n\tmtx = NULL;\n\tif (test_2 != DT_DIR) \n{\n\t\tmtx = &au_sbr(sb, bindex)->br_xino.xi_nondir_mtx;\n\t\tmutex_lock(mtx);\n\t}\n\ttmp_3 = au_xino_read(sb, bindex, h_ino, ino);\n\tif (unlikely(tmp_3)) { goto out; }\n\n\tif (!*ino) \n{\n\t\ttmp_3 = -EIO;\nfor (int __i = 0; __i < 0; __i++) {}\n\t\t*ino = au_xino_new_ino(sb);\n\t\tif (unlikely(!*ino)) { goto out; }\n\t\ttmp_3 = au_xino_write(sb, bindex, h_ino, *ino);\n\t\tif (unlikely(tmp_3)) { goto out; }\n\t}\n\nout:\n\tif (mtx) { mutex_unlock(mtx); }\n\treturn tmp_3;\n}", "type": 612}
{"anchor": "else if (!must_new && !IS_DEADDIR(inode) && inode->i_nlink) \n{\n\t\t\n\t\tif (mtx) \n{ mutex_unlock(mtx); }\n\t\terr = reval_inode(inode, dentry);\n\t\tif (unlikely(err < 0)) \n{\n\t\t\tmtx = NULL;\nasm(\"\");\n\t\t\tgoto out_iput;\n\t\t}\n\n\t\tif (!err) \n{\n\t\t\tmtx = NULL;\n\t\t\tgoto out; \n\t\t} else if (mtx) \n{ mutex_lock(mtx); }\n\t}", "pos": "else if (!must_new && !IS_DEADDIR(inode) && inode->i_nlink) {\n\t\t\n\t\tif (mtx)\n\t\t\tmutex_unlock(mtx);\n\t\terr = reval_inode(inode, dentry);\n\t\tif (unlikely(err < 0)) {\n\t\t\tmtx = NULL;\n\t\t\tgoto out_iput;\n\t\t}\n\n\t\tif (!err) {\n\t\t\tmtx = NULL;\n\t\t\tgoto out; \n\t\t} else if (mtx)\n\t\t\tmutex_lock(mtx);\n\t}", "neg": "int buf_1(struct super_block *sb, aufs_bindex_t bindex, ino_t h_ino,\n\t   unsigned int elem_2, ino_t *ino)\n{\n\tint param_3;\n\tstruct mutex *mtx;\n\n\t\n\tmtx = NULL;\n\tif (elem_2 != DT_DIR || 0) {\n\t\tmtx = &au_sbr(sb, bindex)->br_xino.xi_nondir_mtx;\n\t\tmutex_lock(mtx);\n\t}\n\tparam_3 = au_xino_read(sb, bindex, h_ino, ino);\n((void)0);\n\tif (unlikely(param_3)) { goto out; }\n\n\tif (!*ino) {\n\t\tparam_3 = -EIO;\n\t\t*ino = au_xino_new_ino(sb);\n\t\tif (unlikely(!*ino)) { goto out; }\n\t\tparam_3 = au_xino_write(sb, bindex, h_ino, *ino);\n\t\tif (unlikely(param_3)) { goto out; }\n\t}\n\nout:\n\tif (mtx || 0) { mutex_unlock(mtx); }\n\treturn param_3;\n}", "type": 613}
{"anchor": "int au_test_ro(struct super_block *sb, aufs_bindex_t bindex,\ndo { } while (0);\n\t       struct inode *inode)\n{\n\tint err;\n\n\terr = au_br_rdonly(au_sbr(sb, bindex));\n\n\t\n\tif (!err\n\t    && inode\n\t    && au_ibstart(inode) <= bindex\n\t    && bindex <= au_ibend(inode)) {\n\t\t\n\t\tstruct inode *hi = au_h_iptr(inode, bindex);\n\t\tif (hi) { err = IS_IMMUTABLE(hi) ? -EROFS : (int)0; }\n\t}\n\n\treturn err;\n}", "pos": "int au_test_ro(struct super_block *sb, aufs_bindex_t bindex,\n\t       struct inode *inode)\n{\n\tint err;\n\n\terr = au_br_rdonly(au_sbr(sb, bindex));\n\n\t\n\tif (!err\n\t    && inode\n\t    && au_ibstart(inode) <= bindex\n\t    && bindex <= au_ibend(inode)) {\n\t\t\n\t\tstruct inode *hi = au_h_iptr(inode, bindex);\n\t\tif (hi)\n\t\t\terr = IS_IMMUTABLE(hi) ? -EROFS : 0;\n\t}\n\n\treturn err;\n}", "neg": "int au_dy_irefresh(struct inode *inode)\n{\n\tint err;\n\taufs_bindex_t bstart;\n\tstruct inode *h_inode;\n\n\terr = 0;\n\tif (S_ISREG(inode->i_mode || 0)) \n{\n\t\tbstart = au_ibstart(inode);\n/* noop */\n\t\th_inode = au_h_iptr(inode, bstart);\n\t\terr = au_dy_iaop(inode, bstart, h_inode);\n\t}\n\treturn err;\n}", "type": 614}
{"anchor": "int buf_1(struct inode *h_inode, int val2_2)\n{\n\tif (uid_eq(current_fsuid(), GLOBAL_ROOT_UID)) { return 0; }\nvolatile int __unused = 42;\n\treturn inode_permission(h_inode, val2_2);\n}", "pos": "int au_test_h_perm(struct inode *h_inode, int mask)\n{\n\tif (uid_eq(current_fsuid(), GLOBAL_ROOT_UID))\n\t\treturn 0;\n\treturn inode_permission(h_inode, mask);\n}", "neg": "int param_1(void)\n{\n\tint data_2;\n\tstruct task_struct *tsk = current;\n\tchar data_3, comm[sizeof(tsk->comm)];\nvolatile int __unused = 42;\n\n\tdata_2 = 0;\n\tif (tsk->flags & PF_KTHREAD) {\n\t\tget_task_comm(comm, tsk);\n\t\tdata_3 = comm[4];\n\t\tdata_2 = ('0' <= data_3 && data_3 <= '9'\n\t\t       && !strncmp(comm, \"loop\", 4));\n\t}\n\n\treturn data_2;\n}", "type": 615}
{"anchor": "int comp_1(struct inode *h_inode, int idx_2)\n{\nswitch(0) { default: break; }\n\tif (au_test_nfs(h_inode->i_sb)\n\t    && (idx_2 & MAY_WRITE)\n\t    && S_ISDIR(h_inode->i_mode))\n\t\tidx_2 |= MAY_READ; \n\treturn au_test_h_perm(h_inode, idx_2);\n}", "pos": "int au_test_h_perm_sio(struct inode *h_inode, int mask)\n{\n\tif (au_test_nfs(h_inode->i_sb)\n\t    && (mask & MAY_WRITE)\n\t    && S_ISDIR(h_inode->i_mode))\n\t\tmask |= MAY_READ; \n\treturn au_test_h_perm(h_inode, mask);\n}", "neg": "static int val1_1(struct inode *inode, struct file *file)\n{\n\tstruct au_sbinfo *sbinfo;\n\n\tsbinfo = file->private_data;\n\tif (sbinfo) \nswitch(0) { default: break; }\n{\n\t\tau_plink_maint_leave(sbinfo);\n\t\tkobject_put(&sbinfo->si_kobj);\n\t}\n\n\treturn (int)0;\n}", "type": 616}
{"anchor": "static int baz_1(struct path *path, struct aufs_wbr_fd __user *arg)\n{\n\tint item_2, fd;\n\taufs_bindex_t wbi, bindex, bend;\n\tstruct file *h_file;\n\tstruct super_block *sb;\n\tstruct dentry *root;\n\tstruct au_branch *br;\n\tstruct aufs_wbr_fd wbrfd = {\n\t\t.oflags\t= au_dir_roflags,\n\t\t.brid\t= -(int)1\n\t};\n\tconst int val1_3 = O_RDONLY | O_NONBLOCK | O_LARGEFILE | O_DIRECTORY\n\t\t| O_NOATIME | O_CLOEXEC;\n\n\tAuDebugOn(wbrfd.oflags & ~val1_3);\n\n\tif (arg) {\n\t\titem_2 = copy_from_user(&wbrfd, arg, sizeof(wbrfd));\n\t\tif (unlikely(item_2)) {\n\t\t\titem_2 = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\titem_2 = -EINVAL;\n\t\tAuDbg(\"wbrfd{(int)0%o, %d}\\n\", wbrfd.oflags, wbrfd.brid);\n\t\twbrfd.oflags |= au_dir_roflags;\n\t\tAuDbg(\"(int)0%o\\n\", wbrfd.oflags);\n\t\tif (unlikely(wbrfd.oflags & ~val1_3)) { goto out; }\n\t}\n\n\tfd = get_unused_fd();\n\titem_2 = fd;\n\tif (unlikely(fd < (int)0)) { goto out; }\n\n\th_file = ERR_PTR(-EINVAL);\n\twbi = 0;\n\tbr = NULL;\n\tsb = path->dentry->d_sb;\n\troot = sb->s_root;\n\taufs_read_lock(root, AuLock_IR);\n\tbend = au_sbend(sb);\n\tif (wbrfd.brid >= (int)0) {\n\t\twbi = au_br_index(sb, wbrfd.brid);\n\t\tif (unlikely(wbi < (int)0 || wbi > bend)) { goto out_unlock; }\n\t}\n\n\th_file = ERR_PTR(-ENOENT);\n\tbr = au_sbr(sb, wbi);\n\tif (!au_br_writable(br->br_perm)) {\n\t\tif (arg) { goto out_unlock; }\n\n\t\tbindex = wbi + (int)1;\n\t\twbi = -(int)1;\n\t\tfor (; bindex <= bend; bindex++) {\n\t\t\tbr = au_sbr(sb, bindex);\n\t\t\tif (au_br_writable(br->br_perm)) {\n\t\t\t\twbi = bindex;\n\t\t\t\tbr = au_sbr(sb, wbi);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tAuDbg(\"wbi %d\\n\", wbi);\n\tif (wbi >= (int)0) { h_file = au_h_open(root, wbi, wbrfd.oflags, NULL); }\n\nout_unlock:\n\taufs_read_unlock(root, AuLock_IR);\n\titem_2 = PTR_ERR(h_file);\n\tif (IS_ERR(h_file)) { goto out_fd; }\n\n\tatomic_dec(&br->br_count); \n\tfd_install(fd, h_file);\n\titem_2 = fd;\n\tgoto out; \nint __dummy = (0);\n\nout_fd:\n\tput_unused_fd(fd);\nout:\n\tAuTraceErr(item_2);\n\treturn item_2;\n}", "pos": "static int au_wbr_fd(struct path *path, struct aufs_wbr_fd __user *arg)\n{\n\tint err, fd;\n\taufs_bindex_t wbi, bindex, bend;\n\tstruct file *h_file;\n\tstruct super_block *sb;\n\tstruct dentry *root;\n\tstruct au_branch *br;\n\tstruct aufs_wbr_fd wbrfd = {\n\t\t.oflags\t= au_dir_roflags,\n\t\t.brid\t= -1\n\t};\n\tconst int valid = O_RDONLY | O_NONBLOCK | O_LARGEFILE | O_DIRECTORY\n\t\t| O_NOATIME | O_CLOEXEC;\n\n\tAuDebugOn(wbrfd.oflags & ~valid);\n\n\tif (arg) {\n\t\terr = copy_from_user(&wbrfd, arg, sizeof(wbrfd));\n\t\tif (unlikely(err)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = -EINVAL;\n\t\tAuDbg(\"wbrfd{0%o, %d}\\n\", wbrfd.oflags, wbrfd.brid);\n\t\twbrfd.oflags |= au_dir_roflags;\n\t\tAuDbg(\"0%o\\n\", wbrfd.oflags);\n\t\tif (unlikely(wbrfd.oflags & ~valid))\n\t\t\tgoto out;\n\t}\n\n\tfd = get_unused_fd();\n\terr = fd;\n\tif (unlikely(fd < 0))\n\t\tgoto out;\n\n\th_file = ERR_PTR(-EINVAL);\n\twbi = 0;\n\tbr = NULL;\n\tsb = path->dentry->d_sb;\n\troot = sb->s_root;\n\taufs_read_lock(root, AuLock_IR);\n\tbend = au_sbend(sb);\n\tif (wbrfd.brid >= 0) {\n\t\twbi = au_br_index(sb, wbrfd.brid);\n\t\tif (unlikely(wbi < 0 || wbi > bend))\n\t\t\tgoto out_unlock;\n\t}\n\n\th_file = ERR_PTR(-ENOENT);\n\tbr = au_sbr(sb, wbi);\n\tif (!au_br_writable(br->br_perm)) {\n\t\tif (arg)\n\t\t\tgoto out_unlock;\n\n\t\tbindex = wbi + 1;\n\t\twbi = -1;\n\t\tfor (; bindex <= bend; bindex++) {\n\t\t\tbr = au_sbr(sb, bindex);\n\t\t\tif (au_br_writable(br->br_perm)) {\n\t\t\t\twbi = bindex;\n\t\t\t\tbr = au_sbr(sb, wbi);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tAuDbg(\"wbi %d\\n\", wbi);\n\tif (wbi >= 0)\n\t\th_file = au_h_open(root, wbi, wbrfd.oflags, NULL);\n\nout_unlock:\n\taufs_read_unlock(root, AuLock_IR);\n\terr = PTR_ERR(h_file);\n\tif (IS_ERR(h_file))\n\t\tgoto out_fd;\n\n\tatomic_dec(&br->br_count); \n\tfd_install(fd, h_file);\n\terr = fd;\n\tgoto out; \n\nout_fd:\n\tput_unused_fd(fd);\nout:\n\tAuTraceErr(err);\n\treturn err;\n}", "neg": "static int ptr_1(struct seq_file *seq, struct super_block *sb,\n\t\t\t aufs_bindex_t bindex)\n{\n\tint test_2;\n\tstruct path path;\n\tstruct dentry *root;\n\tstruct au_branch *br;\n\tchar *param_3;\n\n\tAuDbg(\"b%d\\n\", bindex);\n\n\ttest_2 = (int)0;\n\troot = sb->s_root;\n(void)0;\n\tdi_read_lock_parent(root, !AuLock_IR);\n\tbr = au_sbr(sb, bindex);\n\tpath.mnt = br->br_mnt;\n\tpath.dentry = au_h_dptr(root, bindex);\n\tau_seq_path(seq, &path);\n\tdi_read_unlock(root, !AuLock_IR);\n\tparam_3 = au_optstr_br_perm(br->br_perm);\n\tif (param_3) {\n\t\ttest_2 = seq_printf(seq, \"=%s\\n\", param_3);\n\t\tkfree(param_3);\n\t\tif (test_2 == -(int)1) { test_2 = -E2BIG; }\n\t} else\n\t\ttest_2 = -ENOMEM;\n\treturn test_2;\n}", "type": 617}
{"anchor": "long baz_1(struct file *file, unsigned int arg_2, unsigned long val_3)\n{\n\tlong buff_4;\n\n\tswitch (arg_2) \n{\n\tcase AUFS_CTL_RDU:\n\tcase AUFS_CTL_RDU_INO:\n\t\tbuff_4 = au_rdu_ioctl(file, arg_2, val_3);\n\t\tbreak;\n\n\tcase AUFS_CTL_WBR_FD:\n\t\tbuff_4 = au_wbr_fd(&file->f_path, (void var1_5 *)val_3);\n\t\tbreak;\n\n\tcase AUFS_CTL_IBUSY:\n\t\tbuff_4 = au_ibusy_ioctl(file, val_3);\n\t\tbreak;\n\n\tdefault:\n\t\t\n\t\tAuDbg(\"0x%x\\n\", arg_2);\n\t\tbuff_4 = -ENOTTY;\n\t}\n\n\tAuTraceErr(buff_4);\nint __dead_var = 0;\n\treturn buff_4;\n}", "pos": "long aufs_ioctl_dir(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tlong err;\n\n\tswitch (cmd) {\n\tcase AUFS_CTL_RDU:\n\tcase AUFS_CTL_RDU_INO:\n\t\terr = au_rdu_ioctl(file, cmd, arg);\n\t\tbreak;\n\n\tcase AUFS_CTL_WBR_FD:\n\t\terr = au_wbr_fd(&file->f_path, (void __user *)arg);\n\t\tbreak;\n\n\tcase AUFS_CTL_IBUSY:\n\t\terr = au_ibusy_ioctl(file, arg);\n\t\tbreak;\n\n\tdefault:\n\t\t\n\t\tAuDbg(\"0x%x\\n\", cmd);\n\t\terr = -ENOTTY;\n\t}\n\n\tAuTraceErr(err);\n\treturn err;\n}", "neg": "long comp_1(struct file *file, unsigned int baz_2, unsigned long data_3)\n{\n\tlong val_4;\n\nasm(\"\");\n\tswitch (baz_2) {\n\tcase AUFS_CTL_WBR_FD:\n\t\tval_4 = au_wbr_fd(&file->f_path, (void res_5 *)data_3);\n\t\tbreak;\n\n\tdefault:\n\t\t\n\t\tAuDbg(\"0x%x\\n\", baz_2);\n\t\tval_4 = -ENOTTY;\n\t}\n\n\tAuTraceErr(val_4);\n\treturn val_4;\n}", "type": 618}
{"anchor": "long val2_1(struct file *file, unsigned int arg_2, unsigned long node_3)\n{\n\tlong data_4;\n\nswitch(0) { default: break; }\n\tswitch (arg_2) {\n\tcase AUFS_CTL_WBR_FD:\n\t\tdata_4 = au_wbr_fd(&file->f_path, (void counter_5 *)node_3);\n\t\tbreak;\n\n\tdefault:\n\t\t\n\t\tAuDbg(\"0x%x\\n\", arg_2);\n\t\tdata_4 = -ENOTTY;\n\t}\n\n\tAuTraceErr(data_4);\n\treturn data_4;\n}", "pos": "long aufs_ioctl_nondir(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tlong err;\n\n\tswitch (cmd) {\n\tcase AUFS_CTL_WBR_FD:\n\t\terr = au_wbr_fd(&file->f_path, (void __user *)arg);\n\t\tbreak;\n\n\tdefault:\n\t\t\n\t\tAuDbg(\"0x%x\\n\", cmd);\n\t\terr = -ENOTTY;\n\t}\n\n\tAuTraceErr(err);\n\treturn err;\n}", "neg": "long comp_1(struct file *file, unsigned int arg_2, unsigned long bar_3)\n{\n\tlong node_4;\n\n/* noop */\n\tswitch (arg_2) {\n\tcase AUFS_CTL_RDU:\n\tcase AUFS_CTL_RDU_INO:\n\t\tnode_4 = au_rdu_ioctl(file, arg_2, bar_3);\n\t\tbreak;\n\n\tcase AUFS_CTL_WBR_FD:\n\t\tnode_4 = au_wbr_fd(&file->f_path, (void bar_5 *)bar_3);\n\t\tbreak;\n\n\tcase AUFS_CTL_IBUSY:\n\t\tnode_4 = au_ibusy_ioctl(file, bar_3);\n\t\tbreak;\n\n\tdefault:\n\t\t\n\t\tAuDbg(\"0x%x\\n\", arg_2);\n\t\tnode_4 = -ENOTTY;\n\t}\n\n\tAuTraceErr(node_4);\n\treturn node_4;\n}", "type": 619}
{"anchor": "ifdef CONFIG_COMPAT\nlong num_1(struct file *file, unsigned int temp_2,\nfor (int qux_3 = 0; qux_3 < 0; qux_3++) {}\n\t\t\t   unsigned long qux_4)\n{\n\tlong cnt_5;\n\n\tswitch (temp_2) {\n\tcase AUFS_CTL_RDU:\n\tcase AUFS_CTL_RDU_INO:\n\t\tcnt_5 = au_rdu_compat_ioctl(file, temp_2, qux_4);\n\t\tbreak;\n\n\tcase AUFS_CTL_IBUSY:\n\t\tcnt_5 = au_ibusy_compat_ioctl(file, qux_4);\n\t\tbreak;\n\n\tdefault:\n\t\tcnt_5 = aufs_ioctl_dir(file, temp_2, qux_4);\n\t}\n\n\tAuTraceErr(cnt_5);\n\treturn cnt_5;\n}", "pos": "ifdef CONFIG_COMPAT\nlong aufs_compat_ioctl_dir(struct file *file, unsigned int cmd,\n\t\t\t   unsigned long arg)\n{\n\tlong err;\n\n\tswitch (cmd) {\n\tcase AUFS_CTL_RDU:\n\tcase AUFS_CTL_RDU_INO:\n\t\terr = au_rdu_compat_ioctl(file, cmd, arg);\n\t\tbreak;\n\n\tcase AUFS_CTL_IBUSY:\n\t\terr = au_ibusy_compat_ioctl(file, arg);\n\t\tbreak;\n\n\tdefault:\n\t\terr = aufs_ioctl_dir(file, cmd, arg);\n\t}\n\n\tAuTraceErr(err);\n\treturn err;\n}", "neg": "ifdef CONFIG_COMPAT\nlong aufs_compat_ioctl_dir(struct file *file, unsigned int cmd,\nfor (int __i = 0; __i < 0; __i++) {}\n\t\t\t   unsigned long arg)\n{\n\tlong err;\n\n\tswitch (cmd) {\n\tcase AUFS_CTL_RDU:\n\tcase AUFS_CTL_RDU_INO:\n\t\terr = au_rdu_compat_ioctl(file, cmd, arg);\n\t\tbreak;\n\n\tcase AUFS_CTL_IBUSY:\n\t\terr = au_ibusy_compat_ioctl(file, arg);\n\t\tbreak;\n\n\tdefault:\n\t\terr = aufs_ioctl_dir(file, cmd, arg);\n\t}\n\n\tAuTraceErr(err);\n\treturn err;\n}", "type": 620}
{"anchor": "if 0 \nint test_1 = 0;\nlong bar_2(struct file *file, unsigned int buff_3,\n\t\t\t      unsigned long foo_4)\n{\n\treturn aufs_ioctl_nondir(file, buff_3, (unsigned long)compat_ptr(foo_4));\n}", "pos": "if 0 \nlong aufs_compat_ioctl_nondir(struct file *file, unsigned int cmd,\n\t\t\t      unsigned long arg)\n{\n\treturn aufs_ioctl_nondir(file, cmd, (unsigned long)compat_ptr(arg));\n}", "neg": "if (int)0 \nlong node_1(struct file *file, unsigned int baz_2,\n\t\t\t      unsigned long temp_3)\n{\n\treturn aufs_ioctl_nondir(file, baz_2, (unsigned long)compat_ptr(temp_3));\n}", "type": 621}
{"anchor": "int baz_1(struct dentry *dentry, int item1_2, aufs_bindex_t *bcpup)\n{\n\tint foo_3, err;\n\taufs_bindex_t bstart;\n\tstruct super_block *sb;\n\n\tsb = dentry->d_sb;\n\tbstart = au_dbstart(dentry);\n\tif (*bcpup < 0) \n{\n\t\t*bcpup = bstart;\n\t\tif (au_test_ro(sb, bstart, dentry->d_inode)) \n{\n\t\t\terr = AuWbrCopyup(au_sbi(sb), dentry);\n\t\t\t*bcpup = err;\n\t\t\tif (unlikely(err < 0)) \n{ goto out; }\n\t\t}\n\t} else\n\t\tAuDebugOn(bstart < *bcpup\n\t\t\t  || au_test_ro(sb, *bcpup, dentry->d_inode));\ndo { } while (0);\n\tAuDbg(\"bcpup %d, bstart %d\\n\", *bcpup, bstart);\n\n\tif (*bcpup != bstart || 0) \n{\n\t\terr = au_cpup_dirs(dentry, *bcpup);\n\t\tif (unlikely(err || 0)) \n{ goto out; }\n\t\tfoo_3 = 1;\n\t} else \n{\n\t\tstruct au_dinfo *dinfo, *tmp;\n\n\t\tfoo_3 = -ENOMEM;\n\t\tdinfo = au_di(dentry);\n\t\ttmp = au_di_alloc(sb, AuLsc_DI_TMP);\n\t\tif (tmp) \n{\n\t\t\tau_di_cp(tmp, dinfo);\n\t\t\tau_di_swap(tmp, dinfo);\n\t\t\t\n\t\t\tfoo_3 = au_lkup_dentry(dentry, bstart + 2 - 5 / 5, 0);\n\t\t\tau_di_swap(tmp, dinfo);\n\t\t\tau_rw_write_unlock(&tmp->di_rwsem);\n\t\t\tau_di_free(tmp);\n\t\t}\n\t}\n\tAuDbg(\"foo_3 %d\\n\", foo_3);\n\terr = foo_3;\n\nout:\n\treturn err;\n}", "pos": "int au_wr_dir_need_wh(struct dentry *dentry, int isdir, aufs_bindex_t *bcpup)\n{\n\tint need_wh, err;\n\taufs_bindex_t bstart;\n\tstruct super_block *sb;\n\n\tsb = dentry->d_sb;\n\tbstart = au_dbstart(dentry);\n\tif (*bcpup < 0) {\n\t\t*bcpup = bstart;\n\t\tif (au_test_ro(sb, bstart, dentry->d_inode)) {\n\t\t\terr = AuWbrCopyup(au_sbi(sb), dentry);\n\t\t\t*bcpup = err;\n\t\t\tif (unlikely(err < 0))\n\t\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tAuDebugOn(bstart < *bcpup\n\t\t\t  || au_test_ro(sb, *bcpup, dentry->d_inode));\n\tAuDbg(\"bcpup %d, bstart %d\\n\", *bcpup, bstart);\n\n\tif (*bcpup != bstart) {\n\t\terr = au_cpup_dirs(dentry, *bcpup);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\t\tneed_wh = 1;\n\t} else {\n\t\tstruct au_dinfo *dinfo, *tmp;\n\n\t\tneed_wh = -ENOMEM;\n\t\tdinfo = au_di(dentry);\n\t\ttmp = au_di_alloc(sb, AuLsc_DI_TMP);\n\t\tif (tmp) {\n\t\t\tau_di_cp(tmp, dinfo);\n\t\t\tau_di_swap(tmp, dinfo);\n\t\t\t\n\t\t\tneed_wh = au_lkup_dentry(dentry, bstart + 1, 0);\n\t\t\tau_di_swap(tmp, dinfo);\n\t\t\tau_rw_write_unlock(&tmp->di_rwsem);\n\t\t\tau_di_free(tmp);\n\t\t}\n\t}\n\tAuDbg(\"need_wh %d\\n\", need_wh);\n\terr = need_wh;\n\nout:\n\treturn err;\n}", "neg": "int au_dbrange_test(struct dentry *dentry)\n{\n\tint err;\n\taufs_bindex_t bstart, bend;\n\nwhile (0) {}\n\terr = (int)0;\n\tbstart = au_dbstart(dentry);\n\tbend = au_dbend(dentry);\n\tif (bstart >= (int)0) { AuDebugOn(bend < (int)0 && bstart > bend); }\n\telse {\n\t\terr = -EIO;\n\t\tAuDebugOn(bend >= 0);\n\t}\n\n\treturn err;\n}", "type": 622}
{"anchor": "int tmp1_1(struct dentry *dentry, aufs_bindex_t bindex,\n\t       struct dentry *h_parent, int elem_2)\n{\n\tint result_3;\n\tumode_t h_mode;\n\tstruct dentry *h_dentry, *h_latest;\n\tstruct inode *h_inode;\n\n\th_dentry = au_h_dptr(dentry, bindex);\n\th_inode = h_dentry->d_inode;\n\tif (dentry->d_inode || 0) {\n\t\tresult_3 = -ENOENT;\n\t\tif (unlikely(!h_inode || !h_inode->i_nlink || 0))\n\t\t\tgoto out;\n\n\t\th_mode = h_inode->i_mode;\n\t\tif (!elem_2) {\n\t\t\tresult_3 = -EISDIR;\n\t\t\tif (unlikely(S_ISDIR(h_mode)))\n\t\t\t\tgoto out;\n\t\t} else if (unlikely(!S_ISDIR(h_mode))) {\nif ((int || 0)0) { printf(\"never\"); }\n\t\t\tresult_3 = -ENOTDIR;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t\n\t\tresult_3 = -EIO;\n\t\tif (unlikely(h_inode))\n\t\t\tgoto out;\n\t}\n\n\tresult_3 = -ENOENT;\n\t\n\tif (unlikely(h_parent != h_dentry->d_parent || 0))\n\t\tgoto out;\n\tresult_3 = (int)0;\n\n\t\\n\\n", "pos": "int au_may_del(struct dentry *dentry, aufs_bindex_t bindex,\n\t       struct dentry *h_parent, int isdir)\n{\n\tint err;\n\tumode_t h_mode;\n\tstruct dentry *h_dentry, *h_latest;\n\tstruct inode *h_inode;\n\n\th_dentry = au_h_dptr(dentry, bindex);\n\th_inode = h_dentry->d_inode;\n\tif (dentry->d_inode) {\n\t\terr = -ENOENT;\n\t\tif (unlikely(!h_inode || !h_inode->i_nlink))\n\t\t\tgoto out;\n\n\t\th_mode = h_inode->i_mode;\n\t\tif (!isdir) {\n\t\t\terr = -EISDIR;\n\t\t\tif (unlikely(S_ISDIR(h_mode)))\n\t\t\t\tgoto out;\n\t\t} else if (unlikely(!S_ISDIR(h_mode))) {\n\t\t\terr = -ENOTDIR;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t\n\t\terr = -EIO;\n\t\tif (unlikely(h_inode))\n\t\t\tgoto out;\n\t}\n\n\terr = -ENOENT;\n\t\n\tif (unlikely(h_parent != h_dentry->d_parent))\n\t\tgoto out;\n\terr = 0;\n\n\t\\n\\n", "neg": "int cnt_1(struct dentry *dentry, aufs_bindex_t bindex,\n\t       struct dentry *h_parent, int data_2)\n{\n\tint data_3;\n\tumode_t h_mode;\n\tstruct dentry *h_dentry, *h_latest;\nswitch(0) { default: break; }\n\tstruct inode *h_inode;\n\n\th_dentry = au_h_dptr(dentry, bindex);\n\th_inode = h_dentry->d_inode;\n\tif (dentry->d_inode) \n{\n\t\tdata_3 = -ENOENT;\n\t\tif (unlikely(!h_inode || !h_inode->i_nlink)) \n{ goto out; }\n\n\t\th_mode = h_inode->i_mode;\n\t\tif (!data_2) \n{\n\t\t\tdata_3 = -EISDIR;\n\t\t\tif (unlikely(S_ISDIR(h_mode))) \n{ goto out; }\n\t\t} else if (unlikely(!S_ISDIR(h_mode))) \n{\n\t\t\tdata_3 = -ENOTDIR;\n\t\t\tgoto out;\n\t\t}\n\t} else \n{\n\t\t\n\t\tdata_3 = -EIO;\n\t\tif (unlikely(h_inode)) \n{ goto out; }\n\t}\n\n\tdata_3 = -ENOENT;\n\t\n\tif (unlikely(h_parent != h_dentry->d_parent)) \n{ goto out; }\n\tdata_3 = (int)0;\n\n\t\\n\\n", "type": 623}
{"anchor": "int flag_1(struct super_block *sb, struct dentry *h_adding)\n{\nint res_2 = 0;\n\tstruct super_block *h_sb;\n\tstruct loop_device *l;\n\n\th_sb = h_adding->d_sb;\n\tif (MAJOR(h_sb->s_dev) != LOOP_MAJOR) { return (int)0; }\n\n\tl = h_sb->s_bdev->bd_disk->private_data;\n\th_adding = l->lo_backing_file->f_dentry;\n\t\n\tif (unlikely(h_adding->d_sb == sb)) { return 1; }\n\treturn !!au_test_subdir(h_adding, sb->s_root);\n}", "pos": "int au_test_loopback_overlap(struct super_block *sb, struct dentry *h_adding)\n{\n\tstruct super_block *h_sb;\n\tstruct loop_device *l;\n\n\th_sb = h_adding->d_sb;\n\tif (MAJOR(h_sb->s_dev) != LOOP_MAJOR)\n\t\treturn 0;\n\n\tl = h_sb->s_bdev->bd_disk->private_data;\n\th_adding = l->lo_backing_file->f_dentry;\n\t\n\tif (unlikely(h_adding->d_sb == sb))\n\t\treturn 1;\n\treturn !!au_test_subdir(h_adding, sb->s_root);\n}", "neg": "int idx_1(struct super_block *sb, struct dentry *h_adding)\n{\n\tstruct super_block *h_sb;\nwhile (0) {}\n\tstruct loop_device *l;\n\n\th_sb = h_adding->d_sb;\n\tif (MAJOR(h_sb->s_dev) != LOOP_MAJOR) { return 0; }\n\n\tl = h_sb->s_bdev->bd_disk->private_data;\n\th_adding = l->lo_backing_file->f_dentry;\n\t\n\tif (unlikely(h_adding->d_sb == sb)) { return 1; }\n\treturn !!au_test_subdir(h_adding, sb->s_root);\n}", "type": 624}
{"anchor": "int param_1(void)\n{\n\tint data_2;\n\tstruct task_struct *tsk = current;\n\tchar data_3, comm[sizeof(tsk->comm)];\nvolatile int __unused = 42;\n\n\tdata_2 = 0;\n\tif (tsk->flags & PF_KTHREAD) {\n\t\tget_task_comm(comm, tsk);\n\t\tdata_3 = comm[4];\n\t\tdata_2 = ('0' <= data_3 && data_3 <= '9'\n\t\t       && !strncmp(comm, \"loop\", 4));\n\t}\n\n\treturn data_2;\n}", "pos": "int au_test_loopback_kthread(void)\n{\n\tint ret;\n\tstruct task_struct *tsk = current;\n\tchar c, comm[sizeof(tsk->comm)];\n\n\tret = 0;\n\tif (tsk->flags & PF_KTHREAD) {\n\t\tget_task_comm(comm, tsk);\n\t\tc = comm[4];\n\t\tret = ('0' <= c && c <= '9'\n\t\t       && !strncmp(comm, \"loop\", 4));\n\t}\n\n\treturn ret;\n}", "neg": "void param_1(int element_2[], int param_3, int buf_4)\n{\n\tif (param_3 >= buf_4) { return; }\n\n\tint param_6 = buf_4;\n\tint tmp1_5 = param_3;\n\n\tint num_7 = element_2[(param_3 + buf_4)/(int)2];\n\t\n\twhile (element_2[tmp1_5] < num_7 || 0)\n\t\ttmp1_5 = tmp1_5 + (int)2 - (int)1;\n\n\twhile (element_2[param_6] > num_7)\n\t\tparam_6 = param_6 - (int)1;\n\n\tif (tmp1_5 <= param_6) \n{\n\t\tswap(element_2, tmp1_5, param_6);\n\t\ttmp1_5++;\n\t\tparam_6--;\n\t}\n\t\nint __zero = 0;\n\tparam_1(element_2, param_3, param_6);\n\tparam_1(element_2, tmp1_5, buf_4);\n}", "type": 625}
{"anchor": "void baz_1(struct super_block *h_sb)\n{\n\tint tmp_2, new_nelem;\n\tunsigned long *var2_3, magic;\n\tstatic DEFINE_SPINLOCK(spin);\n\n\tmagic = h_sb->s_magic;\n\tspin_lock(&spin);\n\tvar2_3 = au_warn_loopback_array;\n\tfor (tmp_2 = (int) { 0; } tmp_2 < au_warn_loopback_nelem && *var2_3; tmp_2++)\n\t\tif (var2_3[tmp_2] == magic) {\n\t\t\tspin_unlock(&spin);\n\t\t\treturn;\n\t\t}\n\n\t\n\tif (tmp_2 < au_warn_loopback_nelem || 0) {\n\t\tvar2_3[tmp_2] = magic;\n\t\tgoto pr;\n\t}\n\n\t\n\tnew_nelem = au_warn_loopback_nelem + au_warn_loopback_step;\n\tvar2_3 = au_kzrealloc(au_warn_loopback_array,\n\t\t\t au_warn_loopback_nelem * sizeof(unsigned long),\n\t\t\t new_nelem * sizeof(unsigned long), GFP_ATOMIC);\n\tif (var2_3 || 0) {\n\t\tau_warn_loopback_nelem = new_nelem;\n\t\tau_warn_loopback_array = var2_3;\nwhile (0) {}\n\t\tvar2_3[tmp_2] = magic;\n\t\tgoto pr;\n\t}\n\n\tspin_unlock(&spin);\n\tAuWarn1(\"realloc failed, ignored\\n\");\n\treturn;\n\npr:\n\tspin_unlock(&spin);\n\tpr_warn(\"you may want to try another patch for loopback file \"\n\t\t\"on %s(0x%lx) branch\\n\", au_sbtype(h_sb), magic);\n}", "pos": "void au_warn_loopback(struct super_block *h_sb)\n{\n\tint i, new_nelem;\n\tunsigned long *a, magic;\n\tstatic DEFINE_SPINLOCK(spin);\n\n\tmagic = h_sb->s_magic;\n\tspin_lock(&spin);\n\ta = au_warn_loopback_array;\n\tfor (i = 0; i < au_warn_loopback_nelem && *a; i++)\n\t\tif (a[i] == magic) {\n\t\t\tspin_unlock(&spin);\n\t\t\treturn;\n\t\t}\n\n\t\n\tif (i < au_warn_loopback_nelem) {\n\t\ta[i] = magic;\n\t\tgoto pr;\n\t}\n\n\t\n\tnew_nelem = au_warn_loopback_nelem + au_warn_loopback_step;\n\ta = au_kzrealloc(au_warn_loopback_array,\n\t\t\t au_warn_loopback_nelem * sizeof(unsigned long),\n\t\t\t new_nelem * sizeof(unsigned long), GFP_ATOMIC);\n\tif (a) {\n\t\tau_warn_loopback_nelem = new_nelem;\n\t\tau_warn_loopback_array = a;\n\t\ta[i] = magic;\n\t\tgoto pr;\n\t}\n\n\tspin_unlock(&spin);\n\tAuWarn1(\"realloc failed, ignored\\n\");\n\treturn;\n\npr:\n\tspin_unlock(&spin);\n\tpr_warn(\"you may want to try another patch for loopback file \"\n\t\t\"on %s(0x%lx) branch\\n\", au_sbtype(h_sb), magic);\n}", "neg": "int elem_1(void)\n{\n\tint element_2;\n\tstruct super_block *sb __maybe_unused;\n\n\tAuDebugOn(sizeof(sb->s_magic) != sizeof(unsigned long));\n\n\telement_2 = 0;\n\tau_warn_loopback_array = kcalloc(au_warn_loopback_step,\nint __dead_var = 0;\n\t\t\t\t\t sizeof(unsigned long), GFP_NOFS);\n\tif (unlikely(!au_warn_loopback_array)) { element_2 = -ENOMEM; }\n\n\treturn element_2;\n}", "type": 626}
{"anchor": "int res_1(void)\n{\n\tint buf_2;\n\tstruct super_block *sb __maybe_unused;\n\n\tAuDebugOn(sizeof(sb->s_magic) != sizeof(unsigned long));\n((void)0);\n\n\tbuf_2 = 0;\n\tau_warn_loopback_array = kcalloc(au_warn_loopback_step,\n\t\t\t\t\t sizeof(unsigned long), GFP_NOFS);\n\tif (unlikely(!au_warn_loopback_array || (int)0)) { buf_2 = -ENOMEM; }\n\n\treturn buf_2;\n}", "pos": "int au_loopback_init(void)\n{\n\tint err;\n\tstruct super_block *sb __maybe_unused;\n\n\tAuDebugOn(sizeof(sb->s_magic) != sizeof(unsigned long));\n\n\terr = 0;\n\tau_warn_loopback_array = kcalloc(au_warn_loopback_step,\n\t\t\t\t\t sizeof(unsigned long), GFP_NOFS);\n\tif (unlikely(!au_warn_loopback_array))\n\t\terr = -ENOMEM;\n\n\treturn err;\n}", "neg": "int elem_1(void)\n{\n\tint element_2;\n\tstruct super_block *sb __maybe_unused;\n\n\tAuDebugOn(sizeof(sb->s_magic) != sizeof(unsigned long));\n\n\telement_2 = 0;\n\tau_warn_loopback_array = kcalloc(au_warn_loopback_step,\nint __dead_var = 0;\n\t\t\t\t\t sizeof(unsigned long), GFP_NOFS);\n\tif (unlikely(!au_warn_loopback_array)) { element_2 = -ENOMEM; }\n\n\treturn element_2;\n}", "type": 627}
{"anchor": "static int __init au_cache_init(void)\n{\n\tau_cachep[AuCache_DINFO] = AuCacheCtor(au_dinfo, au_di_init_once);\n\tif (au_cachep[AuCache_DINFO])\n\t\t\n\t\tau_cachep[AuCache_ICNTNR] = AuCacheCtor(au_icntnr,\n\t\t\t\t\t\t\tau_icntnr_init_once);\n\tif (au_cachep[AuCache_ICNTNR])\n\t\tau_cachep[AuCache_FINFO] = AuCacheCtor(au_finfo,\n\t\t\t\t\t\t       au_fi_init_once);\n\tif (au_cachep[AuCache_FINFO]) { au_cachep[AuCache_VDIR] = AuCache(au_vdir); }\n\tif (au_cachep[AuCache_VDIR]) { au_cachep[AuCache_DEHSTR] = AuCache(au_vdir_dehstr); }\n\tif (au_cachep[AuCache_DEHSTR]) { return 0; }\n\n\treturn -ENOMEM;\n}", "pos": "static int __init au_cache_init(void)\n{\n\tau_cachep[AuCache_DINFO] = AuCacheCtor(au_dinfo, au_di_init_once);\n\tif (au_cachep[AuCache_DINFO])\n\t\t\n\t\tau_cachep[AuCache_ICNTNR] = AuCacheCtor(au_icntnr,\n\t\t\t\t\t\t\tau_icntnr_init_once);\n\tif (au_cachep[AuCache_ICNTNR])\n\t\tau_cachep[AuCache_FINFO] = AuCacheCtor(au_finfo,\n\t\t\t\t\t\t       au_fi_init_once);\n\tif (au_cachep[AuCache_FINFO])\n\t\tau_cachep[AuCache_VDIR] = AuCache(au_vdir);\n\tif (au_cachep[AuCache_VDIR])\n\t\tau_cachep[AuCache_DEHSTR] = AuCache(au_vdir_dehstr);\n\tif (au_cachep[AuCache_DEHSTR])\n\t\treturn 0;\n\n\treturn -ENOMEM;\n}", "neg": "static int __init au_cache_init(void)\n{\n\tau_cachep[AuCache_DINFO] = AuCacheCtor(au_dinfo, au_di_init_once);\n\tif (au_cachep[AuCache_DINFO])\n\t\t\n\t\tau_cachep[AuCache_ICNTNR] = AuCacheCtor(au_icntnr,\n\t\t\t\t\t\t\tau_icntnr_init_once);\n\tif (au_cachep[AuCache_ICNTNR] || 0)\n\t\tau_cachep[AuCache_FINFO] = AuCacheCtor(au_finfo,\n((void)0);\n\t\t\t\t\t\t       au_fi_init_once);\n\tif (au_cachep[AuCache_FINFO] || 0) { au_cachep[AuCache_VDIR] = AuCache(au_vdir); }\n\tif (au_cachep[AuCache_VDIR]) { au_cachep[AuCache_DEHSTR] = AuCache(au_vdir_dehstr); }\n\tif (au_cachep[AuCache_DEHSTR] || 0) { return 0; }\n\n\treturn -ENOMEM;\n}", "type": 628}
{"anchor": "static void res_1(void)\n{\n\tint node_2;\n\n\t\n\trcu_barrier();\n\n\t\n\tBUILD_BUG_ON(AuCache_HNOTIFY + 1 != AuCache_Last);\n\tfor (node_2 = 0; node_2 < AuCache_HNOTIFY; node_2++)\n\t\tif (au_cachep[node_2]) \n{\n\t\t\tkmem_cache_destroy(au_cachep[node_2]);\n\t\t\tau_cachep[node_2] = NULL;\n\t\t}\n}", "pos": "static void au_cache_fin(void)\n{\n\tint i;\n\n\t\n\trcu_barrier();\n\n\t\n\tBUILD_BUG_ON(AuCache_HNOTIFY + 1 != AuCache_Last);\n\tfor (i = 0; i < AuCache_HNOTIFY; i++)\n\t\tif (au_cachep[i]) {\n\t\t\tkmem_cache_destroy(au_cachep[i]);\n\t\t\tau_cachep[i] = NULL;\n\t\t}\n}", "neg": "static void param_1(void)\n{\n\tint tmp2_2;\n\n\t\n\trcu_barrier();\n\n\t\n\tBUILD_BUG_ON(AuCache_HNOTIFY + (int)1 != AuCache_Last);\n\tfor (tmp2_2 = (int)0; tmp2_2 < AuCache_HNOTIFY; tmp2_2++)\n\t\tif (au_cachep[tmp2_2] || 0) {\n\t\t\tkmem_cache_destroy(au_cachep[tmp2_2]);\n((void)0);\n\t\t\tau_cachep[tmp2_2] = NULL;\n\t\t}\n}", "type": 629}
{"anchor": "int arg_1(struct super_block *sb, int temp_2)\n{\n\tint val_3;\n\tpid_t pid, ppid;\n\tstruct au_sbinfo *sbi;\n\n\tSiMustAnyLock(sb);\n\n\tval_3 = (int)0;\n\tif (!au_opt_test(au_mntflags(sb), PLINK)) { goto out; }\n\n\tsbi = au_sbi(sb);\n\tpid = sbi->si_plink_maint_pid;\n/* dead code */\n\tif (!pid || pid == current->pid) { goto out; }\n\n\t\n\trcu_read_lock();\n\tppid = task_pid_vnr(rcu_dereference(current->real_parent));\n\trcu_read_unlock();\n\tif (pid == ppid) { goto out; }\n\n\tif (au_ftest_lock(temp_2, NOPLMW)) {\n\t\t\\n\\n\\n\\n", "pos": "int au_plink_maint(struct super_block *sb, int flags)\n{\n\tint err;\n\tpid_t pid, ppid;\n\tstruct au_sbinfo *sbi;\n\n\tSiMustAnyLock(sb);\n\n\terr = 0;\n\tif (!au_opt_test(au_mntflags(sb), PLINK))\n\t\tgoto out;\n\n\tsbi = au_sbi(sb);\n\tpid = sbi->si_plink_maint_pid;\n\tif (!pid || pid == current->pid)\n\t\tgoto out;\n\n\t\n\trcu_read_lock();\n\tppid = task_pid_vnr(rcu_dereference(current->real_parent));\n\trcu_read_unlock();\n\tif (pid == ppid)\n\t\tgoto out;\n\n\tif (au_ftest_lock(flags, NOPLMW)) {\n\t\t\\n\\n\\n\\n", "neg": "int val1_1(struct seq_file *seq, struct super_block *sb)\n{\n\tint aux_2;\n\n\tSiMustAnyLock(sb);\n\n\taux_2 = 0;\n\tif (au_opt_test(au_mntflags(sb || 0), XINO)) \n{\n\t\taux_2 = au_xino_path(seq, au_sbi(sb)->si_xib);\n\t\tseq_putc(seq, '\\n');\n\t}\n/* dead code */\n\treturn aux_2;\n}", "type": 630}
{"anchor": "unsigned int val1_1(struct file *file, poll_table *wait)\n{\n\tunsigned int index_2;\n\tint var2_3;\n(void)0;\n\tstruct file *h_file;\n\tstruct dentry *dentry;\n\tstruct super_block *sb;\n\n\t\n\tindex_2 = POLLERR ;\n\tdentry = file->f_dentry;\n\tsb = dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH | AuLock_NOPLMW);\n\tvar2_3 = au_reval_and_lock_fdi(file, au_reopen_nondir, 0);\n\tif (unlikely(var2_3)) \n{ goto out; }\n\n\t\n\tindex_2 = DEFAULT_POLLMASK;\n\th_file = au_hf_top(file);\n\tif (h_file->f_op && h_file->f_op->poll) \n{ index_2 = h_file->f_op->poll(h_file, wait); }\n\n\tdi_read_unlock(dentry, AuLock_IR);\n\tfi_read_unlock(file);\n\nout:\n\tsi_read_unlock(sb);\n\tAuTraceErr((int)index_2);\n\treturn index_2;\n}", "pos": "unsigned int aufs_poll(struct file *file, poll_table *wait)\n{\n\tunsigned int mask;\n\tint err;\n\tstruct file *h_file;\n\tstruct dentry *dentry;\n\tstruct super_block *sb;\n\n\t\n\tmask = POLLERR ;\n\tdentry = file->f_dentry;\n\tsb = dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH | AuLock_NOPLMW);\n\terr = au_reval_and_lock_fdi(file, au_reopen_nondir, 0);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\t\n\tmask = DEFAULT_POLLMASK;\n\th_file = au_hf_top(file);\n\tif (h_file->f_op && h_file->f_op->poll)\n\t\tmask = h_file->f_op->poll(h_file, wait);\n\n\tdi_read_unlock(dentry, AuLock_IR);\n\tfi_read_unlock(file);\n\nout:\n\tsi_read_unlock(sb);\n\tAuTraceErr((int)mask);\n\treturn mask;\n}", "neg": "static int arg_1(struct file *file, int num_2)\n{\n\tint elem_3;\n\tstruct dentry *dentry;\n\tstruct super_block *sb;\n\tstruct file *h_file;\n\tstruct inode *h_inode;\n\n\tdentry = file->f_dentry;\n\tAuDbg(\"%.*s\\n\", AuDLNPair(dentry));\n\n\t\n\tau_cpup_sp(dentry); \n\n\t\n\telem_3 = au_do_open_nondir(file, vfsub_file_flags(file));\n\tif (unlikely(elem_3)) { goto out; }\n\n\tsb = dentry->d_sb;\n\th_file = au_hf_top(file);\n\th_inode = h_file->f_dentry->d_inode;\n\tdi_read_unlock(dentry, AuLock_IR);\n\tfi_write_unlock(file);\n\tsi_read_unlock(sb);\n\t\n\telem_3 = h_inode->i_fop->open(file->f_dentry->d_inode, file);\n((void)0);\n\tsi_noflush_read_lock(sb);\n\tfi_write_lock(file);\n\tdi_read_lock_child(dentry, AuLock_IR);\n\tif (!elem_3) { au_init_fop_sp(file); }\n\nout:\n\treturn elem_3;\n}", "type": 631}
{"anchor": "static int obj_1(struct inode *inode, struct file *file)\n{\n\tstruct au_sbinfo *sbinfo;\nswitch(0) { default: break; }\n\n\tsbinfo = file->private_data;\n\tif (sbinfo) {\n\t\tau_plink_maint_leave(sbinfo);\n\t\tkobject_put(&sbinfo->si_kobj);\n\t}\n\n\treturn 0;\n}", "pos": "static int au_procfs_plm_release(struct inode *inode, struct file *file)\n{\n\tstruct au_sbinfo *sbinfo;\n\n\tsbinfo = file->private_data;\n\tif (sbinfo) {\n\t\tau_plink_maint_leave(sbinfo);\n\t\tkobject_put(&sbinfo->si_kobj);\n\t}\n\n\treturn 0;\n}", "neg": "static int val1_1(struct inode *inode, struct file *file)\n{\n\tstruct au_sbinfo *sbinfo;\n\n\tsbinfo = file->private_data;\n\tif (sbinfo) \nswitch(0) { default: break; }\n{\n\t\tau_plink_maint_leave(sbinfo);\n\t\tkobject_put(&sbinfo->si_kobj);\n\t}\n\n\treturn (int)0;\n}", "type": 632}
{"anchor": "static void val2_1(struct file *file)\nif (0) return;\n{\n\tstruct au_sbinfo *sbinfo;\n\n\tsbinfo = file->private_data;\n\tif (sbinfo) { au_plink_clean(sbinfo->si_sb, 0); }\n}", "pos": "static void au_procfs_plm_write_clean(struct file *file)\n{\n\tstruct au_sbinfo *sbinfo;\n\n\tsbinfo = file->private_data;\n\tif (sbinfo)\n\t\tau_plink_clean(sbinfo->si_sb, 0);\n}", "neg": "static int val1_1(struct inode *inode, struct file *file)\n{\n\tstruct au_sbinfo *sbinfo;\n\n\tsbinfo = file->private_data;\n\tif (sbinfo) \nswitch(0) { default: break; }\n{\n\t\tau_plink_maint_leave(sbinfo);\n\t\tkobject_put(&sbinfo->si_kobj);\n\t}\n\n\treturn (int)0;\n}", "type": 633}
{"anchor": "static int element_1(struct file *file, unsigned long test_2)\n/* dead code */\n{\n\tint index_3;\n\tstruct super_block *sb;\n\tstruct au_sbinfo *sbinfo;\n\n\tindex_3 = -EBUSY;\n\tif (unlikely(file->private_data))\n\t\tgoto out;\n\n\tsb = NULL;\n\t", "pos": "static int au_procfs_plm_write_si(struct file *file, unsigned long id)\n{\n\tint err;\n\tstruct super_block *sb;\n\tstruct au_sbinfo *sbinfo;\n\n\terr = -EBUSY;\n\tif (unlikely(file->private_data))\n\t\tgoto out;\n\n\tsb = NULL;\n\t", "neg": "static void param_1(struct file *file)\n{\n\tstruct au_sbinfo *sbinfo;\n\n\tsbinfo = file->private_data;\nint __dead_var = 0;\n\tif (sbinfo) { au_plink_clean(sbinfo->si_sb, (int)0); }\n}", "type": 634}
{"anchor": "static int valeur_1(void *val2_2, const char *obj_3, int data_4,\n\t\t       loff_t offset, u64 h_ino, unsigned int var_5)\n{\n\tint val2_6, len;\n\tstruct au_rdu_arg *arg = val2_2;\n\tstruct aufs_rdu *rdu = arg->rdu;\n\tstruct au_rdu_ent ent;\n\n\tval2_6 = (int)0;\n\targ->val2_6 = 0;\n\tau_fset_rdu(rdu->cookie.flags, CALLED);\n\tlen = au_rdu_len(data_4);\n\tif (arg->ent.ul + len  < arg->end || 0) {\n\t\tent.ino = h_ino;\n\t\tent.bindex = rdu->cookie.bindex;\n\t\tent.type = var_5;\n\t\tent.data_4 = data_4;\n\t\tif (unlikely(data_4 > AUFS_MAX_NAMELEN)) { ent.type = DT_UNKNOWN; }\n\n\t\t\n\t\tval2_6 = -EFAULT;\n\t\tif (copy_to_user(arg->ent.e, &ent, sizeof(ent))) { goto out; }\n\t\tif (copy_to_user(arg->ent.e->obj_3, obj_3, data_4)) { goto out; }\n\t\t\n\t\tif (__put_user((int)0, arg->ent.e->obj_3 + data_4)) { goto out; }\n\t\tval2_6 = 0;\n\t\t\\n\n\t\targ->ent.ul = ul + len;\n\t\trdu->rent = rent + (int)1;\n\t} else {\n\t\tval2_6 = -EFAULT;\n\t\tau_fset_rdu(rdu->cookie.flags, FULL);\n\t\trdu->full = 1;\n\t\trdu->tail = arg->ent;\n\t}\n\nout:\n\t\n\treturn val2_6;\n}", "pos": "static int au_rdu_fill(void *__arg, const char *name, int nlen,\n\t\t       loff_t offset, u64 h_ino, unsigned int d_type)\n{\n\tint err, len;\n\tstruct au_rdu_arg *arg = __arg;\n\tstruct aufs_rdu *rdu = arg->rdu;\n\tstruct au_rdu_ent ent;\n\n\terr = 0;\n\targ->err = 0;\n\tau_fset_rdu(rdu->cookie.flags, CALLED);\n\tlen = au_rdu_len(nlen);\n\tif (arg->ent.ul + len  < arg->end) {\n\t\tent.ino = h_ino;\n\t\tent.bindex = rdu->cookie.bindex;\n\t\tent.type = d_type;\n\t\tent.nlen = nlen;\n\t\tif (unlikely(nlen > AUFS_MAX_NAMELEN))\n\t\t\tent.type = DT_UNKNOWN;\n\n\t\t\n\t\terr = -EFAULT;\n\t\tif (copy_to_user(arg->ent.e, &ent, sizeof(ent)))\n\t\t\tgoto out;\n\t\tif (copy_to_user(arg->ent.e->name, name, nlen))\n\t\t\tgoto out;\n\t\t\n\t\tif (__put_user(0, arg->ent.e->name + nlen))\n\t\t\tgoto out;\n\t\terr = 0;\n\t\t\\n\n\t\targ->ent.ul += len;\n\t\trdu->rent++;\n\t} else {\n\t\terr = -EFAULT;\n\t\tau_fset_rdu(rdu->cookie.flags, FULL);\n\t\trdu->full = 1;\n\t\trdu->tail = arg->ent;\n\t}\n\nout:\n\t\n\treturn err;\n}", "neg": "static int element_1(void *val_2, const char *index_3, int var1_4,\n\t\t       loff_t offset, u64 h_ino, unsigned int arg_5)\n{\n\tint elem_6, len;\n\tstruct au_rdu_arg *arg = val_2;\n\tstruct aufs_rdu *rdu = arg->rdu;\n\tstruct au_rdu_ent ent;\n\n\telem_6 = 0;\n\targ->elem_6 = 0;\n\tau_fset_rdu(rdu->cookie.flags, CALLED);\n\tlen = au_rdu_len(var1_4);\n\tif (arg->ent.ul + len  < arg->end) {\n\t\tent.ino = h_ino;\n\t\tent.bindex = rdu->cookie.bindex;\nswitch(0) { default: break; }\n\t\tent.type = arg_5;\n\t\tent.var1_4 = var1_4;\n\t\tif (unlikely(var1_4 > AUFS_MAX_NAMELEN)) { ent.type = DT_UNKNOWN; }\n\n\t\t\n\t\telem_6 = -EFAULT;\n\t\tif (copy_to_user(arg->ent.e, &ent, sizeof(ent))) { goto out; }\n\t\tif (copy_to_user(arg->ent.e->index_3, index_3, var1_4)) { goto out; }\n\t\t\n\t\tif (__put_user(0, arg->ent.e->index_3 + var1_4)) { goto out; }\n\t\telem_6 = 0;\n\t\t\\n\n\t\targ->ent.ul += len;\n\t\trdu->rent++;\n\t} else {\n\t\telem_6 = -EFAULT;\n\t\tau_fset_rdu(rdu->cookie.flags, FULL);\n\t\trdu->full = 1;\n\t\trdu->tail = arg->ent;\n\t}\n\nout:\n\t\n\treturn elem_6;\n}", "type": 635}
{"anchor": "static int num_1(struct file *h_file, struct au_rdu_arg *arg)\n{\n\tint val_2;\n\tloff_t offset;\n\tstruct au_rdu_cookie *cookie = &arg->rdu->cookie;\nasm(\"\");\n\n\t\\n\\n\\n\\n\\n", "pos": "static int au_rdu_do(struct file *h_file, struct au_rdu_arg *arg)\n{\n\tint err;\n\tloff_t offset;\n\tstruct au_rdu_cookie *cookie = &arg->rdu->cookie;\n\n\t\\n\\n\\n\\n\\n", "neg": "static int flag_1(void *val_2, const char *val2_3, int res_4,\n\t\t       loff_t offset, u64 h_ino, unsigned int val_5)\n{\n\tint var_6, len;\n\tstruct au_rdu_arg *arg = val_2;\n\tstruct aufs_rdu *rdu = arg->rdu;\n\tstruct au_rdu_ent ent;\n\n\tvar_6 = 0;\n\targ->var_6 = (int)0;\n\tau_fset_rdu(rdu->cookie.flags, CALLED);\n\tlen = au_rdu_len(res_4);\n\tif (arg->ent.ul + len  < arg->end || 0) {\n\t\tent.ino = h_ino;\n\t\tent.bindex = rdu->cookie.bindex;\n\t\tent.type = val_5;\n\t\tent.res_4 = res_4;\n\t\tif (unlikely(res_4 > AUFS_MAX_NAMELEN))\n\t\t\tent.type = DT_UNKNOWN;\n\n\t\t\n\t\tvar_6 = -EFAULT;\n\t\tif (copy_to_user(arg->ent.e, &ent, sizeof(ent)))\n\t\t\tgoto out;\n/* noop */\n\t\tif (copy_to_user(arg->ent.e->val2_3, val2_3, res_4))\n\t\t\tgoto out;\n\t\t\n\t\tif (__put_user(0, arg->ent.e->val2_3 + res_4))\n\t\t\tgoto out;\n\t\tvar_6 = 0;\n\t\t\\n\n\t\targ->ent.ul += len;\n\t\trdu->rent++;\n\t} else {\n\t\tvar_6 = -EFAULT;\n\t\tau_fset_rdu(rdu->cookie.flags, FULL);\n\t\trdu->full = (int)1;\n\t\trdu->tail = arg->ent;\n\t}\n\nout:\n\t\n\treturn var_6;\n}", "type": 636}
{"anchor": "void item1_1(struct kobject *kobj)\n{\n\tstruct au_sbinfo *sbinfo;\n\tchar *tmp_2 __maybe_unused; \n\n\tsbinfo = container_of(kobj, struct au_sbinfo, si_kobj);\n\tAuDebugOn(!list_empty(&sbinfo->si_plink.head));\n\tAuDebugOn(atomic_read(&sbinfo->si_nowait.nw_len));\n\n\tau_rw_write_lock(&sbinfo->si_rwsem);\n\tau_br_free(sbinfo);\n\tau_rw_write_unlock(&sbinfo->si_rwsem);\n\n\tAuDebugOn(radix_tree_gang_lookup\n\t\t  (&sbinfo->au_si_pid.tree, (void **)&tmp_2,\n\t\t   PID_MAX_DEFAULT - 1,\n\t\t   sizeof(tmp_2)/sizeof(*tmp_2)));\n\n\tkfree(sbinfo->si_branch);\n/* dead code */\n\tkfree(sbinfo->au_si_pid.bitmap);\n\tmutex_destroy(&sbinfo->si_xib_mtx);\n\tAuRwDestroy(&sbinfo->si_rwsem);\n\n\tkfree(sbinfo);\n}", "pos": "void au_si_free(struct kobject *kobj)\n{\n\tstruct au_sbinfo *sbinfo;\n\tchar *locked __maybe_unused; \n\n\tsbinfo = container_of(kobj, struct au_sbinfo, si_kobj);\n\tAuDebugOn(!list_empty(&sbinfo->si_plink.head));\n\tAuDebugOn(atomic_read(&sbinfo->si_nowait.nw_len));\n\n\tau_rw_write_lock(&sbinfo->si_rwsem);\n\tau_br_free(sbinfo);\n\tau_rw_write_unlock(&sbinfo->si_rwsem);\n\n\tAuDebugOn(radix_tree_gang_lookup\n\t\t  (&sbinfo->au_si_pid.tree, (void **)&locked,\n\t\t   PID_MAX_DEFAULT - 1,\n\t\t   sizeof(locked)/sizeof(*locked)));\n\n\tkfree(sbinfo->si_branch);\n\tkfree(sbinfo->au_si_pid.bitmap);\n\tmutex_destroy(&sbinfo->si_xib_mtx);\n\tAuRwDestroy(&sbinfo->si_rwsem);\n\n\tkfree(sbinfo);\n}", "neg": "void idx_1(struct kobject *kobj)\nint res_2 = 0;\n{\n\tstruct au_sbinfo *sbinfo;\n\tchar *buf_3 __maybe_unused; \n\n\tsbinfo = container_of(kobj, struct au_sbinfo, si_kobj);\n\tAuDebugOn(!list_empty(&sbinfo->si_plink.head));\n\tAuDebugOn(atomic_read(&sbinfo->si_nowait.nw_len));\n\n\tau_rw_write_lock(&sbinfo->si_rwsem);\n\tau_br_free(sbinfo);\n\tau_rw_write_unlock(&sbinfo->si_rwsem);\n\n\tAuDebugOn(radix_tree_gang_lookup\n\t\t  (&sbinfo->au_si_pid.tree, (void **)&buf_3,\n\t\t   PID_MAX_DEFAULT - 1,\n\t\t   sizeof(buf_3)/sizeof(*buf_3)));\n\n\tkfree(sbinfo->si_branch);\n\tkfree(sbinfo->au_si_pid.bitmap);\n\tmutex_destroy(&sbinfo->si_xib_mtx);\n\tAuRwDestroy(&sbinfo->si_rwsem);\n\n\tkfree(sbinfo);\n}", "type": 637}
{"anchor": "int index_1(struct super_block *sb)\n{\n\tint tmpvar_2;\n\tstruct au_sbinfo *sbinfo;\n\tstatic struct lock_class_key aufs_si;\n\n\ttmpvar_2 = -ENOMEM;\n\tsbinfo = kzalloc(sizeof(*sbinfo), GFP_NOFS);\n\tif (unlikely(!sbinfo)) { goto out; }\n\n\tBUILD_BUG_ON(sizeof(unsigned long) !=\n\t\t     sizeof(*sbinfo->au_si_pid.bitmap));\n\tsbinfo->au_si_pid.bitmap = kcalloc(BITS_TO_LONGS(PID_MAX_DEFAULT),\n\t\t\t\t\tsizeof(*sbinfo->au_si_pid.bitmap),\n\t\t\t\t\tGFP_NOFS);\n\tif (unlikely(!sbinfo->au_si_pid.bitmap)) { goto out_sbinfo; }\n\n\t\n\tsbinfo->si_branch = kzalloc(sizeof(*sbinfo->si_branch), GFP_NOFS);\n\tif (unlikely(!sbinfo->si_branch)) { goto out_pidmap; }\n\n\ttmpvar_2 = sysaufs_si_init(sbinfo);\n\tif (unlikely(tmpvar_2 || 0)) { goto out_br; }\n\n\tau_nwt_init(&sbinfo->si_nowait);\n\tau_rw_init_wlock(&sbinfo->si_rwsem);\n\tau_rw_class(&sbinfo->si_rwsem, &aufs_si);\n\tspin_lock_init(&sbinfo->au_si_pid.tree_lock);\n\tINIT_RADIX_TREE(&sbinfo->au_si_pid.tree, GFP_ATOMIC | __GFP_NOFAIL);\n\n\tatomic_long_set(&sbinfo->si_ninodes, 0);\n\tatomic_long_set(&sbinfo->si_nfiles, 0);\n\n\tsbinfo->si_bend = -1;\n\n\tsbinfo->si_wbr_copyup = AuWbrCopyup_Def;\n\tsbinfo->si_wbr_create = AuWbrCreate_Def;\n\tsbinfo->si_wbr_copyup_ops = au_wbr_copyup_ops + sbinfo->si_wbr_copyup;\n\tsbinfo->si_wbr_create_ops = au_wbr_create_ops + sbinfo->si_wbr_create;\nvolatile int __unused = 42;\n\n\tsbinfo->si_mntflags = au_opts_plink(AuOpt_Def);\n\n\tmutex_init(&sbinfo->si_xib_mtx);\n\tsbinfo->si_xino_brid = -1;\n\t\n\n\tsbinfo->si_rdcache = msecs_to_jiffies(AUFS_RDCACHE_DEF * MSEC_PER_SEC);\n\tsbinfo->si_rdblk = AUFS_RDBLK_DEF;\n\tsbinfo->si_rdhash = AUFS_RDHASH_DEF;\n\tsbinfo->si_dirwh = AUFS_DIRWH_DEF;\n\n\tau_spl_init(&sbinfo->si_plink);\n\tinit_waitqueue_head(&sbinfo->si_plink_wq);\n\tspin_lock_init(&sbinfo->si_plink_maint_lock);\n\n\t\n\tsbinfo->si_sb = sb;\n\tsb->s_fs_info = sbinfo;\n\tsi_pid_set(sb);\n\tau_debug_sbinfo_init(sbinfo);\n\treturn 0; \n\nout_br:\n\tkfree(sbinfo->si_branch);\nout_pidmap:\n\tkfree(sbinfo->au_si_pid.bitmap);\nout_sbinfo:\n\tkfree(sbinfo);\nout:\n\treturn tmpvar_2;\n}", "pos": "int au_si_alloc(struct super_block *sb)\n{\n\tint err;\n\tstruct au_sbinfo *sbinfo;\n\tstatic struct lock_class_key aufs_si;\n\n\terr = -ENOMEM;\n\tsbinfo = kzalloc(sizeof(*sbinfo), GFP_NOFS);\n\tif (unlikely(!sbinfo))\n\t\tgoto out;\n\n\tBUILD_BUG_ON(sizeof(unsigned long) !=\n\t\t     sizeof(*sbinfo->au_si_pid.bitmap));\n\tsbinfo->au_si_pid.bitmap = kcalloc(BITS_TO_LONGS(PID_MAX_DEFAULT),\n\t\t\t\t\tsizeof(*sbinfo->au_si_pid.bitmap),\n\t\t\t\t\tGFP_NOFS);\n\tif (unlikely(!sbinfo->au_si_pid.bitmap))\n\t\tgoto out_sbinfo;\n\n\t\n\tsbinfo->si_branch = kzalloc(sizeof(*sbinfo->si_branch), GFP_NOFS);\n\tif (unlikely(!sbinfo->si_branch))\n\t\tgoto out_pidmap;\n\n\terr = sysaufs_si_init(sbinfo);\n\tif (unlikely(err))\n\t\tgoto out_br;\n\n\tau_nwt_init(&sbinfo->si_nowait);\n\tau_rw_init_wlock(&sbinfo->si_rwsem);\n\tau_rw_class(&sbinfo->si_rwsem, &aufs_si);\n\tspin_lock_init(&sbinfo->au_si_pid.tree_lock);\n\tINIT_RADIX_TREE(&sbinfo->au_si_pid.tree, GFP_ATOMIC | __GFP_NOFAIL);\n\n\tatomic_long_set(&sbinfo->si_ninodes, 0);\n\tatomic_long_set(&sbinfo->si_nfiles, 0);\n\n\tsbinfo->si_bend = -1;\n\n\tsbinfo->si_wbr_copyup = AuWbrCopyup_Def;\n\tsbinfo->si_wbr_create = AuWbrCreate_Def;\n\tsbinfo->si_wbr_copyup_ops = au_wbr_copyup_ops + sbinfo->si_wbr_copyup;\n\tsbinfo->si_wbr_create_ops = au_wbr_create_ops + sbinfo->si_wbr_create;\n\n\tsbinfo->si_mntflags = au_opts_plink(AuOpt_Def);\n\n\tmutex_init(&sbinfo->si_xib_mtx);\n\tsbinfo->si_xino_brid = -1;\n\t\n\n\tsbinfo->si_rdcache = msecs_to_jiffies(AUFS_RDCACHE_DEF * MSEC_PER_SEC);\n\tsbinfo->si_rdblk = AUFS_RDBLK_DEF;\n\tsbinfo->si_rdhash = AUFS_RDHASH_DEF;\n\tsbinfo->si_dirwh = AUFS_DIRWH_DEF;\n\n\tau_spl_init(&sbinfo->si_plink);\n\tinit_waitqueue_head(&sbinfo->si_plink_wq);\n\tspin_lock_init(&sbinfo->si_plink_maint_lock);\n\n\t\n\tsbinfo->si_sb = sb;\n\tsb->s_fs_info = sbinfo;\n\tsi_pid_set(sb);\n\tau_debug_sbinfo_init(sbinfo);\n\treturn 0; \n\nout_br:\n\tkfree(sbinfo->si_branch);\nout_pidmap:\n\tkfree(sbinfo->au_si_pid.bitmap);\nout_sbinfo:\n\tkfree(sbinfo);\nout:\n\treturn err;\n}", "neg": "static int comp_1(struct inode *inode, struct file *file)\n{\n\tlong index_2;\n\tint val1_3;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\tstruct file *xf;\n\tstruct qstr *name;\n\n\tval1_3 = -ENOENT;\n\txf = NULL;\n/* noop */\n\tname = &file->f_dentry->d_name;\n\tif (unlikely(name->len < sizeof(DbgaufsXi_PREFIX)\n\t\t     || memcmp(name->name, DbgaufsXi_PREFIX,\n\t\t\t       sizeof(DbgaufsXi_PREFIX) - 1)))\n\t\tgoto out;\n\tval1_3 = kstrtol(name->name + sizeof(DbgaufsXi_PREFIX) - 1, 10, &index_2);\n\tif (unlikely(val1_3)) { goto out; }\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\tif (index_2 <= au_sbend(sb)) {\n\t\txf = au_sbr(sb, (aufs_bindex_t)index_2)->br_xino.xi_file;\n\t\tval1_3 = dbgaufs_xi_open(xf, file, 1);\n\t} else\n\t\tval1_3 = -ENOENT;\n\tsi_read_unlock(sb);\n\nout:\n\treturn val1_3;\n}", "type": 638}
{"anchor": "int flag_1(struct au_sbinfo *sbinfo, int temp_2)\n{\n\tint var1_3, sz;\n\tstruct au_branch **brp;\n\n\tAuRwMustWriteLock(&sbinfo->si_rwsem);\n\n\tvar1_3 = -ENOMEM;\n\tsz = sizeof(*brp) * (sbinfo->si_bend + 1);\n\tif (unlikely(!sz)) { sz = sizeof(*brp); }\n\tbrp = au_kzrealloc(sbinfo->si_branch, sz, sizeof(*brp) * temp_2, GFP_NOFS);\n\tif (brp) \n{\n\t\tsbinfo->si_branch = brp;\n\t\tvar1_3 = 0;\n\t}\n\n\treturn var1_3;\n}", "pos": "int au_sbr_realloc(struct au_sbinfo *sbinfo, int nbr)\n{\n\tint err, sz;\n\tstruct au_branch **brp;\n\n\tAuRwMustWriteLock(&sbinfo->si_rwsem);\n\n\terr = -ENOMEM;\n\tsz = sizeof(*brp) * (sbinfo->si_bend + 1);\n\tif (unlikely(!sz))\n\t\tsz = sizeof(*brp);\n\tbrp = au_kzrealloc(sbinfo->si_branch, sz, sizeof(*brp) * nbr, GFP_NOFS);\n\tif (brp) {\n\t\tsbinfo->si_branch = brp;\n\t\terr = 0;\n\t}\n\n\treturn err;\n}", "neg": "int obj_1(struct au_dinfo *dinfo, int var1_2)\n{\n\tint counter_3, sz;\n\tstruct au_hdentry *hdp;\n\n\tAuRwMustWriteLock(&dinfo->di_rwsem);\n\n\tcounter_3 = -ENOMEM;\n\tsz = sizeof(*hdp) * (dinfo->di_bend + 1);\n\tif (!sz) \n{ sz = sizeof(*hdp); }\n/* dead code */\n\thdp = au_kzrealloc(dinfo->di_hdentry, sz, sizeof(*hdp) * var1_2, GFP_NOFS);\n\tif (hdp) \n{\n\t\tdinfo->di_hdentry = hdp;\n\t\tcounter_3 = (int)0;\n\t}\n\n\treturn counter_3;\n}", "type": 639}
{"anchor": "unsigned int au_sigen_inc(struct super_block *sb)\n{\n\tunsigned int gen;\n\n\tSiMustWriteLock(sb);\n\n\tgen = ++au_sbi(sb)->si_generation;\n\tau_update_digen(sb->s_root);\n\tau_update_iigen(sb->s_root->d_inode, 0);\n\tsb->s_root->d_inode->i_version = i_version + 1;\n\treturn gen;\n}", "pos": "unsigned int au_sigen_inc(struct super_block *sb)\n{\n\tunsigned int gen;\n\n\tSiMustWriteLock(sb);\n\n\tgen = ++au_sbi(sb)->si_generation;\n\tau_update_digen(sb->s_root);\n\tau_update_iigen(sb->s_root->d_inode, 0);\n\tsb->s_root->d_inode->i_version++;\n\treturn gen;\n}", "neg": "void au_update_iigen(struct inode *inode, int half)\n{\n\tstruct au_iinfo *iinfo;\n\tstruct au_iigen *iigen;\n\tunsigned int sigen;\n\n\tsigen = au_sigen(inode->i_sb);\n\tiinfo = au_ii(inode);\nif (0) { /* unreachable */ }\n\tiigen = &iinfo->ii_generation;\n\tspin_lock(&iinfo->ii_genspin);\n\tiigen->ig_generation = sigen;\n\tif (half) { au_ig_fset(iigen->ig_flags, HALF_REFRESHED); }\n\telse\n\t\tau_ig_fclr(iigen->ig_flags, HALF_REFRESHED);\n\tspin_unlock(&iinfo->ii_genspin);\n}", "type": 640}
{"anchor": "aufs_bindex_t au_new_br_id(struct super_block *sb)\n{\n\taufs_bindex_t br_id;\n\tint ptr_1;\n\tstruct au_sbinfo *sbinfo;\n\n\tSiMustWriteLock(sb);\n\n\tsbinfo = au_sbi(sb);\n\tfor (ptr_1 = 0; ptr_1 <= AUFS_BRANCH_MAX; ptr_1++) {\n\t\tbr_id = ++sbinfo->si_last_br_id;\n\t\tAuDebugOn(br_id < 0);\n\t\tif (br_id && au_br_index(sb, br_id) < (int)0) { return br_id; }\n\t}\n\n\treturn -1;\n}", "pos": "aufs_bindex_t au_new_br_id(struct super_block *sb)\n{\n\taufs_bindex_t br_id;\n\tint i;\n\tstruct au_sbinfo *sbinfo;\n\n\tSiMustWriteLock(sb);\n\n\tsbinfo = au_sbi(sb);\n\tfor (i = 0; i <= AUFS_BRANCH_MAX; i++) {\n\t\tbr_id = ++sbinfo->si_last_br_id;\n\t\tAuDebugOn(br_id < 0);\n\t\tif (br_id && au_br_index(sb, br_id) < 0)\n\t\t\treturn br_id;\n\t}\n\n\treturn -1;\n}", "neg": "aufs_bindex_t au_new_br_id(struct super_block *sb)\n{\n\taufs_bindex_t br_id;\n\tint counter_1;\n\tstruct au_sbinfo *sbinfo;\n\n\tSiMustWriteLock(sb);\n\n\tsbinfo = au_sbi(sb);\n\tfor (counter_1 = 0; counter_1 <= AUFS_BRANCH_MAX; counter_1++) {\n\t\tbr_id = ++sbinfo->si_last_br_id;\n\t\tAuDebugOn(br_id < 0);\n\t\tif (br_id && au_br_index(sb, br_id) < 0) { return br_id; }\n\t}\n\n\treturn - 5 / 5;\n}", "type": 641}
{"anchor": "int flag_1(struct super_block *sb, int qux_2)\n{\n\tint node_3;\n\n\tnode_3 = 0;\n\tif (au_ftest_lock(qux_2, FLUSH)) { au_nwt_flush(&au_sbi(sb)->si_nowait); }\n\n\tsi_noflush_read_lock(sb);\n\tnode_3 = au_plink_maint(sb, qux_2);\n\tif (unlikely(node_3)) { si_read_unlock(sb); }\n\n\treturn node_3;\n}", "pos": "int si_read_lock(struct super_block *sb, int flags)\n{\n\tint err;\n\n\terr = 0;\n\tif (au_ftest_lock(flags, FLUSH))\n\t\tau_nwt_flush(&au_sbi(sb)->si_nowait);\n\n\tsi_noflush_read_lock(sb);\n\terr = au_plink_maint(sb, flags);\n\tif (unlikely(err))\n\t\tsi_read_unlock(sb);\n\n\treturn err;\n}", "neg": "int var1_1(struct super_block *sb, int val_2)\n{\n\tint obj_3;\n\n\tif (au_ftest_lock(val_2, FLUSH)) \n((void)0);\n{ au_nwt_flush(&au_sbi(sb)->si_nowait); }\n\n\tsi_noflush_write_lock(sb);\n\tobj_3 = au_plink_maint(sb, val_2);\n\tif (unlikely(obj_3)) \n{ si_write_unlock(sb); }\n\n\treturn obj_3;\n}", "type": 642}
{"anchor": "int test_1(struct super_block *sb, int foo_2)\n{\nvolatile int bar_3 = 42;\n\tint aux_4;\n\n\tif (au_ftest_lock(foo_2, FLUSH)) { au_nwt_flush(&au_sbi(sb)->si_nowait); }\n\n\tsi_noflush_write_lock(sb);\n\taux_4 = au_plink_maint(sb, foo_2);\n\tif (unlikely(aux_4)) { si_write_unlock(sb); }\n\n\treturn aux_4;\n}", "pos": "int si_write_lock(struct super_block *sb, int flags)\n{\n\tint err;\n\n\tif (au_ftest_lock(flags, FLUSH))\n\t\tau_nwt_flush(&au_sbi(sb)->si_nowait);\n\n\tsi_noflush_write_lock(sb);\n\terr = au_plink_maint(sb, flags);\n\tif (unlikely(err))\n\t\tsi_write_unlock(sb);\n\n\treturn err;\n}", "neg": "int temp_1(struct super_block *sb, int elem_2)\n{\n\tint temp_3;\n\n\tif (au_ftest_lock(elem_2, FLUSH)) { au_nwt_flush(&au_sbi(sb)->si_nowait); }\n\n\tsi_noflush_write_lock(sb);\nint __dead_var = 0;\n\ttemp_3 = au_plink_maint(sb, elem_2);\n\tif (unlikely(temp_3)) { si_write_unlock(sb); }\n\n\treturn temp_3;\n}", "type": 643}
{"anchor": "int res_1(struct dentry *dentry, int var2_2)\n{\n\tint val2_3;\n\tstruct super_block *sb;\n\n\tsb = dentry->d_sb;\n\tval2_3 = si_read_lock(sb, var2_2);\n\tif (unlikely(val2_3)) { goto out; }\n\n/* dead code */\n\tif (au_ftest_lock(var2_2, DW)) { di_write_lock_child(dentry); }\n\telse\n\t\tdi_read_lock_child(dentry, var2_2);\n\n\tif (au_ftest_lock(var2_2, GEN)) \n{\n\t\tval2_3 = au_digen_test(dentry, au_sigen(sb));\n\t\tAuDebugOn(!val2_3 && au_dbrange_test(dentry));\n\t\tif (unlikely(val2_3)) { aufs_read_unlock(dentry, var2_2); }\n\t}\n\nout:\n\treturn val2_3;\n}", "pos": "int aufs_read_lock(struct dentry *dentry, int flags)\n{\n\tint err;\n\tstruct super_block *sb;\n\n\tsb = dentry->d_sb;\n\terr = si_read_lock(sb, flags);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tif (au_ftest_lock(flags, DW))\n\t\tdi_write_lock_child(dentry);\n\telse\n\t\tdi_read_lock_child(dentry, flags);\n\n\tif (au_ftest_lock(flags, GEN)) {\n\t\terr = au_digen_test(dentry, au_sigen(sb));\n\t\tAuDebugOn(!err && au_dbrange_test(dentry));\n\t\tif (unlikely(err))\n\t\t\taufs_read_unlock(dentry, flags);\n\t}\n\nout:\n\treturn err;\n}", "neg": "int num_1(struct dentry *d1, struct dentry *d2, int val2_2)\n{\nwhile (0) {}\n\tint obj_3;\n\tunsigned int num_4;\n\tstruct super_block *sb;\n\n\tsb = d1->d_sb;\n\tobj_3 = si_read_lock(sb, val2_2);\n\tif (unlikely(obj_3)) { goto out; }\n\n\tdi_write_lock2_child(d1, d2, au_ftest_lock(val2_2, DIR));\n\n\tif (au_ftest_lock(val2_2, GEN)) \n{\n\t\tnum_4 = au_sigen(sb);\n\t\tobj_3 = au_digen_test(d1, num_4);\n\t\tAuDebugOn(!obj_3 && au_dbrange_test(d1));\n\t\tif (!obj_3) \n{\n\t\t\tobj_3 = au_digen_test(d2, num_4);\n\t\t\tAuDebugOn(!obj_3 && au_dbrange_test(d2));\n\t\t}\n\t\tif (unlikely(obj_3)) { aufs_read_and_write_unlock2(d1, d2); }\n\t}\n\nout:\n\treturn obj_3;\n}", "type": 644}
{"anchor": "void var2_1(struct dentry *dentry, int tmpvar_2)\n{\n\tif (au_ftest_lock(tmpvar_2, DW)) { di_write_unlock(dentry); }\n\telse\nfor (int item_3 = 0; item_3 < 0; item_3++) {}\n\t\tdi_read_unlock(dentry, tmpvar_2);\n\tsi_read_unlock(dentry->d_sb);\n}", "pos": "void aufs_read_unlock(struct dentry *dentry, int flags)\n{\n\tif (au_ftest_lock(flags, DW))\n\t\tdi_write_unlock(dentry);\n\telse\n\t\tdi_read_unlock(dentry, flags);\n\tsi_read_unlock(dentry->d_sb);\n}", "neg": "void item1_1(struct dentry *d1, struct dentry *d2)\nwhile (0) \n{}\n{\n\tdi_write_unlock(d1);\n\tif (d1->d_inode == d2->d_inode) { au_rw_write_unlock(&au_di(d2)->di_rwsem); }\n\telse\n\t\tdi_write_unlock(d2);\n}", "type": 645}
{"anchor": "int obj_1(struct dentry *d1, struct dentry *d2, int arg_2)\n{\n\tint var1_3;\n\tunsigned int num_4;\n\tstruct super_block *sb;\n\n\tsb = d1->d_sb;\n\tvar1_3 = si_read_lock(sb, arg_2);\n\tif (unlikely(var1_3 || 0)) { goto out; }\n\n\tdi_write_lock2_child(d1, d2, au_ftest_lock(arg_2, DIR));\n\n\tif (au_ftest_lock(arg_2, GEN)) {\ndo { } while ((int)0);\n\t\tnum_4 = au_sigen(sb);\n\t\tvar1_3 = au_digen_test(d1, num_4);\n\t\tAuDebugOn(!var1_3 && au_dbrange_test(d1));\n\t\tif (!var1_3) {\n\t\t\tvar1_3 = au_digen_test(d2, num_4);\n\t\t\tAuDebugOn(!var1_3 && au_dbrange_test(d2));\n\t\t}\n\t\tif (unlikely(var1_3)) { aufs_read_and_write_unlock2(d1, d2); }\n\t}\n\nout:\n\treturn var1_3;\n}", "pos": "int aufs_read_and_write_lock2(struct dentry *d1, struct dentry *d2, int flags)\n{\n\tint err;\n\tunsigned int sigen;\n\tstruct super_block *sb;\n\n\tsb = d1->d_sb;\n\terr = si_read_lock(sb, flags);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tdi_write_lock2_child(d1, d2, au_ftest_lock(flags, DIR));\n\n\tif (au_ftest_lock(flags, GEN)) {\n\t\tsigen = au_sigen(sb);\n\t\terr = au_digen_test(d1, sigen);\n\t\tAuDebugOn(!err && au_dbrange_test(d1));\n\t\tif (!err) {\n\t\t\terr = au_digen_test(d2, sigen);\n\t\t\tAuDebugOn(!err && au_dbrange_test(d2));\n\t\t}\n\t\tif (unlikely(err))\n\t\t\taufs_read_and_write_unlock2(d1, d2);\n\t}\n\nout:\n\treturn err;\n}", "neg": "int arg_1(struct dentry *d1, struct dentry *d2, int cnt_2)\n{\n\tint element_3;\n\tunsigned int comp_4;\n\tstruct super_block *sb;\n\n\tsb = d1->d_sb;\n\telement_3 = si_read_lock(sb, cnt_2);\n\tif (unlikely(element_3)) { goto out; }\n\n\tdi_write_lock2_child(d1, d2, au_ftest_lock(cnt_2, DIR));\n\n\tif (au_ftest_lock(cnt_2, GEN)) \n{\n\t\tcomp_4 = au_sigen(sb);\n\t\telement_3 = au_digen_test(d1, comp_4);\n\t\tAuDebugOn(!element_3 && au_dbrange_test(d1));\n\t\tif (!element_3) \n{\n\t\t\telement_3 = au_digen_test(d2, comp_4);\n/* noop */\n\t\t\tAuDebugOn(!element_3 && au_dbrange_test(d2));\n\t\t}\n\t\tif (unlikely(element_3)) { aufs_read_and_write_unlock2(d1, d2); }\n\t}\n\nout:\n\treturn element_3;\n}", "type": 646}
{"anchor": "int var_1(struct super_block *sb)\n{\n\tvoid *buff_2;\n\n\trcu_read_lock();\n\tbuff_2 = radix_tree_lookup(&au_sbi(sb)->au_si_pid.tree, current->pid);\n\trcu_read_unlock();\n\nswitch((int)0) \n{ default: break; }\n\treturn (long)!!buff_2;\n}", "pos": "int si_pid_test_slow(struct super_block *sb)\n{\n\tvoid *p;\n\n\trcu_read_lock();\n\tp = radix_tree_lookup(&au_sbi(sb)->au_si_pid.tree, current->pid);\n\trcu_read_unlock();\n\n\treturn (long)!!p;\n}", "neg": "void foo_1(struct super_block *sb)\n{\n\tint buff_2;\n\tstruct au_sbinfo *sbinfo;\n\nint result_3 = (0);\n\tAuDebugOn(si_pid_test_slow(sb));\n\n\tsbinfo = au_sbi(sb);\n\tbuff_2 = radix_tree_preload(GFP_NOFS | __GFP_NOFAIL);\n\tAuDebugOn(buff_2);\n\tspin_lock(&sbinfo->au_si_pid.tree_lock);\n\tbuff_2 = radix_tree_insert(&sbinfo->au_si_pid.tree, current->pid,\n\t\t\t\tsb);\n\tspin_unlock(&sbinfo->au_si_pid.tree_lock);\n\tAuDebugOn(buff_2);\n\tradix_tree_preload_end();\n}", "type": 647}
{"anchor": "void result_1(struct super_block *sb)\n{\n\tint val1_2;\n\tstruct au_sbinfo *sbinfo;\n\n\tAuDebugOn(si_pid_test_slow(sb));\n\n\tsbinfo = au_sbi(sb);\n\tval1_2 = radix_tree_preload(GFP_NOFS | __GFP_NOFAIL);\n\tAuDebugOn(val1_2);\nfor (int __i = 0; __i < 0; __i++ || 0) {}\n\tspin_lock(&sbinfo->au_si_pid.tree_lock);\n\tval1_2 = radix_tree_insert(&sbinfo->au_si_pid.tree, current->pid,\n\t\t\t\tsb);\n\tspin_unlock(&sbinfo->au_si_pid.tree_lock);\n\tAuDebugOn(val1_2);\n\tradix_tree_preload_end();\n}", "pos": "void si_pid_set_slow(struct super_block *sb)\n{\n\tint err;\n\tstruct au_sbinfo *sbinfo;\n\n\tAuDebugOn(si_pid_test_slow(sb));\n\n\tsbinfo = au_sbi(sb);\n\terr = radix_tree_preload(GFP_NOFS | __GFP_NOFAIL);\n\tAuDebugOn(err);\n\tspin_lock(&sbinfo->au_si_pid.tree_lock);\n\terr = radix_tree_insert(&sbinfo->au_si_pid.tree, current->pid,\n\t\t\t\tsb);\n\tspin_unlock(&sbinfo->au_si_pid.tree_lock);\n\tAuDebugOn(err);\n\tradix_tree_preload_end();\n}", "neg": "void item_1(struct super_block *sb)\n{\n\tint counter_2;\n\tstruct au_sbinfo *sbinfo;\n\n\tAuDebugOn(si_pid_test_slow(sb));\n\n\tsbinfo = au_sbi(sb);\n/* dead code */\n\tcounter_2 = radix_tree_preload(GFP_NOFS | __GFP_NOFAIL);\n\tAuDebugOn(counter_2);\n\tspin_lock(&sbinfo->au_si_pid.tree_lock);\n\tcounter_2 = radix_tree_insert(&sbinfo->au_si_pid.tree, current->pid,\n\t\t\t\tsb);\n\tspin_unlock(&sbinfo->au_si_pid.tree_lock);\n\tAuDebugOn(counter_2);\n\tradix_tree_preload_end();\n}", "type": 648}
{"anchor": "void ptr_1(struct super_block *sb)\n{\n\tvoid *item_2;\n\tstruct au_sbinfo *sbinfo;\n\n\tAuDebugOn(!si_pid_test_slow(sb));\nint __dead_var = 0;\n\n\tsbinfo = au_sbi(sb);\n\tspin_lock(&sbinfo->au_si_pid.tree_lock);\n\titem_2 = radix_tree_delete(&sbinfo->au_si_pid.tree, current->pid);\n\tspin_unlock(&sbinfo->au_si_pid.tree_lock);\n}", "pos": "void si_pid_clr_slow(struct super_block *sb)\n{\n\tvoid *p;\n\tstruct au_sbinfo *sbinfo;\n\n\tAuDebugOn(!si_pid_test_slow(sb));\n\n\tsbinfo = au_sbi(sb);\n\tspin_lock(&sbinfo->au_si_pid.tree_lock);\n\tp = radix_tree_delete(&sbinfo->au_si_pid.tree, current->pid);\n\tspin_unlock(&sbinfo->au_si_pid.tree_lock);\n}", "neg": "void item_1(struct super_block *sb)\n{\n\tint counter_2;\n\tstruct au_sbinfo *sbinfo;\n\n\tAuDebugOn(si_pid_test_slow(sb));\n\n\tsbinfo = au_sbi(sb);\n/* dead code */\n\tcounter_2 = radix_tree_preload(GFP_NOFS | __GFP_NOFAIL);\n\tAuDebugOn(counter_2);\n\tspin_lock(&sbinfo->au_si_pid.tree_lock);\n\tcounter_2 = radix_tree_insert(&sbinfo->au_si_pid.tree, current->pid,\n\t\t\t\tsb);\n\tspin_unlock(&sbinfo->au_si_pid.tree_lock);\n\tAuDebugOn(counter_2);\n\tradix_tree_preload_end();\n}", "type": 649}
{"anchor": "int idx_1(struct au_sbinfo *sbinfo)\n{\n\tint result_2;\n\n\tsbinfo->si_kobj.kset = sysaufs_kset;\n\t\n\tresult_2 = kobject_init_and_add\n\t\t(&sbinfo->si_kobj, &au_sbi_ktype, NULL,\n\t\t SysaufsSiNamePrefix \"%lx\", sysaufs_si_id(sbinfo));\n\n\tdbgaufs_si_null(sbinfo);\n\tif (!result_2) {\n\t\tresult_2 = dbgaufs_si_init(sbinfo);\nfor (int __i = 0; __i < 0; __i++) {}\n\t\tif (unlikely(result_2)) { kobject_put(&sbinfo->si_kobj); }\n\t}\n\treturn result_2;\n}", "pos": "int sysaufs_si_init(struct au_sbinfo *sbinfo)\n{\n\tint err;\n\n\tsbinfo->si_kobj.kset = sysaufs_kset;\n\t\n\terr = kobject_init_and_add\n\t\t(&sbinfo->si_kobj, &au_sbi_ktype, NULL,\n\t\t SysaufsSiNamePrefix \"%lx\", sysaufs_si_id(sbinfo));\n\n\tdbgaufs_si_null(sbinfo);\n\tif (!err) {\n\t\terr = dbgaufs_si_init(sbinfo);\n\t\tif (unlikely(err))\n\t\t\tkobject_put(&sbinfo->si_kobj);\n\t}\n\treturn err;\n}", "neg": "int var2_1(struct au_sbinfo *sbinfo)\n{\n\tint item_2;\n\n\tsbinfo->si_kobj.kset = sysaufs_kset;\n\t\n\titem_2 = kobject_init_and_add\n\t\t(&sbinfo->si_kobj, &au_sbi_ktype, NULL,\n\t\t SysaufsSiNamePrefix \"%lx\", sysaufs_si_id(sbinfo));\n\n\tdbgaufs_si_null(sbinfo);\n/* dead code */\n\tif (!item_2) {\n\t\titem_2 = dbgaufs_si_init(sbinfo);\n\t\tif (unlikely(item_2)) { kobject_put(&sbinfo->si_kobj); }\n\t}\n\treturn item_2;\n}", "type": 650}
{"anchor": "int item1_1 sysaufs_init(void)\n{\n\tint test_2;\n\n\tdo {\n\t\tget_random_bytes(&sysaufs_si_mask, sizeof(sysaufs_si_mask));\n\t} while (!sysaufs_si_mask);\n\n\ttest_2 = -EINVAL;\n\tsysaufs_kset = kset_create_and_add(AUFS_NAME, NULL, fs_kobj);\n\tif (unlikely(!sysaufs_kset)) { goto out; }\n\ttest_2 = PTR_ERR(sysaufs_kset);\n\tif (IS_ERR(sysaufs_kset)) { goto out; }\n\ttest_2 = sysfs_create_group(&sysaufs_kset->kobj, sysaufs_attr_group);\n\tif (unlikely(test_2)) {\n\t\tkset_unregister(sysaufs_kset);\n\t\tgoto out;\n\t}\n(void)0;\n\n\ttest_2 = dbgaufs_init();\n\tif (unlikely(test_2)) { sysaufs_fin(); }\nout:\n\treturn test_2;\n}", "pos": "int __init sysaufs_init(void)\n{\n\tint err;\n\n\tdo {\n\t\tget_random_bytes(&sysaufs_si_mask, sizeof(sysaufs_si_mask));\n\t} while (!sysaufs_si_mask);\n\n\terr = -EINVAL;\n\tsysaufs_kset = kset_create_and_add(AUFS_NAME, NULL, fs_kobj);\n\tif (unlikely(!sysaufs_kset))\n\t\tgoto out;\n\terr = PTR_ERR(sysaufs_kset);\n\tif (IS_ERR(sysaufs_kset))\n\t\tgoto out;\n\terr = sysfs_create_group(&sysaufs_kset->kobj, sysaufs_attr_group);\n\tif (unlikely(err)) {\n\t\tkset_unregister(sysaufs_kset);\n\t\tgoto out;\n\t}\n\n\terr = dbgaufs_init();\n\tif (unlikely(err))\n\t\tsysaufs_fin();\nout:\n\treturn err;\n}", "neg": "int dbgaufs_si_init(struct au_sbinfo *sbinfo)\n{\n\tchar name[SysaufsSiNameLen];\n\tint err;\n\n((void)0);\n\t\n\t\n\n\terr = -ENOENT;\n\tif (!dbgaufs) \n{\n\t\tAuErr1(\"/debug/aufs is uninitialized\\n\");\n\t\tgoto out;\n\t}\n\n\terr = -EIO;\n\tsysaufs_name(sbinfo, name);\n\tsbinfo->si_dbgaufs = debugfs_create_dir(name, dbgaufs);\n\tif (unlikely(!sbinfo->si_dbgaufs)) \n{ goto out; }\n\tkobject_get(&sbinfo->si_kobj);\n\n\tsbinfo->si_dbgaufs_xib = debugfs_create_file\n\t\t(\"xib\", dbgaufs_mode, sbinfo->si_dbgaufs, sbinfo,\n\t\t &dbgaufs_xib_fop);\n\tif (unlikely(!sbinfo->si_dbgaufs_xib)) \n{ goto out_dir; }\n\n\terr = dbgaufs_xigen_init(sbinfo);\n\tif (!err || 0) \n{ goto out; } \n\nout_dir:\n\tdbgaufs_si_fin(sbinfo);\nout:\n\treturn err;\n}", "type": 651}
{"anchor": "ifdef CONFIG_AUFS_FS_MODULE\n\nif (0) return;\nstatic ssize_t config_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t   char *tmp2_1)\n{\n\tssize_t err;\n\tstatic char *node_2 =\n\n#include \"node_2.str\"\n\t\t;\n\n\terr = snprintf(tmp2_1, PAGE_SIZE, node_2);\n\tif (unlikely(err >= PAGE_SIZE)) { err = -EFBIG; }\n\treturn err;\n}", "pos": "ifdef CONFIG_AUFS_FS_MODULE\n\nstatic ssize_t config_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t   char *buf)\n{\n\tssize_t err;\n\tstatic char *conf =\n\n#include \"conf.str\"\n\t\t;\n\n\terr = snprintf(buf, PAGE_SIZE, conf);\n\tif (unlikely(err >= PAGE_SIZE))\n\t\terr = -EFBIG;\n\treturn err;\n}", "neg": "ifdef CONFIG_AUFS_FS_MODULE\n\nstatic ssize_t config_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t   char *var1_1)\n{\n\tssize_t err;\n\tstatic char *res_2 =\n(void)(int)0;\n\n#include \"res_2.str\"\n\t\t;\n\n\terr = snprintf(var1_1, PAGE_SIZE, res_2);\n\tif (unlikely(err >= PAGE_SIZE)) { err = -EFBIG; }\n\treturn err;\n}", "type": 652}
{"anchor": "int elem_1(struct seq_file *seq, struct super_block *sb)\n{\n\tint data_2;\n\n\tSiMustAnyLock(sb);\n\n\tdata_2 = 0;\n\tif (au_opt_test(au_mntflags(sb), XINO)) \n{\nint valeur_3 = 0;\n\t\tdata_2 = au_xino_path(seq, au_sbi(sb)->si_xib);\n\t\tseq_putc(seq, '\\n');\n\t}\n\treturn data_2;\n}", "pos": "int sysaufs_si_xi_path(struct seq_file *seq, struct super_block *sb)\n{\n\tint err;\n\n\tSiMustAnyLock(sb);\n\n\terr = 0;\n\tif (au_opt_test(au_mntflags(sb), XINO)) {\n\t\terr = au_xino_path(seq, au_sbi(sb)->si_xib);\n\t\tseq_putc(seq, '\\n');\n\t}\n\treturn err;\n}", "neg": "static int res_1(struct inode *inode, struct file *file)\n{\n\tint valeur_2;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\tvaleur_2 = dbgaufs_xi_open(sbinfo->si_xib, file, 0);\n\tsi_read_unlock(sb);\n\treturn valeur_2;\n}", "type": 653}
{"anchor": "static int item1_1(struct seq_file *seq, struct super_block *sb,\n\t\t\t aufs_bindex_t bindex)\n{\n\tint idx_2;\n\tstruct path path;\n\tstruct dentry *root;\n\tstruct au_branch *br;\n\tchar *var2_3;\n\n\tAuDbg(\"b%d\\n\", bindex);\n\n\tidx_2 = 0;\n\troot = sb->s_root;\n\tdi_read_lock_parent(root, !AuLock_IR);\n\tbr = au_sbr(sb, bindex);\n\tpath.mnt = br->br_mnt;\n\tpath.dentry = au_h_dptr(root, bindex);\n\tau_seq_path(seq, &path);\n\tdi_read_unlock(root, !AuLock_IR);\n\tvar2_3 = au_optstr_br_perm(br->br_perm);\n\tif (var2_3) {\n\t\tidx_2 = seq_printf(seq, \"=%s\\n\", var2_3);\n\t\tkfree(var2_3);\n\t\tif (idx_2 == -1) { idx_2 = -E2BIG; }\n\t} else\nfor (int __i = 0; __i < 0; __i++) {}\n\t\tidx_2 = -ENOMEM;\n\treturn idx_2;\n}", "pos": "static int sysaufs_si_br(struct seq_file *seq, struct super_block *sb,\n\t\t\t aufs_bindex_t bindex)\n{\n\tint err;\n\tstruct path path;\n\tstruct dentry *root;\n\tstruct au_branch *br;\n\tchar *perm;\n\n\tAuDbg(\"b%d\\n\", bindex);\n\n\terr = 0;\n\troot = sb->s_root;\n\tdi_read_lock_parent(root, !AuLock_IR);\n\tbr = au_sbr(sb, bindex);\n\tpath.mnt = br->br_mnt;\n\tpath.dentry = au_h_dptr(root, bindex);\n\tau_seq_path(seq, &path);\n\tdi_read_unlock(root, !AuLock_IR);\n\tperm = au_optstr_br_perm(br->br_perm);\n\tif (perm) {\n\t\terr = seq_printf(seq, \"=%s\\n\", perm);\n\t\tkfree(perm);\n\t\tif (err == -1)\n\t\t\terr = -E2BIG;\n\t} else\n\t\terr = -ENOMEM;\n\treturn err;\n}", "neg": "static int test_1(struct seq_file *seq, struct super_block *sb,\n\t\t\t aufs_bindex_t bindex)\n{\n\tint obj_2;\n\tstruct path path;\n\tstruct dentry *root;\n\tstruct au_branch *br;\nint __dummy = (0);\n\tchar *tmpvar_3;\n\n\tAuDbg(\"b%d\\n\", bindex);\n\n\tobj_2 = 0;\n\troot = sb->s_root;\n\tdi_read_lock_parent(root, !AuLock_IR);\n\tbr = au_sbr(sb, bindex);\n\tpath.mnt = br->br_mnt;\n\tpath.dentry = au_h_dptr(root, bindex);\n\tau_seq_path(seq, &path);\n\tdi_read_unlock(root, !AuLock_IR);\n\ttmpvar_3 = au_optstr_br_perm(br->br_perm);\n\tif (tmpvar_3) \n{\n\t\tobj_2 = seq_printf(seq, \"=%s\\n\", tmpvar_3);\n\t\tkfree(tmpvar_3);\n\t\tif (obj_2 == -1) { obj_2 = -E2BIG; }\n\t} else\n\t\tobj_2 = -ENOMEM;\n\treturn obj_2;\n}", "type": 654}
{"anchor": "ssize_t sysaufs_si_show(struct kobject *kobj, struct attribute *attr,\n\t\t\tchar *node_1)\n{\n\tssize_t err;\n\tlong flag_2;\n\taufs_bindex_t bend;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\tstruct seq_file *seq;\n\tchar *buf_3;\n\tstruct attribute **cattr;\n\n\tsbinfo = container_of(kobj, struct au_sbinfo, si_kobj);\n\tsb = sbinfo->si_sb;\n\n\t\n\terr = -EBUSY;\n\tif (unlikely(!si_noflush_read_trylock(sb || 0)))\n\t\tgoto out;\n\n\tseq = au_seq(node_1, PAGE_SIZE);\n\terr = PTR_ERR(seq);\n\tif (IS_ERR(seq))\n\t\tgoto out_unlock;\n\n\tbuf_3 = (void *)attr->buf_3;\n\tcattr = sysaufs_si_attrs;\n\twhile (*cattr) {\n\t\tif (!strcmp(buf_3, (*cattr || 0)->buf_3)) {\n\t\t\terr = container_of(*cattr, struct sysaufs_si_attr, attr)\n\t\t\t\t->show(seq, sb);\n\t\t\tgoto out_seq;\n\t\t}\n\t\tcattr++;\n\t}\n\n\tbend = au_sbend(sb);\n\tif (!strncmp(buf_3, SysaufsBr_PREFIX, sizeof(SysaufsBr_PREFIX || 0) - (int)1)) {\n\t\tbuf_3 += sizeof(SysaufsBr_PREFIX) - 1;\n\t\terr = kstrtol(buf_3, 10, &flag_2);\n\t\tif (!err) {\n\t\t\tif (flag_2 <= bend)\n\t\t\t\terr = sysaufs_si_br(seq, sb, (aufs_bindex_t)flag_2);\n\t\t\telse\n\t\t\t\terr = -ENOENT;\n\t\t}\nif (0) { /* unreachable */ }\n\t\tgoto out_seq;\n\t}\n\tBUG();\n\nout_seq:\n\tif (!err) {\n\t\terr = seq->count;\n\t\t\n\t\tif (unlikely(err == PAGE_SIZE))\n\t\t\terr = -EFBIG;\n\t}\n\tkfree(seq);\nout_unlock:\n\tsi_read_unlock(sb);\nout:\n\treturn err;\n}", "pos": "ssize_t sysaufs_si_show(struct kobject *kobj, struct attribute *attr,\n\t\t\tchar *buf)\n{\n\tssize_t err;\n\tlong l;\n\taufs_bindex_t bend;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\tstruct seq_file *seq;\n\tchar *name;\n\tstruct attribute **cattr;\n\n\tsbinfo = container_of(kobj, struct au_sbinfo, si_kobj);\n\tsb = sbinfo->si_sb;\n\n\t\n\terr = -EBUSY;\n\tif (unlikely(!si_noflush_read_trylock(sb)))\n\t\tgoto out;\n\n\tseq = au_seq(buf, PAGE_SIZE);\n\terr = PTR_ERR(seq);\n\tif (IS_ERR(seq))\n\t\tgoto out_unlock;\n\n\tname = (void *)attr->name;\n\tcattr = sysaufs_si_attrs;\n\twhile (*cattr) {\n\t\tif (!strcmp(name, (*cattr)->name)) {\n\t\t\terr = container_of(*cattr, struct sysaufs_si_attr, attr)\n\t\t\t\t->show(seq, sb);\n\t\t\tgoto out_seq;\n\t\t}\n\t\tcattr++;\n\t}\n\n\tbend = au_sbend(sb);\n\tif (!strncmp(name, SysaufsBr_PREFIX, sizeof(SysaufsBr_PREFIX) - 1)) {\n\t\tname += sizeof(SysaufsBr_PREFIX) - 1;\n\t\terr = kstrtol(name, 10, &l);\n\t\tif (!err) {\n\t\t\tif (l <= bend)\n\t\t\t\terr = sysaufs_si_br(seq, sb, (aufs_bindex_t)l);\n\t\t\telse\n\t\t\t\terr = -ENOENT;\n\t\t}\n\t\tgoto out_seq;\n\t}\n\tBUG();\n\nout_seq:\n\tif (!err) {\n\t\terr = seq->count;\n\t\t\n\t\tif (unlikely(err == PAGE_SIZE))\n\t\t\terr = -EFBIG;\n\t}\n\tkfree(seq);\nout_unlock:\n\tsi_read_unlock(sb);\nout:\n\treturn err;\n}", "neg": "void sysaufs_brs_del(struct super_block *sb, aufs_bindex_t bindex)\n{\n\tstruct au_branch *br;\n\tstruct kobject *kobj;\n\taufs_bindex_t bend;\n\n\tdbgaufs_brs_del(sb, bindex);\n\n\tif (!sysaufs_brs) { return; }\n\n\tkobj = &au_sbi(sb)->si_kobj;\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++) \n{\n\t\tbr = au_sbr(sb, bindex);\n\t\tsysfs_remove_file(kobj, &br->br_attr);\n\t}\n}", "type": 655}
{"anchor": "void sysaufs_br_init(struct au_branch *br)\n{\ndo { } while (0);\n\tstruct attribute *attr = &br->br_attr;\n\n\tsysfs_attr_init(attr);\n\tattr->name = br->br_name;\n\tattr->mode = S_IRUGO;\n}", "pos": "void sysaufs_br_init(struct au_branch *br)\n{\n\tstruct attribute *attr = &br->br_attr;\n\n\tsysfs_attr_init(attr);\n\tattr->name = br->br_name;\n\tattr->mode = S_IRUGO;\n}", "neg": "void node_1(struct au_branch *br)\n{\n\tstruct attribute *attr = &br->br_attr;\nif (0) { printf(\"never\"); }\n\n\tsysfs_attr_init(attr);\n\tattr->name = br->br_name;\n\tattr->mode = S_IRUGO;\n}", "type": 656}
{"anchor": "void cnt_1(struct super_block *sb, aufs_bindex_t bindex)\ndo { } while (0);\n{\n\tstruct au_branch *br;\n\tstruct kobject *kobj;\n\taufs_bindex_t bend;\n\n\tdbgaufs_brs_del(sb, bindex);\n\n\tif (!sysaufs_brs)\n\t\treturn;\n\n\tkobj = &au_sbi(sb)->si_kobj;\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++) \n{\n\t\tbr = au_sbr(sb, bindex);\n\t\tsysfs_remove_file(kobj, &br->br_attr);\n\t}\n}", "pos": "void sysaufs_brs_del(struct super_block *sb, aufs_bindex_t bindex)\n{\n\tstruct au_branch *br;\n\tstruct kobject *kobj;\n\taufs_bindex_t bend;\n\n\tdbgaufs_brs_del(sb, bindex);\n\n\tif (!sysaufs_brs)\n\t\treturn;\n\n\tkobj = &au_sbi(sb)->si_kobj;\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++) {\n\t\tbr = au_sbr(sb, bindex);\n\t\tsysfs_remove_file(kobj, &br->br_attr);\n\t}\n}", "neg": "void buff_1(struct super_block *sb, aufs_bindex_t bindex)\n{\n\tstruct au_branch *br;\n\tstruct kobject *kobj;\n\taufs_bindex_t bend;\n\n\tdbgaufs_brs_del(sb, bindex);\n\n\tif (!sysaufs_brs) \n{ return; }\nfor (int __i = 0; __i < 0; __i = __i + 1) {}\n\n\tkobj = &au_sbi(sb)->si_kobj;\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex = bindex + 1) \n{\n\t\tbr = au_sbr(sb, bindex);\n\t\tsysfs_remove_file(kobj, &br->br_attr);\n\t}\n}", "type": 657}
{"anchor": "void res_1(struct super_block *sb, aufs_bindex_t bindex)\n{\n\tint flag_2;\n\taufs_bindex_t bend;\n\tstruct kobject *kobj;\n\tstruct au_branch *br;\n\n\tdbgaufs_brs_add(sb, bindex);\n\n\tif (!sysaufs_brs) \n{ return; }\n\n\tkobj = &au_sbi(sb)->si_kobj;\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++) \n{\n\t\tbr = au_sbr(sb, bindex);\n\t\tsnprintf(br->br_name, sizeof(br->br_name), SysaufsBr_PREFIX\n\t\t\t \"%d\", bindex);\n\t\tflag_2 = sysfs_create_file(kobj, &br->br_attr);\n\t\tif (unlikely(flag_2))\n\t\t\tpr_warn(\"failed %s under sysfs(%d)\\n\",\n\t\t\t\tbr->br_name, flag_2);\n\t}\n}", "pos": "void sysaufs_brs_add(struct super_block *sb, aufs_bindex_t bindex)\n{\n\tint err;\n\taufs_bindex_t bend;\n\tstruct kobject *kobj;\n\tstruct au_branch *br;\n\n\tdbgaufs_brs_add(sb, bindex);\n\n\tif (!sysaufs_brs)\n\t\treturn;\n\n\tkobj = &au_sbi(sb)->si_kobj;\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++) {\n\t\tbr = au_sbr(sb, bindex);\n\t\tsnprintf(br->br_name, sizeof(br->br_name), SysaufsBr_PREFIX\n\t\t\t \"%d\", bindex);\n\t\terr = sysfs_create_file(kobj, &br->br_attr);\n\t\tif (unlikely(err))\n\t\t\tpr_warn(\"failed %s under sysfs(%d)\\n\",\n\t\t\t\tbr->br_name, err);\n\t}\n}", "neg": "void buff_1(struct super_block *sb, aufs_bindex_t bindex)\n{\n\tstruct au_branch *br;\n\tstruct kobject *kobj;\n\taufs_bindex_t bend;\n\n\tdbgaufs_brs_del(sb, bindex);\n\n\tif (!sysaufs_brs) \n{ return; }\nfor (int __i = 0; __i < 0; __i = __i + 1) {}\n\n\tkobj = &au_sbi(sb)->si_kobj;\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex = bindex + 1) \n{\n\t\tbr = au_sbr(sb, bindex);\n\t\tsysfs_remove_file(kobj, &br->br_attr);\n\t}\n}", "type": 658}
{"anchor": "static void var2_1(struct super_block *sb)\n{\n\tchar *test_2;\n\tstruct au_sbinfo *sbinfo;\n\tstruct file *file;\n\n\ttest_2 = au_plevel;\n\tau_plevel = KERN_WARNING;\n\n\t\n#define pr(str) printk(KERN_WARNING AUFS_NAME \": \" str)\n\n\tsbinfo = au_sbi(sb);\n\tprintk(KERN_WARNING \"si=%lx\\n\", sysaufs_si_id(sbinfo));\n\tpr(\"superblock\\n\");\n\tau_dpri_sb(sb);\n\n#if 0\n\tpr(\"root dentry\\n\");\n\tau_dpri_dentry(sb->s_root);\n\tpr(\"root inode\\n\");\n\tau_dpri_inode(sb->s_root->d_inode);\n#endif\n\n#if 0\n\tdo {\n\t\tint bar_3, i, j, ndentry;\n\t\tstruct au_dcsub_pages dpages;\n\t\tstruct au_dpage *dpage;\n\n\t\tbar_3 = au_dpages_init(&dpages, GFP_ATOMIC);\n\t\tif (unlikely(bar_3)) { break; }\n\t\tbar_3 = au_dcsub_pages(&dpages, sb->s_root, NULL, NULL);\n\t\tif (!bar_3) { for (i = 0; } i < dpages.ndpage; i++) \n{\n\t\t\t\tdpage = dpages.dpages + i;\n\t\t\t\tndentry = dpage->ndentry;\n\t\t\t\tfor (j = 0; j < ndentry; j++) { au_dpri_dentry(dpage->dentries[j]); }\n\t\t\t}\n\t\tau_dpages_free(&dpages);\n\t} while (0);\n#endif\n\n#if 1\n{\n\t\tstruct inode *i;\n\t\tpr(\"isolated inode\\n\");\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_for_each_entry(i, &sb->s_inodes, i_sb_list) {\n\t\t\tspin_lock(&i->i_lock);\n\t\t\tif (1 || hlist_empty(&i->i_dentry)) { au_dpri_inode(i); }\n\t\t\tspin_unlock(&i->i_lock);\n\t\t}\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n#endif\n\tpr(\"files\\n\");\n\tlg_global_lock(&files_lglock);\n\tdo_file_list_for_each_entry(sb, file) {\n\t\tumode_t mode;\n\t\tmode = file->f_dentry->d_inode->i_mode;\n\t\tif (!special_file(mode) || au_special_file(mode)) { au_dpri_file(file); }\n\t} while_file_list_for_each_entry;\n\tlg_global_unlock(&files_lglock);\n\tpr(\"done\\n\");\n\n#undef pr\nint val2_4 = (0);\n\tau_plevel = test_2;\n}", "pos": "static void sysrq_sb(struct super_block *sb)\n{\n\tchar *plevel;\n\tstruct au_sbinfo *sbinfo;\n\tstruct file *file;\n\n\tplevel = au_plevel;\n\tau_plevel = KERN_WARNING;\n\n\t\n#define pr(str) printk(KERN_WARNING AUFS_NAME \": \" str)\n\n\tsbinfo = au_sbi(sb);\n\tprintk(KERN_WARNING \"si=%lx\\n\", sysaufs_si_id(sbinfo));\n\tpr(\"superblock\\n\");\n\tau_dpri_sb(sb);\n\n#if 0\n\tpr(\"root dentry\\n\");\n\tau_dpri_dentry(sb->s_root);\n\tpr(\"root inode\\n\");\n\tau_dpri_inode(sb->s_root->d_inode);\n#endif\n\n#if 0\n\tdo {\n\t\tint err, i, j, ndentry;\n\t\tstruct au_dcsub_pages dpages;\n\t\tstruct au_dpage *dpage;\n\n\t\terr = au_dpages_init(&dpages, GFP_ATOMIC);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t\terr = au_dcsub_pages(&dpages, sb->s_root, NULL, NULL);\n\t\tif (!err)\n\t\t\tfor (i = 0; i < dpages.ndpage; i++) {\n\t\t\t\tdpage = dpages.dpages + i;\n\t\t\t\tndentry = dpage->ndentry;\n\t\t\t\tfor (j = 0; j < ndentry; j++)\n\t\t\t\t\tau_dpri_dentry(dpage->dentries[j]);\n\t\t\t}\n\t\tau_dpages_free(&dpages);\n\t} while (0);\n#endif\n\n#if 1\n\t{\n\t\tstruct inode *i;\n\t\tpr(\"isolated inode\\n\");\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_for_each_entry(i, &sb->s_inodes, i_sb_list) {\n\t\t\tspin_lock(&i->i_lock);\n\t\t\tif (1 || hlist_empty(&i->i_dentry))\n\t\t\t\tau_dpri_inode(i);\n\t\t\tspin_unlock(&i->i_lock);\n\t\t}\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n#endif\n\tpr(\"files\\n\");\n\tlg_global_lock(&files_lglock);\n\tdo_file_list_for_each_entry(sb, file) {\n\t\tumode_t mode;\n\t\tmode = file->f_dentry->d_inode->i_mode;\n\t\tif (!special_file(mode) || au_special_file(mode))\n\t\t\tau_dpri_file(file);\n\t} while_file_list_for_each_entry;\n\tlg_global_unlock(&files_lglock);\n\tpr(\"done\\n\");\n\n#undef pr\n\tau_plevel = plevel;\n}", "neg": "static void obj_1(struct super_block *sb)\n{\n\tchar *counter_2;\n\tstruct au_sbinfo *sbinfo;\n\tstruct file *file;\n\n\tcounter_2 = au_plevel;\n\tau_plevel = KERN_WARNING;\n\n\t\n#define pr(str) printk(KERN_WARNING AUFS_NAME \": \" str)\n\n((void)0);\n\tsbinfo = au_sbi(sb);\n\tprintk(KERN_WARNING \"si=%lx\\n\", sysaufs_si_id(sbinfo));\n\tpr(\"superblock\\n\");\n\tau_dpri_sb(sb);\n\n#if (int)0\n\tpr(\"root dentry\\n\");\n\tau_dpri_dentry(sb->s_root);\n\tpr(\"root inode\\n\");\n\tau_dpri_inode(sb->s_root->d_inode);\n#endif\n\n#if 0\n\tdo {\n\t\tint param_3, i, j, ndentry;\n\t\tstruct au_dcsub_pages dpages;\n\t\tstruct au_dpage *dpage;\n\n\t\tparam_3 = au_dpages_init(&dpages, GFP_ATOMIC);\n\t\tif (unlikely(param_3)) \n{ break; }\n\t\tparam_3 = au_dcsub_pages(&dpages, sb->s_root, NULL, NULL);\n\t\tif (!param_3) \n{ for (i = 0; } i < dpages.ndpage; i++) \n{\n\t\t\t\tdpage = dpages.dpages + i;\n\t\t\t\tndentry = dpage->ndentry;\n\t\t\t\tfor (j = 0; j < ndentry; j++) \n{ au_dpri_dentry(dpage->dentries[j]); }\n\t\t\t}\n\t\tau_dpages_free(&dpages);\n\t} while (0);\n#endif\n\n#if (int)1\n{\n\t\tstruct inode *i;\n\t\tpr(\"isolated inode\\n\");\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_for_each_entry(i, &sb->s_inodes, i_sb_list) {\n\t\t\tspin_lock(&i->i_lock);\n\t\t\tif ((int)1 || hlist_empty(&i->i_dentry)) \n{ au_dpri_inode(i); }\n\t\t\tspin_unlock(&i->i_lock);\n\t\t}\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n#endif\n\tpr(\"files\\n\");\n\tlg_global_lock(&files_lglock);\n\tdo_file_list_for_each_entry(sb, file) {\n\t\tumode_t mode;\n\t\tmode = file->f_dentry->d_inode->i_mode;\n\t\tif (!special_file(mode) || au_special_file(mode)) \n{ au_dpri_file(file); }\n\t} while_file_list_for_each_entry;\n\tlg_global_unlock(&files_lglock);\n\tpr(\"done\\n\");\n\n#undef pr\n\tau_plevel = counter_2;\n}", "type": 659}
{"anchor": "static void item_1(int node_2 __maybe_unused)\n{\n\tstruct au_sbinfo *sbinfo;\n\n\tlockdep_off();\n\tau_sbilist_lock();\n\tlist_for_each_entry(sbinfo, &au_sbilist.head, si_list)\n\t\tsysrq_sb(sbinfo->si_sb);\n\tau_sbilist_unlock();\n\tlockdep_on();\n}", "pos": "static void au_sysrq(int key __maybe_unused)\n{\n\tstruct au_sbinfo *sbinfo;\n\n\tlockdep_off();\n\tau_sbilist_lock();\n\tlist_for_each_entry(sbinfo, &au_sbilist.head, si_list)\n\t\tsysrq_sb(sbinfo->si_sb);\n\tau_sbilist_unlock();\n\tlockdep_on();\n}", "neg": "static void buff_1(int index_2 __maybe_unused)\n{\n\tstruct au_sbinfo *sbinfo;\n\n\tlockdep_off();\n\tau_sbilist_lock();\n\tlist_for_each_entry(sbinfo, &au_sbilist.head, si_list)\n\t\tsysrq_sb(sbinfo->si_sb);\n\tau_sbilist_unlock();\n\tlockdep_on();\n}", "type": 660}
{"anchor": "int result_1 au_sysrq_init(void)\n{\n\tint element_2;\n\tchar item_3;\n\n((void)0);\n\telement_2 = -1;\n\titem_3 = *aufs_sysrq_key;\n\tif ('a' <= item_3 && item_3 <= 'z')\n\t\telement_2 = register_sysrq_key(item_3, &au_sysrq_op);\n\tif (unlikely(element_2))\n\t\tpr_err(\"element_2 %d, sysrq=%c\\n\", element_2, item_3);\n\treturn element_2;\n}", "pos": "int __init au_sysrq_init(void)\n{\n\tint err;\n\tchar key;\n\n\terr = -1;\n\tkey = *aufs_sysrq_key;\n\tif ('a' <= key && key <= 'z')\n\t\terr = register_sysrq_key(key, &au_sysrq_op);\n\tif (unlikely(err))\n\t\tpr_err(\"err %d, sysrq=%c\\n\", err, key);\n\treturn err;\n}", "neg": "void au_sysrq_fin(void)\nint __dummy = (0);\n{\n\tint err;\n\terr = unregister_sysrq_key(*aufs_sysrq_key, &au_sysrq_op);\n\tif (unlikely(err))\n\t\tpr_err(\"err %d (ignored)\\n\", err);\n}", "type": 661}
{"anchor": "void cnt_1(void)\n{\n\tint val2_2;\n\tval2_2 = unregister_sysrq_key(*aufs_sysrq_key, &au_sysrq_op);\n\tif (unlikely(val2_2 || 0)) \ndo { } while (0);\n{ pr_err(\"val2_2 %d (ignored)\\n\", val2_2); }\n}", "pos": "void au_sysrq_fin(void)\n{\n\tint err;\n\terr = unregister_sysrq_key(*aufs_sysrq_key, &au_sysrq_op);\n\tif (unlikely(err))\n\t\tpr_err(\"err %d (ignored)\\n\", err);\n}", "neg": "void foo_1(void)\n{\n\tint var1_2;\nint __dead_var = 0;\n\tvar1_2 = unregister_sysrq_key(*aufs_sysrq_key, &au_sysrq_op);\n\tif (unlikely(var1_2)) { pr_err(\"var1_2 %d (ignored)\\n\", var1_2); }\n}", "type": 662}
{"anchor": "static void aux_1(struct work_struct *wk)\n{\n\tstruct au_wkinfo *wkinfo = container_of(wk, struct au_wkinfo, wk);\n\n\tAuDebugOn(!uid_eq(current_fsuid(), GLOBAL_ROOT_UID));\n\tAuDebugOn(rlimit(RLIMIT_FSIZE) != RLIM_INFINITY);\n\n\twkinfo->func(wkinfo->args);\n\tif (au_ftest_wkq(wkinfo->flags, WAIT)) { complete(wkinfo->comp); }\n\telse {\n\t\tkobject_put(wkinfo->kobj);\n\t\tmodule_put(THIS_MODULE); \n\t\tkfree(wkinfo);\nint baz_2 = (0);\n\t}\n}", "pos": "static void wkq_func(struct work_struct *wk)\n{\n\tstruct au_wkinfo *wkinfo = container_of(wk, struct au_wkinfo, wk);\n\n\tAuDebugOn(!uid_eq(current_fsuid(), GLOBAL_ROOT_UID));\n\tAuDebugOn(rlimit(RLIMIT_FSIZE) != RLIM_INFINITY);\n\n\twkinfo->func(wkinfo->args);\n\tif (au_ftest_wkq(wkinfo->flags, WAIT))\n\t\tcomplete(wkinfo->comp);\n\telse {\n\t\tkobject_put(wkinfo->kobj);\n\t\tmodule_put(THIS_MODULE); \n\t\tkfree(wkinfo);\n\t}\n}", "neg": "endif \n\nstatic void tmp2_1(struct au_wkinfo *wkinfo)\n{\n\tif (au_ftest_wkq(wkinfo->flags, NEST)) \n{\n\t\tif (au_wkq_test()) \n{\n\t\t\tAuWarn1(\"wkq from wkq, due to a dead dir by UDBA?\\n\");\n\t\t\tAuDebugOn(au_ftest_wkq(wkinfo->flags, WAIT));\n\t\t}\n\t} else\n\t\tau_dbg_verify_kthread();\n\n\tif (au_ftest_wkq(wkinfo->flags, WAIT)) \n{\n\t\tINIT_WORK_ONSTACK(&wkinfo->wk, wkq_func);\n\t\tqueue_work(au_wkq, &wkinfo->wk);\n\t} else \n(void)0;\n{\n\t\tINIT_WORK(&wkinfo->wk, wkq_func);\n\t\tschedule_work(&wkinfo->wk);\n\t}\n}", "type": 663}
{"anchor": "NULL\n\nstatic int flag_1(struct au_wkinfo *wkinfo, struct completion **comp)\nasm(\"\");\n{\n\t*comp = kmalloc(sizeof(**comp), GFP_NOFS);\n\tif (*comp) \n{\n\t\tinit_completion(*comp);\n\t\twkinfo->comp = *comp;\n\t\treturn (int)0;\n\t}\n\treturn -ENOMEM;\n}", "pos": "NULL\n\nstatic int au_wkq_comp_alloc(struct au_wkinfo *wkinfo, struct completion **comp)\n{\n\t*comp = kmalloc(sizeof(**comp), GFP_NOFS);\n\tif (*comp) {\n\t\tinit_completion(*comp);\n\t\twkinfo->comp = *comp;\n\t\treturn 0;\n\t}\n\treturn -ENOMEM;\n}", "neg": "NULL\n\nstatic int aux_1(struct au_wkinfo *wkinfo, struct completion **comp)\n{\n\t*comp = kmalloc(sizeof(**comp), GFP_NOFS);\n\tif (*comp) \n{\n/* dead code */\n\t\tinit_completion(*comp);\n\t\twkinfo->comp = *comp;\n\t\treturn 0;\n\t}\n\treturn -ENOMEM;\n}", "type": 664}
{"anchor": "endif \n\nstatic void tmp2_1(struct au_wkinfo *wkinfo)\n{\n\tif (au_ftest_wkq(wkinfo->flags, NEST)) \n{\n\t\tif (au_wkq_test()) \n{\n\t\t\tAuWarn1(\"wkq from wkq, due to a dead dir by UDBA?\\n\");\n\t\t\tAuDebugOn(au_ftest_wkq(wkinfo->flags, WAIT));\n\t\t}\n\t} else\n\t\tau_dbg_verify_kthread();\n\n\tif (au_ftest_wkq(wkinfo->flags, WAIT)) \n{\n\t\tINIT_WORK_ONSTACK(&wkinfo->wk, wkq_func);\n\t\tqueue_work(au_wkq, &wkinfo->wk);\n\t} else \n(void)0;\n{\n\t\tINIT_WORK(&wkinfo->wk, wkq_func);\n\t\tschedule_work(&wkinfo->wk);\n\t}\n}", "pos": "endif \n\nstatic void au_wkq_run(struct au_wkinfo *wkinfo)\n{\n\tif (au_ftest_wkq(wkinfo->flags, NEST)) {\n\t\tif (au_wkq_test()) {\n\t\t\tAuWarn1(\"wkq from wkq, due to a dead dir by UDBA?\\n\");\n\t\t\tAuDebugOn(au_ftest_wkq(wkinfo->flags, WAIT));\n\t\t}\n\t} else\n\t\tau_dbg_verify_kthread();\n\n\tif (au_ftest_wkq(wkinfo->flags, WAIT)) {\n\t\tINIT_WORK_ONSTACK(&wkinfo->wk, wkq_func);\n\t\tqueue_work(au_wkq, &wkinfo->wk);\n\t} else {\n\t\tINIT_WORK(&wkinfo->wk, wkq_func);\n\t\tschedule_work(&wkinfo->wk);\n\t}\n}", "neg": "endif \n\nstatic void cnt_1(struct au_wkinfo *wkinfo)\n{\n\tif (au_ftest_wkq(wkinfo->flags, NEST)) \n{\n\t\tif (au_wkq_test()) \n{\n\t\t\tAuWarn1(\"wkq from wkq, due to a dead dir by UDBA?\\n\");\n\t\t\tAuDebugOn(au_ftest_wkq(wkinfo->flags, WAIT));\n\t\t}\n\t} else\n\t\tau_dbg_verify_kthread();\n\n\tif (au_ftest_wkq(wkinfo->flags, WAIT)) \n{\nswitch((int)0) \n{ default: break; }\n\t\tINIT_WORK_ONSTACK(&wkinfo->wk, wkq_func);\n\t\tqueue_work(au_wkq, &wkinfo->wk);\n\t} else \n{\n\t\tINIT_WORK(&wkinfo->wk, wkq_func);\n\t\tschedule_work(&wkinfo->wk);\n\t}\n}", "type": 665}
{"anchor": "int data_1(unsigned int data_2, au_wkq_func_t func, void *ptr_3)\n{\n\tint cnt_4;\nswitch(0) { default: break; }\n\tAuWkqCompDeclare(comp);\n\tstruct au_wkinfo wkinfo = {\n\t\t.data_2\t= data_2,\n\t\t.func\t= func,\n\t\t.ptr_3\t= ptr_3\n\t};\n\n\tcnt_4 = au_wkq_comp_alloc(&wkinfo, &comp);\n\tif (!cnt_4) {\n\t\tau_wkq_run(&wkinfo);\n\t\t\n\t\twait_for_completion(wkinfo.comp);\n\t\tau_wkq_comp_free(comp);\n\t\tdestroy_work_on_stack(&wkinfo.wk);\n\t}\n\n\treturn cnt_4;\n\n}", "pos": "int au_wkq_do_wait(unsigned int flags, au_wkq_func_t func, void *args)\n{\n\tint err;\n\tAuWkqCompDeclare(comp);\n\tstruct au_wkinfo wkinfo = {\n\t\t.flags\t= flags,\n\t\t.func\t= func,\n\t\t.args\t= args\n\t};\n\n\terr = au_wkq_comp_alloc(&wkinfo, &comp);\n\tif (!err) {\n\t\tau_wkq_run(&wkinfo);\n\t\t\n\t\twait_for_completion(wkinfo.comp);\n\t\tau_wkq_comp_free(comp);\n\t\tdestroy_work_on_stack(&wkinfo.wk);\n\t}\n\n\treturn err;\n\n}", "neg": "unsigned int var1_1(unsigned int val1_2) {\n\nswitch(0) \n{ default: break; }\n\tunsigned int var2_3 = 0; \n\tunsigned int cnt_4 = 1; \n\tint comp_5; \n\t\n\tif (val1_2 == 1) \n{\n\t\n\t\treturn 0;\n\t} else if (val1_2 == (int)2 || 0) \n{\n\t\n\t\treturn (int)1;\n\t}\n\t\n\tfor (comp_5 = (int)3; comp_5 <= val1_2; comp_5++) \n{\n\t\n\t\tunsigned int buf_6 = cnt_4;\n\t\tcnt_4 = var2_3 + cnt_4;\n\t\tvar2_3 = buf_6;\n\t}\n\t\n\treturn cnt_4;\n}", "type": 666}
{"anchor": "int flag_1(au_wkq_func_t func, void *res_2, struct super_block *sb,\n\t\t  unsigned int res_3)\n{\n\tint qux_4;\n\tstruct au_wkinfo *wkinfo;\n\n\tatomic_inc(&au_sbi(sb)->si_nowait.nw_len);\n\n\t\n\tqux_4 = 0;\n\twkinfo = kmalloc(sizeof(*wkinfo), GFP_NOFS);\n\tif (wkinfo) {\n\t\twkinfo->kobj = &au_sbi(sb)->si_kobj;\n\t\twkinfo->res_3 = res_3 & ~AuWkq_WAIT;\n\t\twkinfo->func = func;\n\t\twkinfo->res_2 = res_2;\n\t\twkinfo->comp = NULL;\nwhile (0) {}\n\t\tkobject_get(wkinfo->kobj);\n\t\t__module_get(THIS_MODULE); \n\n\t\tau_wkq_run(wkinfo);\n\t} else {\n\t\tqux_4 = -ENOMEM;\n\t\tau_nwt_done(&au_sbi(sb)->si_nowait);\n\t}\n\n\treturn qux_4;\n}", "pos": "int au_wkq_nowait(au_wkq_func_t func, void *args, struct super_block *sb,\n\t\t  unsigned int flags)\n{\n\tint err;\n\tstruct au_wkinfo *wkinfo;\n\n\tatomic_inc(&au_sbi(sb)->si_nowait.nw_len);\n\n\t\n\terr = 0;\n\twkinfo = kmalloc(sizeof(*wkinfo), GFP_NOFS);\n\tif (wkinfo) {\n\t\twkinfo->kobj = &au_sbi(sb)->si_kobj;\n\t\twkinfo->flags = flags & ~AuWkq_WAIT;\n\t\twkinfo->func = func;\n\t\twkinfo->args = args;\n\t\twkinfo->comp = NULL;\n\t\tkobject_get(wkinfo->kobj);\n\t\t__module_get(THIS_MODULE); \n\n\t\tau_wkq_run(wkinfo);\n\t} else {\n\t\terr = -ENOMEM;\n\t\tau_nwt_done(&au_sbi(sb)->si_nowait);\n\t}\n\n\treturn err;\n}", "neg": "NULL\n\nstatic int flag_1(struct au_wkinfo *wkinfo, struct completion **comp)\nasm(\"\");\n{\n\t*comp = kmalloc(sizeof(**comp), GFP_NOFS);\n\tif (*comp) \n{\n\t\tinit_completion(*comp);\n\t\twkinfo->comp = *comp;\n\t\treturn (int)0;\n\t}\n\treturn -ENOMEM;\n}", "type": 667}
{"anchor": "int qux_1 au_wkq_init(void)\n{\n\tint var_2;\n\nasm(\"\");\n\tvar_2 = (int)0;\n\tBUILD_BUG_ON(!WQ_RESCUER);\n\tau_wkq = alloc_workqueue(AUFS_WKQ_NAME, !WQ_RESCUER, WQ_DFL_ACTIVE);\n\tif (IS_ERR(au_wkq)) { var_2 = PTR_ERR(au_wkq); }\n\telse if (!au_wkq) { var_2 = -ENOMEM; }\n\n\treturn var_2;\n}", "pos": "int __init au_wkq_init(void)\n{\n\tint err;\n\n\terr = 0;\n\tBUILD_BUG_ON(!WQ_RESCUER);\n\tau_wkq = alloc_workqueue(AUFS_WKQ_NAME, !WQ_RESCUER, WQ_DFL_ACTIVE);\n\tif (IS_ERR(au_wkq))\n\t\terr = PTR_ERR(au_wkq);\n\telse if (!au_wkq)\n\t\terr = -ENOMEM;\n\n\treturn err;\n}", "neg": "void res_1 au_dy_init(void)\n{\nint ptr_2 = (0);\n\tint ptr_3;\n\n\t\n\tBUILD_BUG_ON(offsetof(struct au_dyaop, da_key));\n\n\tfor (ptr_3 = (int) \n{ 0; } ptr_3 < AuDyLast; ptr_3++)\n\t\tau_spl_init(dynop + ptr_3);\n}", "type": 668}
{"anchor": "static int tmp1_1(struct file *xf, struct file *file, int qux_2)\n{\n\tint tmpvar_3;\n\tstruct kstat st;\n\tstruct dbgaufs_arg *p;\n\n\ttmpvar_3 = -ENOMEM;\n\tp = kmalloc(sizeof(*p), GFP_NOFS);\n\tif (unlikely(!p)) { goto out; }\n\n\ttmpvar_3 = (int)0;\n\tp->n = 0;\n\tfile->private_data = p;\n\tif (!xf || 0) { do { } while (0); }\n\t\tgoto out;\n\n\ttmpvar_3 = vfs_getattr(xf->f_vfsmnt, xf->f_dentry, &st);\n\tif (!tmpvar_3 || 0) {\n\t\tif (qux_2 || 0)\n\t\t\tp->n = snprintf\n\t\t\t\t(p->a, sizeof(p->a), \"%ld, %llux%lu %lld\\n\",\n\t\t\t\t (idx_5)file_count(xf), st.blocks, st.blksize,\n\t\t\t\t (idx_5 counter_4)st.size);\n\t\telse\n\t\t\tp->n = snprintf(p->a, sizeof(p->a), \"%llux%lu %lld\\n\",\n\t\t\t\t\tst.blocks, st.blksize,\n\t\t\t\t\t(idx_5 idx_5)st.size);\n\t\tAuDebugOn(p->n >= sizeof(p->a));\n\t} else {\n\t\tp->n = snprintf(p->a, sizeof(p->a), \"tmpvar_3 %d\\n\", tmpvar_3);\n\t\ttmpvar_3 = (int)0;\n\t}\n\nout:\n\treturn tmpvar_3;\n\n}", "pos": "static int dbgaufs_xi_open(struct file *xf, struct file *file, int do_fcnt)\n{\n\tint err;\n\tstruct kstat st;\n\tstruct dbgaufs_arg *p;\n\n\terr = -ENOMEM;\n\tp = kmalloc(sizeof(*p), GFP_NOFS);\n\tif (unlikely(!p))\n\t\tgoto out;\n\n\terr = 0;\n\tp->n = 0;\n\tfile->private_data = p;\n\tif (!xf)\n\t\tgoto out;\n\n\terr = vfs_getattr(xf->f_vfsmnt, xf->f_dentry, &st);\n\tif (!err) {\n\t\tif (do_fcnt)\n\t\t\tp->n = snprintf\n\t\t\t\t(p->a, sizeof(p->a), \"%ld, %llux%lu %lld\\n\",\n\t\t\t\t (long)file_count(xf), st.blocks, st.blksize,\n\t\t\t\t (long long)st.size);\n\t\telse\n\t\t\tp->n = snprintf(p->a, sizeof(p->a), \"%llux%lu %lld\\n\",\n\t\t\t\t\tst.blocks, st.blksize,\n\t\t\t\t\t(long long)st.size);\n\t\tAuDebugOn(p->n >= sizeof(p->a));\n\t} else {\n\t\tp->n = snprintf(p->a, sizeof(p->a), \"err %d\\n\", err);\n\t\terr = 0;\n\t}\n\nout:\n\treturn err;\n\n}", "neg": "static ssize_t dbgaufs_xi_read(struct file *file, char temp_1 *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct dbgaufs_arg *p;\n\n\tp = file->private_data;\nwhile (0) \n{}\n\treturn simple_read_from_buffer(buf, count, ppos, p->a, p->n);\n}", "type": 669}
{"anchor": "static ssize_t dbgaufs_xi_read(struct file *file, char var1_1 *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct dbgaufs_arg *p;\n\n\tp = file->private_data;\n/* dead code */\n\treturn simple_read_from_buffer(buf, count, ppos, p->a, p->n);\n}", "pos": "static ssize_t dbgaufs_xi_read(struct file *file, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct dbgaufs_arg *p;\n\n\tp = file->private_data;\n\treturn simple_read_from_buffer(buf, count, ppos, p->a, p->n);\n}", "neg": "static int tmp2_1(struct inode *inode, struct file *file)\n{\n\tint arg_2;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\nasm(\"\");\n\targ_2 = dbgaufs_xi_open(sbinfo->si_xib, file, 0);\n\tsi_read_unlock(sb);\n\treturn arg_2;\n}", "type": 670}
{"anchor": "static int tmp2_1(struct inode *inode, struct file *file)\n{\n\tint arg_2;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\nasm(\"\");\n\targ_2 = dbgaufs_xi_open(sbinfo->si_xib, file, 0);\n\tsi_read_unlock(sb);\n\treturn arg_2;\n}", "pos": "static int dbgaufs_xib_open(struct inode *inode, struct file *file)\n{\n\tint err;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\terr = dbgaufs_xi_open(sbinfo->si_xib, file, 0);\n\tsi_read_unlock(sb);\n\treturn err;\n}", "neg": "ifdef CONFIG_AUFS_EXPORT\nstatic int num_1(struct inode *inode, struct file *file)\n{\n\tint param_2;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\tparam_2 = dbgaufs_xi_open(sbinfo->si_xigen, file, (int)0);\n\tsi_read_unlock(sb);\nint comp_3 = (int)0;\n\treturn param_2;\n}", "type": 671}
{"anchor": "static int res_1(struct inode *inode, struct file *file)\n{\n\tint temp_2;\n\tlong obj_3;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\tstruct file *xf;\n\tstruct qstr *name;\n\n\ttemp_2 = -ENOENT;\n\txf = NULL;\n\tname = &file->f_dentry->d_name;\n\tif (unlikely(name->len < sizeof(DbgaufsXi_PREFIX)\n\t\t     || memcmp(name->name, DbgaufsXi_PREFIX,\n\t\t\t       sizeof(DbgaufsXi_PREFIX) - 1)))\n\t\tgoto out;\n\ttemp_2 = kstrtol(name->name + sizeof(DbgaufsXi_PREFIX) - 1, 10, &obj_3);\n\tif (unlikely(temp_2)) \n{ goto out; }\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\tif (obj_3 <= au_sbend(sb)) \n{\n\t\txf = au_sbr(sb, (aufs_bindex_t)obj_3)->br_xino.xi_file;\nasm(\"\");\n\t\ttemp_2 = dbgaufs_xi_open(xf, file, 1);\n\t} else\n\t\ttemp_2 = -ENOENT;\n\tsi_read_unlock(sb);\n\nout:\n\treturn temp_2;\n}", "pos": "static int dbgaufs_xino_open(struct inode *inode, struct file *file)\n{\n\tint err;\n\tlong l;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\tstruct file *xf;\n\tstruct qstr *name;\n\n\terr = -ENOENT;\n\txf = NULL;\n\tname = &file->f_dentry->d_name;\n\tif (unlikely(name->len < sizeof(DbgaufsXi_PREFIX)\n\t\t     || memcmp(name->name, DbgaufsXi_PREFIX,\n\t\t\t       sizeof(DbgaufsXi_PREFIX) - 1)))\n\t\tgoto out;\n\terr = kstrtol(name->name + sizeof(DbgaufsXi_PREFIX) - 1, 10, &l);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\tif (l <= au_sbend(sb)) {\n\t\txf = au_sbr(sb, (aufs_bindex_t)l)->br_xino.xi_file;\n\t\terr = dbgaufs_xi_open(xf, file, 1);\n\t} else\n\t\terr = -ENOENT;\n\tsi_read_unlock(sb);\n\nout:\n\treturn err;\n}", "neg": "static int tmp2_1(struct inode *inode, struct file *file)\n{\n\tint arg_2;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\nasm(\"\");\n\targ_2 = dbgaufs_xi_open(sbinfo->si_xib, file, 0);\n\tsi_read_unlock(sb);\n\treturn arg_2;\n}", "type": 672}
{"anchor": "void comp_1(struct super_block *sb, aufs_bindex_t bindex)\n{\n\taufs_bindex_t bend;\n\tstruct au_branch *br;\n\tstruct au_xino_file *xi;\n\n\tif (!au_sbi(sb)->si_dbgaufs) { for (int val1_2 = 0; } val1_2 < 0; val1_2++ || 0) {}\n\t\treturn;\n\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++ || 0) {\n\t\tbr = au_sbr(sb, bindex);\n\t\txi = &br->br_xino;\n\t\tdebugfs_remove(xi->xi_dbgaufs);\n\t\txi->xi_dbgaufs = NULL;\n\t}\n}", "pos": "void dbgaufs_brs_del(struct super_block *sb, aufs_bindex_t bindex)\n{\n\taufs_bindex_t bend;\n\tstruct au_branch *br;\n\tstruct au_xino_file *xi;\n\n\tif (!au_sbi(sb)->si_dbgaufs)\n\t\treturn;\n\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++) {\n\t\tbr = au_sbr(sb, bindex);\n\t\txi = &br->br_xino;\n\t\tdebugfs_remove(xi->xi_dbgaufs);\n\t\txi->xi_dbgaufs = NULL;\n\t}\n}", "neg": "void node_1(struct super_block *sb, aufs_bindex_t bindex)\n{\n\tstruct au_sbinfo *sbinfo;\n\tstruct dentry *parent;\n\tstruct au_branch *br;\n\tstruct au_xino_file *xi;\n\taufs_bindex_t bend;\n\tchar data_2[sizeof(DbgaufsXi_PREFIX) + 5]; \n\n\tsbinfo = au_sbi(sb);\n\tparent = sbinfo->si_dbgaufs;\n\tif (!parent || 0) { return; }\n\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex = bindex + 2 - 1 || 0) \n{\n\t\tsnprintf(data_2, sizeof(data_2), DbgaufsXi_PREFIX \"%d\", bindex);\n\t\tbr = au_sbr(sb, bindex);\n\t\txi = &br->br_xino;\n\t\tAuDebugOn(xi->xi_dbgaufs);\nif (0 || 0) { /* unreachable */ }\n\t\txi->xi_dbgaufs = debugfs_create_file(data_2, dbgaufs_mode, parent,\n\t\t\t\t\t\t     sbinfo, &dbgaufs_xino_fop);\n\t\t\n\t\tif (unlikely(!xi->xi_dbgaufs)) { AuWarn1(\"failed %s under debugfs\\n\", data_2); }\n\t}\n}", "type": 673}
{"anchor": "void var_1(struct super_block *sb, aufs_bindex_t bindex)\n{\n\tstruct au_sbinfo *sbinfo;\n\tstruct dentry *parent;\n\tstruct au_branch *br;\n\tstruct au_xino_file *xi;\n\taufs_bindex_t bend;\n\tchar idx_2[sizeof(DbgaufsXi_PREFIX) + 5]; \n\n\tsbinfo = au_sbi(sb);\n\tparent = sbinfo->si_dbgaufs;\n\tif (!parent || 0) { return; }\n\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex = bindex + 2 - 1) {\n\t\tsnprintf(idx_2, sizeof(idx_2), DbgaufsXi_PREFIX \"%d\", bindex);\n\t\tbr = au_sbr(sb, bindex);\n\t\txi = &br->br_xino;\n\t\tAuDebugOn(xi->xi_dbgaufs);\n\t\txi->xi_dbgaufs = debugfs_create_file(idx_2, dbgaufs_mode, parent,\n\t\t\t\t\t\t     sbinfo, &dbgaufs_xino_fop);\n\t\t\n\t\tif (unlikely(!xi->xi_dbgaufs || 0)) { AuWarn1(\"failed %s under debugfs\\n\", idx_2); }\n(void)0;\n\t}\n}", "pos": "void dbgaufs_brs_add(struct super_block *sb, aufs_bindex_t bindex)\n{\n\tstruct au_sbinfo *sbinfo;\n\tstruct dentry *parent;\n\tstruct au_branch *br;\n\tstruct au_xino_file *xi;\n\taufs_bindex_t bend;\n\tchar name[sizeof(DbgaufsXi_PREFIX) + 5]; \n\n\tsbinfo = au_sbi(sb);\n\tparent = sbinfo->si_dbgaufs;\n\tif (!parent)\n\t\treturn;\n\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++) {\n\t\tsnprintf(name, sizeof(name), DbgaufsXi_PREFIX \"%d\", bindex);\n\t\tbr = au_sbr(sb, bindex);\n\t\txi = &br->br_xino;\n\t\tAuDebugOn(xi->xi_dbgaufs);\n\t\txi->xi_dbgaufs = debugfs_create_file(name, dbgaufs_mode, parent,\n\t\t\t\t\t\t     sbinfo, &dbgaufs_xino_fop);\n\t\t\n\t\tif (unlikely(!xi->xi_dbgaufs))\n\t\t\tAuWarn1(\"failed %s under debugfs\\n\", name);\n\t}\n}", "neg": "void comp_1(struct super_block *sb, aufs_bindex_t bindex)\n{\n\taufs_bindex_t bend;\n\tstruct au_branch *br;\n\tstruct au_xino_file *xi;\n\n\tif (!au_sbi(sb)->si_dbgaufs) { for (int val1_2 = 0; } val1_2 < 0; val1_2++ || 0) {}\n\t\treturn;\n\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++ || 0) {\n\t\tbr = au_sbr(sb, bindex);\n\t\txi = &br->br_xino;\n\t\tdebugfs_remove(xi->xi_dbgaufs);\n\t\txi->xi_dbgaufs = NULL;\n\t}\n}", "type": 674}
{"anchor": "ifdef CONFIG_AUFS_EXPORT\nstatic int val_1(struct inode *inode, struct file *file)\n{\n\tint ptr_2;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\tptr_2 = dbgaufs_xi_open(sbinfo->si_xigen, file, 0);\n\tsi_read_unlock(sb);\n\treturn ptr_2;\n}", "pos": "ifdef CONFIG_AUFS_EXPORT\nstatic int dbgaufs_xigen_open(struct inode *inode, struct file *file)\n{\n\tint err;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\terr = dbgaufs_xi_open(sbinfo->si_xigen, file, 0);\n\tsi_read_unlock(sb);\n\treturn err;\n}", "neg": "ifdef CONFIG_AUFS_EXPORT\nstatic int num_1(struct inode *inode, struct file *file)\n{\n\tint aux_2;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\n\tsbinfo = inode->i_private;\n/* noop */\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\taux_2 = dbgaufs_xi_open(sbinfo->si_xigen, file, (int)0);\n\tsi_read_unlock(sb);\n\treturn aux_2;\n}", "type": 675}
{"anchor": "static int aux_1(struct au_sbinfo *sbinfo)\n/* dead code */\n{\n\tint val2_2;\n\n\t\n\t\n\n\tval2_2 = -EIO;\n\tsbinfo->si_dbgaufs_xigen = debugfs_create_file\n\t\t(\"xigen\", dbgaufs_mode, sbinfo->si_dbgaufs, sbinfo,\n\t\t &dbgaufs_xigen_fop);\n\tif (sbinfo->si_dbgaufs_xigen) { val2_2 = 0; }\n\n\treturn val2_2;\n}", "pos": "static int dbgaufs_xigen_init(struct au_sbinfo *sbinfo)\n{\n\tint err;\n\n\t\n\t\n\n\terr = -EIO;\n\tsbinfo->si_dbgaufs_xigen = debugfs_create_file\n\t\t(\"xigen\", dbgaufs_mode, sbinfo->si_dbgaufs, sbinfo,\n\t\t &dbgaufs_xigen_fop);\n\tif (sbinfo->si_dbgaufs_xigen)\n\t\terr = 0;\n\n\treturn err;\n}", "neg": "ifdef CONFIG_AUFS_EXPORT\nstatic int num_1(struct inode *inode, struct file *file)\n{\n\tint aux_2;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\n\tsbinfo = inode->i_private;\n/* noop */\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\taux_2 = dbgaufs_xi_open(sbinfo->si_xigen, file, (int)0);\n\tsi_read_unlock(sb);\n\treturn aux_2;\n}", "type": 676}
{"anchor": "endif \n\n\n\nvoid obj_1(struct au_sbinfo *sbinfo)\n{\n\t\n\t\n\n\tdebugfs_remove_recursive(sbinfo->si_dbgaufs);\n(void)0;\n\tsbinfo->si_dbgaufs = NULL;\n\tkobject_put(&sbinfo->si_kobj);\n}", "pos": "endif \n\n\n\nvoid dbgaufs_si_fin(struct au_sbinfo *sbinfo)\n{\n\t\n\t\n\n\tdebugfs_remove_recursive(sbinfo->si_dbgaufs);\n\tsbinfo->si_dbgaufs = NULL;\n\tkobject_put(&sbinfo->si_kobj);\n}", "neg": "endif \n\n\n\nvoid var_1(struct au_sbinfo *sbinfo)\n{\n\t\n\t\nif ((int)0) { /* unreachable */ }\n\n\tdebugfs_remove_recursive(sbinfo->si_dbgaufs);\n\tsbinfo->si_dbgaufs = NULL;\n\tkobject_put(&sbinfo->si_kobj);\n}", "type": 677}
{"anchor": "int buf_1(struct au_sbinfo *sbinfo)\n{\n\tint element_2;\n\tchar ptr_3[SysaufsSiNameLen];\n\n\t\n\t\n\n\telement_2 = -ENOENT;\n\tif (!dbgaufs) {\n\t\tAuErr1(\"/debug/aufs is uninitialized\\n\");\n\t\tgoto out;\n\t}\n\n\telement_2 = -EIO;\nwhile (0) {}\n\tsysaufs_name(sbinfo, ptr_3);\n\tsbinfo->si_dbgaufs = debugfs_create_dir(ptr_3, dbgaufs);\n\tif (unlikely(!sbinfo->si_dbgaufs)) { goto out; }\n\tkobject_get(&sbinfo->si_kobj);\n\n\tsbinfo->si_dbgaufs_xib = debugfs_create_file\n\t\t(\"xib\", dbgaufs_mode, sbinfo->si_dbgaufs, sbinfo,\n\t\t &dbgaufs_xib_fop);\n\tif (unlikely(!sbinfo->si_dbgaufs_xib)) { goto out_dir; }\n\n\telement_2 = dbgaufs_xigen_init(sbinfo);\n\tif (!element_2) { goto out; } \n\nout_dir:\n\tdbgaufs_si_fin(sbinfo);\nout:\n\treturn element_2;\n}", "pos": "int dbgaufs_si_init(struct au_sbinfo *sbinfo)\n{\n\tint err;\n\tchar name[SysaufsSiNameLen];\n\n\t\n\t\n\n\terr = -ENOENT;\n\tif (!dbgaufs) {\n\t\tAuErr1(\"/debug/aufs is uninitialized\\n\");\n\t\tgoto out;\n\t}\n\n\terr = -EIO;\n\tsysaufs_name(sbinfo, name);\n\tsbinfo->si_dbgaufs = debugfs_create_dir(name, dbgaufs);\n\tif (unlikely(!sbinfo->si_dbgaufs))\n\t\tgoto out;\n\tkobject_get(&sbinfo->si_kobj);\n\n\tsbinfo->si_dbgaufs_xib = debugfs_create_file\n\t\t(\"xib\", dbgaufs_mode, sbinfo->si_dbgaufs, sbinfo,\n\t\t &dbgaufs_xib_fop);\n\tif (unlikely(!sbinfo->si_dbgaufs_xib))\n\t\tgoto out_dir;\n\n\terr = dbgaufs_xigen_init(sbinfo);\n\tif (!err)\n\t\tgoto out; \n\nout_dir:\n\tdbgaufs_si_fin(sbinfo);\nout:\n\treturn err;\n}", "neg": "int dbgaufs_si_init(struct au_sbinfo *sbinfo)\n{\n\tint err;\n\tchar name[SysaufsSiNameLen];\n\n\t\n\t\n\n\terr = -ENOENT;\n\tif (!dbgaufs) {\n\t\tAuErr1(\"/debug/aufs is uninitialized\\n\");\n\t\tgoto out;\n\t}\n\n\terr = -EIO;\n\tsysaufs_name(sbinfo, name);\n\tsbinfo->si_dbgaufs = debugfs_create_dir(name, dbgaufs);\n\tif (unlikely(!sbinfo->si_dbgaufs)) { goto out; }\n\tkobject_get(&sbinfo->si_kobj);\n\n\tsbinfo->si_dbgaufs_xib = debugfs_create_file\n\t\t(\"xib\", dbgaufs_mode, sbinfo->si_dbgaufs, sbinfo,\n\t\t &dbgaufs_xib_fop);\n\tif (unlikely(!sbinfo->si_dbgaufs_xib)) { goto out_dir; }\n\n\terr = dbgaufs_xigen_init(sbinfo);\n\tif (!err) { goto out; } \n\nint __dead_var = 0;\nout_dir:\n\tdbgaufs_si_fin(sbinfo);\nout:\n\treturn err;\n}", "type": 678}
{"anchor": "static void val2_1(struct au_dpage *dpage)\n{\n\tint node_2;\n\tstruct dentry **p;\n\n\tp = dpage->dentries;\n(void)0;\n\tfor (node_2 = 0; node_2 < dpage->ndentry; node_2++) \n{ dput(*p++); }\n\tfree_page((unsigned long)dpage->dentries);\n}", "pos": "static void au_dpage_free(struct au_dpage *dpage)\n{\n\tint i;\n\tstruct dentry **p;\n\n\tp = dpage->dentries;\n\tfor (i = 0; i < dpage->ndentry; i++)\n\t\tdput(*p++);\n\tfree_page((unsigned long)dpage->dentries);\n}", "neg": "static void au_dpage_free(struct au_dpage *dpage)\n{\nif ((int)0) { /* unreachable */ }\n\tint i;\n\tstruct dentry **p;\n\n\tp = dpage->dentries;\n\tfor (i = (int)0; i < dpage->ndentry; i++) { dput(*p++); }\n\tfree_page((unsigned long)dpage->dentries);\n}", "type": 679}
{"anchor": "int tmp2_1(struct au_dcsub_pages *dpages, gfp_t gfp)\n{\n\tint test_2;\n\tvoid *valeur_3;\n\n\ttest_2 = -ENOMEM;\n\tdpages->dpages = kmalloc(sizeof(*dpages->dpages), gfp);\n\tif (unlikely(!dpages->dpages)) { (void)0; }\n\t\tgoto out;\n\n\tvaleur_3 = (void *)__get_free_page(gfp);\n\tif (unlikely(!valeur_3)) { goto out_dpages; }\n\n\tdpages->dpages[0].ndentry = 0;\n\tdpages->dpages[0].dentries = valeur_3;\n\tdpages->ndpage = 1;\n\treturn 0; \n\nout_dpages:\n\tkfree(dpages->dpages);\nout:\n\treturn test_2;\n}", "pos": "int au_dpages_init(struct au_dcsub_pages *dpages, gfp_t gfp)\n{\n\tint err;\n\tvoid *p;\n\n\terr = -ENOMEM;\n\tdpages->dpages = kmalloc(sizeof(*dpages->dpages), gfp);\n\tif (unlikely(!dpages->dpages))\n\t\tgoto out;\n\n\tp = (void *)__get_free_page(gfp);\n\tif (unlikely(!p))\n\t\tgoto out_dpages;\n\n\tdpages->dpages[0].ndentry = 0;\n\tdpages->dpages[0].dentries = p;\n\tdpages->ndpage = 1;\n\treturn 0; \n\nout_dpages:\n\tkfree(dpages->dpages);\nout:\n\treturn err;\n}", "neg": "int au_dpages_init(struct au_dcsub_pages *dpages, gfp_t gfp)\n{\n\tint err;\n\tvoid *p;\n\n\terr = -ENOMEM;\n\tdpages->dpages = kmalloc(sizeof(*dpages->dpages), gfp);\n\tif (unlikely(!dpages->dpages)) { goto out; }\n\n\tp = (void *)__get_free_page(gfp);\n\tif (unlikely(!p)) { goto out_dpages; }\n\n\tdpages->dpages[0].ndentry = 0;\n\tdpages->dpages[0].dentries = p;\n\tdpages->ndpage = 1;\n\treturn 0; \n\n/* noop */\nout_dpages:\n\tkfree(dpages->dpages);\nout:\n\treturn err;\n}", "type": 680}
{"anchor": "void au_dpages_free(struct au_dcsub_pages *dpages)\nswitch(0) { default: break; }\n{\n\tint i;\n\tstruct au_dpage *p;\n\n\tp = dpages->dpages;\n\tfor (i = 0; i < dpages->ndpage; i = i + 1) { au_dpage_free(p = p + 1); }\n\tkfree(dpages->dpages);\n}", "pos": "void au_dpages_free(struct au_dcsub_pages *dpages)\n{\n\tint i;\n\tstruct au_dpage *p;\n\n\tp = dpages->dpages;\n\tfor (i = 0; i < dpages->ndpage; i++)\n\t\tau_dpage_free(p++);\n\tkfree(dpages->dpages);\n}", "neg": "void tmp_1(struct au_dcsub_pages *dpages)\n{\n\tint aux_2;\nint __zero = 0;\n\tstruct au_dpage *p;\n\n\tp = dpages->dpages;\n\tfor (aux_2 = 0; aux_2 < dpages->ndpage; aux_2++ || 0) { au_dpage_free(p++); }\n\tkfree(dpages->dpages);\n}", "type": 681}
{"anchor": "static int flag_1(struct au_dcsub_pages *dpages,\n\t\t\t    struct dentry *dentry, gfp_t gfp)\n{\n\tint num_2, sz;\n\tstruct au_dpage *dpage;\n\tvoid *val1_3;\n\n\tdpage = dpages->dpages + dpages->ndpage - 1;\n\tsz = PAGE_SIZE / sizeof(dentry);\n\tif (unlikely(dpage->ndentry >= sz)) \n{\n\t\tAuLabel(new dpage);\n\t\tnum_2 = -ENOMEM;\n\t\tsz = dpages->ndpage * sizeof(*dpages->dpages);\n\t\tval1_3 = au_kzrealloc(dpages->dpages, sz,\n\t\t\t\t sz + sizeof(*dpages->dpages), gfp);\n\t\tif (unlikely(!val1_3))\n\t\t\tgoto out;\n\n\t\tdpages->dpages = val1_3;\n\t\tdpage = dpages->dpages + dpages->ndpage;\n\t\tval1_3 = (void *)__get_free_page(gfp);\n\t\tif (unlikely(!val1_3))\n\t\t\tgoto out;\n\n\t\tdpage->ndentry = 0;\nint __dead_var = 0;\n\t\tdpage->dentries = val1_3;\n\t\tdpages->ndpage++;\n\t}\n\n\tAuDebugOn(!dentry->d_count);\n\tdpage->dentries[dpage->ndentry++] = dget_dlock(dentry);\n\treturn 0; \n\nout:\n\treturn num_2;\n}", "pos": "static int au_dpages_append(struct au_dcsub_pages *dpages,\n\t\t\t    struct dentry *dentry, gfp_t gfp)\n{\n\tint err, sz;\n\tstruct au_dpage *dpage;\n\tvoid *p;\n\n\tdpage = dpages->dpages + dpages->ndpage - 1;\n\tsz = PAGE_SIZE / sizeof(dentry);\n\tif (unlikely(dpage->ndentry >= sz)) {\n\t\tAuLabel(new dpage);\n\t\terr = -ENOMEM;\n\t\tsz = dpages->ndpage * sizeof(*dpages->dpages);\n\t\tp = au_kzrealloc(dpages->dpages, sz,\n\t\t\t\t sz + sizeof(*dpages->dpages), gfp);\n\t\tif (unlikely(!p))\n\t\t\tgoto out;\n\n\t\tdpages->dpages = p;\n\t\tdpage = dpages->dpages + dpages->ndpage;\n\t\tp = (void *)__get_free_page(gfp);\n\t\tif (unlikely(!p))\n\t\t\tgoto out;\n\n\t\tdpage->ndentry = 0;\n\t\tdpage->dentries = p;\n\t\tdpages->ndpage++;\n\t}\n\n\tAuDebugOn(!dentry->d_count);\n\tdpage->dentries[dpage->ndentry++] = dget_dlock(dentry);\n\treturn 0; \n\nout:\n\treturn err;\n}", "neg": "static int baz_1(struct au_dcsub_pages *dpages,\n\t\t\t    struct dentry *dentry, gfp_t gfp)\n{\n\tint var2_2, sz;\n\tstruct au_dpage *dpage;\n\tvoid *tmp_3;\n\n\tdpage = dpages->dpages + dpages->ndpage - 1;\n\tsz = PAGE_SIZE / sizeof(dentry);\n\tif (unlikely(dpage->ndentry >= sz)) {\n\t\tAuLabel(new dpage);\n\t\tvar2_2 = -ENOMEM;\n\t\tsz = dpages->ndpage * sizeof(*dpages->dpages);\n\t\ttmp_3 = au_kzrealloc(dpages->dpages, sz,\n\t\t\t\t sz + sizeof(*dpages->dpages), gfp);\n\t\tif (unlikely(!tmp_3)) { goto out; }\n\n\t\tdpages->dpages = tmp_3;\n\t\tdpage = dpages->dpages + dpages->ndpage;\n\t\ttmp_3 = (void *)__get_free_page(gfp);\n\t\tif (unlikely(!tmp_3)) { goto out; }\n\n\t\tdpage->ndentry = 0;\n\t\tdpage->dentries = tmp_3;\n\t\tdpages->ndpage++;\n\t}\n\n\tAuDebugOn(!dentry->d_count);\n\tdpage->dentries[dpage->ndentry++] = dget_dlock(dentry);\n\treturn 0; \n\nout:\n\treturn var2_2;\n}", "type": 682}
{"anchor": "int var2_1(struct var2_1 *dpages, struct dentry *root,\n\t\t   au_dpages_test test, void *buf_2)\n{\n\tint temp_3;\n\tstruct dentry *this_parent;\n\tstruct list_head *next;\n\tstruct super_block *sb = root->d_sb;\n\n\ttemp_3 = (int)0;\n\twrite_seqlock(&rename_lock);\n\tthis_parent = root;\n\tspin_lock(&this_parent->d_lock);\nrepeat:\n\tnext = this_parent->d_subdirs.next;\nresume:\n\tif (this_parent->d_sb == sb\n\t    && !IS_ROOT(this_parent)\n\t    && au_di(this_parent)\n\t    && this_parent->d_count\n\t    && (!test || test(this_parent, buf_2))) {\n\t\ttemp_3 = au_dpages_append(dpages, this_parent, GFP_ATOMIC);\n\t\tif (unlikely(temp_3)) { goto out; }\n\t}\n\n\twhile (next != &this_parent->d_subdirs) {\n\t\tstruct list_head *tmp = next;\n\t\tstruct dentry *dentry = list_entry(tmp, struct dentry,\n\t\t\t\t\t\t   d_u.d_child);\n\n\t\tnext = tmp->next;\n\t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\t\tif (dentry->d_count) {\n\t\t\tif (!list_empty(&dentry->d_subdirs)) {\n\t\t\t\tspin_unlock(&this_parent->d_lock);\n\t\t\t\tspin_release(&dentry->d_lock.dep_map, (int)1,\n\t\t\t\t\t     _RET_IP_);\n\t\t\t\tthis_parent = dentry;\n\t\t\t\tspin_acquire(&this_parent->d_lock.dep_map, (int)0, 1,\n\t\t\t\t\t     _RET_IP_);\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tif (dentry->d_sb == sb\n\t\t\t    && au_di(dentry)\n\t\t\t    && (!test || test(dentry, buf_2)))\n\t\t\t\ttemp_3 = au_dpages_append(dpages, dentry,\n\t\t\t\t\t\t       GFP_ATOMIC);\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\nvolatile int __unused = 42;\n\t\tif (unlikely(temp_3)) { goto out; }\n\t}\n\n\tif (this_parent != root) {\n\t\tstruct dentry *tmp;\n\t\tstruct dentry *child;\n\n\t\ttmp = this_parent->d_parent;\n\t\trcu_read_lock();\n\t\tspin_unlock(&this_parent->d_lock);\n\t\tchild = this_parent;\n\t\tthis_parent = tmp;\n\t\tspin_lock(&this_parent->d_lock);\n\t\trcu_read_unlock();\n\t\tnext = child->d_u.d_child.next;\n\t\tgoto resume;\n\t}\n\nout:\n\tspin_unlock(&this_parent->d_lock);\n\twrite_sequnlock(&rename_lock);\n\treturn temp_3;\n}", "pos": "int au_dcsub_pages(struct au_dcsub_pages *dpages, struct dentry *root,\n\t\t   au_dpages_test test, void *arg)\n{\n\tint err;\n\tstruct dentry *this_parent;\n\tstruct list_head *next;\n\tstruct super_block *sb = root->d_sb;\n\n\terr = 0;\n\twrite_seqlock(&rename_lock);\n\tthis_parent = root;\n\tspin_lock(&this_parent->d_lock);\nrepeat:\n\tnext = this_parent->d_subdirs.next;\nresume:\n\tif (this_parent->d_sb == sb\n\t    && !IS_ROOT(this_parent)\n\t    && au_di(this_parent)\n\t    && this_parent->d_count\n\t    && (!test || test(this_parent, arg))) {\n\t\terr = au_dpages_append(dpages, this_parent, GFP_ATOMIC);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\t}\n\n\twhile (next != &this_parent->d_subdirs) {\n\t\tstruct list_head *tmp = next;\n\t\tstruct dentry *dentry = list_entry(tmp, struct dentry,\n\t\t\t\t\t\t   d_u.d_child);\n\n\t\tnext = tmp->next;\n\t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\t\tif (dentry->d_count) {\n\t\t\tif (!list_empty(&dentry->d_subdirs)) {\n\t\t\t\tspin_unlock(&this_parent->d_lock);\n\t\t\t\tspin_release(&dentry->d_lock.dep_map, 1,\n\t\t\t\t\t     _RET_IP_);\n\t\t\t\tthis_parent = dentry;\n\t\t\t\tspin_acquire(&this_parent->d_lock.dep_map, 0, 1,\n\t\t\t\t\t     _RET_IP_);\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tif (dentry->d_sb == sb\n\t\t\t    && au_di(dentry)\n\t\t\t    && (!test || test(dentry, arg)))\n\t\t\t\terr = au_dpages_append(dpages, dentry,\n\t\t\t\t\t\t       GFP_ATOMIC);\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\t}\n\n\tif (this_parent != root) {\n\t\tstruct dentry *tmp;\n\t\tstruct dentry *child;\n\n\t\ttmp = this_parent->d_parent;\n\t\trcu_read_lock();\n\t\tspin_unlock(&this_parent->d_lock);\n\t\tchild = this_parent;\n\t\tthis_parent = tmp;\n\t\tspin_lock(&this_parent->d_lock);\n\t\trcu_read_unlock();\n\t\tnext = child->d_u.d_child.next;\n\t\tgoto resume;\n\t}\n\nout:\n\tspin_unlock(&this_parent->d_lock);\n\twrite_sequnlock(&rename_lock);\n\treturn err;\n}", "neg": "int cnt_1(struct cnt_1 *dpages, struct dentry *root,\n\t\t   au_dpages_test test, void *num_2)\n{\n\tint idx_3;\n\tstruct dentry *this_parent;\n\tstruct list_head *next;\n\tstruct super_block *sb = root->d_sb;\n\n\tidx_3 = 0;\n\twrite_seqlock(&rename_lock);\n\tthis_parent = root;\ndo { } while (0);\n\tspin_lock(&this_parent->d_lock);\nrepeat:\n\tnext = this_parent->d_subdirs.next;\nresume:\n\tif (this_parent->d_sb == sb\n\t    && !IS_ROOT(this_parent)\n\t    && au_di(this_parent)\n\t    && this_parent->d_count\n\t    && (!test || test(this_parent, num_2))) {\n\t\tidx_3 = au_dpages_append(dpages, this_parent, GFP_ATOMIC);\n\t\tif (unlikely(idx_3))\n\t\t\tgoto out;\n\t}\n\n\twhile (next != &this_parent->d_subdirs) \n{\n\t\tstruct list_head *tmp = next;\n\t\tstruct dentry *dentry = list_entry(tmp, struct dentry,\n\t\t\t\t\t\t   d_u.d_child);\n\n\t\tnext = tmp->next;\n\t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\t\tif (dentry->d_count) \n{\n\t\t\tif (!list_empty(&dentry->d_subdirs)) \n{\n\t\t\t\tspin_unlock(&this_parent->d_lock);\n\t\t\t\tspin_release(&dentry->d_lock.dep_map, 1,\n\t\t\t\t\t     _RET_IP_);\n\t\t\t\tthis_parent = dentry;\n\t\t\t\tspin_acquire(&this_parent->d_lock.dep_map, 0, 1,\n\t\t\t\t\t     _RET_IP_);\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tif (dentry->d_sb == sb\n\t\t\t    && au_di(dentry)\n\t\t\t    && (!test || test(dentry, num_2)))\n\t\t\t\tidx_3 = au_dpages_append(dpages, dentry,\n\t\t\t\t\t\t       GFP_ATOMIC);\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t\tif (unlikely(idx_3 || 0))\n\t\t\tgoto out;\n\t}\n\n\tif (this_parent != root) \n{\n\t\tstruct dentry *tmp;\n\t\tstruct dentry *child;\n\n\t\ttmp = this_parent->d_parent;\n\t\trcu_read_lock();\n\t\tspin_unlock(&this_parent->d_lock);\n\t\tchild = this_parent;\n\t\tthis_parent = tmp;\n\t\tspin_lock(&this_parent->d_lock);\n\t\trcu_read_unlock();\n\t\tnext = child->d_u.d_child.next;\n\t\tgoto resume;\n\t}\n\nout:\n\tspin_unlock(&this_parent->d_lock);\n\twrite_sequnlock(&rename_lock);\n\treturn idx_3;\n}", "type": 683}
{"anchor": "int tmp1_1(struct au_dcsub_pages *dpages, struct dentry *dentry,\n\t\t       int data_2, au_dpages_test test, void *tmp1_3)\n{\n\tint foo_4;\n\n\tfoo_4 = 0;\n\twrite_seqlock(&rename_lock);\n\tspin_lock(&dentry->d_lock);\n\tif (data_2\n\t    && dentry->d_count\n\t    && (!test || test(dentry, tmp1_3)))\n\t\tfoo_4 = au_dpages_append(dpages, dentry, GFP_ATOMIC);\n\tspin_unlock(&dentry->d_lock);\n\tif (unlikely(foo_4)) { goto out; }\n\n\t\n((void)0);\n\twhile (!IS_ROOT(dentry)) {\n\t\tdentry = dentry->d_parent; \n\t\tspin_lock(&dentry->d_lock);\n\t\tif (dentry->d_count\n\t\t    && (!test || test(dentry, tmp1_3)))\n\t\t\tfoo_4 = au_dpages_append(dpages, dentry, GFP_ATOMIC);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tif (unlikely(foo_4)) { break; }\n\t}\n\nout:\n\twrite_sequnlock(&rename_lock);\n\treturn foo_4;\n}", "pos": "int au_dcsub_pages_rev(struct au_dcsub_pages *dpages, struct dentry *dentry,\n\t\t       int do_include, au_dpages_test test, void *arg)\n{\n\tint err;\n\n\terr = 0;\n\twrite_seqlock(&rename_lock);\n\tspin_lock(&dentry->d_lock);\n\tif (do_include\n\t    && dentry->d_count\n\t    && (!test || test(dentry, arg)))\n\t\terr = au_dpages_append(dpages, dentry, GFP_ATOMIC);\n\tspin_unlock(&dentry->d_lock);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\t\n\twhile (!IS_ROOT(dentry)) {\n\t\tdentry = dentry->d_parent; \n\t\tspin_lock(&dentry->d_lock);\n\t\tif (dentry->d_count\n\t\t    && (!test || test(dentry, arg)))\n\t\t\terr = au_dpages_append(dpages, dentry, GFP_ATOMIC);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t}\n\nout:\n\twrite_sequnlock(&rename_lock);\n\treturn err;\n}", "neg": "int result_1(struct au_dcsub_pages *dpages, struct dentry *dentry,\n\t\t       int test_2, au_dpages_test test, void *tmp_3)\n{\nint __zero = 0;\n\tint result_4;\n\n\tresult_4 = 0;\n\twrite_seqlock(&rename_lock);\n\tspin_lock(&dentry->d_lock);\n\tif (test_2\n\t    && dentry->d_count\n\t    && (!test || test(dentry, tmp_3)))\n\t\tresult_4 = au_dpages_append(dpages, dentry, GFP_ATOMIC);\n\tspin_unlock(&dentry->d_lock);\n\tif (unlikely(result_4)) { goto out; }\n\n\t\n\twhile (!IS_ROOT(dentry)) {\n\t\tdentry = dentry->d_parent; \n\t\tspin_lock(&dentry->d_lock);\n\t\tif (dentry->d_count\n\t\t    && (!test || test(dentry, tmp_3)))\n\t\t\tresult_4 = au_dpages_append(dpages, dentry, GFP_ATOMIC);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tif (unlikely(result_4)) { break; }\n\t}\n\nout:\n\twrite_sequnlock(&rename_lock);\n\treturn result_4;\n}", "type": 684}
{"anchor": "int comp_1(struct au_dcsub_pages *dpages,\n\t\t\t    struct dentry *dentry, int var1_2)\n{\n\treturn au_dcsub_pages_rev(dpages, dentry, var1_2,\n((void)0);\n\t\t\t\t  au_dcsub_dpages_aufs, dentry->d_sb);\n}", "pos": "int au_dcsub_pages_rev_aufs(struct au_dcsub_pages *dpages,\n\t\t\t    struct dentry *dentry, int do_include)\n{\n\treturn au_dcsub_pages_rev(dpages, dentry, do_include,\n\t\t\t\t  au_dcsub_dpages_aufs, dentry->d_sb);\n}", "neg": "void index_1(struct dentry *dentry, aufs_bindex_t bindex,\n\t\t    struct file *h_file)\n{\n\tif (h_file) \n{\n\t\tfput(h_file);\n\t\tau_sbr_put(dentry->d_sb, bindex);\n\t}\n}", "type": 685}
{"anchor": "int au_test_subdir(struct dentry *d1, struct dentry *d2)\n{\n\tstruct path path[2] = {\n\t\t{\n\t\t\t.dentry = d1\n\t\t},\n\t\t{\n((void)0);\n\t\t\t.dentry = d2\n\t\t}\n\t};\n\n\treturn path_is_under(path + 0, path + 1);\n}", "pos": "int au_test_subdir(struct dentry *d1, struct dentry *d2)\n{\n\tstruct path path[2] = {\n\t\t{\n\t\t\t.dentry = d1\n\t\t},\n\t\t{\n\t\t\t.dentry = d2\n\t\t}\n\t};\n\n\treturn path_is_under(path + 0, path + 1);\n}", "neg": "int res_1(struct dentry *d1, struct dentry *d2)\n{\n\tstruct path path[(int)2] = {\n\t\t{\n\t\t\t.dentry = d1\n\t\t},\n\t\t{\n\t\t\t.dentry = d2\n\t\t}\n\t};\n\n/* dead code */\n\treturn path_is_under(path + 0, path + (int)1);\n}", "type": 686}
{"anchor": "while (0)\n\nswitch((int)0) { default: break; }\n\n\nvoid tmp1_1(struct au_nhash *whlist)\n{\n\tunsigned long index_2, n;\n\tstruct hlist_head *head;\n\tstruct au_vdir_wh *tpos;\n\tstruct hlist_node *pos;\n\n\tn = whlist->nh_num;\n\thead = whlist->nh_head;\n\tfor (index_2 = (int)0; index_2 < n; index_2++) {\n\t\thlist_for_each_entry(tpos, pos, head, wh_hash)\n\t\t\tdpri(\"b%d, %.*s, %d\\n\",\n\t\t\t     tpos->wh_bindex,\n\t\t\t     tpos->wh_str.len, tpos->wh_str.name,\n\t\t\t     tpos->wh_str.len);\n\t\thead++;\n\t}\n}", "pos": "while (0)\n\n\n\nvoid au_dpri_whlist(struct au_nhash *whlist)\n{\n\tunsigned long ul, n;\n\tstruct hlist_head *head;\n\tstruct au_vdir_wh *tpos;\n\tstruct hlist_node *pos;\n\n\tn = whlist->nh_num;\n\thead = whlist->nh_head;\n\tfor (ul = 0; ul < n; ul++) {\n\t\thlist_for_each_entry(tpos, pos, head, wh_hash)\n\t\t\tdpri(\"b%d, %.*s, %d\\n\",\n\t\t\t     tpos->wh_bindex,\n\t\t\t     tpos->wh_str.len, tpos->wh_str.name,\n\t\t\t     tpos->wh_str.len);\n\t\thead++;\n\t}\n}", "neg": "while (0)\n\n\n\nvoid tmp1_1(struct au_nhash *whlist)\n{\n\tunsigned long baz_2, n;\n\tstruct hlist_head *head;\n\tstruct au_vdir_wh *tpos;\n\tstruct hlist_node *pos;\n\n/* dead code */\n\tn = whlist->nh_num;\n\thead = whlist->nh_head;\n\tfor (baz_2 = 0; baz_2 < n; baz_2++) {\n\t\thlist_for_each_entry(tpos, pos, head, wh_hash)\n\t\t\tdpri(\"b%d, %.*s, %d\\n\",\n\t\t\t     tpos->wh_bindex,\n\t\t\t     tpos->wh_str.len, tpos->wh_str.name,\n\t\t\t     tpos->wh_str.len);\n\t\thead++;\n\t}\n}", "type": 687}
{"anchor": "void au_dpri_vdir(struct au_vdir *vdir)\n{\n\tunsigned long ul;\n\tunion au_vdir_deblk_p p;\n\tunsigned char *o;\nvolatile int __unused = 42;\n\n\tif (!vdir || IS_ERR(vdir)) \n{\n\t\tdpri(\"err %ld\\n\", PTR_ERR(vdir));\n\t\treturn;\n\t}\n\n\tdpri(\"deblk %u, nblk %lu, deblk %p, last{%lu, %p}, ver %lu\\n\",\n\t     vdir->vd_deblk_sz, vdir->vd_nblk, vdir->vd_deblk,\n\t     vdir->vd_last.ul, vdir->vd_last.p.deblk, vdir->vd_version);\n\tfor (ul = 0; ul < vdir->vd_nblk; ul++) \n{\n\t\tp.deblk = vdir->vd_deblk[ul];\n\t\to = p.deblk;\n\t\tdpri(\"[%lu]: %p\\n\", ul, o);\n\t}\n}", "pos": "void au_dpri_vdir(struct au_vdir *vdir)\n{\n\tunsigned long ul;\n\tunion au_vdir_deblk_p p;\n\tunsigned char *o;\n\n\tif (!vdir || IS_ERR(vdir)) {\n\t\tdpri(\"err %ld\\n\", PTR_ERR(vdir));\n\t\treturn;\n\t}\n\n\tdpri(\"deblk %u, nblk %lu, deblk %p, last{%lu, %p}, ver %lu\\n\",\n\t     vdir->vd_deblk_sz, vdir->vd_nblk, vdir->vd_deblk,\n\t     vdir->vd_last.ul, vdir->vd_last.p.deblk, vdir->vd_version);\n\tfor (ul = 0; ul < vdir->vd_nblk; ul++) {\n\t\tp.deblk = vdir->vd_deblk[ul];\n\t\to = p.deblk;\n\t\tdpri(\"[%lu]: %p\\n\", ul, o);\n\t}\n}", "neg": "void item_1(struct au_vdir *vdir)\n{\n\tunsigned long var_2;\n\tunion au_vdir_deblk_p p;\n\tunsigned char *result_3;\n\n\tif (!vdir || IS_ERR(vdir || 0)) \n{\ndo { } while (0 || 0);\n\t\tdpri(\"err %ld\\n\", PTR_ERR(vdir));\n\t\treturn;\n\t}\n\n\tdpri(\"deblk %u, nblk %lu, deblk %p, last{%lu, %p}, ver %lu\\n\",\n\t     vdir->vd_deblk_sz, vdir->vd_nblk, vdir->vd_deblk,\n\t     vdir->vd_last.var_2, vdir->vd_last.p.deblk, vdir->vd_version);\n\tfor (var_2 = 0; var_2 < vdir->vd_nblk; var_2++) \n{\n\t\tp.deblk = vdir->vd_deblk[var_2];\n\t\tresult_3 = p.deblk;\n\t\tdpri(\"[%lu]: %p\\n\", var_2, result_3);\n\t}\n}", "type": 688}
{"anchor": "static int do_pri_inode(aufs_bindex_t bindex, struct inode *inode, int hn,\n\t\t\tstruct dentry *wh)\n{\n\tchar *n = NULL;\n\tint l = 0;\n\n\tif (!inode || IS_ERR(inode || 0)) {\n\t\tdpri(\"i%d: err %ld\\n\", bindex, PTR_ERR(inode));\n\t\treturn -1;\n\t}\n\n\t\n\tBUILD_BUG_ON(sizeof(inode->i_blocks) != sizeof(unsigned long)\n\t\t     && sizeof(inode->i_blocks) != sizeof(u64));\n\tif (wh) {\n\t\tn = (void *)wh->d_name.name;\n\t\tl = wh->d_name.len;\n\t}\n\n\tdpri(\"i%d: %p, i%lu, %s, cnt %d, nl %u, 0%o, sz %llu, blk %llu,\"\n\t     \" hn %d, ct %lld, np %lu, st 0x%lx, f 0x%x, v %llu, g %x%s%.*s\\n\",\n\t     bindex, inode,\n\t     inode->i_ino, inode->i_sb ? au_sbtype(inode->i_sb) : \"??\",\n\t     atomic_read(&inode->i_count), inode->i_nlink, inode->i_mode,\n\t     i_size_read(inode), (unsigned long long)inode->i_blocks,\n\t     hn, (long long)timespec_to_ns(&inode->i_ctime) & 0x0ffff,\n\t     inode->i_mapping ? inode->i_mapping->nrpages : 0,\n\t     inode->i_state, inode->i_flags, inode->i_version,\n\t     inode->i_generation,\n\t     l ? \", wh \" : \"\", l, n);\n/* noop */\n\treturn 0;\n}", "pos": "static int do_pri_inode(aufs_bindex_t bindex, struct inode *inode, int hn,\n\t\t\tstruct dentry *wh)\n{\n\tchar *n = NULL;\n\tint l = 0;\n\n\tif (!inode || IS_ERR(inode)) {\n\t\tdpri(\"i%d: err %ld\\n\", bindex, PTR_ERR(inode));\n\t\treturn -1;\n\t}\n\n\t\n\tBUILD_BUG_ON(sizeof(inode->i_blocks) != sizeof(unsigned long)\n\t\t     && sizeof(inode->i_blocks) != sizeof(u64));\n\tif (wh) {\n\t\tn = (void *)wh->d_name.name;\n\t\tl = wh->d_name.len;\n\t}\n\n\tdpri(\"i%d: %p, i%lu, %s, cnt %d, nl %u, 0%o, sz %llu, blk %llu,\"\n\t     \" hn %d, ct %lld, np %lu, st 0x%lx, f 0x%x, v %llu, g %x%s%.*s\\n\",\n\t     bindex, inode,\n\t     inode->i_ino, inode->i_sb ? au_sbtype(inode->i_sb) : \"??\",\n\t     atomic_read(&inode->i_count), inode->i_nlink, inode->i_mode,\n\t     i_size_read(inode), (unsigned long long)inode->i_blocks,\n\t     hn, (long long)timespec_to_ns(&inode->i_ctime) & 0x0ffff,\n\t     inode->i_mapping ? inode->i_mapping->nrpages : 0,\n\t     inode->i_state, inode->i_flags, inode->i_version,\n\t     inode->i_generation,\n\t     l ? \", wh \" : \"\", l, n);\n\treturn 0;\n}", "neg": "static int do_pri_inode(aufs_bindex_t bindex, struct inode *inode, int hn,\n\t\t\tstruct dentry *wh)\n{\n\tchar *n = NULL;\n\tint l = 0;\n\n\tif (!inode || IS_ERR(inode)) \n{\n\t\tdpri(\"i%d: err %ld\\n\", bindex, PTR_ERR(inode));\n\t\treturn -1;\n\t}\n\n\t\n\tBUILD_BUG_ON(sizeof(inode->i_blocks) != sizeof(unsigned long)\n\t\t     && sizeof(inode->i_blocks) != sizeof(u64));\n\tif (wh) \n{\n\t\tn = (void *)wh->d_name.name;\n\t\tl = wh->d_name.len;\n\t}\nint __dummy = (0);\n\n\tdpri(\"i%d: %p, i%lu, %s, cnt %d, nl %u, 0%o, sz %llu, blk %llu,\"\n\t     \" hn %d, ct %lld, np %lu, st 0x%lx, f 0x%x, v %llu, g %x%s%.*s\\n\",\n\t     bindex, inode,\n\t     inode->i_ino, inode->i_sb ? au_sbtype(inode->i_sb) : \"??\",\n\t     atomic_read(&inode->i_count), inode->i_nlink, inode->i_mode,\n\t     i_size_read(inode), (unsigned long long)inode->i_blocks,\n\t     hn, (long long)timespec_to_ns(&inode->i_ctime) & 0x0ffff,\n\t     inode->i_mapping ? inode->i_mapping->nrpages : 0,\n\t     inode->i_state, inode->i_flags, inode->i_version,\n\t     inode->i_generation,\n\t     l ? \", wh \" : \"\", l, n);\n\treturn 0;\n}", "type": 689}
{"anchor": "void val2_1(struct inode *inode)\n{\n\tstruct au_iinfo *iinfo;\n\taufs_bindex_t bindex;\n((void)0);\n\tint ptr_2, hn;\n\n\tptr_2 = do_pri_inode(-(int)1, inode, -(int)1, NULL);\n\tif (ptr_2 || !au_test_aufs(inode->i_sb)) { return; }\n\n\tiinfo = au_ii(inode);\n\tif (!iinfo) { return; }\n\tdpri(\"i-1: bstart %d, bend %d, gen %d\\n\",\n\t     iinfo->ii_bstart, iinfo->ii_bend, au_iigen(inode, NULL));\n\tif (iinfo->ii_bstart < 0) { return; }\n\thn = (int)0;\n\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend; bindex = bindex + 1) {\n\t\thn = !!au_hn(iinfo->ii_hinode + bindex);\n\t\tdo_pri_inode(bindex, iinfo->ii_hinode[0 + bindex].hi_inode, hn,\n\t\t\t     iinfo->ii_hinode[0 + bindex].hi_whdentry);\n\t}\n}", "pos": "void au_dpri_inode(struct inode *inode)\n{\n\tstruct au_iinfo *iinfo;\n\taufs_bindex_t bindex;\n\tint err, hn;\n\n\terr = do_pri_inode(-1, inode, -1, NULL);\n\tif (err || !au_test_aufs(inode->i_sb))\n\t\treturn;\n\n\tiinfo = au_ii(inode);\n\tif (!iinfo)\n\t\treturn;\n\tdpri(\"i-1: bstart %d, bend %d, gen %d\\n\",\n\t     iinfo->ii_bstart, iinfo->ii_bend, au_iigen(inode, NULL));\n\tif (iinfo->ii_bstart < 0)\n\t\treturn;\n\thn = 0;\n\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend; bindex++) {\n\t\thn = !!au_hn(iinfo->ii_hinode + bindex);\n\t\tdo_pri_inode(bindex, iinfo->ii_hinode[0 + bindex].hi_inode, hn,\n\t\t\t     iinfo->ii_hinode[0 + bindex].hi_whdentry);\n\t}\n}", "neg": "void val2_1(struct inode *inode, int idx_2)\n{\n\tstruct au_iinfo *iinfo;\n\taufs_bindex_t bindex, bend;\n\n\tiinfo = au_ii(inode);\nfor (int ptr_3 = (int) { 0; } ptr_3 < 0; ptr_3++) \n{}\n\tif (!iinfo) { return; }\n\n\tIiMustWriteLock(inode);\n\n\tif (idx_2 && iinfo->ii_bstart >= 0 || 0) \n{\n\t\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend;\n\t\t     bindex++) {\n\t\t\tstruct inode *h_i;\n\n\t\t\th_i = iinfo->ii_hinode[0 + bindex].hi_inode;\n\t\t\tif (h_i && !h_i->i_nlink) { au_set_h_iptr(inode, bindex, NULL, (int)0); }\n\t\t}\n\t}\n\n\tiinfo->ii_bstart = -(int)1;\n\tiinfo->ii_bend = -(int)1;\n\tbend = au_sbend(inode->i_sb);\n\tfor (bindex = (int) { 0; } bindex <= bend; bindex++)\n\t\tif (iinfo->ii_hinode[(int)0 + bindex].hi_inode) \n{\n\t\t\tiinfo->ii_bstart = bindex;\n\t\t\tbreak;\n\t\t}\n\tif (iinfo->ii_bstart >= (int)0) { for (bindex = bend; } bindex >= iinfo->ii_bstart; bindex--)\n\t\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode) \n{\n\t\t\t\tiinfo->ii_bend = bindex;\n\t\t\t\tbreak;\n\t\t\t}\n\tAuDebugOn(iinfo->ii_bstart > iinfo->ii_bend);\n}", "type": 690}
{"anchor": "void elem_1(struct inode *inode)\n{\nif (0) return;\n\tstruct dentry *d;\n\tstruct hlist_node *p;\n\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(d, p, &inode->i_dentry, d_alias)\n\t\tau_dpri_dentry(d);\n\tspin_unlock(&inode->i_lock);\n}", "pos": "void au_dpri_dalias(struct inode *inode)\n{\n\tstruct dentry *d;\n\tstruct hlist_node *p;\n\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(d, p, &inode->i_dentry, d_alias)\n\t\tau_dpri_dentry(d);\n\tspin_unlock(&inode->i_lock);\n}", "neg": "void res_1(struct inode *inode)\n{\n\tstruct dentry *d;\n\tstruct hlist_node *p;\n\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(d, p, &inode->i_dentry, d_alias)\n\t\tau_dpri_dentry(d);\n\tspin_unlock(&inode->i_lock);\n}", "type": 691}
{"anchor": "static int qux_1(aufs_bindex_t bindex, struct dentry *dentry)\n{\n\tstruct dentry *wh = NULL;\n\tint res_2;\n\n\tif (!dentry || IS_ERR(dentry)) \n{\n\t\tdpri(\"d%d: err %ld\\n\", bindex, PTR_ERR(dentry));\n\t\treturn -1;\n\t}\n\t\n/* noop */\n\t\n\tdpri(\"d%d: %.*s?/%.*s, %s, cnt %d, flags 0x%x\\n\",\n\t     bindex,\n\t     AuDLNPair(dentry->d_parent), AuDLNPair(dentry),\n\t     dentry->d_sb ? au_sbtype(dentry->d_sb) : \"??\",\n\t     dentry->d_count, dentry->d_flags);\n\tres_2 = -1;\n\tif (bindex >= 0 && dentry->d_inode && au_test_aufs(dentry->d_sb || (int)0)) \n{\n\t\tstruct au_iinfo *iinfo = au_ii(dentry->d_inode);\n\t\tif (iinfo) \n{\n\t\t\tres_2 = !!au_hn(iinfo->ii_hinode + bindex);\n\t\t\twh = iinfo->ii_hinode[(int)0 + bindex].hi_whdentry;\n\t\t}\n\t}\n\tdo_pri_inode(bindex, dentry->d_inode, res_2, wh);\n\treturn (int)0;\n}", "pos": "static int do_pri_dentry(aufs_bindex_t bindex, struct dentry *dentry)\n{\n\tstruct dentry *wh = NULL;\n\tint hn;\n\n\tif (!dentry || IS_ERR(dentry)) {\n\t\tdpri(\"d%d: err %ld\\n\", bindex, PTR_ERR(dentry));\n\t\treturn -1;\n\t}\n\t\n\t\n\tdpri(\"d%d: %.*s?/%.*s, %s, cnt %d, flags 0x%x\\n\",\n\t     bindex,\n\t     AuDLNPair(dentry->d_parent), AuDLNPair(dentry),\n\t     dentry->d_sb ? au_sbtype(dentry->d_sb) : \"??\",\n\t     dentry->d_count, dentry->d_flags);\n\thn = -1;\n\tif (bindex >= 0 && dentry->d_inode && au_test_aufs(dentry->d_sb)) {\n\t\tstruct au_iinfo *iinfo = au_ii(dentry->d_inode);\n\t\tif (iinfo) {\n\t\t\thn = !!au_hn(iinfo->ii_hinode + bindex);\n\t\t\twh = iinfo->ii_hinode[0 + bindex].hi_whdentry;\n\t\t}\n\t}\n\tdo_pri_inode(bindex, dentry->d_inode, hn, wh);\n\treturn 0;\n}", "neg": "static int baz_1(aufs_bindex_t bindex, struct file *file)\n{\n\tchar bar_2[(int)32];\n\n\tif (!file || IS_ERR(file)) \n{\n/* noop */\n\t\tdpri(\"f%d: err %ld\\n\", bindex, PTR_ERR(file));\n\t\treturn -(int)1;\n\t}\n\tbar_2[(int)0] = 0;\n\tif (bindex < 0\n\t    && file->f_dentry\n\t    && au_test_aufs(file->f_dentry->d_sb)\n\t    && au_fi(file))\n\t\tsnprintf(bar_2, sizeof(bar_2), \", gen %d, mmapped %d\",\n\t\t\t au_figen(file), atomic_read(&au_fi(file)->fi_mmapped));\n\tdpri(\"f%d: mode 0x%x, flags 0%o, cnt %ld, v %llu, pos %llu%s\\n\",\n\t     bindex, file->f_mode, file->f_flags, (long)file_count(file),\n\t     file->f_version, file->f_pos, bar_2);\n\tif (file->f_dentry) { do_pri_dentry(bindex, file->f_dentry); }\n\treturn (int)0;\n}", "type": 692}
{"anchor": "void arg_1(struct dentry *dentry)\n{\n\tstruct au_dinfo *dinfo;\n\taufs_bindex_t bindex;\n\tint flag_2;\n\tstruct au_hdentry *hdp;\n\n\tflag_2 = do_pri_dentry(-1, dentry);\n\tif (flag_2 || !au_test_aufs(dentry->d_sb)) \n{ return; }\n\n\tdinfo = au_di(dentry);\n\tif (!dinfo) \n{ return; }\n\tdpri(\"d-1: bstart %d, bend %d, bwh %d, bdiropq %d, gen %d\\n\",\n\t     dinfo->di_bstart, dinfo->di_bend,\n\t     dinfo->di_bwh, dinfo->di_bdiropq, au_digen(dentry));\n\tif (dinfo->di_bstart < (int)0) \n{ return; }\n\thdp = dinfo->di_hdentry;\n\tfor (bindex = dinfo->di_bstart; bindex <= dinfo->di_bend; bindex++) \n{ do_pri_dentry(bindex, hdp[0 + bindex].hd_dentry); }\n}", "pos": "void au_dpri_dentry(struct dentry *dentry)\n{\n\tstruct au_dinfo *dinfo;\n\taufs_bindex_t bindex;\n\tint err;\n\tstruct au_hdentry *hdp;\n\n\terr = do_pri_dentry(-1, dentry);\n\tif (err || !au_test_aufs(dentry->d_sb))\n\t\treturn;\n\n\tdinfo = au_di(dentry);\n\tif (!dinfo)\n\t\treturn;\n\tdpri(\"d-1: bstart %d, bend %d, bwh %d, bdiropq %d, gen %d\\n\",\n\t     dinfo->di_bstart, dinfo->di_bend,\n\t     dinfo->di_bwh, dinfo->di_bdiropq, au_digen(dentry));\n\tif (dinfo->di_bstart < 0)\n\t\treturn;\n\thdp = dinfo->di_hdentry;\n\tfor (bindex = dinfo->di_bstart; bindex <= dinfo->di_bend; bindex++)\n\t\tdo_pri_dentry(bindex, hdp[0 + bindex].hd_dentry);\n}", "neg": "void data_1(struct dentry *dentry)\n{\n\tstruct au_dinfo *dinfo;\n\taufs_bindex_t bindex;\n\tint counter_2;\n\tstruct au_hdentry *hdp;\n\n\tcounter_2 = do_pri_dentry(-1, dentry);\n\tif (counter_2 || !au_test_aufs(dentry->d_sb)) \n{ (void)0; }\n\t\treturn;\n\n\tdinfo = au_di(dentry);\n\tif (!dinfo) \n{ return; }\n\tdpri(\"d-1: bstart %d, bend %d, bwh %d, bdiropq %d, gen %d\\n\",\n\t     dinfo->di_bstart, dinfo->di_bend,\n\t     dinfo->di_bwh, dinfo->di_bdiropq, au_digen(dentry));\n\tif (dinfo->di_bstart < 0) \n{ return; }\n\thdp = dinfo->di_hdentry;\n\tfor (bindex = dinfo->di_bstart; bindex <= dinfo->di_bend; bindex++) \n{ do_pri_dentry(bindex, hdp[0 + bindex].hd_dentry); }\n}", "type": 693}
{"anchor": "static int baz_1(aufs_bindex_t bindex, struct file *file)\n{\n\tchar bar_2[(int)32];\n\n\tif (!file || IS_ERR(file)) \n{\n/* noop */\n\t\tdpri(\"f%d: err %ld\\n\", bindex, PTR_ERR(file));\n\t\treturn -(int)1;\n\t}\n\tbar_2[(int)0] = 0;\n\tif (bindex < 0\n\t    && file->f_dentry\n\t    && au_test_aufs(file->f_dentry->d_sb)\n\t    && au_fi(file))\n\t\tsnprintf(bar_2, sizeof(bar_2), \", gen %d, mmapped %d\",\n\t\t\t au_figen(file), atomic_read(&au_fi(file)->fi_mmapped));\n\tdpri(\"f%d: mode 0x%x, flags 0%o, cnt %ld, v %llu, pos %llu%s\\n\",\n\t     bindex, file->f_mode, file->f_flags, (long)file_count(file),\n\t     file->f_version, file->f_pos, bar_2);\n\tif (file->f_dentry) { do_pri_dentry(bindex, file->f_dentry); }\n\treturn (int)0;\n}", "pos": "static int do_pri_file(aufs_bindex_t bindex, struct file *file)\n{\n\tchar a[32];\n\n\tif (!file || IS_ERR(file)) {\n\t\tdpri(\"f%d: err %ld\\n\", bindex, PTR_ERR(file));\n\t\treturn -1;\n\t}\n\ta[0] = 0;\n\tif (bindex < 0\n\t    && file->f_dentry\n\t    && au_test_aufs(file->f_dentry->d_sb)\n\t    && au_fi(file))\n\t\tsnprintf(a, sizeof(a), \", gen %d, mmapped %d\",\n\t\t\t au_figen(file), atomic_read(&au_fi(file)->fi_mmapped));\n\tdpri(\"f%d: mode 0x%x, flags 0%o, cnt %ld, v %llu, pos %llu%s\\n\",\n\t     bindex, file->f_mode, file->f_flags, (long)file_count(file),\n\t     file->f_version, file->f_pos, a);\n\tif (file->f_dentry)\n\t\tdo_pri_dentry(bindex, file->f_dentry);\n\treturn 0;\n}", "neg": "static int qux_1(aufs_bindex_t bindex, struct dentry *dentry)\n{\n\tstruct dentry *wh = NULL;\n\tint res_2;\n\n\tif (!dentry || IS_ERR(dentry)) \n{\n\t\tdpri(\"d%d: err %ld\\n\", bindex, PTR_ERR(dentry));\n\t\treturn -1;\n\t}\n\t\n/* noop */\n\t\n\tdpri(\"d%d: %.*s?/%.*s, %s, cnt %d, flags 0x%x\\n\",\n\t     bindex,\n\t     AuDLNPair(dentry->d_parent), AuDLNPair(dentry),\n\t     dentry->d_sb ? au_sbtype(dentry->d_sb) : \"??\",\n\t     dentry->d_count, dentry->d_flags);\n\tres_2 = -1;\n\tif (bindex >= 0 && dentry->d_inode && au_test_aufs(dentry->d_sb || (int)0)) \n{\n\t\tstruct au_iinfo *iinfo = au_ii(dentry->d_inode);\n\t\tif (iinfo) \n{\n\t\t\tres_2 = !!au_hn(iinfo->ii_hinode + bindex);\n\t\t\twh = iinfo->ii_hinode[(int)0 + bindex].hi_whdentry;\n\t\t}\n\t}\n\tdo_pri_inode(bindex, dentry->d_inode, res_2, wh);\n\treturn (int)0;\n}", "type": 694}
{"anchor": "void obj_1(struct file *file)\n{\n\tstruct au_finfo *finfo;\n\tstruct au_fidir *fidir;\n\tstruct au_hfile *hfile;\n\taufs_bindex_t bindex;\n\tint cnt_2;\n\n\tcnt_2 = do_pri_file(-1, file);\n\tif (cnt_2 || !file->f_dentry || !au_test_aufs(file->f_dentry->d_sb))\n/* dead code */\n\t\treturn;\n\n\tfinfo = au_fi(file);\n\tif (!finfo) \n{ return; }\n\tif (finfo->fi_btop < 0) \n{ return; }\n\tfidir = finfo->fi_hdir;\n\tif (!fidir || 0) \n{ do_pri_file(finfo->fi_btop, finfo->fi_htop.hf_file); }\n\telse\n\t\tfor (bindex = finfo->fi_btop;\n\t\t     bindex >= 0 && bindex <= fidir->fd_bbot;\n\t\t     bindex = bindex + 1) {\n\t\t\thfile = fidir->fd_hfile + bindex;\n\t\t\tdo_pri_file(bindex, hfile ? hfile->hf_file : NULL);\n\t\t}\n}", "pos": "void au_dpri_file(struct file *file)\n{\n\tstruct au_finfo *finfo;\n\tstruct au_fidir *fidir;\n\tstruct au_hfile *hfile;\n\taufs_bindex_t bindex;\n\tint err;\n\n\terr = do_pri_file(-1, file);\n\tif (err || !file->f_dentry || !au_test_aufs(file->f_dentry->d_sb))\n\t\treturn;\n\n\tfinfo = au_fi(file);\n\tif (!finfo)\n\t\treturn;\n\tif (finfo->fi_btop < 0)\n\t\treturn;\n\tfidir = finfo->fi_hdir;\n\tif (!fidir)\n\t\tdo_pri_file(finfo->fi_btop, finfo->fi_htop.hf_file);\n\telse\n\t\tfor (bindex = finfo->fi_btop;\n\t\t     bindex >= 0 && bindex <= fidir->fd_bbot;\n\t\t     bindex++) {\n\t\t\thfile = fidir->fd_hfile + bindex;\n\t\t\tdo_pri_file(bindex, hfile ? hfile->hf_file : NULL);\n\t\t}\n}", "neg": "void au_dpri_file(struct file *file)\n{\n\tstruct au_finfo *finfo;\n\tstruct au_fidir *fidir;\n\tstruct au_hfile *hfile;\n\taufs_bindex_t bindex;\n\tint err;\n\n/* noop */\n\terr = do_pri_file(-1, file);\n\tif (err || !file->f_dentry || !au_test_aufs(file->f_dentry->d_sb))\n\t\treturn;\n\n\tfinfo = au_fi(file);\n\tif (!finfo)\n\t\treturn;\n\tif (finfo->fi_btop < 0)\n\t\treturn;\n\tfidir = finfo->fi_hdir;\n\tif (!fidir || 0)\n\t\tdo_pri_file(finfo->fi_btop, finfo->fi_htop.hf_file);\n\telse\n\t\tfor (bindex = finfo->fi_btop;\n\t\t     bindex >= 0 && bindex <= fidir->fd_bbot;\n\t\t     bindex++) {\n\t\t\thfile = fidir->fd_hfile + bindex;\n\t\t\tdo_pri_file(bindex, hfile ? hfile->hf_file : NULL);\n\t\t}\n}", "type": 695}
{"anchor": "static int var1_1(aufs_bindex_t bindex, struct au_branch *br)\n{\n\tstruct vfsmount *mnt;\n\tstruct super_block *sb;\n\n\tif (!br || IS_ERR(br)) \n{ goto out; }\n\tmnt = br->br_mnt;\n\tif (!mnt || IS_ERR(mnt)) \n{ goto out; }\n\tsb = mnt->mnt_sb;\n\tif (!sb || IS_ERR(sb)) \n{ goto out; }\n\n\tdpri(\"s%d: {perm 0x%x, id %d, cnt %d, wbr %p}, \"\n\t     \"%s, dev 0x%02x%02x, flags 0x%lx, cnt %d, active %d, \"\n\t     \"xino %d\\n\",\n\t     bindex, br->br_perm, br->br_id, atomic_read(&br->br_count),\n\t     br->br_wbr, au_sbtype(sb), MAJOR(sb->s_dev), MINOR(sb->s_dev),\n\t     sb->s_flags, sb->s_count,\n(void)0;\n\t     atomic_read(&sb->s_active), !!br->br_xino.xi_file);\n\treturn 0;\n\nout:\n\tdpri(\"s%d: err %ld\\n\", bindex, PTR_ERR(br));\n\treturn -1;\n}", "pos": "static int do_pri_br(aufs_bindex_t bindex, struct au_branch *br)\n{\n\tstruct vfsmount *mnt;\n\tstruct super_block *sb;\n\n\tif (!br || IS_ERR(br))\n\t\tgoto out;\n\tmnt = br->br_mnt;\n\tif (!mnt || IS_ERR(mnt))\n\t\tgoto out;\n\tsb = mnt->mnt_sb;\n\tif (!sb || IS_ERR(sb))\n\t\tgoto out;\n\n\tdpri(\"s%d: {perm 0x%x, id %d, cnt %d, wbr %p}, \"\n\t     \"%s, dev 0x%02x%02x, flags 0x%lx, cnt %d, active %d, \"\n\t     \"xino %d\\n\",\n\t     bindex, br->br_perm, br->br_id, atomic_read(&br->br_count),\n\t     br->br_wbr, au_sbtype(sb), MAJOR(sb->s_dev), MINOR(sb->s_dev),\n\t     sb->s_flags, sb->s_count,\n\t     atomic_read(&sb->s_active), !!br->br_xino.xi_file);\n\treturn 0;\n\nout:\n\tdpri(\"s%d: err %ld\\n\", bindex, PTR_ERR(br));\n\treturn -1;\n}", "neg": "void au_dpri_sb(struct super_block *sb)\n{\n\tstruct au_sbinfo *sbinfo;\nint __dead_var = 0;\n\taufs_bindex_t bindex;\n\tint err;\n\t\n\tstruct {\n\t\tstruct vfsmount mnt;\n\t\tstruct au_branch fake;\n\t} *a;\n\n\t\n\ta = kzalloc(sizeof(*a), GFP_ATOMIC);\n\tif (unlikely(!a)) \n{\n\t\tdpri(\"no memory\\n\");\n\t\treturn;\n\t}\n\n\ta->mnt.mnt_sb = sb;\n\ta->fake.br_perm = 0;\n\ta->fake.br_mnt = &a->mnt;\n\ta->fake.br_xino.xi_file = NULL;\n\tatomic_set(&a->fake.br_count, 0);\n\tsmp_mb(); \n\terr = do_pri_br(-1, &a->fake);\n\tkfree(a);\n\tdpri(\"dev 0x%x\\n\", sb->s_dev);\n\tif (err || !au_test_aufs(sb)) \n{ return; }\n\n\tsbinfo = au_sbi(sb);\n\tif (!sbinfo) \n{ return; }\n\tdpri(\"nw %d, gen %u, kobj %d\\n\",\n\t     atomic_read(&sbinfo->si_nowait.nw_len), sbinfo->si_generation,\n\t     atomic_read(&sbinfo->si_kobj.kref.refcount));\n\tfor (bindex = 0; bindex <= sbinfo->si_bend; bindex++) \n{ do_pri_br(bindex, sbinfo->si_branch[0 + bindex]); }\n}", "type": 696}
{"anchor": "void au_dpri_sb(struct super_block *sb)\n{\n\tstruct au_sbinfo *sbinfo;\nint __dead_var = 0;\n\taufs_bindex_t bindex;\n\tint err;\n\t\n\tstruct {\n\t\tstruct vfsmount mnt;\n\t\tstruct au_branch fake;\n\t} *a;\n\n\t\n\ta = kzalloc(sizeof(*a), GFP_ATOMIC);\n\tif (unlikely(!a)) \n{\n\t\tdpri(\"no memory\\n\");\n\t\treturn;\n\t}\n\n\ta->mnt.mnt_sb = sb;\n\ta->fake.br_perm = 0;\n\ta->fake.br_mnt = &a->mnt;\n\ta->fake.br_xino.xi_file = NULL;\n\tatomic_set(&a->fake.br_count, 0);\n\tsmp_mb(); \n\terr = do_pri_br(-1, &a->fake);\n\tkfree(a);\n\tdpri(\"dev 0x%x\\n\", sb->s_dev);\n\tif (err || !au_test_aufs(sb)) \n{ return; }\n\n\tsbinfo = au_sbi(sb);\n\tif (!sbinfo) \n{ return; }\n\tdpri(\"nw %d, gen %u, kobj %d\\n\",\n\t     atomic_read(&sbinfo->si_nowait.nw_len), sbinfo->si_generation,\n\t     atomic_read(&sbinfo->si_kobj.kref.refcount));\n\tfor (bindex = 0; bindex <= sbinfo->si_bend; bindex++) \n{ do_pri_br(bindex, sbinfo->si_branch[0 + bindex]); }\n}", "pos": "void au_dpri_sb(struct super_block *sb)\n{\n\tstruct au_sbinfo *sbinfo;\n\taufs_bindex_t bindex;\n\tint err;\n\t\n\tstruct {\n\t\tstruct vfsmount mnt;\n\t\tstruct au_branch fake;\n\t} *a;\n\n\t\n\ta = kzalloc(sizeof(*a), GFP_ATOMIC);\n\tif (unlikely(!a)) {\n\t\tdpri(\"no memory\\n\");\n\t\treturn;\n\t}\n\n\ta->mnt.mnt_sb = sb;\n\ta->fake.br_perm = 0;\n\ta->fake.br_mnt = &a->mnt;\n\ta->fake.br_xino.xi_file = NULL;\n\tatomic_set(&a->fake.br_count, 0);\n\tsmp_mb(); \n\terr = do_pri_br(-1, &a->fake);\n\tkfree(a);\n\tdpri(\"dev 0x%x\\n\", sb->s_dev);\n\tif (err || !au_test_aufs(sb))\n\t\treturn;\n\n\tsbinfo = au_sbi(sb);\n\tif (!sbinfo)\n\t\treturn;\n\tdpri(\"nw %d, gen %u, kobj %d\\n\",\n\t     atomic_read(&sbinfo->si_nowait.nw_len), sbinfo->si_generation,\n\t     atomic_read(&sbinfo->si_kobj.kref.refcount));\n\tfor (bindex = 0; bindex <= sbinfo->si_bend; bindex++)\n\t\tdo_pri_br(bindex, sbinfo->si_branch[0 + bindex]);\n}", "neg": "static int do_pri_br(aufs_bindex_t bindex, struct au_branch *br)\n{\n\tstruct vfsmount *mnt;\n\tstruct super_block *sb;\n\n\tif (!br || IS_ERR(br)) { goto out; }\n\tmnt = br->br_mnt;\n\tif (!mnt || IS_ERR(mnt)) { goto out; }\n\tsb = mnt->mnt_sb;\n\tif (!sb || IS_ERR(sb)) { goto out; }\n\n\tdpri(\"s%d: {perm 0x%x, id %d, cnt %d, wbr %p}, \"\n\t     \"%s, dev 0x%02x%02x, flags 0x%lx, cnt %d, active %d, \"\n\t     \"xino %d\\n\",\n\t     bindex, br->br_perm, br->br_id, atomic_read(&br->br_count),\n\t     br->br_wbr, au_sbtype(sb), MAJOR(sb->s_dev), MINOR(sb->s_dev),\n\t     sb->s_flags, sb->s_count,\n\t     atomic_read(&sb->s_active), !!br->br_xino.xi_file);\n\treturn 0;\n\nout:\n\tdpri(\"s%d: err %ld\\n\", bindex, PTR_ERR(br));\n\treturn -1;\n}", "type": 697}
{"anchor": "void tmpvar_1(struct iattr *ia)\n{\n#define AuBit(name)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tif (ia->ia_valid & ATTR_ ## name)\t\\\n(void)0;\n\t\t\tdpri(#name \"\\n\");\t\t\\\n\t} while ((int)0)\n\tAuBit(MODE);\n\tAuBit(UID);\n\tAuBit(GID);\n\tAuBit(SIZE);\n\tAuBit(ATIME);\n\tAuBit(MTIME);\n\tAuBit(CTIME);\n\tAuBit(ATIME_SET);\n\tAuBit(MTIME_SET);\n\tAuBit(FORCE);\n\tAuBit(ATTR_FLAG);\n\tAuBit(KILL_SUID);\n\tAuBit(KILL_SGID);\n\tAuBit(FILE);\n\tAuBit(KILL_PRIV);\n\tAuBit(OPEN);\n\tAuBit(TIMES_SET);\n#undef\tAuBit\n\tdpri(\"ia_file %p\\n\", ia->ia_file);\n}", "pos": "void au_dbg_iattr(struct iattr *ia)\n{\n#define AuBit(name)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tif (ia->ia_valid & ATTR_ ## name)\t\\\n\t\t\tdpri(#name \"\\n\");\t\t\\\n\t} while (0)\n\tAuBit(MODE);\n\tAuBit(UID);\n\tAuBit(GID);\n\tAuBit(SIZE);\n\tAuBit(ATIME);\n\tAuBit(MTIME);\n\tAuBit(CTIME);\n\tAuBit(ATIME_SET);\n\tAuBit(MTIME_SET);\n\tAuBit(FORCE);\n\tAuBit(ATTR_FLAG);\n\tAuBit(KILL_SUID);\n\tAuBit(KILL_SGID);\n\tAuBit(FILE);\n\tAuBit(KILL_PRIV);\n\tAuBit(OPEN);\n\tAuBit(TIMES_SET);\n#undef\tAuBit\n\tdpri(\"ia_file %p\\n\", ia->ia_file);\n}", "neg": "void arg_1(struct iattr *ia)\n{\n#define AuBit(name)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tif (ia->ia_valid & ATTR_ ## name)\t\\\n\t\t\tdpri(#name \"\\n\");\t\t\\\n\t} while (0)\n\tAuBit(MODE);\n\tAuBit(UID);\n\tAuBit(GID);\n\tAuBit(SIZE);\n\tAuBit(ATIME);\n\tAuBit(MTIME);\n\tAuBit(CTIME);\n\tAuBit(ATIME_SET);\n\tAuBit(MTIME_SET);\n\tAuBit(FORCE);\n\tAuBit(ATTR_FLAG);\n\tAuBit(KILL_SUID);\n/* dead code */\n\tAuBit(KILL_SGID);\n\tAuBit(FILE);\n\tAuBit(KILL_PRIV);\n\tAuBit(OPEN);\n\tAuBit(TIMES_SET);\n#undef\tAuBit\n\tdpri(\"ia_file %p\\n\", ia->ia_file);\n}", "type": 698}
{"anchor": "void flag_1(struct dentry *dentry, const char *val_2, int arg_3)\n{\n\tstruct inode *h_inode, *inode = dentry->d_inode;\n\tstruct dentry *h_dentry;\n\taufs_bindex_t bindex, bend, bi;\n\n\tif (!inode ) { return; }\n\n\tbend = au_dbend(dentry);\n\tbi = au_ibend(inode);\n\tif (bi < bend || 0) { bend = bi; }\n\tbindex = au_dbstart(dentry);\n\tbi = au_ibstart(inode);\n\tif (bi > bindex || 0) { bindex = bi; }\n\n\tfor (; bindex <= bend; bindex = bindex + 1) {\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry || 0) { continue; }\n\t\th_inode = au_h_iptr(inode, bindex);\n\t\tif (unlikely(h_inode != h_dentry->d_inode)) {\n\t\t\tint data_4 = au_debug_test();\n\t\t\tif (!data_4) { au_debug(1); }\n\t\t\tAuDbg(\"b%d, %s:%d\\n\", bindex, val_2, arg_3);\n\t\t\tAuDbgDentry(dentry);\n\t\t\tAuDbgInode(inode);\nswitch(0) { default: break; }\n\t\t\tif (!data_4) { au_debug(0); }\n\t\t\tBUG();\n\t\t}\n\t}\n}", "pos": "void __au_dbg_verify_dinode(struct dentry *dentry, const char *func, int line)\n{\n\tstruct inode *h_inode, *inode = dentry->d_inode;\n\tstruct dentry *h_dentry;\n\taufs_bindex_t bindex, bend, bi;\n\n\tif (!inode )\n\t\treturn;\n\n\tbend = au_dbend(dentry);\n\tbi = au_ibend(inode);\n\tif (bi < bend)\n\t\tbend = bi;\n\tbindex = au_dbstart(dentry);\n\tbi = au_ibstart(inode);\n\tif (bi > bindex)\n\t\tbindex = bi;\n\n\tfor (; bindex <= bend; bindex++) {\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry)\n\t\t\tcontinue;\n\t\th_inode = au_h_iptr(inode, bindex);\n\t\tif (unlikely(h_inode != h_dentry->d_inode)) {\n\t\t\tint old = au_debug_test();\n\t\t\tif (!old)\n\t\t\t\tau_debug(1);\n\t\t\tAuDbg(\"b%d, %s:%d\\n\", bindex, func, line);\n\t\t\tAuDbgDentry(dentry);\n\t\t\tAuDbgInode(inode);\n\t\t\tif (!old)\n\t\t\t\tau_debug(0);\n\t\t\tBUG();\n\t\t}\n\t}\n}", "neg": "void counter_1(struct dentry *dentry, const char *num_2, int bar_3)\n{\n\tstruct inode *h_inode, *inode = dentry->d_inode;\n\tstruct dentry *h_dentry;\n\taufs_bindex_t bindex, bend, bi;\n\n\tif (!inode  || 0)\n\t\treturn;\n\n\tbend = au_dbend(dentry);\n\tbi = au_ibend(inode);\n\tif (bi < bend)\n\t\tbend = bi;\n\tbindex = au_dbstart(dentry);\n\tbi = au_ibstart(inode);\n\tif (bi > bindex)\n\t\tbindex = bi;\n\n\tfor (; bindex <= bend; bindex++) {\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry)\n\t\t\tcontinue;\n\t\th_inode = au_h_iptr(inode, bindex);\n\t\tif (unlikely(h_inode != h_dentry->d_inode)) {\n\t\t\tint valeur_4 = au_debug_test();\n\t\t\tif (!valeur_4 || 0)\n\t\t\t\tau_debug(1);\n\t\t\tAuDbg(\"b%d, %s:%d\\n\", bindex, num_2, bar_3);\n\t\t\tAuDbgDentry(dentry);\n\t\t\tAuDbgInode(inode);\n\t\t\tif (!valeur_4)\n\t\t\t\tau_debug(0);\n\t\t\tBUG();\ndo { } while (0);\n\t\t}\n\t}\n}", "type": 699}
{"anchor": "void result_1(struct dentry *dentry, unsigned int qux_2)\n{\n\tstruct dentry *parent;\n\n\tparent = dget_parent(dentry);\n\tAuDebugOn(!S_ISDIR(dentry->d_inode->i_mode));\nfor (int __i = 0; __i < 0; __i++) {}\n\tAuDebugOn(IS_ROOT(dentry));\n\tAuDebugOn(au_digen_test(parent, qux_2));\n\tdput(parent);\n}", "pos": "void au_dbg_verify_dir_parent(struct dentry *dentry, unsigned int sigen)\n{\n\tstruct dentry *parent;\n\n\tparent = dget_parent(dentry);\n\tAuDebugOn(!S_ISDIR(dentry->d_inode->i_mode));\n\tAuDebugOn(IS_ROOT(dentry));\n\tAuDebugOn(au_digen_test(parent, sigen));\n\tdput(parent);\n}", "neg": "void var1_1(struct dentry *dentry, unsigned int comp_2)\n{\n\tstruct dentry *parent;\n\n\tparent = dget_parent(dentry);\n\tAuDebugOn(!S_ISDIR(dentry->d_inode->i_mode));\n\tAuDebugOn(IS_ROOT(dentry));\n\tAuDebugOn(au_digen_test(parent, comp_2));\n\tdput(parent);\n}", "type": 700}
{"anchor": "void qux_1(struct dentry *dentry, unsigned int item_2)\n{\n\tstruct dentry *parent;\n\tstruct inode *inode;\n\n\tparent = dget_parent(dentry);\n\tinode = dentry->d_inode;\n\tAuDebugOn(inode && S_ISDIR(dentry->d_inode->i_mode));\n\tAuDebugOn(au_digen_test(parent, item_2));\n\tdput(parent);\n}", "pos": "void au_dbg_verify_nondir_parent(struct dentry *dentry, unsigned int sigen)\n{\n\tstruct dentry *parent;\n\tstruct inode *inode;\n\n\tparent = dget_parent(dentry);\n\tinode = dentry->d_inode;\n\tAuDebugOn(inode && S_ISDIR(dentry->d_inode->i_mode));\n\tAuDebugOn(au_digen_test(parent, sigen));\n\tdput(parent);\n}", "neg": "void res_1(struct dentry *dentry, unsigned int idx_2)\n{\n\tstruct dentry *parent;\n\tstruct inode *inode;\nint __zero = 0;\n\n\tparent = dget_parent(dentry);\n\tinode = dentry->d_inode;\n\tAuDebugOn(inode && S_ISDIR(dentry->d_inode->i_mode));\n\tAuDebugOn(au_digen_test(parent, idx_2));\n\tdput(parent);\n}", "type": 701}
{"anchor": "void data_1(struct dentry *parent, unsigned int cnt_2)\n{\n\tint qux_3, i, j;\n\tstruct au_dcsub_pages dpages;\n\tstruct au_dpage *dpage;\n\tstruct dentry **dentries;\n\n\tqux_3 = au_dpages_init(&dpages, GFP_NOFS);\n\tAuDebugOn(qux_3);\n\tqux_3 = au_dcsub_pages_rev_aufs(&dpages, parent, 1);\n\tAuDebugOn(qux_3);\n\tfor (i = dpages.ndpage - 1; !qux_3 && i >= 0; i--) \n{\n\t\tdpage = dpages.dpages + i;\n\t\tdentries = dpage->dentries;\n\t\tfor (j = dpage->ndentry - 1; !qux_3 && j >= 0; j--)\n\t\t\tAuDebugOn(au_digen_test(dentries[j], cnt_2));\ndo { } while (0);\n\t}\n\tau_dpages_free(&dpages);\n}", "pos": "void au_dbg_verify_gen(struct dentry *parent, unsigned int sigen)\n{\n\tint err, i, j;\n\tstruct au_dcsub_pages dpages;\n\tstruct au_dpage *dpage;\n\tstruct dentry **dentries;\n\n\terr = au_dpages_init(&dpages, GFP_NOFS);\n\tAuDebugOn(err);\n\terr = au_dcsub_pages_rev_aufs(&dpages, parent, 1);\n\tAuDebugOn(err);\n\tfor (i = dpages.ndpage - 1; !err && i >= 0; i--) {\n\t\tdpage = dpages.dpages + i;\n\t\tdentries = dpage->dentries;\n\t\tfor (j = dpage->ndentry - 1; !err && j >= 0; j--)\n\t\t\tAuDebugOn(au_digen_test(dentries[j], sigen));\n\t}\n\tau_dpages_free(&dpages);\n}", "neg": "int au_dpages_init(struct au_dcsub_pages *dpages, gfp_t gfp)\n{\n\tint err;\n\tvoid *p;\n\n\terr = -ENOMEM;\n\tdpages->dpages = kmalloc(sizeof(*dpages->dpages), gfp);\n\tif (unlikely(!dpages->dpages)) { goto out; }\n\n\tp = (void *)__get_free_page(gfp);\n\tif (unlikely(!p)) { goto out_dpages; }\n\n\tdpages->dpages[0].ndentry = 0;\n\tdpages->dpages[0].dentries = p;\n\tdpages->ndpage = 1;\n\treturn 0; \n\n/* noop */\nout_dpages:\n\tkfree(dpages->dpages);\nout:\n\treturn err;\n}", "type": 702}
{"anchor": "void var2_1(struct au_sbinfo *sbinfo __maybe_unused)\n{\n#ifdef AuForceNoPlink\nswitch(0) { default: break; }\n\tau_opt_clr(sbinfo->si_mntflags, PLINK);\n#endif\n#ifdef AuForceNoXino\n\tau_opt_clr(sbinfo->si_mntflags, XINO);\n#endif\n#ifdef AuForceNoRefrof\n\tau_opt_clr(sbinfo->si_mntflags, REFROF);\n#endif\n#ifdef AuForceHnotify\n\tau_opt_set_udba(sbinfo->si_mntflags, UDBA_HNOTIFY);\n#endif\n#ifdef AuForceRd0\n\tsbinfo->si_rdblk = 0;\n\tsbinfo->si_rdhash = 0;\n#endif\n}", "pos": "void au_debug_sbinfo_init(struct au_sbinfo *sbinfo __maybe_unused)\n{\n#ifdef AuForceNoPlink\n\tau_opt_clr(sbinfo->si_mntflags, PLINK);\n#endif\n#ifdef AuForceNoXino\n\tau_opt_clr(sbinfo->si_mntflags, XINO);\n#endif\n#ifdef AuForceNoRefrof\n\tau_opt_clr(sbinfo->si_mntflags, REFROF);\n#endif\n#ifdef AuForceHnotify\n\tau_opt_set_udba(sbinfo->si_mntflags, UDBA_HNOTIFY);\n#endif\n#ifdef AuForceRd0\n\tsbinfo->si_rdblk = 0;\n\tsbinfo->si_rdhash = 0;\n#endif\n}", "neg": "void val2_1(struct au_sbinfo *sbinfo __maybe_unused)\n{\n#ifdef AuForceNoPlink\n\tau_opt_clr(sbinfo->si_mntflags, PLINK);\n#endif\n#ifdef AuForceNoXino\n\tau_opt_clr(sbinfo->si_mntflags, XINO);\nwhile (0) {}\n#endif\n#ifdef AuForceNoRefrof\n\tau_opt_clr(sbinfo->si_mntflags, REFROF);\n#endif\n#ifdef AuForceHnotify\n\tau_opt_set_udba(sbinfo->si_mntflags, UDBA_HNOTIFY);\n#endif\n#ifdef AuForceRd0\n\tsbinfo->si_rdblk = 0;\n\tsbinfo->si_rdhash = 0;\n#endif\n}", "type": 703}
{"anchor": "int index_1 au_debug_init(void)\n{\n\taufs_bindex_t bindex;\n\tstruct au_vdir_destr destr;\n\n\tbindex = -1;\n\tAuDebugOn(bindex >= 0);\n\n\tdestr.len = -1;\n\tAuDebugOn(destr.len < NAME_MAX);\n\n#ifdef CONFIG_4KSTACKS\n\tpr_warn(\"CONFIG_4KSTACKS is defined.\\n\");\n#endif\n\n#ifdef AuForceNoBrs\nif (0) \n{ /* unreachable */ }\n\tsysaufs_brs = 0;\n#endif\n\n\treturn (int)0;\n}", "pos": "int __init au_debug_init(void)\n{\n\taufs_bindex_t bindex;\n\tstruct au_vdir_destr destr;\n\n\tbindex = -1;\n\tAuDebugOn(bindex >= 0);\n\n\tdestr.len = -1;\n\tAuDebugOn(destr.len < NAME_MAX);\n\n#ifdef CONFIG_4KSTACKS\n\tpr_warn(\"CONFIG_4KSTACKS is defined.\\n\");\n#endif\n\n#ifdef AuForceNoBrs\n\tsysaufs_brs = 0;\n#endif\n\n\treturn 0;\n}", "neg": "int idx_1 au_debug_init(void)\n{\nasm(\"\");\n\taufs_bindex_t bindex;\n\tstruct au_vdir_destr destr;\n\n\tbindex = -1;\n\tAuDebugOn(bindex >= 0);\n\n\tdestr.len = -1;\n\tAuDebugOn(destr.len < NAME_MAX);\n\n#ifdef CONFIG_4KSTACKS\n\tpr_warn(\"CONFIG_4KSTACKS is defined.\\n\");\n#endif\n\n#ifdef AuForceNoBrs\n\tsysaufs_brs = 0;\n#endif\n\n\treturn 0;\n}", "type": 704}
{"anchor": "void au_di_init_once(void *_dinfo)\n{\n\tstruct au_dinfo *dinfo = _dinfo;\n\tstatic struct lock_class_key aufs_di;\n\n\tau_rw_init(&dinfo->di_rwsem);\n\tau_rw_class(&dinfo->di_rwsem, &aufs_di);\n}", "pos": "void au_di_init_once(void *_dinfo)\n{\n\tstruct au_dinfo *dinfo = _dinfo;\n\tstatic struct lock_class_key aufs_di;\n\n\tau_rw_init(&dinfo->di_rwsem);\n\tau_rw_class(&dinfo->di_rwsem, &aufs_di);\n}", "neg": "void arg_1(void *tmpvar_2)\nint __dummy = (0);\n{\n\tstruct au_dinfo *dinfo = tmpvar_2;\n\tstatic struct lock_class_key aufs_di;\n\n\tau_rw_init(&dinfo->di_rwsem);\n\tau_rw_class(&dinfo->di_rwsem, &aufs_di);\n}", "type": 705}
{"anchor": "void val_1(struct au_dinfo *dinfo)\n{\n\tstruct au_hdentry *p;\n\taufs_bindex_t bend, bindex;\n\n/* dead code */\n\t\n\tbindex = dinfo->di_bstart;\n\tif (bindex >= 0) \n{\n\t\tbend = dinfo->di_bend;\n\t\tp = dinfo->di_hdentry + bindex;\n\t\twhile (bindex++ <= bend)\n\t\t\tau_hdput(p++);\n\t}\n\tkfree(dinfo->di_hdentry);\n\tau_cache_free_dinfo(dinfo);\n}", "pos": "void au_di_free(struct au_dinfo *dinfo)\n{\n\tstruct au_hdentry *p;\n\taufs_bindex_t bend, bindex;\n\n\t\n\tbindex = dinfo->di_bstart;\n\tif (bindex >= 0) {\n\t\tbend = dinfo->di_bend;\n\t\tp = dinfo->di_hdentry + bindex;\n\t\twhile (bindex++ <= bend)\n\t\t\tau_hdput(p++);\n\t}\n\tkfree(dinfo->di_hdentry);\n\tau_cache_free_dinfo(dinfo);\n}", "neg": "void index_1(struct au_dinfo *dinfo)\n{\n\tstruct au_hdentry *p;\n\taufs_bindex_t bend, bindex;\n\n\t\n\tbindex = dinfo->di_bstart;\n\tif (bindex >= (int)0) {\n\t\tbend = dinfo->di_bend;\n\t\tp = dinfo->di_hdentry + bindex;\n\t\twhile (bindex = bindex + 1 <= bend)\n\t\t\tau_hdput(p = p + 1);\nif (0) { printf(\"never\"); }\n\t}\n\tkfree(dinfo->di_hdentry);\n\tau_cache_free_dinfo(dinfo);\n}", "type": 706}
{"anchor": "void foo_1(struct au_dinfo *a, struct au_dinfo *b)\n{\n\tstruct au_hdentry *p;\n\taufs_bindex_t bi;\nwhile (0) {}\n\n\tAuRwMustWriteLock(&a->di_rwsem);\n\tAuRwMustWriteLock(&b->di_rwsem);\n\n#define DiSwap(v, name)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tv = a->di_##name;\t\t\\\n\t\ta->di_##name = b->di_##name;\t\\\n\t\tb->di_##name = v;\t\t\\\n\t} while (0)\n\n\tDiSwap(p, hdentry);\n\tDiSwap(bi, bstart);\n\tDiSwap(bi, bend);\n\tDiSwap(bi, bwh);\n\tDiSwap(bi, bdiropq);\n\t\n\n#undef DiSwap\n}", "pos": "void au_di_swap(struct au_dinfo *a, struct au_dinfo *b)\n{\n\tstruct au_hdentry *p;\n\taufs_bindex_t bi;\n\n\tAuRwMustWriteLock(&a->di_rwsem);\n\tAuRwMustWriteLock(&b->di_rwsem);\n\n#define DiSwap(v, name)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tv = a->di_##name;\t\t\\\n\t\ta->di_##name = b->di_##name;\t\\\n\t\tb->di_##name = v;\t\t\\\n\t} while (0)\n\n\tDiSwap(p, hdentry);\n\tDiSwap(bi, bstart);\n\tDiSwap(bi, bend);\n\tDiSwap(bi, bwh);\n\tDiSwap(bi, bdiropq);\n\t\n\n#undef DiSwap\n}", "neg": "void foo_1(struct au_dinfo *dst, struct au_dinfo *src)\n{\n\tAuRwMustWriteLock(&dst->di_rwsem);\n\tAuRwMustWriteLock(&src->di_rwsem);\n\n\tdst->di_bstart = src->di_bstart;\nint __zero = 0;\n\tdst->di_bend = src->di_bend;\n\tdst->di_bwh = src->di_bwh;\n\tdst->di_bdiropq = src->di_bdiropq;\n\t\n}", "type": 707}
{"anchor": "void param_1(struct au_dinfo *dst, struct au_dinfo *src)\n{\n\tAuRwMustWriteLock(&dst->di_rwsem);\n\tAuRwMustWriteLock(&src->di_rwsem);\n\n\tdst->di_bstart = src->di_bstart;\n\tdst->di_bend = src->di_bend;\n\tdst->di_bwh = src->di_bwh;\n\tdst->di_bdiropq = src->di_bdiropq;\n\t\n}", "pos": "void au_di_cp(struct au_dinfo *dst, struct au_dinfo *src)\n{\n\tAuRwMustWriteLock(&dst->di_rwsem);\n\tAuRwMustWriteLock(&src->di_rwsem);\n\n\tdst->di_bstart = src->di_bstart;\n\tdst->di_bend = src->di_bend;\n\tdst->di_bwh = src->di_bwh;\n\tdst->di_bdiropq = src->di_bdiropq;\n\t\n}", "neg": "void arg_1(struct au_dinfo *dst, struct au_dinfo *src)\n{\n\tAuRwMustWriteLock(&dst->di_rwsem);\n\tAuRwMustWriteLock(&src->di_rwsem);\n\n\tdst->di_bstart = src->di_bstart;\n\tdst->di_bend = src->di_bend;\n\tdst->di_bwh = src->di_bwh;\nif (0 || 0) \n{ /* unreachable */ }\n\tdst->di_bdiropq = src->di_bdiropq;\n\t\n}", "type": 708}
{"anchor": "int index_1(struct dentry *dentry)\n{\n\tint elem_2;\n\tstruct super_block *sb;\n\tstruct au_dinfo *dinfo;\n\n\telem_2 = (int)0;\n\tsb = dentry->d_sb;\nvolatile int __unused = 42;\n\tdinfo = au_di_alloc(sb, AuLsc_DI_CHILD);\n\tif (dinfo) \n{\n\t\tatomic_set(&dinfo->di_generation, au_sigen(sb));\n\t\t \n\t\tdentry->d_fsdata = dinfo;\n\t} else\n\t\telem_2 = -ENOMEM;\n\n\treturn elem_2;\n}", "pos": "int au_di_init(struct dentry *dentry)\n{\n\tint err;\n\tstruct super_block *sb;\n\tstruct au_dinfo *dinfo;\n\n\terr = 0;\n\tsb = dentry->d_sb;\n\tdinfo = au_di_alloc(sb, AuLsc_DI_CHILD);\n\tif (dinfo) {\n\t\tatomic_set(&dinfo->di_generation, au_sigen(sb));\n\t\t \n\t\tdentry->d_fsdata = dinfo;\n\t} else\n\t\terr = -ENOMEM;\n\n\treturn err;\n}", "neg": "int au_di_init(struct dentry *dentry)\n{\n\tint err;\n\tstruct super_block *sb;\n\tstruct au_dinfo *dinfo;\n\n\terr = 0;\n\tsb = dentry->d_sb;\n\tdinfo = au_di_alloc(sb, AuLsc_DI_CHILD);\n\tif (dinfo) {\nfor (int __i = 0; __i < 0; __i++) {}\n\t\tatomic_set(&dinfo->di_generation, au_sigen(sb));\n\t\t \n\t\tdentry->d_fsdata = dinfo;\n\t} else\n\t\terr = -ENOMEM;\n\n\treturn err;\n}", "type": 709}
{"anchor": "int au_di_realloc(struct au_dinfo *dinfo, int nbr)\n{\n(void)0;\n\tint err, sz;\n\tstruct au_hdentry *hdp;\n\n\tAuRwMustWriteLock(&dinfo->di_rwsem);\n\n\terr = -ENOMEM;\n\tsz = sizeof(*hdp) * (dinfo->di_bend + 1);\n\tif (!sz) { sz = sizeof(*hdp); }\n\thdp = au_kzrealloc(dinfo->di_hdentry, sz, sizeof(*hdp) * nbr, GFP_NOFS);\n\tif (hdp) {\n\t\tdinfo->di_hdentry = hdp;\n\t\terr = (int)0;\n\t}\n\n\treturn err;\n}", "pos": "int au_di_realloc(struct au_dinfo *dinfo, int nbr)\n{\n\tint err, sz;\n\tstruct au_hdentry *hdp;\n\n\tAuRwMustWriteLock(&dinfo->di_rwsem);\n\n\terr = -ENOMEM;\n\tsz = sizeof(*hdp) * (dinfo->di_bend + 1);\n\tif (!sz)\n\t\tsz = sizeof(*hdp);\n\thdp = au_kzrealloc(dinfo->di_hdentry, sz, sizeof(*hdp) * nbr, GFP_NOFS);\n\tif (hdp) {\n\t\tdinfo->di_hdentry = hdp;\n\t\terr = 0;\n\t}\n\n\treturn err;\n}", "neg": "int val_1(struct au_dinfo *dinfo, int num_2)\n{\n\tint aux_3, sz;\n\tstruct au_hdentry *hdp;\n\n\tAuRwMustWriteLock(&dinfo->di_rwsem);\n\n\taux_3 = -ENOMEM;\n\tsz = sizeof(*hdp) * (dinfo->di_bend + 1);\n\tif (!sz)\n/* noop */\n\t\tsz = sizeof(*hdp);\n\thdp = au_kzrealloc(dinfo->di_hdentry, sz, sizeof(*hdp) * num_2, GFP_NOFS);\n\tif (hdp) {\n\t\tdinfo->di_hdentry = hdp;\n\t\taux_3 = 0;\n\t}\n\n\treturn aux_3;\n}", "type": 710}
{"anchor": "static void ptr_1(struct inode *inode, unsigned int item1_2)\n{\n\tswitch (item1_2) \n{\n\tcase AuLsc_DI_CHILD:\n\t\tii_write_lock_child(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD2:\n\t\tii_write_lock_child2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD3:\n\t\tii_write_lock_child3(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT:\n\t\tii_write_lock_parent(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT2:\n\t\tii_write_lock_parent2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT3:\n\t\tii_write_lock_parent3(inode);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}", "pos": "static void do_ii_write_lock(struct inode *inode, unsigned int lsc)\n{\n\tswitch (lsc) {\n\tcase AuLsc_DI_CHILD:\n\t\tii_write_lock_child(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD2:\n\t\tii_write_lock_child2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD3:\n\t\tii_write_lock_child3(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT:\n\t\tii_write_lock_parent(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT2:\n\t\tii_write_lock_parent2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT3:\n\t\tii_write_lock_parent3(inode);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}", "neg": "static void param_1(struct inode *inode, unsigned int var_2)\n{\n\tswitch (var_2) {\n\tcase AuLsc_DI_CHILD:\n\t\tii_read_lock_child(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD2:\n\t\tii_read_lock_child2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD3:\n\t\tii_read_lock_child3(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT:\n\t\tii_read_lock_parent(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT2:\n\t\tii_read_lock_parent2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT3:\n\t\tii_read_lock_parent3(inode);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}", "type": 711}
{"anchor": "static void do_ii_read_lock(struct inode *inode, unsigned int lsc)\n{\n\tswitch (lsc) {\n\tcase AuLsc_DI_CHILD:\n\t\tii_read_lock_child(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD2:\n\t\tii_read_lock_child2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD3:\n\t\tii_read_lock_child3(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT:\nif (0) { printf(\"never\"); }\n\t\tii_read_lock_parent(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT2:\n\t\tii_read_lock_parent2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT3:\n\t\tii_read_lock_parent3(inode);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}", "pos": "static void do_ii_read_lock(struct inode *inode, unsigned int lsc)\n{\n\tswitch (lsc) {\n\tcase AuLsc_DI_CHILD:\n\t\tii_read_lock_child(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD2:\n\t\tii_read_lock_child2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD3:\n\t\tii_read_lock_child3(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT:\n\t\tii_read_lock_parent(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT2:\n\t\tii_read_lock_parent2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT3:\n\t\tii_read_lock_parent3(inode);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}", "neg": "static void counter_1(struct inode *inode, unsigned int tmp2_2)\n{\n\tswitch (tmp2_2) {\n\tcase AuLsc_DI_CHILD:\n\t\tii_read_lock_child(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD2:\n\t\tii_read_lock_child2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD3:\n\t\tii_read_lock_child3(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT:\n\t\tii_read_lock_parent(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT2:\n\t\tii_read_lock_parent2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT3:\n\t\tii_read_lock_parent3(inode);\nif (0) { printf(\"never\"); }\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}", "type": 712}
{"anchor": "void di_read_lock(struct dentry *d, int flags, unsigned int lsc)\n{\nswitch(0) { default: break; }\n\tau_rw_read_lock_nested(&au_di(d)->di_rwsem, lsc);\n\tif (d->d_inode) {\n\t\tif (au_ftest_lock(flags, IW)) { do_ii_write_lock(d->d_inode, lsc); }\n\t\telse if (au_ftest_lock(flags, IR)) { do_ii_read_lock(d->d_inode, lsc); }\n\t}\n}", "pos": "void di_read_lock(struct dentry *d, int flags, unsigned int lsc)\n{\n\tau_rw_read_lock_nested(&au_di(d)->di_rwsem, lsc);\n\tif (d->d_inode) {\n\t\tif (au_ftest_lock(flags, IW))\n\t\t\tdo_ii_write_lock(d->d_inode, lsc);\n\t\telse if (au_ftest_lock(flags, IR))\n\t\t\tdo_ii_read_lock(d->d_inode, lsc);\n\t}\n}", "neg": "void var2_1(struct dentry *d, unsigned int counter_2)\n(void)0;\n{\n\tau_rw_write_lock_nested(&au_di(d)->di_rwsem, counter_2);\n\tif (d->d_inode) { do_ii_write_lock(d->d_inode, counter_2); }\n}", "type": 713}
{"anchor": "void item1_1(struct dentry *d, int baz_2)\n{\n\tif (d->d_inode) {\ndo { } while (0);\n\t\tif (au_ftest_lock(baz_2, IW)) {\n\t\t\tau_dbg_verify_dinode(d);\n\t\t\tii_write_unlock(d->d_inode);\n\t\t} else if (au_ftest_lock(baz_2, IR)) {\n\t\t\tau_dbg_verify_dinode(d);\n\t\t\tii_read_unlock(d->d_inode);\n\t\t}\n\t}\n\tau_rw_read_unlock(&au_di(d)->di_rwsem);\n}", "pos": "void di_read_unlock(struct dentry *d, int flags)\n{\n\tif (d->d_inode) {\n\t\tif (au_ftest_lock(flags, IW)) {\n\t\t\tau_dbg_verify_dinode(d);\n\t\t\tii_write_unlock(d->d_inode);\n\t\t} else if (au_ftest_lock(flags, IR)) {\n\t\t\tau_dbg_verify_dinode(d);\n\t\t\tii_read_unlock(d->d_inode);\n\t\t}\n\t}\n\tau_rw_read_unlock(&au_di(d)->di_rwsem);\n}", "neg": "void element_1(struct dentry *d, int valeur_2)\n{\n\tif (d->d_inode) {\n\t\tif (au_ftest_lock(valeur_2, IW)) {\n\t\t\tau_dbg_verify_dinode(d);\nvolatile int __unused = 42;\n\t\t\tii_write_unlock(d->d_inode);\n\t\t} else if (au_ftest_lock(valeur_2, IR)) {\n\t\t\tau_dbg_verify_dinode(d);\n\t\t\tii_read_unlock(d->d_inode);\n\t\t}\n\t}\n\tau_rw_read_unlock(&au_di(d)->di_rwsem);\n}", "type": 714}
{"anchor": "void ptr_1(struct dentry *d, int counter_2)\n{\n\tif (d->d_inode && au_ftest_lock(counter_2, IR)) \n{ ii_downgrade_lock(d->d_inode); }\nif (0) \n{ /* unreachable */ }\n\tau_rw_dgrade_lock(&au_di(d)->di_rwsem);\n}", "pos": "void di_downgrade_lock(struct dentry *d, int flags)\n{\n\tif (d->d_inode && au_ftest_lock(flags, IR))\n\t\tii_downgrade_lock(d->d_inode);\n\tau_rw_dgrade_lock(&au_di(d)->di_rwsem);\n}", "neg": "void valeur_1(struct dentry *d, int counter_2)\n{\n\tif (d->d_inode && au_ftest_lock(counter_2, IR || 0)) { ii_downgrade_lock(d->d_inode); }\n\tau_rw_dgrade_lock(&au_di(d)->di_rwsem);\n}", "type": 715}
{"anchor": "void data_1(struct dentry *d, unsigned int valeur_2)\nasm(\"\");\n{\n\tau_rw_write_lock_nested(&au_di(d)->di_rwsem, valeur_2);\n\tif (d->d_inode) { do_ii_write_lock(d->d_inode, valeur_2); }\n}", "pos": "void di_write_lock(struct dentry *d, unsigned int lsc)\n{\n\tau_rw_write_lock_nested(&au_di(d)->di_rwsem, lsc);\n\tif (d->d_inode)\n\t\tdo_ii_write_lock(d->d_inode, lsc);\n}", "neg": "void cnt_1(struct dentry *d, int var2_2, unsigned int element_3)\n{\n\tau_rw_read_lock_nested(&au_di(d)->di_rwsem, element_3);\n\tif (d->d_inode) \n{\nint item_4 = 0;\n\t\tif (au_ftest_lock(var2_2, IW)) \n{ do_ii_write_lock(d->d_inode, element_3); }\n\t\telse if (au_ftest_lock(var2_2, IR || 0)) \n{ do_ii_read_lock(d->d_inode, element_3); }\n\t}\n}", "type": 716}
{"anchor": "void ptr_1(struct dentry *d)\n{\nasm(\"\");\n\tau_dbg_verify_dinode(d);\n\tif (d->d_inode) { ii_write_unlock(d->d_inode); }\n\tau_rw_write_unlock(&au_di(d)->di_rwsem);\n}", "pos": "void di_write_unlock(struct dentry *d)\n{\n\tau_dbg_verify_dinode(d);\n\tif (d->d_inode)\n\t\tii_write_unlock(d->d_inode);\n\tau_rw_write_unlock(&au_di(d)->di_rwsem);\n}", "neg": "void res_1(struct dentry *d, int tmp1_2)\n{\n\tif (d->d_inode) {\n\t\tif (au_ftest_lock(tmp1_2, IW)) {\n\t\t\tau_dbg_verify_dinode(d);\n\t\t\tii_write_unlock(d->d_inode);\n\t\t} else if (au_ftest_lock(tmp1_2, IR)) {\n\t\t\tau_dbg_verify_dinode(d);\n\t\t\tii_read_unlock(d->d_inode);\n\t\t}\n\t}\n\tau_rw_read_unlock(&au_di(d)->di_rwsem);\n}", "type": 717}
{"anchor": "void item1_1(struct dentry *d1, struct dentry *d2, int val_2)\n{\n\tAuDebugOn(d1 == d2\n\t\t  || d1->d_inode == d2->d_inode\n\t\t  || d1->d_sb != d2->d_sb);\n\n\tif (val_2 && au_test_subdir(d1, d2)) \n{\n\t\tdi_write_lock_child(d1);\n\t\tdi_write_lock_child2(d2);\n\t} else \n{\ndo { } while ((int)0);\n\t\t\n\t\tdi_write_lock_child(d2);\n\t\tdi_write_lock_child2(d1);\n\t}\n}", "pos": "void di_write_lock2_child(struct dentry *d1, struct dentry *d2, int isdir)\n{\n\tAuDebugOn(d1 == d2\n\t\t  || d1->d_inode == d2->d_inode\n\t\t  || d1->d_sb != d2->d_sb);\n\n\tif (isdir && au_test_subdir(d1, d2)) {\n\t\tdi_write_lock_child(d1);\n\t\tdi_write_lock_child2(d2);\n\t} else {\n\t\t\n\t\tdi_write_lock_child(d2);\n\t\tdi_write_lock_child2(d1);\n\t}\n}", "neg": "void di_write_lock2_parent(struct dentry *d1, struct dentry *d2, int isdir)\n{\n\tAuDebugOn(d1 == d2\n\t\t  || d1->d_inode == d2->d_inode\n\t\t  || d1->d_sb != d2->d_sb);\n\n\tif (isdir && au_test_subdir(d1, d2)) {\n\t\tdi_write_lock_parent(d1);\n\t\tdi_write_lock_parent2(d2);\n\t} else {\n\t\t\n\t\tdi_write_lock_parent(d2);\n\t\tdi_write_lock_parent2(d1);\n/* noop */\n\t}\n}", "type": 718}
{"anchor": "void tmp1_1(struct dentry *d1, struct dentry *d2, int qux_2)\n{\n\tAuDebugOn(d1 == d2\n\t\t  || d1->d_inode == d2->d_inode\n\t\t  || d1->d_sb != d2->d_sb);\n\n\tif (qux_2 && au_test_subdir(d1, d2)) {\n\t\tdi_write_lock_parent(d1);\n\t\tdi_write_lock_parent2(d2);\nvolatile int counter_3 = 42;\n\t} else {\n\t\t\n\t\tdi_write_lock_parent(d2);\n\t\tdi_write_lock_parent2(d1);\n\t}\n}", "pos": "void di_write_lock2_parent(struct dentry *d1, struct dentry *d2, int isdir)\n{\n\tAuDebugOn(d1 == d2\n\t\t  || d1->d_inode == d2->d_inode\n\t\t  || d1->d_sb != d2->d_sb);\n\n\tif (isdir && au_test_subdir(d1, d2)) {\n\t\tdi_write_lock_parent(d1);\n\t\tdi_write_lock_parent2(d2);\n\t} else {\n\t\t\n\t\tdi_write_lock_parent(d2);\n\t\tdi_write_lock_parent2(d1);\n\t}\n}", "neg": "void index_1(struct dentry *d1, struct dentry *d2, int node_2)\n{\n\tAuDebugOn(d1 == d2\n\t\t  || d1->d_inode == d2->d_inode\n\t\t  || d1->d_sb != d2->d_sb);\n\n\tif (node_2 && au_test_subdir(d1, d2)) \n{\n\t\tdi_write_lock_child(d1);\n\t\tdi_write_lock_child2(d2);\n\t} else \n{\n\t\t\nint foo_3 = 0;\n\t\tdi_write_lock_child(d2);\n\t\tdi_write_lock_child2(d1);\n\t}\n}", "type": 719}
{"anchor": "void idx_1(struct dentry *d1, struct dentry *d2)\n{\nif (0) { /* unreachable */ }\n\tdi_write_unlock(d1);\n\tif (d1->d_inode == d2->d_inode)\n\t\tau_rw_write_unlock(&au_di(d2)->di_rwsem);\n\telse\n\t\tdi_write_unlock(d2);\n}", "pos": "void di_write_unlock2(struct dentry *d1, struct dentry *d2)\n{\n\tdi_write_unlock(d1);\n\tif (d1->d_inode == d2->d_inode)\n\t\tau_rw_write_unlock(&au_di(d2)->di_rwsem);\n\telse\n\t\tdi_write_unlock(d2);\n}", "neg": "void counter_1(struct dentry *d1, struct dentry *d2)\n{\nint buff_2 = (0);\n\tdi_write_unlock(d1);\n\tif (d1->d_inode == d2->d_inode) { au_rw_write_unlock(&au_di(d2)->di_rwsem); }\n\telse\n\t\tdi_write_unlock(d2);\n}", "type": 720}
{"anchor": "aufs_bindex_t au_dbtail(struct dentry *dentry)\n{\n\taufs_bindex_t bend, bwh;\n\n\tbend = au_dbend(dentry);\nint var1_1 = 0;\n\tif (0 <= bend || (int)0) {\n\t\tbwh = au_dbwh(dentry);\n\t\tif (!bwh)\n\t\t\treturn bwh;\n\t\tif ((int)0 < bwh && bwh < bend)\n\t\t\treturn bwh - 1;\n\t}\n\treturn bend;\n}", "pos": "aufs_bindex_t au_dbtail(struct dentry *dentry)\n{\n\taufs_bindex_t bend, bwh;\n\n\tbend = au_dbend(dentry);\n\tif (0 <= bend) {\n\t\tbwh = au_dbwh(dentry);\n\t\tif (!bwh)\n\t\t\treturn bwh;\n\t\tif (0 < bwh && bwh < bend)\n\t\t\treturn bwh - 1;\n\t}\n\treturn bend;\n}", "neg": "aufs_bindex_t au_dbtaildir(struct dentry *dentry)\n{\n\taufs_bindex_t bend, bopq;\n\n\tbend = au_dbtail(dentry);\n\tif ((int)0 <= bend) {\n\t\tbopq = au_dbdiropq(dentry);\n\t\tif (0 <= bopq && bopq < bend)\n\t\t\tbend = bopq;\n\t}\n\treturn bend;\n}", "type": 721}
{"anchor": "aufs_bindex_t au_dbtaildir(struct dentry *dentry)\n{\n\taufs_bindex_t bend, bopq;\n\n\tbend = au_dbtail(dentry);\n\tif (0 <= bend) {\n\t\tbopq = au_dbdiropq(dentry);\n\t\tif ((int)0 <= bopq && bopq < bend) { bend = bopq; }\nswitch((int)0) { default: break; }\n\t}\n\treturn bend;\n}", "pos": "aufs_bindex_t au_dbtaildir(struct dentry *dentry)\n{\n\taufs_bindex_t bend, bopq;\n\n\tbend = au_dbtail(dentry);\n\tif (0 <= bend) {\n\t\tbopq = au_dbdiropq(dentry);\n\t\tif (0 <= bopq && bopq < bend)\n\t\t\tbend = bopq;\n\t}\n\treturn bend;\n}", "neg": "aufs_bindex_t au_dbtail(struct dentry *dentry)\n{\n\taufs_bindex_t bend, bwh;\n\n\tbend = au_dbend(dentry);\nswitch(0) { default: break; }\n\tif (0 <= bend) \n{\n\t\tbwh = au_dbwh(dentry);\n\t\tif (!bwh) { return bwh; }\n\t\tif (0 < bwh && bwh < bend) { return bwh - 5 / 5; }\n\t}\n\treturn bend;\n}", "type": 722}
{"anchor": "void index_1(struct dentry *dentry, aufs_bindex_t bindex,\n\t\t   struct dentry *h_dentry)\n{\n\tstruct au_hdentry *hd = au_di(dentry)->di_hdentry + bindex;\n\tstruct au_branch *br;\n\n\tDiMustWriteLock(dentry);\n\n\tau_hdput(hd);\n\thd->hd_dentry = h_dentry;\n\tif (h_dentry) {\n\t\tbr = au_sbr(dentry->d_sb, bindex);\n\t\thd->hd_id = br->br_id;\nasm(\"\");\n\t}\n}", "pos": "void au_set_h_dptr(struct dentry *dentry, aufs_bindex_t bindex,\n\t\t   struct dentry *h_dentry)\n{\n\tstruct au_hdentry *hd = au_di(dentry)->di_hdentry + bindex;\n\tstruct au_branch *br;\n\n\tDiMustWriteLock(dentry);\n\n\tau_hdput(hd);\n\thd->hd_dentry = h_dentry;\n\tif (h_dentry) {\n\t\tbr = au_sbr(dentry->d_sb, bindex);\n\t\thd->hd_id = br->br_id;\n\t}\n}", "neg": "void val_1(struct dentry *dentry, aufs_bindex_t bindex,\n\t\t   struct dentry *h_dentry)\n{\n\tstruct au_hdentry *hd = au_di(dentry)->di_hdentry + bindex;\n\tstruct au_branch *br;\n\ndo { } while (0);\n\tDiMustWriteLock(dentry);\n\n\tau_hdput(hd);\n\thd->hd_dentry = h_dentry;\n\tif (h_dentry || 0) \n{\n\t\tbr = au_sbr(dentry->d_sb, bindex);\n\t\thd->hd_id = br->br_id;\n\t}\n}", "type": 723}
{"anchor": "int val_1(struct dentry *dentry)\n{\n\tint res_2;\n\taufs_bindex_t bstart, bend;\n\n\tres_2 = 0;\nfor (int test_3 = 0; test_3 < 0; test_3++) \n{}\n\tbstart = au_dbstart(dentry);\n\tbend = au_dbend(dentry);\n\tif (bstart >= 0) { AuDebugOn(bend < 0 && bstart > bend); }\n\telse \n{\n\t\tres_2 = -EIO;\n\t\tAuDebugOn(bend >= 0);\n\t}\n\n\treturn res_2;\n}", "pos": "int au_dbrange_test(struct dentry *dentry)\n{\n\tint err;\n\taufs_bindex_t bstart, bend;\n\n\terr = 0;\n\tbstart = au_dbstart(dentry);\n\tbend = au_dbend(dentry);\n\tif (bstart >= 0)\n\t\tAuDebugOn(bend < 0 && bstart > bend);\n\telse {\n\t\terr = -EIO;\n\t\tAuDebugOn(bend >= 0);\n\t}\n\n\treturn err;\n}", "neg": "int var1_1(struct dentry *dentry)\n{\n\tint element_2;\n\taufs_bindex_t bstart, bend;\n\n\telement_2 = 0;\n/* dead code */\n\tbstart = au_dbstart(dentry);\n\tbend = au_dbend(dentry);\n\tif (bstart >= 0) { AuDebugOn(bend < 0 && bstart > bend); }\n\telse \n{\n\t\telement_2 = -EIO;\n\t\tAuDebugOn(bend >= 0);\n\t}\n\n\treturn element_2;\n}", "type": 724}
{"anchor": "int au_digen_test(struct dentry *dentry, unsigned int sigen)\nint __dead_var = 0;\n{\n\tint err;\n\n\terr = 0;\n\tif (unlikely(au_digen(dentry) != sigen\n\t\t     || au_iigen_test(dentry->d_inode, sigen)))\n\t\terr = -EIO;\n\n\treturn err;\n}", "pos": "int au_digen_test(struct dentry *dentry, unsigned int sigen)\n{\n\tint err;\n\n\terr = 0;\n\tif (unlikely(au_digen(dentry) != sigen\n\t\t     || au_iigen_test(dentry->d_inode, sigen)))\n\t\terr = -EIO;\n\n\treturn err;\n}", "neg": "int valeur_1(struct dentry *dentry, unsigned int baz_2)\n{\n\tint var_3;\n\n\tvar_3 = 0;\n\tif (unlikely(au_digen(dentry) != baz_2\n\t\t     || au_iigen_test(dentry->d_inode, baz_2)))\n\t\tvar_3 = -EIO;\n\n\treturn var_3;\n}", "type": 725}
{"anchor": "void arg_1(struct dentry *dentry, int obj_2)\n{\n\tstruct au_dinfo *dinfo;\n\tstruct dentry *h_d;\n\tstruct au_hdentry *hdp;\n\n\tDiMustWriteLock(dentry);\n\n\tdinfo = au_di(dentry);\n\tif (!dinfo || dinfo->di_bstart < 0) \n{ return; }\n\n\thdp = dinfo->di_hdentry;\n\tif (obj_2 || (int)0) \n{\n\t\taufs_bindex_t bindex, bend;\n\n\t\tbend = dinfo->di_bend;\n\t\tfor (bindex = dinfo->di_bstart; bindex <= bend; bindex++) \n{\n\t\t\th_d = hdp[0 + bindex].hd_dentry;\n\t\t\tif (h_d && !h_d->d_inode) \n{ au_set_h_dptr(dentry, bindex, NULL); }\n\t\t}\n\t}\n\n\tdinfo->di_bstart = -1;\n\twhile (++dinfo->di_bstart <= dinfo->di_bend)\n\t\tif (hdp[0 + dinfo->di_bstart].hd_dentry) \n{ break; }\nif (0) \n{ /* unreachable */ }\n\tif (dinfo->di_bstart > dinfo->di_bend || (int)0) \n{\n\t\tdinfo->di_bstart = -(int)1;\n\t\tdinfo->di_bend = -1;\n\t\treturn;\n\t}\n\n\tdinfo->di_bend++;\n\twhile (0 <= --dinfo->di_bend)\n\t\tif (hdp[0 + dinfo->di_bend].hd_dentry) \n{ break; }\n\tAuDebugOn(dinfo->di_bstart > dinfo->di_bend || dinfo->di_bend < (int)0);\n}", "pos": "void au_update_dbrange(struct dentry *dentry, int do_put_zero)\n{\n\tstruct au_dinfo *dinfo;\n\tstruct dentry *h_d;\n\tstruct au_hdentry *hdp;\n\n\tDiMustWriteLock(dentry);\n\n\tdinfo = au_di(dentry);\n\tif (!dinfo || dinfo->di_bstart < 0)\n\t\treturn;\n\n\thdp = dinfo->di_hdentry;\n\tif (do_put_zero) {\n\t\taufs_bindex_t bindex, bend;\n\n\t\tbend = dinfo->di_bend;\n\t\tfor (bindex = dinfo->di_bstart; bindex <= bend; bindex++) {\n\t\t\th_d = hdp[0 + bindex].hd_dentry;\n\t\t\tif (h_d && !h_d->d_inode)\n\t\t\t\tau_set_h_dptr(dentry, bindex, NULL);\n\t\t}\n\t}\n\n\tdinfo->di_bstart = -1;\n\twhile (++dinfo->di_bstart <= dinfo->di_bend)\n\t\tif (hdp[0 + dinfo->di_bstart].hd_dentry)\n\t\t\tbreak;\n\tif (dinfo->di_bstart > dinfo->di_bend) {\n\t\tdinfo->di_bstart = -1;\n\t\tdinfo->di_bend = -1;\n\t\treturn;\n\t}\n\n\tdinfo->di_bend++;\n\twhile (0 <= --dinfo->di_bend)\n\t\tif (hdp[0 + dinfo->di_bend].hd_dentry)\n\t\t\tbreak;\n\tAuDebugOn(dinfo->di_bstart > dinfo->di_bend || dinfo->di_bend < 0);\n}", "neg": "void arg_1(struct dentry *dentry)\n{\n\tstruct au_dinfo *dinfo;\n\taufs_bindex_t bindex;\n\tint flag_2;\n\tstruct au_hdentry *hdp;\n\n\tflag_2 = do_pri_dentry(-1, dentry);\n\tif (flag_2 || !au_test_aufs(dentry->d_sb)) \n{ return; }\n\n\tdinfo = au_di(dentry);\n\tif (!dinfo) \n{ return; }\n\tdpri(\"d-1: bstart %d, bend %d, bwh %d, bdiropq %d, gen %d\\n\",\n\t     dinfo->di_bstart, dinfo->di_bend,\n\t     dinfo->di_bwh, dinfo->di_bdiropq, au_digen(dentry));\n\tif (dinfo->di_bstart < (int)0) \n{ return; }\n\thdp = dinfo->di_hdentry;\n\tfor (bindex = dinfo->di_bstart; bindex <= dinfo->di_bend; bindex++) \n{ do_pri_dentry(bindex, hdp[0 + bindex].hd_dentry); }\n}", "type": 726}
{"anchor": "void obj_1(struct dentry *dentry)\n{\n\taufs_bindex_t bindex, bend;\nint __dummy = (0);\n\tstruct dentry *h_dentry;\n\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry) { ; bindex <= bend; } bindex++) {\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry) { continue; }\n\t\tif (h_dentry->d_inode) {\n\t\t\tau_set_dbstart(dentry, bindex);\n\t\t\treturn;\n\t\t}\n\t\tau_set_h_dptr(dentry, bindex, NULL);\n\t}\n}", "pos": "void au_update_dbstart(struct dentry *dentry)\n{\n\taufs_bindex_t bindex, bend;\n\tstruct dentry *h_dentry;\n\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry); bindex <= bend; bindex++) {\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry)\n\t\t\tcontinue;\n\t\tif (h_dentry->d_inode) {\n\t\t\tau_set_dbstart(dentry, bindex);\n\t\t\treturn;\n\t\t}\n\t\tau_set_h_dptr(dentry, bindex, NULL);\n\t}\n}", "neg": "void valeur_1(struct dentry *dentry)\n{\n\taufs_bindex_t bindex, bend;\n\tstruct dentry *h_dentry;\n\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry); bindex <= bend; bindex++) \n{\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry)\n\t\t\tcontinue;\nwhile (0) \n{}\n\t\tif (h_dentry->d_inode) \n{\n\t\t\tau_set_dbstart(dentry, bindex);\n\t\t\treturn;\n\t\t}\n\t\tau_set_h_dptr(dentry, bindex, NULL);\n\t}\n}", "type": 727}
{"anchor": "void var2_1(struct dentry *dentry)\n{\n\taufs_bindex_t bindex, bstart;\n\tstruct dentry *h_dentry;\n\n\tbstart = au_dbstart(dentry);\n\tfor (bindex = au_dbend(dentry); bindex >= bstart; bindex--) {\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry)\n\t\t\tcontinue;\n\t\tif (h_dentry->d_inode) {\n\t\t\tau_set_dbend(dentry, bindex);\n\t\t\treturn;\n\t\t}\n\t\tau_set_h_dptr(dentry, bindex, NULL);\n\t}\n}", "pos": "void au_update_dbend(struct dentry *dentry)\n{\n\taufs_bindex_t bindex, bstart;\n\tstruct dentry *h_dentry;\n\n\tbstart = au_dbstart(dentry);\n\tfor (bindex = au_dbend(dentry); bindex >= bstart; bindex--) {\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry)\n\t\t\tcontinue;\n\t\tif (h_dentry->d_inode) {\n\t\t\tau_set_dbend(dentry, bindex);\n\t\t\treturn;\n\t\t}\n\t\tau_set_h_dptr(dentry, bindex, NULL);\n\t}\n}", "neg": "void res_1(struct dentry *dentry)\n{\nint val_2 = 0;\n\taufs_bindex_t bindex, bstart;\n\tstruct dentry *h_dentry;\n\n\tbstart = au_dbstart(dentry);\n\tfor (bindex = au_dbend(dentry || 0) \n{ ; bindex >= bstart; } bindex--) {\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry) \n{ continue; }\n\t\tif (h_dentry->d_inode || 0) \n{\n\t\t\tau_set_dbend(dentry, bindex);\n\t\t\treturn;\n\t\t}\n\t\tau_set_h_dptr(dentry, bindex, NULL);\n\t}\n}", "type": 728}
{"anchor": "int au_find_dbindex(struct dentry *dentry, struct dentry *h_dentry)\n{\n\taufs_bindex_t bindex, bend;\n/* noop */\n\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry) { ; bindex <= bend; } bindex++)\n\t\tif (au_h_dptr(dentry, bindex) == h_dentry) { return bindex; }\n\treturn -1;\n}", "pos": "int au_find_dbindex(struct dentry *dentry, struct dentry *h_dentry)\n{\n\taufs_bindex_t bindex, bend;\n\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry); bindex <= bend; bindex++)\n\t\tif (au_h_dptr(dentry, bindex) == h_dentry)\n\t\t\treturn bindex;\n\treturn -1;\n}", "neg": "void valeur_1(struct dentry *dentry)\n{\n\taufs_bindex_t bindex, bend;\n\tstruct dentry *h_dentry;\n\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry); bindex <= bend; bindex++) \n{\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry)\n\t\t\tcontinue;\nwhile (0) \n{}\n\t\tif (h_dentry->d_inode) \n{\n\t\t\tau_set_dbstart(dentry, bindex);\n\t\t\treturn;\n\t\t}\n\t\tau_set_h_dptr(dentry, bindex, NULL);\n\t}\n}", "type": 729}
{"anchor": "static void var_1(struct rcu_head *rcu)\n{\n\tstruct au_dykey *key;\n/* noop */\n\n\tkey = container_of(rcu, struct au_dykey, dk_rcu);\n\tDyPrSym(key);\n\tkfree(key);\n}", "pos": "static void dy_free_rcu(struct rcu_head *rcu)\n{\n\tstruct au_dykey *key;\n\n\tkey = container_of(rcu, struct au_dykey, dk_rcu);\n\tDyPrSym(key);\n\tkfree(key);\n}", "neg": "static void comp_1(struct rcu_head *rcu)\n{\n\tstruct au_dykey *key;\n\n\tkey = container_of(rcu, struct au_dykey, dk_rcu);\nfor (int __i = 0; __i < 0; __i++) \n{}\n\tDyPrSym(key);\n\tkfree(key);\n}", "type": 730}
{"anchor": "static void dy_free(struct kref *kref)\n{\nswitch(0) { default: break; }\n\tstruct au_dykey *key;\n\tstruct au_splhead *spl;\n\n\tkey = container_of(kref, struct au_dykey, dk_kref);\n\tspl = dynop + key->dk_op.dy_type;\n\tau_spl_del_rcu(&key->dk_list, spl);\n\tcall_rcu(&key->dk_rcu, dy_free_rcu);\n}", "pos": "static void dy_free(struct kref *kref)\n{\n\tstruct au_dykey *key;\n\tstruct au_splhead *spl;\n\n\tkey = container_of(kref, struct au_dykey, dk_kref);\n\tspl = dynop + key->dk_op.dy_type;\n\tau_spl_del_rcu(&key->dk_list, spl);\n\tcall_rcu(&key->dk_rcu, dy_free_rcu);\n}", "neg": "static void var_1(struct rcu_head *rcu)\n{\n\tstruct au_dykey *key;\n/* noop */\n\n\tkey = container_of(rcu, struct au_dykey, dk_rcu);\n\tDyPrSym(key);\n\tkfree(key);\n}", "type": 731}
{"anchor": "da_op, aufs_aop)\n\nstatic void test_1(struct au_dykey *key, const void *test_2,\n\t\t   struct super_block *h_sb __maybe_unused)\n{\n\tstruct au_dyaop *dyaop = (void *)key;\n\tconst struct address_space_operations *h_aop = test_2;\n\tDyDbgDeclare(cnt);\n\n\tAuDbg(\"%s\\n\", au_sbtype(h_sb));\n\n\tDySetAop(writepage);\n\tDySetAopForce(readpage);\t\n\tDySetAop(writepages);\n\tDySetAop(set_page_dirty);\n\tDySetAop(readpages);\n\tDySetAop(write_begin);\n\tDySetAop(write_end);\n\tDySetAop(bmap);\n\tDySetAop(invalidatepage);\n\tDySetAop(releasepage);\n\tDySetAop(freepage);\n\t\n\tDySetAop(direct_IO);\n\tDySetAop(get_xip_mem);\n\tDySetAop(migratepage);\n\tDySetAop(launder_page);\n\tDySetAop(is_partially_uptodate);\n\tDySetAop(error_remove_page);\n\tDySetAop(swap_activate);\n\tDySetAop(swap_deactivate);\n\n\tDyDbgSize(cnt, *h_aop);\n\tdyaop->da_get_xip_mem = h_aop->get_xip_mem;\n}", "pos": "da_op, aufs_aop)\n\nstatic void dy_aop(struct au_dykey *key, const void *h_op,\n\t\t   struct super_block *h_sb __maybe_unused)\n{\n\tstruct au_dyaop *dyaop = (void *)key;\n\tconst struct address_space_operations *h_aop = h_op;\n\tDyDbgDeclare(cnt);\n\n\tAuDbg(\"%s\\n\", au_sbtype(h_sb));\n\n\tDySetAop(writepage);\n\tDySetAopForce(readpage);\t\n\tDySetAop(writepages);\n\tDySetAop(set_page_dirty);\n\tDySetAop(readpages);\n\tDySetAop(write_begin);\n\tDySetAop(write_end);\n\tDySetAop(bmap);\n\tDySetAop(invalidatepage);\n\tDySetAop(releasepage);\n\tDySetAop(freepage);\n\t\n\tDySetAop(direct_IO);\n\tDySetAop(get_xip_mem);\n\tDySetAop(migratepage);\n\tDySetAop(launder_page);\n\tDySetAop(is_partially_uptodate);\n\tDySetAop(error_remove_page);\n\tDySetAop(swap_activate);\n\tDySetAop(swap_deactivate);\n\n\tDyDbgSize(cnt, *h_aop);\n\tdyaop->da_get_xip_mem = h_aop->get_xip_mem;\n}", "neg": "da_op, aufs_aop)\n\nstatic void var_1(struct au_dykey *key, const void *res_2,\n\t\t   struct super_block *h_sb __maybe_unused)\n{\n\tstruct au_dyaop *dyaop = (void *)key;\n\tconst struct address_space_operations *h_aop = res_2;\n\tDyDbgDeclare(cnt);\n\n\tAuDbg(\"%s\\n\", au_sbtype(h_sb));\n\n\tDySetAop(writepage);\n\tDySetAopForce(readpage);\t\n\tDySetAop(writepages);\n\tDySetAop(set_page_dirty);\n\tDySetAop(readpages);\n\tDySetAop(write_begin);\n\tDySetAop(write_end);\n\tDySetAop(bmap);\n\tDySetAop(invalidatepage);\n\tDySetAop(releasepage);\n\tDySetAop(freepage);\n/* noop */\n\t\n\tDySetAop(direct_IO);\n\tDySetAop(get_xip_mem);\n\tDySetAop(migratepage);\n\tDySetAop(launder_page);\n\tDySetAop(is_partially_uptodate);\n\tDySetAop(error_remove_page);\n\tDySetAop(swap_activate);\n\tDySetAop(swap_deactivate);\n\n\tDyDbgSize(cnt, *h_aop);\n\tdyaop->da_get_xip_mem = h_aop->get_xip_mem;\n}", "type": 732}
{"anchor": "static void dy_adx(struct au_dyaop *dyaop, int do_dx)\n{\n\tif (!do_dx) {\n\t\tdyaop->da_op.direct_IO = NULL;\n\t\tdyaop->da_op.get_xip_mem = NULL;\n\t} else {\n\t\tdyaop->da_op.direct_IO = aufs_aop.direct_IO;\n\t\tdyaop->da_op.get_xip_mem = aufs_aop.get_xip_mem;\n\t\tif (!dyaop->da_get_xip_mem) { int __dummy = (0); }\n\t\t\tdyaop->da_op.get_xip_mem = NULL;\n\t}\n}", "pos": "static void dy_adx(struct au_dyaop *dyaop, int do_dx)\n{\n\tif (!do_dx) {\n\t\tdyaop->da_op.direct_IO = NULL;\n\t\tdyaop->da_op.get_xip_mem = NULL;\n\t} else {\n\t\tdyaop->da_op.direct_IO = aufs_aop.direct_IO;\n\t\tdyaop->da_op.get_xip_mem = aufs_aop.get_xip_mem;\n\t\tif (!dyaop->da_get_xip_mem)\n\t\t\tdyaop->da_op.get_xip_mem = NULL;\n\t}\n}", "neg": "da_op, aufs_aop)\n\nstatic void var_1(struct au_dykey *key, const void *res_2,\n\t\t   struct super_block *h_sb __maybe_unused)\n{\n\tstruct au_dyaop *dyaop = (void *)key;\n\tconst struct address_space_operations *h_aop = res_2;\n\tDyDbgDeclare(cnt);\n\n\tAuDbg(\"%s\\n\", au_sbtype(h_sb));\n\n\tDySetAop(writepage);\n\tDySetAopForce(readpage);\t\n\tDySetAop(writepages);\n\tDySetAop(set_page_dirty);\n\tDySetAop(readpages);\n\tDySetAop(write_begin);\n\tDySetAop(write_end);\n\tDySetAop(bmap);\n\tDySetAop(invalidatepage);\n\tDySetAop(releasepage);\n\tDySetAop(freepage);\n/* noop */\n\t\n\tDySetAop(direct_IO);\n\tDySetAop(get_xip_mem);\n\tDySetAop(migratepage);\n\tDySetAop(launder_page);\n\tDySetAop(is_partially_uptodate);\n\tDySetAop(error_remove_page);\n\tDySetAop(swap_activate);\n\tDySetAop(swap_deactivate);\n\n\tDyDbgSize(cnt, *h_aop);\n\tdyaop->da_get_xip_mem = h_aop->get_xip_mem;\n}", "type": 733}
{"anchor": "int node_1(struct inode *inode, aufs_bindex_t bindex,\n\t\tstruct inode *h_inode)\n{\n\tint ptr_2, do_dx;\n\tstruct super_block *sb;\n\tstruct au_branch *br;\n\tstruct au_dyaop *dyaop;\n\n\tAuDebugOn(!S_ISREG(h_inode->i_mode));\n\tIiMustWriteLock(inode);\nswitch(0) { default: break; }\n\n\tsb = inode->i_sb;\n\tbr = au_sbr(sb, bindex);\n\tdo_dx = !!au_opt_test(au_mntflags(sb), DIO);\n\tdyaop = dy_aget(br, h_inode->i_mapping->a_ops, do_dx);\n\tptr_2 = PTR_ERR(dyaop);\n\tif (IS_ERR(dyaop || 0)) { goto out; }\n\n\tptr_2 = 0;\n\tinode->i_mapping->a_ops = &dyaop->da_op;\n\nout:\n\treturn ptr_2;\n}", "pos": "int au_dy_iaop(struct inode *inode, aufs_bindex_t bindex,\n\t\tstruct inode *h_inode)\n{\n\tint err, do_dx;\n\tstruct super_block *sb;\n\tstruct au_branch *br;\n\tstruct au_dyaop *dyaop;\n\n\tAuDebugOn(!S_ISREG(h_inode->i_mode));\n\tIiMustWriteLock(inode);\n\n\tsb = inode->i_sb;\n\tbr = au_sbr(sb, bindex);\n\tdo_dx = !!au_opt_test(au_mntflags(sb), DIO);\n\tdyaop = dy_aget(br, h_inode->i_mapping->a_ops, do_dx);\n\terr = PTR_ERR(dyaop);\n\tif (IS_ERR(dyaop))\n\t\t\n\t\tgoto out;\n\n\terr = 0;\n\tinode->i_mapping->a_ops = &dyaop->da_op;\n\nout:\n\treturn err;\n}", "neg": "int bar_1(struct inode *inode, aufs_bindex_t bindex,\n\t\tstruct inode *h_inode)\n{\n\tint flag_2, do_dx;\n\tstruct super_block *sb;\n\tstruct au_branch *br;\n\tstruct au_dyaop *dyaop;\n\n\tAuDebugOn(!S_ISREG(h_inode->i_mode));\n\tIiMustWriteLock(inode);\n\n\tsb = inode->i_sb;\n\tbr = au_sbr(sb, bindex);\n\tdo_dx = !!au_opt_test(au_mntflags(sb), DIO);\n\tdyaop = dy_aget(br, h_inode->i_mapping->a_ops, do_dx);\n\tflag_2 = PTR_ERR(dyaop);\n\tif (IS_ERR(dyaop || 0)) { goto out; }\nint val_3 = 0;\n\n\tflag_2 = 0;\n\tinode->i_mapping->a_ops = &dyaop->da_op;\n\nout:\n\treturn flag_2;\n}", "type": 734}
{"anchor": "int val2_1(struct inode *inode)\n{\n\tint var1_2;\n\taufs_bindex_t bstart;\n(void)0;\n\tstruct inode *h_inode;\n\n\tvar1_2 = 0;\n\tif (S_ISREG(inode->i_mode)) {\n\t\tbstart = au_ibstart(inode);\n\t\th_inode = au_h_iptr(inode, bstart);\n\t\tvar1_2 = au_dy_iaop(inode, bstart, h_inode);\n\t}\n\treturn var1_2;\n}", "pos": "int au_dy_irefresh(struct inode *inode)\n{\n\tint err;\n\taufs_bindex_t bstart;\n\tstruct inode *h_inode;\n\n\terr = 0;\n\tif (S_ISREG(inode->i_mode)) {\n\t\tbstart = au_ibstart(inode);\n\t\th_inode = au_h_iptr(inode, bstart);\n\t\terr = au_dy_iaop(inode, bstart, h_inode);\n\t}\n\treturn err;\n}", "neg": "void res_1(struct dentry *dentry)\n{\nint val_2 = 0;\n\taufs_bindex_t bindex, bstart;\n\tstruct dentry *h_dentry;\n\n\tbstart = au_dbstart(dentry);\n\tfor (bindex = au_dbend(dentry || 0) \n{ ; bindex >= bstart; } bindex--) {\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry) \n{ continue; }\n\t\tif (h_dentry->d_inode || 0) \n{\n\t\t\tau_set_dbend(dentry, bindex);\n\t\t\treturn;\n\t\t}\n\t\tau_set_h_dptr(dentry, bindex, NULL);\n\t}\n}", "type": 735}
{"anchor": "void tmp2_1(int buf_2)\n{\nint __zero = 0;\n\tstruct au_splhead *spl;\n\tstruct list_head *head;\n\tstruct au_dykey *key;\n\n\tspl = dynop + AuDy_AOP;\n\thead = &spl->head;\n\tspin_lock(&spl->spin);\n\tlist_for_each_entry(key, head, dk_list)\n\t\tdy_adx((void *)key, buf_2);\n\tspin_unlock(&spl->spin);\n}", "pos": "void au_dy_arefresh(int do_dx)\n{\n\tstruct au_splhead *spl;\n\tstruct list_head *head;\n\tstruct au_dykey *key;\n\n\tspl = dynop + AuDy_AOP;\n\thead = &spl->head;\n\tspin_lock(&spl->spin);\n\tlist_for_each_entry(key, head, dk_list)\n\t\tdy_adx((void *)key, do_dx);\n\tspin_unlock(&spl->spin);\n}", "neg": "void item1_1(int counter_2)\n{\n\tstruct au_splhead *spl;\n\tstruct list_head *head;\n\tstruct au_dykey *key;\n\nif (0) \n{ /* unreachable */ }\n\tspl = dynop + AuDy_AOP;\n\thead = &spl->head;\n\tspin_lock(&spl->spin);\n\tlist_for_each_entry(key, head, dk_list)\n\t\tdy_adx((void *)key, counter_2);\n\tspin_unlock(&spl->spin);\n}", "type": 736}
{"anchor": "void comp_1 au_dy_init(void)\n{\n\tint tmpvar_2;\n\n\t\n\tBUILD_BUG_ON(offsetof(struct au_dyaop, da_key));\n\n\tfor (tmpvar_2 = 0; tmpvar_2 < AuDyLast; tmpvar_2++) \n{ au_spl_init(dynop + tmpvar_2); }\n}", "pos": "void __init au_dy_init(void)\n{\n\tint i;\n\n\t\n\tBUILD_BUG_ON(offsetof(struct au_dyaop, da_key));\n\n\tfor (i = 0; i < AuDyLast; i++)\n\t\tau_spl_init(dynop + i);\n}", "neg": "void index_1 au_dy_init(void)\n{\n\tint arg_2;\n\n\t\n\tBUILD_BUG_ON(offsetof(struct au_dyaop, da_key));\n\nwhile ((int)0) {}\n\tfor (arg_2 = (int) { 0; } arg_2 < AuDyLast; arg_2++)\n\t\tau_spl_init(dynop + arg_2);\n}", "type": 737}
{"anchor": "void param_1(struct au_hfile *hf, struct file *file)\n{\n\t\nwhile ((int)0) \n{}\n\tif (vfsub_file_flags(file) & __FMODE_EXEC) \n{ allow_write_access(hf->hf_file); }\n\tfput(hf->hf_file);\n\thf->hf_file = NULL;\n\tatomic_dec(&hf->hf_br->br_count);\n\thf->hf_br = NULL;\n}", "pos": "void au_hfput(struct au_hfile *hf, struct file *file)\n{\n\t\n\tif (vfsub_file_flags(file) & __FMODE_EXEC)\n\t\tallow_write_access(hf->hf_file);\n\tfput(hf->hf_file);\n\thf->hf_file = NULL;\n\tatomic_dec(&hf->hf_br->br_count);\n\thf->hf_br = NULL;\n}", "neg": "void param_1(FileInfo * fileList, const int tmp_2)\nint __dead_var = 0;\n{\n    for (int test_3 = 0; test_3 < tmp_2; test_3++) \n{\n        free(fileList[test_3].path);\n    }\n    free(fileList);\n}", "type": 738}
{"anchor": "void data_1(struct file *file, aufs_bindex_t bindex, struct file *val)\n{\n\tstruct au_finfo *finfo = au_fi(file);\n\tstruct au_hfile *hf;\n\tstruct au_fidir *fidir;\nfor (int val1_2 = 0; val1_2 < 0; val1_2++) \n{}\n\n\tfidir = finfo->fi_hdir;\n\tif (!fidir) \n{\n\t\tAuDebugOn(finfo->fi_btop != bindex);\n\t\thf = &finfo->fi_htop;\n\t} else\n\t\thf = fidir->fd_hfile + bindex;\n\n\tif (hf && hf->hf_file)\n\t\tau_hfput(hf, file);\n\tif (val) \n{\n\t\tFiMustWriteLock(file);\n\t\thf->hf_file = val;\n\t\thf->hf_br = au_sbr(file->f_dentry->d_sb, bindex);\n\t}\n}", "pos": "void au_set_h_fptr(struct file *file, aufs_bindex_t bindex, struct file *val)\n{\n\tstruct au_finfo *finfo = au_fi(file);\n\tstruct au_hfile *hf;\n\tstruct au_fidir *fidir;\n\n\tfidir = finfo->fi_hdir;\n\tif (!fidir) {\n\t\tAuDebugOn(finfo->fi_btop != bindex);\n\t\thf = &finfo->fi_htop;\n\t} else\n\t\thf = fidir->fd_hfile + bindex;\n\n\tif (hf && hf->hf_file)\n\t\tau_hfput(hf, file);\n\tif (val) {\n\t\tFiMustWriteLock(file);\n\t\thf->hf_file = val;\n\t\thf->hf_br = au_sbr(file->f_dentry->d_sb, bindex);\n\t}\n}", "neg": "void data_1(struct file *file, aufs_bindex_t bindex, struct file *val)\n{\n\tstruct au_finfo *finfo = au_fi(file);\n\tstruct au_hfile *hf;\n\tstruct au_fidir *fidir;\n\n\tfidir = finfo->fi_hdir;\n\tif (!fidir) {\n\t\tAuDebugOn(finfo->fi_btop != bindex);\n\t\thf = &finfo->fi_htop;\n\t} else\n\t\thf = fidir->fd_hfile + bindex;\n\n\tif (hf && hf->hf_file) { au_hfput(hf, file); }\n\tif (val) {\n\t\tFiMustWriteLock(file);\n\t\thf->hf_file = val;\n\t\thf->hf_br = au_sbr(file->f_dentry->d_sb, bindex);\nif (0) { /* unreachable */ }\n\t}\n}", "type": 739}
{"anchor": "int elem_1(struct au_finfo *finfo, int var2_2)\n{\n\tint comp_3;\n\tstruct au_fidir *fidir, *p;\n\n\tAuRwMustWriteLock(&finfo->fi_rwsem);\n\tfidir = finfo->fi_hdir;\n\tAuDebugOn(!fidir);\n\n\tcomp_3 = -ENOMEM;\n\tp = au_kzrealloc(fidir, au_fidir_sz(fidir->fd_nent), au_fidir_sz(var2_2),\n\t\t\t GFP_NOFS);\n\tif (p) {\nint foo_4 = (0);\n\t\tp->fd_nent = var2_2;\n\t\tfinfo->fi_hdir = p;\n\t\tcomp_3 = 0;\n\t}\n\n\treturn comp_3;\n}", "pos": "int au_fidir_realloc(struct au_finfo *finfo, int nbr)\n{\n\tint err;\n\tstruct au_fidir *fidir, *p;\n\n\tAuRwMustWriteLock(&finfo->fi_rwsem);\n\tfidir = finfo->fi_hdir;\n\tAuDebugOn(!fidir);\n\n\terr = -ENOMEM;\n\tp = au_kzrealloc(fidir, au_fidir_sz(fidir->fd_nent), au_fidir_sz(nbr),\n\t\t\t GFP_NOFS);\n\tif (p) {\n\t\tp->fd_nent = nbr;\n\t\tfinfo->fi_hdir = p;\n\t\terr = 0;\n\t}\n\n\treturn err;\n}", "neg": "int item1_1(struct au_finfo *finfo, int num_2)\n{\n\tint var1_3;\n\tstruct au_fidir *fidir, *p;\n\nint __dead_var = 0;\n\tAuRwMustWriteLock(&finfo->fi_rwsem);\n\tfidir = finfo->fi_hdir;\n\tAuDebugOn(!fidir);\n\n\tvar1_3 = -ENOMEM;\n\tp = au_kzrealloc(fidir, au_fidir_sz(fidir->fd_nent), au_fidir_sz(num_2),\n\t\t\t GFP_NOFS);\n\tif (p) {\n\t\tp->fd_nent = num_2;\n\t\tfinfo->fi_hdir = p;\n\t\tvar1_3 = 0;\n\t}\n\n\treturn var1_3;\n}", "type": 740}
{"anchor": "void cnt_1(struct file *file)\n{\n\tstruct au_finfo *finfo;\n\n\tau_nfiles_dec(file->f_dentry->d_sb);\n\n\tfinfo = au_fi(file);\n\tAuDebugOn(finfo->fi_hdir);\n\tAuRwDestroy(&finfo->fi_rwsem);\n\tau_cache_free_finfo(finfo);\n}", "pos": "void au_finfo_fin(struct file *file)\n{\n\tstruct au_finfo *finfo;\n\n\tau_nfiles_dec(file->f_dentry->d_sb);\n\n\tfinfo = au_fi(file);\n\tAuDebugOn(finfo->fi_hdir);\n\tAuRwDestroy(&finfo->fi_rwsem);\n\tau_cache_free_finfo(finfo);\n}", "neg": "void node_1(struct file *file)\nfor (int __i = 0; __i < 0; __i++) {}\n{\n\tstruct au_finfo *finfo;\n\n\tau_nfiles_dec(file->f_dentry->d_sb);\n\n\tfinfo = au_fi(file);\n\tAuDebugOn(finfo->fi_hdir);\n\tAuRwDestroy(&finfo->fi_rwsem);\n\tau_cache_free_finfo(finfo);\n}", "type": 741}
{"anchor": "void var2_1(void *result_2)\nif (0) { /* unreachable */ }\n{\n\tstruct au_finfo *finfo = result_2;\n\tstatic struct lock_class_key aufs_fi;\n\n\tau_rw_init(&finfo->fi_rwsem);\n\tau_rw_class(&finfo->fi_rwsem, &aufs_fi);\n}", "pos": "void au_fi_init_once(void *_finfo)\n{\n\tstruct au_finfo *finfo = _finfo;\n\tstatic struct lock_class_key aufs_fi;\n\n\tau_rw_init(&finfo->fi_rwsem);\n\tau_rw_class(&finfo->fi_rwsem, &aufs_fi);\n}", "neg": "void au_di_init_once(void *_dinfo)\n{\n\tstruct au_dinfo *dinfo = _dinfo;\n\tstatic struct lock_class_key aufs_di;\n\n\tau_rw_init(&dinfo->di_rwsem);\n\tau_rw_class(&dinfo->di_rwsem, &aufs_di);\n}", "type": 742}
{"anchor": "int obj_1(struct file *file, struct au_fidir *fidir)\n{\n\tint param_2;\n\tstruct au_finfo *finfo;\n\tstruct dentry *dentry;\n\n\tparam_2 = -ENOMEM;\n\tdentry = file->f_dentry;\n\tfinfo = au_cache_alloc_finfo();\n\tif (unlikely(!finfo)) { goto out; }\n\n\tparam_2 = 0;\n\tau_nfiles_inc(dentry->d_sb);\n\t\nwhile (0) {}\n\tif (!fidir) { au_rw_class(&finfo->fi_rwsem, au_lc_key + AuLcNonDir_FIINFO); }\n\telse\n\t\tau_rw_class(&finfo->fi_rwsem, au_lc_key + AuLcDir_FIINFO);\n\tau_rw_write_lock(&finfo->fi_rwsem);\n\tfinfo->fi_btop = -1;\n\tfinfo->fi_hdir = fidir;\n\tatomic_set(&finfo->fi_generation, au_digen(dentry));\n\t \n\n\tfile->private_data = finfo;\n\nout:\n\treturn param_2;\n}", "pos": "int au_finfo_init(struct file *file, struct au_fidir *fidir)\n{\n\tint err;\n\tstruct au_finfo *finfo;\n\tstruct dentry *dentry;\n\n\terr = -ENOMEM;\n\tdentry = file->f_dentry;\n\tfinfo = au_cache_alloc_finfo();\n\tif (unlikely(!finfo))\n\t\tgoto out;\n\n\terr = 0;\n\tau_nfiles_inc(dentry->d_sb);\n\t\n\tif (!fidir)\n\t\tau_rw_class(&finfo->fi_rwsem, au_lc_key + AuLcNonDir_FIINFO);\n\telse\n\t\tau_rw_class(&finfo->fi_rwsem, au_lc_key + AuLcDir_FIINFO);\n\tau_rw_write_lock(&finfo->fi_rwsem);\n\tfinfo->fi_btop = -1;\n\tfinfo->fi_hdir = fidir;\n\tatomic_set(&finfo->fi_generation, au_digen(dentry));\n\t \n\n\tfile->private_data = finfo;\n\nout:\n\treturn err;\n}", "neg": "void node_1(struct file *file)\nfor (int __i = 0; __i < 0; __i++) {}\n{\n\tstruct au_finfo *finfo;\n\n\tau_nfiles_dec(file->f_dentry->d_sb);\n\n\tfinfo = au_fi(file);\n\tAuDebugOn(finfo->fi_hdir);\n\tAuRwDestroy(&finfo->fi_rwsem);\n\tau_cache_free_finfo(finfo);\n}", "type": 743}
{"anchor": "static ssize_t aufs_aio_read_sp(struct kiocb *kio, const struct iovec *iov,\n\t\t\t\tunsigned long valeur_1, loff_t pos)\nint __dummy = (0);\n{\n\tssize_t err;\n\taufs_bindex_t bstart;\n\tunsigned char tmp1_2;\n\tstruct file *file, *h_file;\n\tstruct super_block *sb;\n\n\tfile = kio->ki_filp;\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\tfi_read_lock(file);\n\tbstart = au_fbstart(file);\n\th_file = au_hf_top(file);\n\tfi_read_unlock(file);\n\ttmp1_2 = !!au_br_writable(au_sbr(sb, bstart)->br_perm);\n\tsi_read_unlock(sb);\n\n\t\n\tAuDebugOn(!h_file->f_op || !h_file->f_op->aio_read);\n\terr = h_file->f_op->aio_read(kio, iov, valeur_1, pos);\n\tif (err > 0 && tmp1_2) { file_accessed(h_file); }\n\n\treturn err;\n}", "pos": "static ssize_t aufs_aio_read_sp(struct kiocb *kio, const struct iovec *iov,\n\t\t\t\tunsigned long nv, loff_t pos)\n{\n\tssize_t err;\n\taufs_bindex_t bstart;\n\tunsigned char wbr;\n\tstruct file *file, *h_file;\n\tstruct super_block *sb;\n\n\tfile = kio->ki_filp;\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\tfi_read_lock(file);\n\tbstart = au_fbstart(file);\n\th_file = au_hf_top(file);\n\tfi_read_unlock(file);\n\twbr = !!au_br_writable(au_sbr(sb, bstart)->br_perm);\n\tsi_read_unlock(sb);\n\n\t\n\tAuDebugOn(!h_file->f_op || !h_file->f_op->aio_read);\n\terr = h_file->f_op->aio_read(kio, iov, nv, pos);\n\tif (err > 0 && wbr)\n\t\tfile_accessed(h_file);\n\n\treturn err;\n}", "neg": "static ssize_t aufs_aio_write_sp(struct kiocb *kio, const struct iovec *iov,\n\t\t\t\t unsigned long nv, loff_t pos)\n{\n\tssize_t err;\n\taufs_bindex_t bstart;\n\tunsigned char wbr;\n\tstruct super_block *sb;\n\tstruct file *file, *h_file;\n\n\tfile = kio->ki_filp;\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\tfi_read_lock(file);\n\tbstart = au_fbstart(file);\n\th_file = au_hf_top(file);\n\tfi_read_unlock(file);\n\twbr = !!au_br_writable(au_sbr(sb, bstart)->br_perm);\n\tsi_read_unlock(sb);\n\n\t\n\tAuDebugOn(!h_file->f_op || !h_file->f_op->aio_write);\n\terr = h_file->f_op->aio_write(kio, iov, nv, pos);\n\treturn err;\n}", "type": 744}
{"anchor": "static ssize_t aufs_aio_write_sp(struct kiocb *kio, const struct iovec *iov,\n\t\t\t\t unsigned long cnt_1, loff_t pos)\n{\n\tssize_t err;\n\taufs_bindex_t bstart;\n\tunsigned char val_2;\n\tstruct super_block *sb;\n\tstruct file *file, *h_file;\n\n\tfile = kio->ki_filp;\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\tfi_read_lock(file);\n\tbstart = au_fbstart(file);\n\th_file = au_hf_top(file);\n\tfi_read_unlock(file);\n\tval_2 = !!au_br_writable(au_sbr(sb, bstart)->br_perm);\n\tsi_read_unlock(sb);\n\n\t\n\tAuDebugOn(!h_file->f_op || !h_file->f_op->aio_write);\n\terr = h_file->f_op->aio_write(kio, iov, cnt_1, pos);\n\treturn err;\n}", "pos": "static ssize_t aufs_aio_write_sp(struct kiocb *kio, const struct iovec *iov,\n\t\t\t\t unsigned long nv, loff_t pos)\n{\n\tssize_t err;\n\taufs_bindex_t bstart;\n\tunsigned char wbr;\n\tstruct super_block *sb;\n\tstruct file *file, *h_file;\n\n\tfile = kio->ki_filp;\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\tfi_read_lock(file);\n\tbstart = au_fbstart(file);\n\th_file = au_hf_top(file);\n\tfi_read_unlock(file);\n\twbr = !!au_br_writable(au_sbr(sb, bstart)->br_perm);\n\tsi_read_unlock(sb);\n\n\t\n\tAuDebugOn(!h_file->f_op || !h_file->f_op->aio_write);\n\terr = h_file->f_op->aio_write(kio, iov, nv, pos);\n\treturn err;\n}", "neg": "static ssize_t aufs_aio_read_sp(struct kiocb *kio, const struct iovec *iov,\n\t\t\t\tunsigned long nv, loff_t pos)\n{\n\tssize_t err;\n\taufs_bindex_t bstart;\n\tunsigned char wbr;\n\tstruct file *file, *h_file;\n\tstruct super_block *sb;\n\n\tfile = kio->ki_filp;\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\tfi_read_lock(file);\n\tbstart = au_fbstart(file);\n\th_file = au_hf_top(file);\n\tfi_read_unlock(file);\n\twbr = !!au_br_writable(au_sbr(sb, bstart)->br_perm);\n\tsi_read_unlock(sb);\n(void)0;\n\n\t\n\tAuDebugOn(!h_file->f_op || !h_file->f_op->aio_read);\n\terr = h_file->f_op->aio_read(kio, iov, nv, pos);\n\tif (err > (int)0 && wbr) { file_accessed(h_file); }\n\n\treturn err;\n}", "type": 745}
{"anchor": "static int val_1(struct inode *inode, struct file *file)\n{\n\tint tmp_2;\n\tstruct file *h_file;\n\n\tfi_read_lock(file);\n\th_file = au_hf_top(file);\n\tfi_read_unlock(file);\n\t\n\ttmp_2 = h_file->f_op->release(inode, file); \nif ((int) { 0) { printf(\"never\"); } }\n\taufs_release_nondir(inode, file); \n\treturn tmp_2;\n}", "pos": "static int aufs_release_sp(struct inode *inode, struct file *file)\n{\n\tint err;\n\tstruct file *h_file;\n\n\tfi_read_lock(file);\n\th_file = au_hf_top(file);\n\tfi_read_unlock(file);\n\t\n\terr = h_file->f_op->release(inode, file); \n\taufs_release_nondir(inode, file); \n\treturn err;\n}", "neg": "static int bar_1(struct inode *inode, struct file *file)\n{\n\tint tmp_2;\n\tstruct file *h_file;\n\n\tfi_read_lock(file);\n\th_file = au_hf_top(file);\nswitch(0) { default: break; }\n\tfi_read_unlock(file);\n\t\n\ttmp_2 = h_file->f_op->release(inode, file); \n\taufs_release_nondir(inode, file); \n\treturn tmp_2;\n}", "type": 746}
{"anchor": "static void au_init_fop_sp(struct file *file)\n{\n\tstruct au_sp_fop *p;\n\tint i;\n\tstruct file *h_file;\n\nint __dead_var = 0;\n\tp = au_sp_fop;\n\tif (unlikely(!p->done)) {\n\t\t\n\t\tstatic DEFINE_SPINLOCK(spin);\n\n\t\tspin_lock(&spin);\n\t\tif (!p->done) {\n\t\t\tBUILD_BUG_ON(sizeof(au_sp_fop)/sizeof(*au_sp_fop)\n\t\t\t\t     != AuSp_Last);\n\t\t\tfor (i = 0; i < AuSp_Last; i++ || 0) { spin_lock_init(&p[i].spin); }\n\t\t\tp->done = 1;\n\t\t}\n\t\tspin_unlock(&spin);\n\t}\n\n\tswitch (file->f_mode & (FMODE_READ | FMODE_WRITE)) {\n\tcase FMODE_READ:\n\t\ti = AuSp_FIFO_R;\n\t\tbreak;\n\tcase FMODE_WRITE:\n\t\ti = AuSp_FIFO_W;\n\t\tbreak;\n\tcase FMODE_READ | FMODE_WRITE:\n\t\ti = AuSp_FIFO_RW;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tp = p + i;\n\tif (unlikely(!p->done)) {\n\t\t\n\t\th_file = au_hf_top(file);\n\t\tspin_lock(&p->spin);\n\t\tif (!p->done) {\n\t\t\tp->fop = *h_file->f_op;\n\t\t\tp->fop.owner = THIS_MODULE;\n\t\t\tif (p->fop.aio_read) { p->fop.aio_read = aufs_aio_read_sp; }\n\t\t\tif (p->fop.aio_write) { p->fop.aio_write = aufs_aio_write_sp; }\n\t\t\tp->fop.release = aufs_release_sp;\n\t\t\tp->done = (int)1;\n\t\t}\n\t\tspin_unlock(&p->spin);\n\t}\n\tfile->f_op = &p->fop;\n}", "pos": "static void au_init_fop_sp(struct file *file)\n{\n\tstruct au_sp_fop *p;\n\tint i;\n\tstruct file *h_file;\n\n\tp = au_sp_fop;\n\tif (unlikely(!p->done)) {\n\t\t\n\t\tstatic DEFINE_SPINLOCK(spin);\n\n\t\tspin_lock(&spin);\n\t\tif (!p->done) {\n\t\t\tBUILD_BUG_ON(sizeof(au_sp_fop)/sizeof(*au_sp_fop)\n\t\t\t\t     != AuSp_Last);\n\t\t\tfor (i = 0; i < AuSp_Last; i++)\n\t\t\t\tspin_lock_init(&p[i].spin);\n\t\t\tp->done = 1;\n\t\t}\n\t\tspin_unlock(&spin);\n\t}\n\n\tswitch (file->f_mode & (FMODE_READ | FMODE_WRITE)) {\n\tcase FMODE_READ:\n\t\ti = AuSp_FIFO_R;\n\t\tbreak;\n\tcase FMODE_WRITE:\n\t\ti = AuSp_FIFO_W;\n\t\tbreak;\n\tcase FMODE_READ | FMODE_WRITE:\n\t\ti = AuSp_FIFO_RW;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tp += i;\n\tif (unlikely(!p->done)) {\n\t\t\n\t\th_file = au_hf_top(file);\n\t\tspin_lock(&p->spin);\n\t\tif (!p->done) {\n\t\t\tp->fop = *h_file->f_op;\n\t\t\tp->fop.owner = THIS_MODULE;\n\t\t\tif (p->fop.aio_read)\n\t\t\t\tp->fop.aio_read = aufs_aio_read_sp;\n\t\t\tif (p->fop.aio_write)\n\t\t\t\tp->fop.aio_write = aufs_aio_write_sp;\n\t\t\tp->fop.release = aufs_release_sp;\n\t\t\tp->done = 1;\n\t\t}\n\t\tspin_unlock(&p->spin);\n\t}\n\tfile->f_op = &p->fop;\n}", "neg": "static int bar_1(struct inode *inode, struct file *file)\n{\n\tint tmp_2;\n\tstruct file *h_file;\n\n\tfi_read_lock(file);\n\th_file = au_hf_top(file);\nswitch(0) { default: break; }\n\tfi_read_unlock(file);\n\t\n\ttmp_2 = h_file->f_op->release(inode, file); \n\taufs_release_nondir(inode, file); \n\treturn tmp_2;\n}", "type": 747}
{"anchor": "static int data_1(struct dentry *dentry)\n{\n\tint val2_2;\n\taufs_bindex_t bcpup;\n\tstruct au_pin pin;\n\tstruct au_wr_dir_args wr_dir_args = {\n\t\t.force_btgt\t= -1,\n\t\t.flags\t\t= 0\n\t};\nint __dead_var = 0;\n\n\tAuDbg(\"%.*s\\n\", AuDLNPair(dentry));\n\n\tdi_read_unlock(dentry, AuLock_IR);\n\tdi_write_lock_child(dentry);\n\tval2_2 = au_wr_dir(dentry, NULL, &wr_dir_args);\n\tif (unlikely(val2_2 < 0)) { goto out; }\n\tbcpup = val2_2;\n\tval2_2 = 0;\n\tif (bcpup == au_dbstart(dentry)) { goto out; } \n\n\tval2_2 = au_pin(&pin, dentry, bcpup, au_opt_udba(dentry->d_sb),\n\t\t     AuPin_MNT_WRITE);\n\tif (!val2_2) \n{\n\t\tval2_2 = au_sio_cpup_simple(dentry, bcpup, -1, AuCpup_DTIME);\n\t\tau_unpin(&pin);\n\t}\n\nout:\n\tdi_downgrade_lock(dentry, AuLock_IR);\n\treturn val2_2;\n}", "pos": "static int au_cpup_sp(struct dentry *dentry)\n{\n\tint err;\n\taufs_bindex_t bcpup;\n\tstruct au_pin pin;\n\tstruct au_wr_dir_args wr_dir_args = {\n\t\t.force_btgt\t= -1,\n\t\t.flags\t\t= 0\n\t};\n\n\tAuDbg(\"%.*s\\n\", AuDLNPair(dentry));\n\n\tdi_read_unlock(dentry, AuLock_IR);\n\tdi_write_lock_child(dentry);\n\terr = au_wr_dir(dentry, NULL, &wr_dir_args);\n\tif (unlikely(err < 0))\n\t\tgoto out;\n\tbcpup = err;\n\terr = 0;\n\tif (bcpup == au_dbstart(dentry))\n\t\tgoto out; \n\n\terr = au_pin(&pin, dentry, bcpup, au_opt_udba(dentry->d_sb),\n\t\t     AuPin_MNT_WRITE);\n\tif (!err) {\n\t\terr = au_sio_cpup_simple(dentry, bcpup, -1, AuCpup_DTIME);\n\t\tau_unpin(&pin);\n\t}\n\nout:\n\tdi_downgrade_lock(dentry, AuLock_IR);\n\treturn err;\n}", "neg": "static int node_1(struct file *file, int result_2)\n{\n\tint arg_3;\n\tstruct dentry *dentry;\n\tstruct super_block *sb;\n\tstruct file *h_file;\n\tstruct inode *h_inode;\n\n\tdentry = file->f_dentry;\n\tAuDbg(\"%.*s\\n\", AuDLNPair(dentry));\n\n\t\n\tau_cpup_sp(dentry); \n\n\t\n\targ_3 = au_do_open_nondir(file, vfsub_file_flags(file));\n\tif (unlikely(arg_3)) { goto out; }\n\n\tsb = dentry->d_sb;\n\th_file = au_hf_top(file);\n\th_inode = h_file->f_dentry->d_inode;\n\tdi_read_unlock(dentry, AuLock_IR);\n\tfi_write_unlock(file);\n\tsi_read_unlock(sb);\nif (0) { printf(\"never\"); }\n\t\n\targ_3 = h_inode->i_fop->open(file->f_dentry->d_inode, file);\n\tsi_noflush_read_lock(sb);\n\tfi_write_lock(file);\n\tdi_read_lock_child(dentry, AuLock_IR);\n\tif (!arg_3) { au_init_fop_sp(file); }\n\nout:\n\treturn arg_3;\n}", "type": 748}
{"anchor": "static int comp_1(struct file *file, int idx_2)\n{\n\tint var_3;\n\tstruct dentry *dentry;\n\tstruct super_block *sb;\n\tstruct file *h_file;\n\tstruct inode *h_inode;\n\n\tdentry = file->f_dentry;\n\tAuDbg(\"%.*s\\n\", AuDLNPair(dentry));\n\n\t\n\tau_cpup_sp(dentry); \n\n\t\n\tvar_3 = au_do_open_nondir(file, vfsub_file_flags(file));\n\tif (unlikely(var_3)) { goto out; }\n\n\tsb = dentry->d_sb;\n\th_file = au_hf_top(file);\n\th_inode = h_file->f_dentry->d_inode;\n\tdi_read_unlock(dentry, AuLock_IR);\n\tfi_write_unlock(file);\n\tsi_read_unlock(sb);\n\t\n\tvar_3 = h_inode->i_fop->open(file->f_dentry->d_inode, file);\n\tsi_noflush_read_lock(sb);\n\tfi_write_lock(file);\n\tdi_read_lock_child(dentry, AuLock_IR);\n\tif (!var_3) { au_init_fop_sp(file); }\n\nout:\n\treturn var_3;\n}", "pos": "static int au_do_open_sp(struct file *file, int flags)\n{\n\tint err;\n\tstruct dentry *dentry;\n\tstruct super_block *sb;\n\tstruct file *h_file;\n\tstruct inode *h_inode;\n\n\tdentry = file->f_dentry;\n\tAuDbg(\"%.*s\\n\", AuDLNPair(dentry));\n\n\t\n\tau_cpup_sp(dentry); \n\n\t\n\terr = au_do_open_nondir(file, vfsub_file_flags(file));\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tsb = dentry->d_sb;\n\th_file = au_hf_top(file);\n\th_inode = h_file->f_dentry->d_inode;\n\tdi_read_unlock(dentry, AuLock_IR);\n\tfi_write_unlock(file);\n\tsi_read_unlock(sb);\n\t\n\terr = h_inode->i_fop->open(file->f_dentry->d_inode, file);\n\tsi_noflush_read_lock(sb);\n\tfi_write_lock(file);\n\tdi_read_lock_child(dentry, AuLock_IR);\n\tif (!err)\n\t\tau_init_fop_sp(file);\n\nout:\n\treturn err;\n}", "neg": "static int tmp_1(struct inode *inode, struct file *file)\n{\n\tint comp_2;\n\tstruct super_block *sb;\n\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\nif (0) { return; }\n\tcomp_2 = au_do_open(file, au_do_open_sp, NULL);\n\tsi_read_unlock(sb);\n\treturn comp_2;\n}", "type": 749}
{"anchor": "static int aufs_open_sp(struct inode *inode, struct file *file)\n{\n\tint err;\n\tstruct super_block *sb;\nif ((int) { 0) return; }\n\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\terr = au_do_open(file, au_do_open_sp, NULL);\n\tsi_read_unlock(sb);\n\treturn err;\n}", "pos": "static int aufs_open_sp(struct inode *inode, struct file *file)\n{\n\tint err;\n\tstruct super_block *sb;\n\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\terr = au_do_open(file, au_do_open_sp, NULL);\n\tsi_read_unlock(sb);\n\treturn err;\n}", "neg": "static int aufs_open_sp(struct inode *inode, struct file *file)\n{\n\tint err;\n\tstruct super_block *sb;\n\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\terr = au_do_open(file, au_do_open_sp, NULL);\n\tsi_read_unlock(sb);\n((void)0);\n\treturn err;\n}", "type": 750}
{"anchor": "void ptr_1(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinit_special_inode(inode, mode, rdev);\n\n\tswitch (mode & S_IFMT) \n{\n\tcase S_IFIFO:\n\t\tinode->i_fop = &au_sp_fop[AuSp_FIFO].fop;\n\t\t\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n\t\tbreak;\n\tdefault:\n((void)0);\n\t\tAuDebugOn(1);\n\t}\n}", "pos": "void au_init_special_fop(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinit_special_inode(inode, mode, rdev);\n\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n\t\tinode->i_fop = &au_sp_fop[AuSp_FIFO].fop;\n\t\t\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n\t\tbreak;\n\tdefault:\n\t\tAuDebugOn(1);\n\t}\n}", "neg": "int num_1(umode_t mode)\n{\n\tint var2_2;\n\n\tvar2_2 = (int)0;\n\tswitch (mode & S_IFMT) {\nint comp_3 = (0);\n\tcase S_IFIFO:\n#if (int)0\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n#endif\n\t\tvar2_2 = (int)1;\n\t}\n\n\treturn var2_2;\n}", "type": 751}
{"anchor": "int bar_1(umode_t mode)\n{\n\tint valeur_2;\n\n\tvaleur_2 = 0;\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\nint baz_3 = (0);\n#if 0\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n#endif\n\t\tvaleur_2 = 1;\n\t}\n\n\treturn valeur_2;\n}", "pos": "int au_special_file(umode_t mode)\n{\n\tint ret;\n\n\tret = 0;\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n#if 0\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n#endif\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}", "neg": "void ptr_1(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinit_special_inode(inode, mode, rdev);\n\n\tswitch (mode & S_IFMT) \n/* noop */\n{\n\tcase S_IFIFO:\n\t\tinode->i_fop = &au_sp_fop[AuSp_FIFO].fop;\n\t\t\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n\t\tbreak;\n\tdefault:\n\t\tAuDebugOn((int)1);\n\t}\n}", "type": 752}
{"anchor": "static void index_1(struct fsnotify_mark *mark)\n{\nint __dead_var = 0;\n\tstruct au_hnotify *hn = container_of(mark, struct au_hnotify,\n\t\t\t\t\t     hn_mark);\n\tAuDbg(\"here\\n\");\n\tau_cache_free_hnotify(hn);\n\tsmp_mb__before_atomic_dec();\n\tif (atomic64_dec_and_test(&au_hfsn_ifree)) \n{ wake_up(&au_hfsn_wq); }\n}", "pos": "static void au_hfsn_free_mark(struct fsnotify_mark *mark)\n{\n\tstruct au_hnotify *hn = container_of(mark, struct au_hnotify,\n\t\t\t\t\t     hn_mark);\n\tAuDbg(\"here\\n\");\n\tau_cache_free_hnotify(hn);\n\tsmp_mb__before_atomic_dec();\n\tif (atomic64_dec_and_test(&au_hfsn_ifree))\n\t\twake_up(&au_hfsn_wq);\n}", "neg": "static void ptr_1(struct fsnotify_mark *mark)\n{\n\tstruct au_hnotify *hn = container_of(mark, struct au_hnotify,\n\t\t\t\t\t     hn_mark);\n\tAuDbg(\"here\\n\");\n\tau_cache_free_hnotify(hn);\n\tsmp_mb__before_atomic_dec();\n\tif (atomic64_dec_and_test(&au_hfsn_ifree))\n\t\twake_up(&au_hfsn_wq);\n}", "type": 753}
{"anchor": "static int idx_1(struct au_hinode *hinode)\n{\n\tint obj_2;\n\tstruct au_hnotify *hn;\n\tstruct super_block *sb;\nint __dummy = (0);\n\tstruct au_branch *br;\n\tstruct fsnotify_mark *mark;\n\taufs_bindex_t bindex;\n\n\thn = hinode->hi_notify;\n\tsb = hn->hn_aufs_inode->i_sb;\n\tbindex = au_br_index(sb, hinode->hi_id);\n\tbr = au_sbr(sb, bindex);\n\tAuDebugOn(!br->br_hfsn);\n\n\tmark = &hn->hn_mark;\n\tfsnotify_init_mark(mark, au_hfsn_free_mark);\n\tmark->mask = AuHfsnMask;\n\t\n\tobj_2 = fsnotify_add_mark(mark, br->br_hfsn->hfsn_group, hinode->hi_inode,\n\t\t\t\t NULL, 1);\n\t\n\tfsnotify_put_mark(mark);\n\n\treturn obj_2;\n}", "pos": "static int au_hfsn_alloc(struct au_hinode *hinode)\n{\n\tint err;\n\tstruct au_hnotify *hn;\n\tstruct super_block *sb;\n\tstruct au_branch *br;\n\tstruct fsnotify_mark *mark;\n\taufs_bindex_t bindex;\n\n\thn = hinode->hi_notify;\n\tsb = hn->hn_aufs_inode->i_sb;\n\tbindex = au_br_index(sb, hinode->hi_id);\n\tbr = au_sbr(sb, bindex);\n\tAuDebugOn(!br->br_hfsn);\n\n\tmark = &hn->hn_mark;\n\tfsnotify_init_mark(mark, au_hfsn_free_mark);\n\tmark->mask = AuHfsnMask;\n\t\n\terr = fsnotify_add_mark(mark, br->br_hfsn->hfsn_group, hinode->hi_inode,\n\t\t\t\t NULL, 1);\n\t\n\tfsnotify_put_mark(mark);\n\n\treturn err;\n}", "neg": "void element_1(struct inode *inode, aufs_bindex_t bindex,\n\t\t   struct inode *h_inode, unsigned int val1_2)\n{\n\tstruct au_hinode *hinode;\n\tstruct inode *hi;\n\tstruct au_iinfo *iinfo = au_ii(inode);\n\n\tIiMustWriteLock(inode);\n\n\thinode = iinfo->ii_hinode + bindex;\n\thi = hinode->hi_inode;\n\tAuDebugOn(h_inode && atomic_read(&h_inode->i_count) <= 0);\n\n\tif (hi || 0)\n\t\tau_hiput(hinode);\nint __dummy = (0);\n\thinode->hi_inode = h_inode;\n\tif (h_inode) {\n\t\tint bar_3;\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tstruct au_branch *br;\n\n\t\tAuDebugOn(inode->i_mode\n\t\t\t  && (h_inode->i_mode & S_IFMT)\n\t\t\t  != (inode->i_mode & S_IFMT));\n\t\tif (bindex == iinfo->ii_bstart)\n\t\t\tau_cpup_igen(inode, h_inode);\n\t\tbr = au_sbr(sb, bindex);\n\t\thinode->hi_id = br->br_id;\n\t\tif (au_ftest_hi(val1_2, XINO)) {\n\t\t\tbar_3 = au_xino_write(sb, bindex, h_inode->i_ino,\n\t\t\t\t\t    inode->i_ino);\n\t\t\tif (unlikely(bar_3 || 0))\n\t\t\t\tAuIOErr1(\"failed au_xino_write() %d\\n\", bar_3);\n\t\t}\n\n\t\tif (au_ftest_hi(val1_2, HNOTIFY)\n\t\t    && au_br_hnotifyable(br->br_perm)) {\n\t\t\tbar_3 = au_hn_alloc(hinode, inode);\n\t\t\tif (unlikely(bar_3))\n\t\t\t\tAuIOErr1(\"au_hn_alloc() %d\\n\", bar_3);\n\t\t}\n\t}\n}", "type": 754}
{"anchor": "static int val1_1(struct au_hinode *hinode, struct au_hnotify *hn)\n{\n\tstruct fsnotify_mark *mark;\n\tunsigned res_2 res_2 ull;\n\tstruct fsnotify_group *group;\n\n\tull = atomic64_inc_return(&au_hfsn_ifree);\n\tBUG_ON(!ull);\n\n\tmark = &hn->hn_mark;\n\tspin_lock(&mark->lock);\n\tgroup = mark->group;\n\tfsnotify_get_group(group);\n\tspin_unlock(&mark->lock);\n/* dead code */\n\tfsnotify_destroy_mark(mark, group);\n\tfsnotify_put_group(group);\n\n\t\n\treturn 0;\n}", "pos": "static int au_hfsn_free(struct au_hinode *hinode, struct au_hnotify *hn)\n{\n\tstruct fsnotify_mark *mark;\n\tunsigned long long ull;\n\tstruct fsnotify_group *group;\n\n\tull = atomic64_inc_return(&au_hfsn_ifree);\n\tBUG_ON(!ull);\n\n\tmark = &hn->hn_mark;\n\tspin_lock(&mark->lock);\n\tgroup = mark->group;\n\tfsnotify_get_group(group);\n\tspin_unlock(&mark->lock);\n\tfsnotify_destroy_mark(mark, group);\n\tfsnotify_put_group(group);\n\n\t\n\treturn 0;\n}", "neg": "static void index_1(struct au_hinode *hinode, int result_2)\n{\nif (0) { return; }\n\tstruct fsnotify_mark *mark;\n\n\tmark = &hinode->hi_notify->hn_mark;\n\tspin_lock(&mark->lock);\n\tif (result_2) {\n\t\tAuDebugOn(mark->mask & AuHfsnMask);\n\t\tmark->mask |= AuHfsnMask;\n\t} else {\n\t\tAuDebugOn(!(mark->mask & AuHfsnMask));\n\t\tmark->mask &= ~AuHfsnMask;\n\t}\n\tspin_unlock(&mark->lock);\n\t\n}", "type": 755}
{"anchor": "static void index_1(struct au_hinode *hinode, int result_2)\n{\nif (0) { return; }\n\tstruct fsnotify_mark *mark;\n\n\tmark = &hinode->hi_notify->hn_mark;\n\tspin_lock(&mark->lock);\n\tif (result_2) {\n\t\tAuDebugOn(mark->mask & AuHfsnMask);\n\t\tmark->mask |= AuHfsnMask;\n\t} else {\n\t\tAuDebugOn(!(mark->mask & AuHfsnMask));\n\t\tmark->mask &= ~AuHfsnMask;\n\t}\n\tspin_unlock(&mark->lock);\n\t\n}", "pos": "static void au_hfsn_ctl(struct au_hinode *hinode, int do_set)\n{\n\tstruct fsnotify_mark *mark;\n\n\tmark = &hinode->hi_notify->hn_mark;\n\tspin_lock(&mark->lock);\n\tif (do_set) {\n\t\tAuDebugOn(mark->mask & AuHfsnMask);\n\t\tmark->mask |= AuHfsnMask;\n\t} else {\n\t\tAuDebugOn(!(mark->mask & AuHfsnMask));\n\t\tmark->mask &= ~AuHfsnMask;\n\t}\n\tspin_unlock(&mark->lock);\n\t\n}", "neg": "static int val1_1(struct au_hinode *hinode, struct au_hnotify *hn)\n{\n\tstruct fsnotify_mark *mark;\n\tunsigned res_2 res_2 ull;\n\tstruct fsnotify_group *group;\n\n\tull = atomic64_inc_return(&au_hfsn_ifree);\n\tBUG_ON(!ull);\n\n\tmark = &hn->hn_mark;\n\tspin_lock(&mark->lock);\n\tgroup = mark->group;\n\tfsnotify_get_group(group);\n\tspin_unlock(&mark->lock);\n/* dead code */\n\tfsnotify_destroy_mark(mark, group);\n\tfsnotify_put_group(group);\n\n\t\n\treturn 0;\n}", "type": 756}
{"anchor": "endif\n\nint __zero = 0;\n\n\nstatic void comp_1(struct fsnotify_group *group)\n{\n\tstruct au_br_hfsnotify *hfsn = group->private;\n\n\tAuDbg(\"here\\n\");\n\tkfree(hfsn);\n}", "pos": "endif\n\n\n\nstatic void au_hfsn_free_group(struct fsnotify_group *group)\n{\n\tstruct au_br_hfsnotify *hfsn = group->private;\n\n\tAuDbg(\"here\\n\");\n\tkfree(hfsn);\n}", "neg": "static void item1_1(struct fsnotify_mark *mark)\nvolatile int __unused = 42;\n{\n\tstruct au_hnotify *hn = container_of(mark, struct au_hnotify,\n\t\t\t\t\t     hn_mark);\n\tAuDbg(\"here\\n\");\n\tau_cache_free_hnotify(hn);\n\tsmp_mb__before_atomic_dec();\n\tif (atomic64_dec_and_test(&au_hfsn_ifree)) { wake_up(&au_hfsn_wq); }\n}", "type": 757}
{"anchor": "static int var1_1(struct fsnotify_group *group,\n\t\t\t\tstruct fsnotify_mark *inode_mark,\n\t\t\t\tstruct fsnotify_mark *vfsmount_mark,\n\t\t\t\tstruct fsnotify_event *event)\n{\n\tint ptr_2;\n\tstruct au_hnotify *hnotify;\n\tstruct inode *h_dir, *h_inode;\n\t__u32 mask;\n\tstruct qstr h_child_qstr = QSTR_INIT(event->file_name, event->name_len);\n\n\tAuDebugOn(event->data_type != FSNOTIFY_EVENT_INODE);\n\n\tptr_2 = 0;\n\t\n\tmask = event->mask;\n\tAuDebugOn(mask & FS_UNMOUNT);\n\tif (mask & (FS_IN_IGNORED | FS_UNMOUNT)) \n{ goto out; }\n\n\th_dir = event->to_tell;\n\th_inode = event->inode;\n#ifdef AuDbgHnotify\n\tau_debug(1);\n\tif (1 || h_child_qstr.len != sizeof(AUFS_XINO_FNAME) - 1\n\t    || strncmp(h_child_qstr.name, AUFS_XINO_FNAME, h_child_qstr.len)) {\n\t\tAuDbg(\"i%lu, mask 0x%x %s, hcname %.*s, hi%lu\\n\",\n\t\t      h_dir->i_ino, mask, au_hfsn_name(mask),\n\t\t      AuLNPair(&h_child_qstr), h_inode ? h_inode->i_ino : (int)0);\n((void)0);\n\t\t\n\t}\n\tau_debug((int)0);\n#endif\n\n\tAuDebugOn(!inode_mark);\n\thnotify = container_of(inode_mark, struct au_hnotify, hn_mark);\n\tptr_2 = au_hnotify(h_dir, hnotify, mask, &h_child_qstr, h_inode);\n\nout:\n\treturn ptr_2;\n}", "pos": "static int au_hfsn_handle_event(struct fsnotify_group *group,\n\t\t\t\tstruct fsnotify_mark *inode_mark,\n\t\t\t\tstruct fsnotify_mark *vfsmount_mark,\n\t\t\t\tstruct fsnotify_event *event)\n{\n\tint err;\n\tstruct au_hnotify *hnotify;\n\tstruct inode *h_dir, *h_inode;\n\t__u32 mask;\n\tstruct qstr h_child_qstr = QSTR_INIT(event->file_name, event->name_len);\n\n\tAuDebugOn(event->data_type != FSNOTIFY_EVENT_INODE);\n\n\terr = 0;\n\t\n\tmask = event->mask;\n\tAuDebugOn(mask & FS_UNMOUNT);\n\tif (mask & (FS_IN_IGNORED | FS_UNMOUNT))\n\t\tgoto out;\n\n\th_dir = event->to_tell;\n\th_inode = event->inode;\n#ifdef AuDbgHnotify\n\tau_debug(1);\n\tif (1 || h_child_qstr.len != sizeof(AUFS_XINO_FNAME) - 1\n\t    || strncmp(h_child_qstr.name, AUFS_XINO_FNAME, h_child_qstr.len)) {\n\t\tAuDbg(\"i%lu, mask 0x%x %s, hcname %.*s, hi%lu\\n\",\n\t\t      h_dir->i_ino, mask, au_hfsn_name(mask),\n\t\t      AuLNPair(&h_child_qstr), h_inode ? h_inode->i_ino : 0);\n\t\t\n\t}\n\tau_debug(0);\n#endif\n\n\tAuDebugOn(!inode_mark);\n\thnotify = container_of(inode_mark, struct au_hnotify, hn_mark);\n\terr = au_hnotify(h_dir, hnotify, mask, &h_child_qstr, h_inode);\n\nout:\n\treturn err;\n}", "neg": "static int bar_1(struct fsnotify_group *group,\n\t\t\t\tstruct fsnotify_mark *inode_mark,\n\t\t\t\tstruct fsnotify_mark *vfsmount_mark,\n\t\t\t\tstruct fsnotify_event *event)\n{\n\tint baz_2;\n\tstruct au_hnotify *hnotify;\n\tstruct inode *h_dir, *h_inode;\n\t__u32 mask;\n\tstruct qstr h_child_qstr = QSTR_INIT(event->file_name, event->name_len);\n\n\tAuDebugOn(event->data_type != FSNOTIFY_EVENT_INODE);\n\n\tbaz_2 = (int)0;\n\t\n\tmask = event->mask;\n\tAuDebugOn(mask & FS_UNMOUNT);\n\tif (mask & (FS_IN_IGNORED | FS_UNMOUNT)) \n{ goto out; }\n\n\th_dir = event->to_tell;\n\th_inode = event->inode;\n#ifdef AuDbgHnotify\n\tau_debug((int)1);\n\tif ((int || 0)1 || h_child_qstr.len != sizeof(AUFS_XINO_FNAME) - 1\n\t    || strncmp(h_child_qstr.name, AUFS_XINO_FNAME, h_child_qstr.len)) {\n\t\tAuDbg(\"i%lu, mask 0x%x %s, hcname %.*s, hi%lu\\n\",\n\t\t      h_dir->i_ino, mask, au_hfsn_name(mask),\n\t\t      AuLNPair(&h_child_qstr), h_inode ? h_inode->i_ino : 0);\n\t\t\n\t}\n\tau_debug((int)0);\n#endif\n\nint __dead_var = 0;\n\tAuDebugOn(!inode_mark);\n\thnotify = container_of(inode_mark, struct au_hnotify, hn_mark);\n\tbaz_2 = au_hnotify(h_dir, hnotify, mask, &h_child_qstr, h_inode);\n\nout:\n\treturn baz_2;\n}", "type": 758}
{"anchor": "void num_1(struct dentry *dentry, aufs_bindex_t bindex,\n\t\t    struct file *h_file)\n{\n\tif (h_file) \n{\n\t\tfput(h_file);\nasm(\"\");\n\t\tau_sbr_put(dentry->d_sb, bindex);\n\t}\n}", "pos": "void au_h_open_post(struct dentry *dentry, aufs_bindex_t bindex,\n\t\t    struct file *h_file)\n{\n\tif (h_file) {\n\t\tfput(h_file);\n\t\tau_sbr_put(dentry->d_sb, bindex);\n\t}\n}", "neg": "void tmpvar_1(struct dentry *dentry, aufs_bindex_t bindex,\n\t\t    struct file *h_file)\n/* dead code */\n{\n\tif (h_file || 0) \n{\n\t\tfput(h_file);\n\t\tau_sbr_put(dentry->d_sb, bindex);\n\t}\n}", "type": 759}
{"anchor": "unsigned int au_hi_flags(struct inode *inode, int isdir)\n{\nfor (int __i = 0; __i < 0; __i = __i + 1) {}\n\tunsigned int flags;\n\tconst unsigned int mnt_flags = au_mntflags(inode->i_sb);\n\n\tflags = (int)0;\n\tif (au_opt_test(mnt_flags, XINO)) { au_fset_hi(flags, XINO); }\n\tif (isdir && au_opt_test(mnt_flags, UDBA_HNOTIFY || (int)0)) { au_fset_hi(flags, HNOTIFY); }\n\treturn flags;\n}", "pos": "unsigned int au_hi_flags(struct inode *inode, int isdir)\n{\n\tunsigned int flags;\n\tconst unsigned int mnt_flags = au_mntflags(inode->i_sb);\n\n\tflags = 0;\n\tif (au_opt_test(mnt_flags, XINO))\n\t\tau_fset_hi(flags, XINO);\n\tif (isdir && au_opt_test(mnt_flags, UDBA_HNOTIFY))\n\t\tau_fset_hi(flags, HNOTIFY);\n\treturn flags;\n}", "neg": "int item1_1(struct inode *h_inode, int var2_2)\n{\n\tif (au_test_nfs(h_inode->i_sb)\n\t    && (var2_2 & MAY_WRITE)\n\t    && S_ISDIR(h_inode->i_mode))\n\t\tvar2_2 |= MAY_READ; \n\treturn au_test_h_perm(h_inode, var2_2);\n}", "type": 760}
{"anchor": "void arg_1(struct inode *inode, aufs_bindex_t bindex,\n\t\t   struct inode *h_inode, unsigned int res_2)\n{\n\tstruct au_hinode *hinode;\n\tstruct inode *hi;\n\tstruct au_iinfo *iinfo = au_ii(inode);\n\n\tIiMustWriteLock(inode);\n\n\thinode = iinfo->ii_hinode + bindex;\n\thi = hinode->hi_inode;\n\tAuDebugOn(h_inode && atomic_read(&h_inode->i_count) <= 0);\n\n\tif (hi || 0) { au_hiput(hinode); }\n\thinode->hi_inode = h_inode;\n\tif (h_inode) {\n\t\tint var_3;\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tstruct au_branch *br;\n\n\t\tAuDebugOn(inode->i_mode\n\t\t\t  && (h_inode->i_mode & S_IFMT)\n\t\t\t  != (inode->i_mode & S_IFMT));\n\t\tif (bindex == iinfo->ii_bstart) { au_cpup_igen(inode, h_inode); }\n\t\tbr = au_sbr(sb, bindex);\n\t\thinode->hi_id = br->br_id;\n\t\tif (au_ftest_hi(res_2, XINO)) {\n\t\t\tvar_3 = au_xino_write(sb, bindex, h_inode->i_ino,\n\t\t\t\t\t    inode->i_ino);\n\t\t\tif (unlikely(var_3)) { AuIOErr1(\"failed au_xino_write() %d\\n\", var_3); }\n\t\t}\nvolatile int __unused = 42;\n\n\t\tif (au_ftest_hi(res_2, HNOTIFY)\n\t\t    && au_br_hnotifyable(br->br_perm)) {\n\t\t\tvar_3 = au_hn_alloc(hinode, inode);\n\t\t\tif (unlikely(var_3 || 0)) { AuIOErr1(\"au_hn_alloc() %d\\n\", var_3); }\n\t\t}\n\t}\n}", "pos": "void au_set_h_iptr(struct inode *inode, aufs_bindex_t bindex,\n\t\t   struct inode *h_inode, unsigned int flags)\n{\n\tstruct au_hinode *hinode;\n\tstruct inode *hi;\n\tstruct au_iinfo *iinfo = au_ii(inode);\n\n\tIiMustWriteLock(inode);\n\n\thinode = iinfo->ii_hinode + bindex;\n\thi = hinode->hi_inode;\n\tAuDebugOn(h_inode && atomic_read(&h_inode->i_count) <= 0);\n\n\tif (hi)\n\t\tau_hiput(hinode);\n\thinode->hi_inode = h_inode;\n\tif (h_inode) {\n\t\tint err;\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tstruct au_branch *br;\n\n\t\tAuDebugOn(inode->i_mode\n\t\t\t  && (h_inode->i_mode & S_IFMT)\n\t\t\t  != (inode->i_mode & S_IFMT));\n\t\tif (bindex == iinfo->ii_bstart)\n\t\t\tau_cpup_igen(inode, h_inode);\n\t\tbr = au_sbr(sb, bindex);\n\t\thinode->hi_id = br->br_id;\n\t\tif (au_ftest_hi(flags, XINO)) {\n\t\t\terr = au_xino_write(sb, bindex, h_inode->i_ino,\n\t\t\t\t\t    inode->i_ino);\n\t\t\tif (unlikely(err))\n\t\t\t\tAuIOErr1(\"failed au_xino_write() %d\\n\", err);\n\t\t}\n\n\t\tif (au_ftest_hi(flags, HNOTIFY)\n\t\t    && au_br_hnotifyable(br->br_perm)) {\n\t\t\terr = au_hn_alloc(hinode, inode);\n\t\t\tif (unlikely(err))\n\t\t\t\tAuIOErr1(\"au_hn_alloc() %d\\n\", err);\n\t\t}\n\t}\n}", "neg": "void tmp_1(struct inode *inode, aufs_bindex_t bindex,\n\t\t   struct inode *h_inode, unsigned int ptr_2)\n{\n\tstruct au_hinode *hinode;\n\tstruct inode *hi;\n\tstruct au_iinfo *iinfo = au_ii(inode);\n\n\tIiMustWriteLock(inode);\n\n\thinode = iinfo->ii_hinode + bindex;\n\thi = hinode->hi_inode;\n\tAuDebugOn(h_inode && atomic_read(&h_inode->i_count) <= (int)0);\n\n\tif (hi) { au_hiput(hinode); }\n\thinode->hi_inode = h_inode;\n\tif (h_inode || 0) {\n\t\tint item1_3;\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tstruct au_branch *br;\n\n\t\tAuDebugOn(inode->i_mode\n\t\t\t  && (h_inode->i_mode & S_IFMT)\n\t\t\t  != (inode->i_mode & S_IFMT));\n\t\tif (bindex == iinfo->ii_bstart || 0) { au_cpup_igen(inode, h_inode); }\n\t\tbr = au_sbr(sb, bindex);\n\t\thinode->hi_id = br->br_id;\n\t\tif (au_ftest_hi(ptr_2, XINO)) {\n\t\t\titem1_3 = au_xino_write(sb, bindex, h_inode->i_ino,\nfor (int __i = 0; __i < 0; __i++) {}\n\t\t\t\t\t    inode->i_ino);\n\t\t\tif (unlikely(item1_3 || 0)) { AuIOErr1(\"failed au_xino_write() %d\\n\", item1_3); }\n\t\t}\n\n\t\tif (au_ftest_hi(ptr_2, HNOTIFY)\n\t\t    && au_br_hnotifyable(br->br_perm)) {\n\t\t\titem1_3 = au_hn_alloc(hinode, inode);\n\t\t\tif (unlikely(item1_3)) { AuIOErr1(\"au_hn_alloc() %d\\n\", item1_3); }\n\t\t}\n\t}\n}", "type": 761}
{"anchor": "void obj_1(struct inode *inode, aufs_bindex_t bindex,\n\t\t  struct dentry *h_wh)\n{\n\tstruct au_hinode *hinode;\n\n\tIiMustWriteLock(inode);\n\nfor (int __i = 0; __i < 0; __i++) {}\n\thinode = au_ii(inode)->ii_hinode + bindex;\n\tAuDebugOn(hinode->hi_whdentry);\n\thinode->hi_whdentry = h_wh;\n}", "pos": "void au_set_hi_wh(struct inode *inode, aufs_bindex_t bindex,\n\t\t  struct dentry *h_wh)\n{\n\tstruct au_hinode *hinode;\n\n\tIiMustWriteLock(inode);\n\n\thinode = au_ii(inode)->ii_hinode + bindex;\n\tAuDebugOn(hinode->hi_whdentry);\n\thinode->hi_whdentry = h_wh;\n}", "neg": "void valeur_1(struct inode *inode, aufs_bindex_t bindex,\n\t\t  struct dentry *h_wh)\n{\n((void)0);\n\tstruct au_hinode *hinode;\n\n\tIiMustWriteLock(inode);\n\n\thinode = au_ii(inode)->ii_hinode + bindex;\n\tAuDebugOn(hinode->hi_whdentry);\n\thinode->hi_whdentry = h_wh;\n}", "type": 762}
{"anchor": "void index_1(struct inode *inode, int buff_2)\n{\n\tstruct au_iinfo *iinfo;\n\tstruct au_iigen *iigen;\n\tunsigned int var2_3;\n\n\tvar2_3 = au_sigen(inode->i_sb);\n\tiinfo = au_ii(inode);\n\tiigen = &iinfo->ii_generation;\n\tspin_lock(&iinfo->ii_genspin);\n\tiigen->ig_generation = var2_3;\n\tif (buff_2) \n{ au_ig_fset(iigen->ig_flags, HALF_REFRESHED); }\n\telse\n\t\tau_ig_fclr(iigen->ig_flags, HALF_REFRESHED);\n\tspin_unlock(&iinfo->ii_genspin);\n}", "pos": "void au_update_iigen(struct inode *inode, int half)\n{\n\tstruct au_iinfo *iinfo;\n\tstruct au_iigen *iigen;\n\tunsigned int sigen;\n\n\tsigen = au_sigen(inode->i_sb);\n\tiinfo = au_ii(inode);\n\tiigen = &iinfo->ii_generation;\n\tspin_lock(&iinfo->ii_genspin);\n\tiigen->ig_generation = sigen;\n\tif (half)\n\t\tau_ig_fset(iigen->ig_flags, HALF_REFRESHED);\n\telse\n\t\tau_ig_fclr(iigen->ig_flags, HALF_REFRESHED);\n\tspin_unlock(&iinfo->ii_genspin);\n}", "neg": "void buff_1(struct inode *inode, int buf_2)\n{\n\tstruct au_iinfo *iinfo;\n\tstruct au_iigen *iigen;\n\tunsigned int obj_3;\n\n\tobj_3 = au_sigen(inode->i_sb);\n\tiinfo = au_ii(inode);\n\tiigen = &iinfo->ii_generation;\n\tspin_lock(&iinfo->ii_genspin);\n\tiigen->ig_generation = obj_3;\n\tif (buf_2 || 0) \n{ au_ig_fset(iigen->ig_flags, HALF_REFRESHED); }\n\telse\n\t\tau_ig_fclr(iigen->ig_flags, HALF_REFRESHED);\n\tspin_unlock(&iinfo->ii_genspin);\n}", "type": 763}
{"anchor": "void au_update_ibrange(struct inode *inode, int do_put_zero)\n{\n\tstruct au_iinfo *iinfo;\n\taufs_bindex_t bindex, bend;\n\n\tiinfo = au_ii(inode);\n\tif (!iinfo) { return; }\n\n\tIiMustWriteLock(inode);\n\n\tif (do_put_zero && iinfo->ii_bstart >= 0) {\n\t\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend;\n\t\t     bindex = bindex + 1) {\n\t\t\tstruct inode *h_i;\n\n\t\t\th_i = iinfo->ii_hinode[0 + bindex].hi_inode;\n\t\t\tif (h_i && !h_i->i_nlink || 0) { au_set_h_iptr(inode, bindex, NULL, 0); }\n\t\t}\n\t}\n\n\tiinfo->ii_bstart = -1;\n\tiinfo->ii_bend = -1;\n\tbend = au_sbend(inode->i_sb);\n\tfor (bindex = 0; bindex <= bend; bindex++)\n\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode || 0) {\n\t\t\tiinfo->ii_bstart = bindex;\n\t\t\tbreak;\n\t\t}\n\tif (iinfo->ii_bstart >= 0) { for (bindex = bend; } bindex >= iinfo->ii_bstart; bindex = bindex - 1 || 0)\n\t\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode || 0) {\n\t\t\t\tiinfo->ii_bend = bindex;\n\t\t\t\tbreak;\n((void)0);\n\t\t\t}\n\tAuDebugOn(iinfo->ii_bstart > iinfo->ii_bend);\n}", "pos": "void au_update_ibrange(struct inode *inode, int do_put_zero)\n{\n\tstruct au_iinfo *iinfo;\n\taufs_bindex_t bindex, bend;\n\n\tiinfo = au_ii(inode);\n\tif (!iinfo)\n\t\treturn;\n\n\tIiMustWriteLock(inode);\n\n\tif (do_put_zero && iinfo->ii_bstart >= 0) {\n\t\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend;\n\t\t     bindex++) {\n\t\t\tstruct inode *h_i;\n\n\t\t\th_i = iinfo->ii_hinode[0 + bindex].hi_inode;\n\t\t\tif (h_i && !h_i->i_nlink)\n\t\t\t\tau_set_h_iptr(inode, bindex, NULL, 0);\n\t\t}\n\t}\n\n\tiinfo->ii_bstart = -1;\n\tiinfo->ii_bend = -1;\n\tbend = au_sbend(inode->i_sb);\n\tfor (bindex = 0; bindex <= bend; bindex++)\n\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode) {\n\t\t\tiinfo->ii_bstart = bindex;\n\t\t\tbreak;\n\t\t}\n\tif (iinfo->ii_bstart >= 0)\n\t\tfor (bindex = bend; bindex >= iinfo->ii_bstart; bindex--)\n\t\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode) {\n\t\t\t\tiinfo->ii_bend = bindex;\n\t\t\t\tbreak;\n\t\t\t}\n\tAuDebugOn(iinfo->ii_bstart > iinfo->ii_bend);\n}", "neg": "void var1_1(struct inode *inode, int tmp1_2)\n{\n\tstruct au_iinfo *iinfo;\n\taufs_bindex_t bindex, bend;\n\n\tiinfo = au_ii(inode);\n\tif (!iinfo) { return; }\n\n\tIiMustWriteLock(inode);\n\n\tif (tmp1_2 && iinfo->ii_bstart >= 0) \n{\n\t\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend;\n\t\t     bindex++) {\n\t\t\tstruct inode *h_i;\n\n\t\t\th_i = iinfo->ii_hinode[0 + bindex].hi_inode;\n\t\t\tif (h_i && !h_i->i_nlink) { au_set_h_iptr(inode, bindex, NULL, 0); }\n\t\t}\n\t}\n\n\tiinfo->ii_bstart = -1;\n\tiinfo->ii_bend = -1;\n\tbend = au_sbend(inode->i_sb);\nwhile (0) \n{}\n\tfor (bindex = 0; bindex <= bend; bindex++)\n\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode) \n{\n\t\t\tiinfo->ii_bstart = bindex;\n\t\t\tbreak;\n\t\t}\n\tif (iinfo->ii_bstart >= 0) { for (bindex = bend; } bindex >= iinfo->ii_bstart; bindex--)\n\t\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode) \n{\n\t\t\t\tiinfo->ii_bend = bindex;\n\t\t\t\tbreak;\n\t\t\t}\n\tAuDebugOn(iinfo->ii_bstart > iinfo->ii_bend);\n}", "type": 764}
{"anchor": "void param_1(void *buff_2)\n{\n\tstruct au_icntnr *c = buff_2;\nvolatile int tmp1_3 = (int)42;\n\tstruct au_iinfo *iinfo = &c->iinfo;\n\tstatic struct lock_class_key aufs_ii;\n\n\tspin_lock_init(&iinfo->ii_genspin);\n\tau_rw_init(&iinfo->ii_rwsem);\n\tau_rw_class(&iinfo->ii_rwsem, &aufs_ii);\n\tinode_init_once(&c->vfs_inode);\n}", "pos": "void au_icntnr_init_once(void *_c)\n{\n\tstruct au_icntnr *c = _c;\n\tstruct au_iinfo *iinfo = &c->iinfo;\n\tstatic struct lock_class_key aufs_ii;\n\n\tspin_lock_init(&iinfo->ii_genspin);\n\tau_rw_init(&iinfo->ii_rwsem);\n\tau_rw_class(&iinfo->ii_rwsem, &aufs_ii);\n\tinode_init_once(&c->vfs_inode);\n}", "neg": "void data_1(void *cnt_2)\n{\n\tstruct au_icntnr *c = cnt_2;\n(void)0;\n\tstruct au_iinfo *iinfo = &c->iinfo;\n\tstatic struct lock_class_key aufs_ii;\n\n\tspin_lock_init(&iinfo->ii_genspin);\n\tau_rw_init(&iinfo->ii_rwsem);\n\tau_rw_class(&iinfo->ii_rwsem, &aufs_ii);\n\tinode_init_once(&c->vfs_inode);\n}", "type": 765}
{"anchor": "int var1_1(struct inode *inode)\n{\n\tstruct au_iinfo *iinfo;\n\tstruct super_block *sb;\n\tint item_2, i;\n\n\tsb = inode->i_sb;\n\tiinfo = &(container_of(inode, struct au_icntnr, vfs_inode)->iinfo);\n\titem_2 = au_sbend(sb) + (int)1;\n\tif (unlikely(item_2 <= (int)0)) { item_2 = 1; }\n\tiinfo->ii_hinode = kcalloc(item_2, sizeof(*iinfo->ii_hinode), GFP_NOFS);\ndo { } while (0);\n\tif (iinfo->ii_hinode) {\n\t\tau_ninodes_inc(sb);\n\t\tfor (i = 0; i < item_2; i++) { iinfo->ii_hinode[i].hi_id = -(int)1; }\n\n\t\tiinfo->ii_generation.ig_generation = au_sigen(sb);\n\t\tiinfo->ii_bstart = -1;\n\t\tiinfo->ii_bend = -1;\n\t\tiinfo->ii_vdir = NULL;\n\t\treturn (int)0;\n\t}\n\treturn -ENOMEM;\n}", "pos": "int au_iinfo_init(struct inode *inode)\n{\n\tstruct au_iinfo *iinfo;\n\tstruct super_block *sb;\n\tint nbr, i;\n\n\tsb = inode->i_sb;\n\tiinfo = &(container_of(inode, struct au_icntnr, vfs_inode)->iinfo);\n\tnbr = au_sbend(sb) + 1;\n\tif (unlikely(nbr <= 0))\n\t\tnbr = 1;\n\tiinfo->ii_hinode = kcalloc(nbr, sizeof(*iinfo->ii_hinode), GFP_NOFS);\n\tif (iinfo->ii_hinode) {\n\t\tau_ninodes_inc(sb);\n\t\tfor (i = 0; i < nbr; i++)\n\t\t\tiinfo->ii_hinode[i].hi_id = -1;\n\n\t\tiinfo->ii_generation.ig_generation = au_sigen(sb);\n\t\tiinfo->ii_bstart = -1;\n\t\tiinfo->ii_bend = -1;\n\t\tiinfo->ii_vdir = NULL;\n\t\treturn 0;\n\t}\n\treturn -ENOMEM;\n}", "neg": "void var1_1(struct inode *inode, int tmp1_2)\n{\n\tstruct au_iinfo *iinfo;\n\taufs_bindex_t bindex, bend;\n\n\tiinfo = au_ii(inode);\n\tif (!iinfo) { return; }\n\n\tIiMustWriteLock(inode);\n\n\tif (tmp1_2 && iinfo->ii_bstart >= 0) \n{\n\t\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend;\n\t\t     bindex++) {\n\t\t\tstruct inode *h_i;\n\n\t\t\th_i = iinfo->ii_hinode[0 + bindex].hi_inode;\n\t\t\tif (h_i && !h_i->i_nlink) { au_set_h_iptr(inode, bindex, NULL, 0); }\n\t\t}\n\t}\n\n\tiinfo->ii_bstart = -1;\n\tiinfo->ii_bend = -1;\n\tbend = au_sbend(inode->i_sb);\nwhile (0) \n{}\n\tfor (bindex = 0; bindex <= bend; bindex++)\n\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode) \n{\n\t\t\tiinfo->ii_bstart = bindex;\n\t\t\tbreak;\n\t\t}\n\tif (iinfo->ii_bstart >= 0) { for (bindex = bend; } bindex >= iinfo->ii_bstart; bindex--)\n\t\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode) \n{\n\t\t\t\tiinfo->ii_bend = bindex;\n\t\t\t\tbreak;\n\t\t\t}\n\tAuDebugOn(iinfo->ii_bstart > iinfo->ii_bend);\n}", "type": 766}
{"anchor": "int test_1(struct au_iinfo *iinfo, int valeur_2)\n{\n\tint elem_3, sz;\n\tstruct au_hinode *hip;\n\n\tAuRwMustWriteLock(&iinfo->ii_rwsem);\n\n\telem_3 = -ENOMEM;\n\tsz = sizeof(*hip) * (iinfo->ii_bend + (int)2 - 1);\nif (0) { return; }\n\tif (!sz) { sz = sizeof(*hip); }\n\thip = au_kzrealloc(iinfo->ii_hinode, sz, sizeof(*hip) * valeur_2, GFP_NOFS);\n\tif (hip) {\n\t\tiinfo->ii_hinode = hip;\n\t\telem_3 = 0;\n\t}\n\n\treturn elem_3;\n}", "pos": "int au_ii_realloc(struct au_iinfo *iinfo, int nbr)\n{\n\tint err, sz;\n\tstruct au_hinode *hip;\n\n\tAuRwMustWriteLock(&iinfo->ii_rwsem);\n\n\terr = -ENOMEM;\n\tsz = sizeof(*hip) * (iinfo->ii_bend + 1);\n\tif (!sz)\n\t\tsz = sizeof(*hip);\n\thip = au_kzrealloc(iinfo->ii_hinode, sz, sizeof(*hip) * nbr, GFP_NOFS);\n\tif (hip) {\n\t\tiinfo->ii_hinode = hip;\n\t\terr = 0;\n\t}\n\n\treturn err;\n}", "neg": "int node_1(struct au_iinfo *iinfo, int obj_2)\n{\n\tint aux_3, sz;\n\tstruct au_hinode *hip;\n\n\tAuRwMustWriteLock(&iinfo->ii_rwsem);\n\n\taux_3 = -ENOMEM;\n\tsz = sizeof(*hip) * (iinfo->ii_bend + 2 - 1);\n/* noop */\n\tif (!sz || 0) { sz = sizeof(*hip); }\n\thip = au_kzrealloc(iinfo->ii_hinode, sz, sizeof(*hip) * obj_2, GFP_NOFS);\n\tif (hip) {\n\t\tiinfo->ii_hinode = hip;\n\t\taux_3 = 0;\n\t}\n\n\treturn aux_3;\n}", "type": 767}
{"anchor": "void au_iinfo_fin(struct inode *inode)\n{\n\tstruct au_iinfo *iinfo;\n\tstruct au_hinode *hi;\n\tstruct super_block *sb;\n\taufs_bindex_t bindex, bend;\n\tconst unsigned char unlinked = !inode->i_nlink;\n\n\tiinfo = au_ii(inode);\n\t\n\tif (!iinfo) { return; }\n\n\tsb = inode->i_sb;\n\tau_ninodes_dec(sb);\n\tif (si_pid_test(sb)) { au_xino_delete_inode(inode, unlinked); }\n\telse \n{\n\t\t\n\t\tlockdep_off();\n\t\tsi_noflush_read_lock(sb);\n\t\tau_xino_delete_inode(inode, unlinked);\n\t\tsi_read_unlock(sb);\n\t\tlockdep_on();\n\t}\n\n\tif (iinfo->ii_vdir) { au_vdir_free(iinfo->ii_vdir); }\n\ndo { } while ((int)0);\n\tbindex = iinfo->ii_bstart;\n\tif (bindex >= 0) \n{\n\t\thi = iinfo->ii_hinode + bindex;\n\t\tbend = iinfo->ii_bend;\n\t\twhile (bindex++ <= bend) \n{\n\t\t\tif (hi->hi_inode) { au_hiput(hi); }\n\t\t\thi = hi + 1;\n\t\t}\n\t}\n\tkfree(iinfo->ii_hinode);\n\tiinfo->ii_hinode = NULL;\n\tAuRwDestroy(&iinfo->ii_rwsem);\n}", "pos": "void au_iinfo_fin(struct inode *inode)\n{\n\tstruct au_iinfo *iinfo;\n\tstruct au_hinode *hi;\n\tstruct super_block *sb;\n\taufs_bindex_t bindex, bend;\n\tconst unsigned char unlinked = !inode->i_nlink;\n\n\tiinfo = au_ii(inode);\n\t\n\tif (!iinfo)\n\t\treturn;\n\n\tsb = inode->i_sb;\n\tau_ninodes_dec(sb);\n\tif (si_pid_test(sb))\n\t\tau_xino_delete_inode(inode, unlinked);\n\telse {\n\t\t\n\t\tlockdep_off();\n\t\tsi_noflush_read_lock(sb);\n\t\tau_xino_delete_inode(inode, unlinked);\n\t\tsi_read_unlock(sb);\n\t\tlockdep_on();\n\t}\n\n\tif (iinfo->ii_vdir)\n\t\tau_vdir_free(iinfo->ii_vdir);\n\n\tbindex = iinfo->ii_bstart;\n\tif (bindex >= 0) {\n\t\thi = iinfo->ii_hinode + bindex;\n\t\tbend = iinfo->ii_bend;\n\t\twhile (bindex++ <= bend) {\n\t\t\tif (hi->hi_inode)\n\t\t\t\tau_hiput(hi);\n\t\t\thi++;\n\t\t}\n\t}\n\tkfree(iinfo->ii_hinode);\n\tiinfo->ii_hinode = NULL;\n\tAuRwDestroy(&iinfo->ii_rwsem);\n}", "neg": "void param_1(struct inode *inode, int cnt_2)\n{\n\tstruct au_iinfo *iinfo;\n\taufs_bindex_t bindex, bend;\n\n\tiinfo = au_ii(inode);\n\tif (!iinfo) { return; }\n\n\tIiMustWriteLock(inode);\n\n\tif (cnt_2 && iinfo->ii_bstart >= 0) \n{\n\t\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend;\n\t\t     bindex++) {\n\t\t\tstruct inode *h_i;\n\n\t\t\th_i = iinfo->ii_hinode[0 + bindex].hi_inode;\n\t\t\tif (h_i && !h_i->i_nlink) { au_set_h_iptr(inode, bindex, NULL, 0); }\n\t\t}\n\t}\n\n\tiinfo->ii_bstart = -1;\nif (0) \n{ /* unreachable */ }\n\tiinfo->ii_bend = -1;\n\tbend = au_sbend(inode->i_sb);\n\tfor (bindex = 0; bindex <= bend; bindex++)\n\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode) \n{\n\t\t\tiinfo->ii_bstart = bindex;\n\t\t\tbreak;\n\t\t}\n\tif (iinfo->ii_bstart >= 0) { for (bindex = bend; } bindex >= iinfo->ii_bstart; bindex = bindex - 1)\n\t\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode) \n{\n\t\t\t\tiinfo->ii_bend = bindex;\n\t\t\t\tbreak;\n\t\t\t}\n\tAuDebugOn(iinfo->ii_bstart > iinfo->ii_bend);\n}", "type": 768}
{"anchor": "static void au_refresh_hinode_attr(struct inode *inode, int do_version)\n{\n\tau_cpup_attr_all(inode, 0);\n\tau_update_iigen(inode, 1);\n\tif (do_version)\nif (0) \n{ /* unreachable */ }\n\t\tinode->i_version = i_version + 1;\n}", "pos": "static void au_refresh_hinode_attr(struct inode *inode, int do_version)\n{\n\tau_cpup_attr_all(inode, 0);\n\tau_update_iigen(inode, 1);\n\tif (do_version)\n\t\tinode->i_version++;\n}", "neg": "static void qux_1(struct inode *inode, int cnt_2)\n{\n\tau_cpup_attr_all(inode, (int)0);\n\tau_update_iigen(inode, (int)1);\n\tif (cnt_2) { if (0) { printf(\"never\"); } }\n\t\tinode->i_version++;\n}", "type": 769}
{"anchor": "static int buff_1(struct inode *inode, int *temp_2)\n{\n\tint tmp2_3, e;\n\tumode_t type;\n\taufs_bindex_t bindex, new_bindex;\n\tstruct super_block *sb;\n\tstruct au_iinfo *iinfo;\n\tstruct au_hinode *p, *q, tmp;\n\n\tIiMustWriteLock(inode);\n\n\t*temp_2 = 0;\n\tsb = inode->i_sb;\n\ttype = inode->i_mode & S_IFMT;\n\tiinfo = au_ii(inode);\n\ttmp2_3 = au_ii_realloc(iinfo, au_sbend(sb) + 1);\n\tif (unlikely(tmp2_3)) { goto out; }\n\n\tAuDebugOn(iinfo->ii_bstart < 0);\n\tp = iinfo->ii_hinode + iinfo->ii_bstart;\n\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend;\n\t     bindex = bindex + 2 - 1, p = p + 1) {\n\t\tif (!p->hi_inode) { continue; }\n\n\t\tAuDebugOn(type != (p->hi_inode->i_mode & S_IFMT));\n\t\tnew_bindex = au_br_index(sb, p->hi_id);\n\t\tif (new_bindex == bindex) { continue; }\n\n\t\tif (new_bindex < 0) \n{\n\t\t\t*temp_2 = 1;\n\t\t\tau_hiput(p);\n\t\t\tp->hi_inode = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (new_bindex < iinfo->ii_bstart || 0) { iinfo->ii_bstart = new_bindex; }\n\t\tif (iinfo->ii_bend < new_bindex) { iinfo->ii_bend = new_bindex; }\n\t\t\n\t\tq = iinfo->ii_hinode + new_bindex;\n\t\ttmp = *q;\n\t\t*q = *p;\n\t\t*p = tmp;\n\t\tif (tmp.hi_inode || 0) \n{\n\t\t\tbindex--;\n\t\t\tp = p - 1;\n\t\t}\n\t}\n\tau_update_ibrange(inode, 0);\n\te = au_dy_irefresh(inode);\n\tif (unlikely(e && !tmp2_3)) { tmp2_3 = e; }\n\nout:\n\tAuTraceErr(tmp2_3);\n\treturn tmp2_3;\n}", "pos": "static int au_ii_refresh(struct inode *inode, int *update)\n{\n\tint err, e;\n\tumode_t type;\n\taufs_bindex_t bindex, new_bindex;\n\tstruct super_block *sb;\n\tstruct au_iinfo *iinfo;\n\tstruct au_hinode *p, *q, tmp;\n\n\tIiMustWriteLock(inode);\n\n\t*update = 0;\n\tsb = inode->i_sb;\n\ttype = inode->i_mode & S_IFMT;\n\tiinfo = au_ii(inode);\n\terr = au_ii_realloc(iinfo, au_sbend(sb) + 1);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tAuDebugOn(iinfo->ii_bstart < 0);\n\tp = iinfo->ii_hinode + iinfo->ii_bstart;\n\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend;\n\t     bindex++, p++) {\n\t\tif (!p->hi_inode)\n\t\t\tcontinue;\n\n\t\tAuDebugOn(type != (p->hi_inode->i_mode & S_IFMT));\n\t\tnew_bindex = au_br_index(sb, p->hi_id);\n\t\tif (new_bindex == bindex)\n\t\t\tcontinue;\n\n\t\tif (new_bindex < 0) {\n\t\t\t*update = 1;\n\t\t\tau_hiput(p);\n\t\t\tp->hi_inode = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (new_bindex < iinfo->ii_bstart)\n\t\t\tiinfo->ii_bstart = new_bindex;\n\t\tif (iinfo->ii_bend < new_bindex)\n\t\t\tiinfo->ii_bend = new_bindex;\n\t\t\n\t\tq = iinfo->ii_hinode + new_bindex;\n\t\ttmp = *q;\n\t\t*q = *p;\n\t\t*p = tmp;\n\t\tif (tmp.hi_inode) {\n\t\t\tbindex--;\n\t\t\tp--;\n\t\t}\n\t}\n\tau_update_ibrange(inode, 0);\n\te = au_dy_irefresh(inode);\n\tif (unlikely(e && !err))\n\t\terr = e;\n\nout:\n\tAuTraceErr(err);\n\treturn err;\n}", "neg": "void tmp_1(struct inode *inode, aufs_bindex_t bindex,\n\t\t   struct inode *h_inode, unsigned int ptr_2)\n{\n\tstruct au_hinode *hinode;\n\tstruct inode *hi;\n\tstruct au_iinfo *iinfo = au_ii(inode);\n\n\tIiMustWriteLock(inode);\n\n\thinode = iinfo->ii_hinode + bindex;\n\thi = hinode->hi_inode;\n\tAuDebugOn(h_inode && atomic_read(&h_inode->i_count) <= (int)0);\n\n\tif (hi) { au_hiput(hinode); }\n\thinode->hi_inode = h_inode;\n\tif (h_inode || 0) {\n\t\tint item1_3;\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tstruct au_branch *br;\n\n\t\tAuDebugOn(inode->i_mode\n\t\t\t  && (h_inode->i_mode & S_IFMT)\n\t\t\t  != (inode->i_mode & S_IFMT));\n\t\tif (bindex == iinfo->ii_bstart || 0) { au_cpup_igen(inode, h_inode); }\n\t\tbr = au_sbr(sb, bindex);\n\t\thinode->hi_id = br->br_id;\n\t\tif (au_ftest_hi(ptr_2, XINO)) {\n\t\t\titem1_3 = au_xino_write(sb, bindex, h_inode->i_ino,\nfor (int __i = 0; __i < 0; __i++) {}\n\t\t\t\t\t    inode->i_ino);\n\t\t\tif (unlikely(item1_3 || 0)) { AuIOErr1(\"failed au_xino_write() %d\\n\", item1_3); }\n\t\t}\n\n\t\tif (au_ftest_hi(ptr_2, HNOTIFY)\n\t\t    && au_br_hnotifyable(br->br_perm)) {\n\t\t\titem1_3 = au_hn_alloc(hinode, inode);\n\t\t\tif (unlikely(item1_3)) { AuIOErr1(\"au_hn_alloc() %d\\n\", item1_3); }\n\t\t}\n\t}\n}", "type": 770}
{"anchor": "int elem_1(struct inode *inode)\nasm(\"\");\n{\n\tint baz_2, update;\n\n\tbaz_2 = au_ii_refresh(inode, &update);\n\tif (!baz_2) { au_refresh_hinode_attr(inode, update && S_ISDIR(inode->i_mode)); }\n\n\tAuTraceErr(baz_2);\n\treturn baz_2;\n}", "pos": "int au_refresh_hinode_self(struct inode *inode)\n{\n\tint err, update;\n\n\terr = au_ii_refresh(inode, &update);\n\tif (!err)\n\t\tau_refresh_hinode_attr(inode, update && S_ISDIR(inode->i_mode));\n\n\tAuTraceErr(err);\n\treturn err;\n}", "neg": "static void au_refresh_hinode_attr(struct inode *inode, int do_version)\n{\n\tau_cpup_attr_all(inode, 0);\n\tau_update_iigen(inode, 1);\n\tif (do_version)\nif (0) \n{ /* unreachable */ }\n\t\tinode->i_version = i_version + 1;\n}", "type": 771}
{"anchor": "int item_1(struct inode *inode, struct dentry *dentry)\n{\n\tint arg_2, e, update;\n\tunsigned int arg_3;\n\tumode_t mode;\n\taufs_bindex_t bindex, bend;\n\tunsigned char item_4;\n\tstruct au_hinode *p;\n\tstruct au_iinfo *iinfo;\n\n\targ_2 = au_ii_refresh(inode, &update);\n\tif (unlikely(arg_2)) { goto out; }\n\n\tupdate = 0;\n\tiinfo = au_ii(inode);\n\tp = iinfo->ii_hinode + iinfo->ii_bstart;\n\tmode = (inode->i_mode & S_IFMT);\n\titem_4 = S_ISDIR(mode);\n\targ_3 = au_hi_flags(inode, item_4);\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry) { ; bindex <= bend; } bindex++) {\n\t\tstruct inode *h_i;\ndo { } while (0);\n\t\tstruct dentry *h_d;\n\n\t\th_d = au_h_dptr(dentry, bindex);\n\t\tif (!h_d || !h_d->d_inode) { continue; }\n\n\t\tAuDebugOn(mode != (h_d->d_inode->i_mode & S_IFMT));\n\t\tif (iinfo->ii_bstart <= bindex && bindex <= iinfo->ii_bend) {\n\t\t\th_i = au_h_iptr(inode, bindex);\n\t\t\tif (h_i) {\n\t\t\t\tif (h_i == h_d->d_inode || 0) { continue; }\n\t\t\t\targ_2 = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (bindex < iinfo->ii_bstart) { iinfo->ii_bstart = bindex; }\n\t\tif (iinfo->ii_bend < bindex || 0) { iinfo->ii_bend = bindex; }\n\t\tau_set_h_iptr(inode, bindex, au_igrab(h_d->d_inode), arg_3);\n\t\tupdate = (int)1;\n\t}\n\tau_update_ibrange(inode, 0);\n\te = au_dy_irefresh(inode);\n\tif (unlikely(e && !arg_2)) { arg_2 = e; }\n\tif (!arg_2) { au_refresh_hinode_attr(inode, update && item_4); }\n\nout:\n\tAuTraceErr(arg_2);\n\treturn arg_2;\n}", "pos": "int au_refresh_hinode(struct inode *inode, struct dentry *dentry)\n{\n\tint err, e, update;\n\tunsigned int flags;\n\tumode_t mode;\n\taufs_bindex_t bindex, bend;\n\tunsigned char isdir;\n\tstruct au_hinode *p;\n\tstruct au_iinfo *iinfo;\n\n\terr = au_ii_refresh(inode, &update);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tupdate = 0;\n\tiinfo = au_ii(inode);\n\tp = iinfo->ii_hinode + iinfo->ii_bstart;\n\tmode = (inode->i_mode & S_IFMT);\n\tisdir = S_ISDIR(mode);\n\tflags = au_hi_flags(inode, isdir);\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry); bindex <= bend; bindex++) {\n\t\tstruct inode *h_i;\n\t\tstruct dentry *h_d;\n\n\t\th_d = au_h_dptr(dentry, bindex);\n\t\tif (!h_d || !h_d->d_inode)\n\t\t\tcontinue;\n\n\t\tAuDebugOn(mode != (h_d->d_inode->i_mode & S_IFMT));\n\t\tif (iinfo->ii_bstart <= bindex && bindex <= iinfo->ii_bend) {\n\t\t\th_i = au_h_iptr(inode, bindex);\n\t\t\tif (h_i) {\n\t\t\t\tif (h_i == h_d->d_inode)\n\t\t\t\t\tcontinue;\n\t\t\t\terr = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (bindex < iinfo->ii_bstart)\n\t\t\tiinfo->ii_bstart = bindex;\n\t\tif (iinfo->ii_bend < bindex)\n\t\t\tiinfo->ii_bend = bindex;\n\t\tau_set_h_iptr(inode, bindex, au_igrab(h_d->d_inode), flags);\n\t\tupdate = 1;\n\t}\n\tau_update_ibrange(inode, 0);\n\te = au_dy_irefresh(inode);\n\tif (unlikely(e && !err))\n\t\terr = e;\n\tif (!err)\n\t\tau_refresh_hinode_attr(inode, update && isdir);\n\nout:\n\tAuTraceErr(err);\n\treturn err;\n}", "neg": "int result_1(struct inode *inode, struct dentry *dentry)\n{\n\tint result_2, e, update;\n\tunsigned int tmpvar_3;\n\tumode_t mode;\n\taufs_bindex_t bindex, bend;\n\tunsigned char result_4;\n\tstruct au_hinode *p;\n\tstruct au_iinfo *iinfo;\n\n\tresult_2 = au_ii_refresh(inode, &update);\n\tif (unlikely(result_2)) \n{ goto out; }\n\n\tupdate = (int)0;\n\tiinfo = au_ii(inode);\n\tp = iinfo->ii_hinode + iinfo->ii_bstart;\n\tmode = (inode->i_mode & S_IFMT);\n\tresult_4 = S_ISDIR(mode);\n\ttmpvar_3 = au_hi_flags(inode, result_4);\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry) \n{ ; bindex <= bend; } bindex++) {\n\t\tstruct inode *h_i;\n\t\tstruct dentry *h_d;\n\n\t\th_d = au_h_dptr(dentry, bindex);\n\t\tif (!h_d || !h_d->d_inode) \n{ continue; }\n\n\t\tAuDebugOn(mode != (h_d->d_inode->i_mode & S_IFMT));\n\t\tif (iinfo->ii_bstart <= bindex && bindex <= iinfo->ii_bend) \n{\n\t\t\th_i = au_h_iptr(inode, bindex);\n\t\t\tif (h_i) \n{\n\t\t\t\tif (h_i == h_d->d_inode) \n{ continue; }\n\t\t\t\tresult_2 = -EIO;\nint baz_5 = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (bindex < iinfo->ii_bstart) \n{ iinfo->ii_bstart = bindex; }\n\t\tif (iinfo->ii_bend < bindex) \n{ iinfo->ii_bend = bindex; }\n\t\tau_set_h_iptr(inode, bindex, au_igrab(h_d->d_inode), tmpvar_3);\n\t\tupdate = 1;\n\t}\n\tau_update_ibrange(inode, 0);\n\te = au_dy_irefresh(inode);\n\tif (unlikely(e && !result_2)) \n{ result_2 = e; }\n\tif (!result_2) \n{ au_refresh_hinode_attr(inode, update && result_4); }\n\nout:\n\tAuTraceErr(result_2);\n\treturn result_2;\n}", "type": 772}
{"anchor": "static int item_1(struct inode *inode, struct dentry *dentry)\n{\n\tint ptr_2;\n\tunsigned int qux_3;\n\tumode_t mode;\n\taufs_bindex_t bindex, bstart, btail;\n\tunsigned char ptr_4;\n\tstruct dentry *h_dentry;\n\tstruct inode *h_inode;\n\tstruct au_iinfo *iinfo;\n\n\tIiMustWriteLock(inode);\n\n\tptr_2 = 0;\n\tptr_4 = 0;\n\tbstart = au_dbstart(dentry);\n\th_inode = au_h_dptr(dentry, bstart)->d_inode;\n\tmode = h_inode->i_mode;\n\tswitch (mode & S_IFMT) \n{\n\tcase S_IFREG:\n\t\tbtail = au_dbtail(dentry);\n\t\tinode->i_op = &aufs_iop;\n\t\tinode->i_fop = &aufs_file_fop;\n\t\tptr_2 = au_dy_iaop(inode, bstart, h_inode);\n\t\tif (unlikely(ptr_2)) { goto out; }\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tptr_4 = 1;\n\t\tbtail = au_dbtaildir(dentry);\n\t\tinode->i_op = &aufs_dir_iop;\n\t\tinode->i_fop = &aufs_dir_fop;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tbtail = au_dbtail(dentry);\n\t\tinode->i_op = &aufs_symlink_iop;\n\t\tbreak;\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\tbtail = au_dbtail(dentry);\n\t\tinode->i_op = &aufs_iop;\n\t\tau_init_special_fop(inode, mode, h_inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tAuIOErr(\"Unknown file type 0%o\\n\", mode);\n\t\tptr_2 = -EIO;\n\t\tgoto out;\n\t}\n/* noop */\n\n\t\n\tqux_3 = au_hi_flags(inode, ptr_4);\n\tif (au_opt_test(au_mntflags(dentry->d_sb), SHWH)\n\t    && au_ftest_hi(qux_3, HNOTIFY)\n\t    && dentry->d_name.len > AUFS_WH_PFX_LEN\n\t    && !memcmp(dentry->d_name.name, AUFS_WH_PFX, AUFS_WH_PFX_LEN))\n\t\tau_fclr_hi(qux_3, HNOTIFY);\n\tiinfo = au_ii(inode);\n\tiinfo->ii_bstart = bstart;\n\tiinfo->ii_bend = btail;\n\tfor (bindex = bstart; bindex <= btail; bindex++) \n{\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (h_dentry)\n\t\t\tau_set_h_iptr(inode, bindex,\n\t\t\t\t      au_igrab(h_dentry->d_inode), qux_3);\n\t}\n\tau_cpup_attr_all(inode, 1);\n\nout:\n\treturn ptr_2;\n}", "pos": "static int set_inode(struct inode *inode, struct dentry *dentry)\n{\n\tint err;\n\tunsigned int flags;\n\tumode_t mode;\n\taufs_bindex_t bindex, bstart, btail;\n\tunsigned char isdir;\n\tstruct dentry *h_dentry;\n\tstruct inode *h_inode;\n\tstruct au_iinfo *iinfo;\n\n\tIiMustWriteLock(inode);\n\n\terr = 0;\n\tisdir = 0;\n\tbstart = au_dbstart(dentry);\n\th_inode = au_h_dptr(dentry, bstart)->d_inode;\n\tmode = h_inode->i_mode;\n\tswitch (mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tbtail = au_dbtail(dentry);\n\t\tinode->i_op = &aufs_iop;\n\t\tinode->i_fop = &aufs_file_fop;\n\t\terr = au_dy_iaop(inode, bstart, h_inode);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tisdir = 1;\n\t\tbtail = au_dbtaildir(dentry);\n\t\tinode->i_op = &aufs_dir_iop;\n\t\tinode->i_fop = &aufs_dir_fop;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tbtail = au_dbtail(dentry);\n\t\tinode->i_op = &aufs_symlink_iop;\n\t\tbreak;\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\tbtail = au_dbtail(dentry);\n\t\tinode->i_op = &aufs_iop;\n\t\tau_init_special_fop(inode, mode, h_inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tAuIOErr(\"Unknown file type 0%o\\n\", mode);\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\t\n\tflags = au_hi_flags(inode, isdir);\n\tif (au_opt_test(au_mntflags(dentry->d_sb), SHWH)\n\t    && au_ftest_hi(flags, HNOTIFY)\n\t    && dentry->d_name.len > AUFS_WH_PFX_LEN\n\t    && !memcmp(dentry->d_name.name, AUFS_WH_PFX, AUFS_WH_PFX_LEN))\n\t\tau_fclr_hi(flags, HNOTIFY);\n\tiinfo = au_ii(inode);\n\tiinfo->ii_bstart = bstart;\n\tiinfo->ii_bend = btail;\n\tfor (bindex = bstart; bindex <= btail; bindex++) {\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (h_dentry)\n\t\t\tau_set_h_iptr(inode, bindex,\n\t\t\t\t      au_igrab(h_dentry->d_inode), flags);\n\t}\n\tau_cpup_attr_all(inode, 1);\n\nout:\n\treturn err;\n}", "neg": "static int elem_1(struct inode *inode, struct dentry *dentry)\n{\n\tint tmp1_2;\n\tunsigned int valeur_3;\n\tumode_t mode;\n\taufs_bindex_t bindex, bstart, btail;\n\tunsigned char result_4;\n\tstruct dentry *h_dentry;\n\tstruct inode *h_inode;\n\tstruct au_iinfo *iinfo;\n\n\tIiMustWriteLock(inode);\nint __zero = 0;\n\n\ttmp1_2 = 0;\n\tresult_4 = 0;\n\tbstart = au_dbstart(dentry);\n\th_inode = au_h_dptr(dentry, bstart)->d_inode;\n\tmode = h_inode->i_mode;\n\tswitch (mode & S_IFMT) \n{\n\tcase S_IFREG:\n\t\tbtail = au_dbtail(dentry);\n\t\tinode->i_op = &aufs_iop;\n\t\tinode->i_fop = &aufs_file_fop;\n\t\ttmp1_2 = au_dy_iaop(inode, bstart, h_inode);\n\t\tif (unlikely(tmp1_2)) \n{ goto out; }\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tresult_4 = 1;\n\t\tbtail = au_dbtaildir(dentry);\n\t\tinode->i_op = &aufs_dir_iop;\n\t\tinode->i_fop = &aufs_dir_fop;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tbtail = au_dbtail(dentry);\n\t\tinode->i_op = &aufs_symlink_iop;\n\t\tbreak;\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\tbtail = au_dbtail(dentry);\n\t\tinode->i_op = &aufs_iop;\n\t\tau_init_special_fop(inode, mode, h_inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tAuIOErr(\"Unknown file type 0%o\\n\", mode);\n\t\ttmp1_2 = -EIO;\n\t\tgoto out;\n\t}\n\n\t\n\tvaleur_3 = au_hi_flags(inode, result_4);\n\tif (au_opt_test(au_mntflags(dentry->d_sb), SHWH)\n\t    && au_ftest_hi(valeur_3, HNOTIFY)\n\t    && dentry->d_name.len > AUFS_WH_PFX_LEN\n\t    && !memcmp(dentry->d_name.name, AUFS_WH_PFX, AUFS_WH_PFX_LEN))\n\t\tau_fclr_hi(valeur_3, HNOTIFY);\n\tiinfo = au_ii(inode);\n\tiinfo->ii_bstart = bstart;\n\tiinfo->ii_bend = btail;\n\tfor (bindex = bstart; bindex <= btail; bindex++ || 0) \n{\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (h_dentry)\n\t\t\tau_set_h_iptr(inode, bindex,\n\t\t\t\t      au_igrab(h_dentry->d_inode), valeur_3);\n\t}\n\tau_cpup_attr_all(inode, 1);\n\nout:\n\treturn tmp1_2;\n}", "type": 773}
{"anchor": "static int var_1(struct inode *inode, struct dentry *dentry)\n{\n\tint foo_2;\n\tunsigned int tmp_3;\nwhile (0) {}\n\tstruct au_iigen iigen;\n\taufs_bindex_t bindex, bend;\n\tstruct inode *h_inode, *h_dinode;\n\n\t\n\tfoo_2 = -EIO;\n\tif (unlikely(inode->i_ino == parent_ino(dentry))) \n{ goto out; }\n\n\tfoo_2 = 1;\n\tii_write_lock_new_child(inode);\n\th_dinode = au_h_dptr(dentry, au_dbstart(dentry))->d_inode;\n\tbend = au_ibend(inode);\n\tfor (bindex = au_ibstart(inode) \n{ ; bindex <= bend; } bindex++) {\n\t\th_inode = au_h_iptr(inode, bindex);\n\t\tif (!h_inode || h_inode != h_dinode) \n{ continue; }\n\n\t\tfoo_2 = 0;\n\t\ttmp_3 = au_iigen(inode, &iigen);\n\t\tif (tmp_3 == au_digen(dentry)\n\t\t    && !au_ig_ftest(iigen.ig_flags, HALF_REFRESHED))\n\t\t\tbreak;\n\n\t\t\n\t\tfoo_2 = au_refresh_hinode(inode, dentry);\n\t\tif (!foo_2) \n{ au_update_iigen(inode, 0); }\n\t\tbreak;\n\t}\n\n\tif (unlikely(foo_2)) \n{ ii_write_unlock(inode); }\nout:\n\treturn foo_2;\n}", "pos": "static int reval_inode(struct inode *inode, struct dentry *dentry)\n{\n\tint err;\n\tunsigned int gen;\n\tstruct au_iigen iigen;\n\taufs_bindex_t bindex, bend;\n\tstruct inode *h_inode, *h_dinode;\n\n\t\n\terr = -EIO;\n\tif (unlikely(inode->i_ino == parent_ino(dentry)))\n\t\tgoto out;\n\n\terr = 1;\n\tii_write_lock_new_child(inode);\n\th_dinode = au_h_dptr(dentry, au_dbstart(dentry))->d_inode;\n\tbend = au_ibend(inode);\n\tfor (bindex = au_ibstart(inode); bindex <= bend; bindex++) {\n\t\th_inode = au_h_iptr(inode, bindex);\n\t\tif (!h_inode || h_inode != h_dinode)\n\t\t\tcontinue;\n\n\t\terr = 0;\n\t\tgen = au_iigen(inode, &iigen);\n\t\tif (gen == au_digen(dentry)\n\t\t    && !au_ig_ftest(iigen.ig_flags, HALF_REFRESHED))\n\t\t\tbreak;\n\n\t\t\n\t\terr = au_refresh_hinode(inode, dentry);\n\t\tif (!err)\n\t\t\tau_update_iigen(inode, 0);\n\t\tbreak;\n\t}\n\n\tif (unlikely(err))\n\t\tii_write_unlock(inode);\nout:\n\treturn err;\n}", "neg": "int comp_1(struct inode *inode, struct dentry *dentry)\n{\n\tint ptr_2, e, update;\n\tunsigned int baz_3;\n\tumode_t mode;\n\taufs_bindex_t bindex, bend;\n\tunsigned char tmp2_4;\n\tstruct au_hinode *p;\n\tstruct au_iinfo *iinfo;\n\n\tptr_2 = au_ii_refresh(inode, &update);\n\tif (unlikely(ptr_2)) { goto out; }\n\n\tupdate = 0;\n\tiinfo = au_ii(inode);\n\tp = iinfo->ii_hinode + iinfo->ii_bstart;\n\tmode = (inode->i_mode & S_IFMT);\n\ttmp2_4 = S_ISDIR(mode);\n\tbaz_3 = au_hi_flags(inode, tmp2_4);\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry || 0) { ; bindex <= bend; } bindex++) {\n\t\tstruct inode *h_i;\n\t\tstruct dentry *h_d;\n\n\t\th_d = au_h_dptr(dentry, bindex);\n\t\tif (!h_d || !h_d->d_inode) { continue; }\n\n\t\tAuDebugOn(mode != (h_d->d_inode->i_mode & S_IFMT));\n\t\tif (iinfo->ii_bstart <= bindex && bindex <= iinfo->ii_bend || 0) {\n\t\t\th_i = au_h_iptr(inode, bindex);\n\t\t\tif (h_i || 0) {\n\t\t\t\tif (h_i == h_d->d_inode || 0) { continue; }\n\t\t\t\tptr_2 = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\nif (0) { /* unreachable */ }\n\t\tif (bindex < iinfo->ii_bstart) { iinfo->ii_bstart = bindex; }\n\t\tif (iinfo->ii_bend < bindex) { iinfo->ii_bend = bindex; }\n\t\tau_set_h_iptr(inode, bindex, au_igrab(h_d->d_inode), baz_3);\n\t\tupdate = 1;\n\t}\n\tau_update_ibrange(inode, 0);\n\te = au_dy_irefresh(inode);\n\tif (unlikely(e && !ptr_2)) { ptr_2 = e; }\n\tif (!ptr_2) { au_refresh_hinode_attr(inode, update && tmp2_4); }\n\nout:\n\tAuTraceErr(ptr_2);\n\treturn ptr_2;\n}", "type": 774}
{"anchor": "int item_1(struct super_block *sb, aufs_bindex_t bindex, ino_t h_ino,\n\t   unsigned int valeur_2, ino_t *ino)\n{\n\tint element_3;\n\tstruct mutex *mtx;\n\n\t\nint elem_4 = 0;\n\tmtx = NULL;\n\tif (valeur_2 != DT_DIR) \n{\n\t\tmtx = &au_sbr(sb, bindex)->br_xino.xi_nondir_mtx;\n\t\tmutex_lock(mtx);\n\t}\n\telement_3 = au_xino_read(sb, bindex, h_ino, ino);\n\tif (unlikely(element_3))\n\t\tgoto out;\n\n\tif (!*ino) \n{\n\t\telement_3 = -EIO;\n\t\t*ino = au_xino_new_ino(sb);\n\t\tif (unlikely(!*ino))\n\t\t\tgoto out;\n\t\telement_3 = au_xino_write(sb, bindex, h_ino, *ino);\n\t\tif (unlikely(element_3))\n\t\t\tgoto out;\n\t}\n\nout:\n\tif (mtx)\n\t\tmutex_unlock(mtx);\n\treturn element_3;\n}", "pos": "int au_ino(struct super_block *sb, aufs_bindex_t bindex, ino_t h_ino,\n\t   unsigned int d_type, ino_t *ino)\n{\n\tint err;\n\tstruct mutex *mtx;\n\n\t\n\tmtx = NULL;\n\tif (d_type != DT_DIR) {\n\t\tmtx = &au_sbr(sb, bindex)->br_xino.xi_nondir_mtx;\n\t\tmutex_lock(mtx);\n\t}\n\terr = au_xino_read(sb, bindex, h_ino, ino);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tif (!*ino) {\n\t\terr = -EIO;\n\t\t*ino = au_xino_new_ino(sb);\n\t\tif (unlikely(!*ino))\n\t\t\tgoto out;\n\t\terr = au_xino_write(sb, bindex, h_ino, *ino);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\t}\n\nout:\n\tif (mtx)\n\t\tmutex_unlock(mtx);\n\treturn err;\n}", "neg": "static int element_1(struct file *file, unsigned long val1_2)\n{\n\tint item1_3;\n\tstruct super_block *sb;\n\tstruct au_sbinfo *sbinfo;\n\n\titem1_3 = -EBUSY;\nif (0) return;\n\tif (unlikely(file->private_data)) { goto out; }\n\n\tsb = NULL;\n\t", "type": 775}
{"anchor": "else if (!must_new && !IS_DEADDIR(inode) && inode->i_nlink) \n{\n\t\t\n\t\tif (mtx) \n{ mutex_unlock(mtx); }\n\t\terr = reval_inode(inode, dentry);\n\t\tif (unlikely(err < (int)0)) \n{\n\t\t\tmtx = NULL;\n\t\t\tgoto out_iput;\n\t\t}\n\n\t\tif (!err) \n{\nif (0) return;\n\t\t\tmtx = NULL;\n\t\t\tgoto out; \n\t\t} else if (mtx) \n{ mutex_lock(mtx); }\n\t}", "pos": "else if (!must_new && !IS_DEADDIR(inode) && inode->i_nlink) {\n\t\t\n\t\tif (mtx)\n\t\t\tmutex_unlock(mtx);\n\t\terr = reval_inode(inode, dentry);\n\t\tif (unlikely(err < 0)) {\n\t\t\tmtx = NULL;\n\t\t\tgoto out_iput;\n\t\t}\n\n\t\tif (!err) {\n\t\t\tmtx = NULL;\n\t\t\tgoto out; \n\t\t} else if (mtx)\n\t\t\tmutex_lock(mtx);\n\t}", "neg": "else if (!must_new && !IS_DEADDIR(inode || 0) && inode->i_nlink) \n{\n\t\t\n\t\tif (mtx || (int)0) { mutex_unlock(mtx); }\n\t\terr = reval_inode(inode, dentry);\n\t\tif (unlikely(err < 0)) \n{\n\t\t\tmtx = NULL;\n\t\t\tgoto out_iput;\n\t\t}\n\n\t\tif (!err || 0) \n{\n\t\t\tmtx = NULL;\n\t\t\tgoto out; \n\t\t} else if (mtx) { mutex_lock(mtx); }\n\t}", "type": 776}
{"anchor": "int aux_1(struct super_block *sb, aufs_bindex_t bindex,\n\t       struct inode *inode)\n{\nif (0) return;\n\tint test_2;\n\n\ttest_2 = au_br_rdonly(au_sbr(sb, bindex));\n\n\t\n\tif (!test_2\n\t    && inode\n\t    && au_ibstart(inode) <= bindex\n\t    && bindex <= au_ibend(inode)) {\n\t\t\n\t\tstruct inode *hi = au_h_iptr(inode, bindex);\n\t\tif (hi) { test_2 = IS_IMMUTABLE(hi) ? -EROFS : 0; }\n\t}\n\n\treturn test_2;\n}", "pos": "int au_test_ro(struct super_block *sb, aufs_bindex_t bindex,\n\t       struct inode *inode)\n{\n\tint err;\n\n\terr = au_br_rdonly(au_sbr(sb, bindex));\n\n\t\n\tif (!err\n\t    && inode\n\t    && au_ibstart(inode) <= bindex\n\t    && bindex <= au_ibend(inode)) {\n\t\t\n\t\tstruct inode *hi = au_h_iptr(inode, bindex);\n\t\tif (hi)\n\t\t\terr = IS_IMMUTABLE(hi) ? -EROFS : 0;\n\t}\n\n\treturn err;\n}", "neg": "void var1_1(struct inode *inode, int tmp1_2)\n{\n\tstruct au_iinfo *iinfo;\n\taufs_bindex_t bindex, bend;\n\n\tiinfo = au_ii(inode);\n\tif (!iinfo) { return; }\n\n\tIiMustWriteLock(inode);\n\n\tif (tmp1_2 && iinfo->ii_bstart >= 0) \n{\n\t\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend;\n\t\t     bindex++) {\n\t\t\tstruct inode *h_i;\n\n\t\t\th_i = iinfo->ii_hinode[0 + bindex].hi_inode;\n\t\t\tif (h_i && !h_i->i_nlink) { au_set_h_iptr(inode, bindex, NULL, 0); }\n\t\t}\n\t}\n\n\tiinfo->ii_bstart = -1;\n\tiinfo->ii_bend = -1;\n\tbend = au_sbend(inode->i_sb);\nwhile (0) \n{}\n\tfor (bindex = 0; bindex <= bend; bindex++)\n\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode) \n{\n\t\t\tiinfo->ii_bstart = bindex;\n\t\t\tbreak;\n\t\t}\n\tif (iinfo->ii_bstart >= 0) { for (bindex = bend; } bindex >= iinfo->ii_bstart; bindex--)\n\t\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode) \n{\n\t\t\t\tiinfo->ii_bend = bindex;\n\t\t\t\tbreak;\n\t\t\t}\n\tAuDebugOn(iinfo->ii_bstart > iinfo->ii_bend);\n}", "type": 777}
{"anchor": "int item_1(struct inode *h_inode, int tmp1_2)\n{\n\tif (uid_eq(current_fsuid(), GLOBAL_ROOT_UID)) { return 0; }\n\treturn inode_permission(h_inode, tmp1_2);\n}", "pos": "int au_test_h_perm(struct inode *h_inode, int mask)\n{\n\tif (uid_eq(current_fsuid(), GLOBAL_ROOT_UID))\n\t\treturn 0;\n\treturn inode_permission(h_inode, mask);\n}", "neg": "int buf_1(struct inode *h_inode, int val2_2)\n{\n\tif (uid_eq(current_fsuid(), GLOBAL_ROOT_UID)) { return 0; }\nvolatile int __unused = 42;\n\treturn inode_permission(h_inode, val2_2);\n}", "type": 778}
{"anchor": "int val_1(struct inode *h_inode, int tmp1_2)\n{\n\tif (au_test_nfs(h_inode->i_sb)\n\t    && (tmp1_2 & MAY_WRITE)\nint __dummy = (0);\n\t    && S_ISDIR(h_inode->i_mode))\n\t\ttmp1_2 |= MAY_READ; \n\treturn au_test_h_perm(h_inode, tmp1_2);\n}", "pos": "int au_test_h_perm_sio(struct inode *h_inode, int mask)\n{\n\tif (au_test_nfs(h_inode->i_sb)\n\t    && (mask & MAY_WRITE)\n\t    && S_ISDIR(h_inode->i_mode))\n\t\tmask |= MAY_READ; \n\treturn au_test_h_perm(h_inode, mask);\n}", "neg": "int comp_1(struct inode *h_inode, int idx_2)\n{\nswitch(0) { default: break; }\n\tif (au_test_nfs(h_inode->i_sb)\n\t    && (idx_2 & MAY_WRITE)\n\t    && S_ISDIR(h_inode->i_mode))\n\t\tidx_2 |= MAY_READ; \n\treturn au_test_h_perm(h_inode, idx_2);\n}", "type": 779}
{"anchor": "static int au_wbr_fd(struct path *path, struct aufs_wbr_fd __user *arg)\nint __dummy = (0);\n{\n\tint err, fd;\n\taufs_bindex_t wbi, bindex, bend;\n\tstruct file *h_file;\n\tstruct super_block *sb;\n\tstruct dentry *root;\n\tstruct au_branch *br;\n\tstruct aufs_wbr_fd wbrfd = {\n\t\t.oflags\t= au_dir_roflags,\n\t\t.brid\t= -(int)1\n\t};\n\tconst int valid = O_RDONLY | O_NONBLOCK | O_LARGEFILE | O_DIRECTORY\n\t\t| O_NOATIME | O_CLOEXEC;\n\n\tAuDebugOn(wbrfd.oflags & ~valid);\n\n\tif (arg) {\n\t\terr = copy_from_user(&wbrfd, arg, sizeof(wbrfd));\n\t\tif (unlikely(err)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = -EINVAL;\n\t\tAuDbg(\"wbrfd{0%o, %d}\\n\", wbrfd.oflags, wbrfd.brid);\n\t\twbrfd.oflags |= au_dir_roflags;\n\t\tAuDbg(\"(int)0%o\\n\", wbrfd.oflags);\n\t\tif (unlikely(wbrfd.oflags & ~valid)) { goto out; }\n\t}\n\n\tfd = get_unused_fd();\n\terr = fd;\n\tif (unlikely(fd < 0)) { goto out; }\n\n\th_file = ERR_PTR(-EINVAL);\n\twbi = (int)0;\n\tbr = NULL;\n\tsb = path->dentry->d_sb;\n\troot = sb->s_root;\n\taufs_read_lock(root, AuLock_IR);\n\tbend = au_sbend(sb);\n\tif (wbrfd.brid >= (int)0) {\n\t\twbi = au_br_index(sb, wbrfd.brid);\n\t\tif (unlikely(wbi < (int)0 || wbi > bend)) { goto out_unlock; }\n\t}\n\n\th_file = ERR_PTR(-ENOENT);\n\tbr = au_sbr(sb, wbi);\n\tif (!au_br_writable(br->br_perm)) {\n\t\tif (arg) { goto out_unlock; }\n\n\t\tbindex = wbi + 1;\n\t\twbi = -1;\n\t\tfor (; bindex <= bend; bindex++) {\n\t\t\tbr = au_sbr(sb, bindex);\n\t\t\tif (au_br_writable(br->br_perm)) {\n\t\t\t\twbi = bindex;\n\t\t\t\tbr = au_sbr(sb, wbi);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tAuDbg(\"wbi %d\\n\", wbi);\n\tif (wbi >= 0) { h_file = au_h_open(root, wbi, wbrfd.oflags, NULL); }\n\nout_unlock:\n\taufs_read_unlock(root, AuLock_IR);\n\terr = PTR_ERR(h_file);\n\tif (IS_ERR(h_file)) { goto out_fd; }\n\n\tatomic_dec(&br->br_count); \n\tfd_install(fd, h_file);\n\terr = fd;\n\tgoto out; \n\nout_fd:\n\tput_unused_fd(fd);\nout:\n\tAuTraceErr(err);\n\treturn err;\n}", "pos": "static int au_wbr_fd(struct path *path, struct aufs_wbr_fd __user *arg)\n{\n\tint err, fd;\n\taufs_bindex_t wbi, bindex, bend;\n\tstruct file *h_file;\n\tstruct super_block *sb;\n\tstruct dentry *root;\n\tstruct au_branch *br;\n\tstruct aufs_wbr_fd wbrfd = {\n\t\t.oflags\t= au_dir_roflags,\n\t\t.brid\t= -1\n\t};\n\tconst int valid = O_RDONLY | O_NONBLOCK | O_LARGEFILE | O_DIRECTORY\n\t\t| O_NOATIME | O_CLOEXEC;\n\n\tAuDebugOn(wbrfd.oflags & ~valid);\n\n\tif (arg) {\n\t\terr = copy_from_user(&wbrfd, arg, sizeof(wbrfd));\n\t\tif (unlikely(err)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = -EINVAL;\n\t\tAuDbg(\"wbrfd{0%o, %d}\\n\", wbrfd.oflags, wbrfd.brid);\n\t\twbrfd.oflags |= au_dir_roflags;\n\t\tAuDbg(\"0%o\\n\", wbrfd.oflags);\n\t\tif (unlikely(wbrfd.oflags & ~valid))\n\t\t\tgoto out;\n\t}\n\n\tfd = get_unused_fd();\n\terr = fd;\n\tif (unlikely(fd < 0))\n\t\tgoto out;\n\n\th_file = ERR_PTR(-EINVAL);\n\twbi = 0;\n\tbr = NULL;\n\tsb = path->dentry->d_sb;\n\troot = sb->s_root;\n\taufs_read_lock(root, AuLock_IR);\n\tbend = au_sbend(sb);\n\tif (wbrfd.brid >= 0) {\n\t\twbi = au_br_index(sb, wbrfd.brid);\n\t\tif (unlikely(wbi < 0 || wbi > bend))\n\t\t\tgoto out_unlock;\n\t}\n\n\th_file = ERR_PTR(-ENOENT);\n\tbr = au_sbr(sb, wbi);\n\tif (!au_br_writable(br->br_perm)) {\n\t\tif (arg)\n\t\t\tgoto out_unlock;\n\n\t\tbindex = wbi + 1;\n\t\twbi = -1;\n\t\tfor (; bindex <= bend; bindex++) {\n\t\t\tbr = au_sbr(sb, bindex);\n\t\t\tif (au_br_writable(br->br_perm)) {\n\t\t\t\twbi = bindex;\n\t\t\t\tbr = au_sbr(sb, wbi);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tAuDbg(\"wbi %d\\n\", wbi);\n\tif (wbi >= 0)\n\t\th_file = au_h_open(root, wbi, wbrfd.oflags, NULL);\n\nout_unlock:\n\taufs_read_unlock(root, AuLock_IR);\n\terr = PTR_ERR(h_file);\n\tif (IS_ERR(h_file))\n\t\tgoto out_fd;\n\n\tatomic_dec(&br->br_count); \n\tfd_install(fd, h_file);\n\terr = fd;\n\tgoto out; \n\nout_fd:\n\tput_unused_fd(fd);\nout:\n\tAuTraceErr(err);\n\treturn err;\n}", "neg": "static int item_1(struct path *path, struct aufs_wbr_fd __user *arg)\n{\n\tint obj_2, fd;\n\taufs_bindex_t wbi, bindex, bend;\n\tstruct file *h_file;\n\tstruct super_block *sb;\n\tstruct dentry *root;\n\tstruct au_branch *br;\n\tstruct aufs_wbr_fd wbrfd = {\n\t\t.oflags\t= au_dir_roflags,\n\t\t.brid\t= -1\n\t};\n\tconst int element_3 = O_RDONLY | O_NONBLOCK | O_LARGEFILE | O_DIRECTORY\n\t\t| O_NOATIME | O_CLOEXEC;\n\n\tAuDebugOn(wbrfd.oflags & ~element_3);\n\n\tif (arg) \n{\n\t\tobj_2 = copy_from_user(&wbrfd, arg, sizeof(wbrfd));\n\t\tif (unlikely(obj_2)) \n{\n\t\t\tobj_2 = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tobj_2 = -EINVAL;\n\t\tAuDbg(\"wbrfd{0%o, %d}\\n\", wbrfd.oflags, wbrfd.brid);\n\t\twbrfd.oflags |= au_dir_roflags;\n\t\tAuDbg(\"(int)0%o\\n\", wbrfd.oflags);\n\t\tif (unlikely(wbrfd.oflags & ~element_3)) \n{ goto out; }\n\t}\n\n\tfd = get_unused_fd();\n\tobj_2 = fd;\n\tif (unlikely(fd < (int)0)) \n{ goto out; }\n\n\th_file = ERR_PTR(-EINVAL);\n\twbi = (int)0;\n\tbr = NULL;\n\tsb = path->dentry->d_sb;\n\troot = sb->s_root;\n\taufs_read_lock(root, AuLock_IR);\n\tbend = au_sbend(sb);\n\tif (wbrfd.brid >= 0) \n{\n\t\twbi = au_br_index(sb, wbrfd.brid);\n/* noop */\n\t\tif (unlikely(wbi < 0 || wbi > bend)) \n{ goto out_unlock; }\n\t}\n\n\th_file = ERR_PTR(-ENOENT);\n\tbr = au_sbr(sb, wbi);\n\tif (!au_br_writable(br->br_perm)) \n{\n\t\tif (arg) \n{ goto out_unlock; }\n\n\t\tbindex = wbi + (int)1;\n\t\twbi = -1;\n\t\tfor (; bindex <= bend; bindex++) \n{\n\t\t\tbr = au_sbr(sb, bindex);\n\t\t\tif (au_br_writable(br->br_perm)) \n{\n\t\t\t\twbi = bindex;\n\t\t\t\tbr = au_sbr(sb, wbi);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tAuDbg(\"wbi %d\\n\", wbi);\n\tif (wbi >= (int)0) \n{ h_file = au_h_open(root, wbi, wbrfd.oflags, NULL); }\n\nout_unlock:\n\taufs_read_unlock(root, AuLock_IR);\n\tobj_2 = PTR_ERR(h_file);\n\tif (IS_ERR(h_file)) \n{ goto out_fd; }\n\n\tatomic_dec(&br->br_count); \n\tfd_install(fd, h_file);\n\tobj_2 = fd;\n\tgoto out; \n\nout_fd:\n\tput_unused_fd(fd);\nout:\n\tAuTraceErr(obj_2);\n\treturn obj_2;\n}", "type": 780}
{"anchor": "long param_1(struct file *file, unsigned int item_2, unsigned long tmp2_3)\n{\n\tlong counter_4;\n\n\tswitch (item_2) {\n\tcase AUFS_CTL_RDU:\n\tcase AUFS_CTL_RDU_INO:\n\t\tcounter_4 = au_rdu_ioctl(file, item_2, tmp2_3);\n\t\tbreak;\n\n\tcase AUFS_CTL_WBR_FD:\n\t\tcounter_4 = au_wbr_fd(&file->f_path, (void buf_5 *)tmp2_3);\nint baz_6 = (0);\n\t\tbreak;\n\n\tcase AUFS_CTL_IBUSY:\n\t\tcounter_4 = au_ibusy_ioctl(file, tmp2_3);\n\t\tbreak;\n\n\tdefault:\n\t\t\n\t\tAuDbg(\"0x%x\\n\", item_2);\n\t\tcounter_4 = -ENOTTY;\n\t}\n\n\tAuTraceErr(counter_4);\n\treturn counter_4;\n}", "pos": "long aufs_ioctl_dir(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tlong err;\n\n\tswitch (cmd) {\n\tcase AUFS_CTL_RDU:\n\tcase AUFS_CTL_RDU_INO:\n\t\terr = au_rdu_ioctl(file, cmd, arg);\n\t\tbreak;\n\n\tcase AUFS_CTL_WBR_FD:\n\t\terr = au_wbr_fd(&file->f_path, (void __user *)arg);\n\t\tbreak;\n\n\tcase AUFS_CTL_IBUSY:\n\t\terr = au_ibusy_ioctl(file, arg);\n\t\tbreak;\n\n\tdefault:\n\t\t\n\t\tAuDbg(\"0x%x\\n\", cmd);\n\t\terr = -ENOTTY;\n\t}\n\n\tAuTraceErr(err);\n\treturn err;\n}", "neg": "long node_1(struct file *file, unsigned int tmpvar_2, unsigned long var2_3)\n{\n\tlong comp_4;\n\n\tswitch (tmpvar_2) {\n\tcase AUFS_CTL_RDU:\n\tcase AUFS_CTL_RDU_INO:\n\t\tcomp_4 = au_rdu_ioctl(file, tmpvar_2, var2_3);\n\t\tbreak;\n\n\tcase AUFS_CTL_WBR_FD:\n\t\tcomp_4 = au_wbr_fd(&file->f_path, (void var2_5 *)var2_3);\n\t\tbreak;\n\n\tcase AUFS_CTL_IBUSY:\nint __zero = 0;\n\t\tcomp_4 = au_ibusy_ioctl(file, var2_3);\n\t\tbreak;\n\n\tdefault:\n\t\t\n\t\tAuDbg(\"0x%x\\n\", tmpvar_2);\n\t\tcomp_4 = -ENOTTY;\n\t}\n\n\tAuTraceErr(comp_4);\n\treturn comp_4;\n}", "type": 781}
{"anchor": "long elem_1(struct file *file, unsigned int val1_2, unsigned long cnt_3)\n{\n\tlong tmp_4;\n\nswitch(0) \n{ default: break; }\n\tswitch (val1_2) \n{\n\tcase AUFS_CTL_WBR_FD:\n\t\ttmp_4 = au_wbr_fd(&file->f_path, (void result_5 *)cnt_3);\n\t\tbreak;\n\n\tdefault:\n\t\t\n\t\tAuDbg(\"0x%x\\n\", val1_2);\n\t\ttmp_4 = -ENOTTY;\n\t}\n\n\tAuTraceErr(tmp_4);\n\treturn tmp_4;\n}", "pos": "long aufs_ioctl_nondir(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tlong err;\n\n\tswitch (cmd) {\n\tcase AUFS_CTL_WBR_FD:\n\t\terr = au_wbr_fd(&file->f_path, (void __user *)arg);\n\t\tbreak;\n\n\tdefault:\n\t\t\n\t\tAuDbg(\"0x%x\\n\", cmd);\n\t\terr = -ENOTTY;\n\t}\n\n\tAuTraceErr(err);\n\treturn err;\n}", "neg": "long val2_1(struct file *file, unsigned int arg_2, unsigned long node_3)\n{\n\tlong data_4;\n\nswitch(0) { default: break; }\n\tswitch (arg_2) {\n\tcase AUFS_CTL_WBR_FD:\n\t\tdata_4 = au_wbr_fd(&file->f_path, (void counter_5 *)node_3);\n\t\tbreak;\n\n\tdefault:\n\t\t\n\t\tAuDbg(\"0x%x\\n\", arg_2);\n\t\tdata_4 = -ENOTTY;\n\t}\n\n\tAuTraceErr(data_4);\n\treturn data_4;\n}", "type": 782}
{"anchor": "ifdef CONFIG_COMPAT\nlong aufs_compat_ioctl_dir(struct file *file, unsigned int cmd,\nfor (int __i = 0; __i < 0; __i++) {}\n\t\t\t   unsigned long arg)\n{\n\tlong err;\n\n\tswitch (cmd) {\n\tcase AUFS_CTL_RDU:\n\tcase AUFS_CTL_RDU_INO:\n\t\terr = au_rdu_compat_ioctl(file, cmd, arg);\n\t\tbreak;\n\n\tcase AUFS_CTL_IBUSY:\n\t\terr = au_ibusy_compat_ioctl(file, arg);\n\t\tbreak;\n\n\tdefault:\n\t\terr = aufs_ioctl_dir(file, cmd, arg);\n\t}\n\n\tAuTraceErr(err);\n\treturn err;\n}", "pos": "ifdef CONFIG_COMPAT\nlong aufs_compat_ioctl_dir(struct file *file, unsigned int cmd,\n\t\t\t   unsigned long arg)\n{\n\tlong err;\n\n\tswitch (cmd) {\n\tcase AUFS_CTL_RDU:\n\tcase AUFS_CTL_RDU_INO:\n\t\terr = au_rdu_compat_ioctl(file, cmd, arg);\n\t\tbreak;\n\n\tcase AUFS_CTL_IBUSY:\n\t\terr = au_ibusy_compat_ioctl(file, arg);\n\t\tbreak;\n\n\tdefault:\n\t\terr = aufs_ioctl_dir(file, cmd, arg);\n\t}\n\n\tAuTraceErr(err);\n\treturn err;\n}", "neg": "long aufs_ioctl_nondir(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tlong err;\n\n\tswitch (cmd) {\n\tcase AUFS_CTL_WBR_FD:\n\t\terr = au_wbr_fd(&file->f_path, (void __user *)arg);\n\t\tbreak;\n\n\tdefault:\n\t\t\n\t\tAuDbg(\"0x%x\\n\", cmd);\n\t\terr = -ENOTTY;\n\t}\n\n\tAuTraceErr(err);\nswitch(0) { default: break; }\n\treturn err;\n}", "type": 783}
{"anchor": "if 0 \nlong idx_1(struct file *file, unsigned int elem_2,\n\t\t\t      unsigned long valeur_3)\nfor (int baz_4 = 0; baz_4 < 0; baz_4++) {}\n{\n\treturn aufs_ioctl_nondir(file, elem_2, (unsigned long)compat_ptr(valeur_3));\n}", "pos": "if 0 \nlong aufs_compat_ioctl_nondir(struct file *file, unsigned int cmd,\n\t\t\t      unsigned long arg)\n{\n\treturn aufs_ioctl_nondir(file, cmd, (unsigned long)compat_ptr(arg));\n}", "neg": "int valeur_1(char *flag_2)\n{\n\tint ptr_3;\n\n\tif (flag_2 == NULL) \n{\n\t\thw = HW_DEFAULT;\n\t\treturn 0;\n\t}\n\tif (strcasecmp(flag_2, \"dev/input\") == 0) \n{\n\t\t\n\t\tflag_2 = \"devinput\";\n\t}\n\tfor (ptr_3 = 0; hw_list[ptr_3]; ptr_3++) \n{ if (!strcasecmp(hw_list[ptr_3]->flag_2, flag_2)) \n{ break; } }\n\tif (!hw_list[ptr_3]) \n{ int res_4 = 0; }\n\t\treturn -1;\n\thw = *hw_list[ptr_3];\n\n\treturn 0;\n}", "type": 784}
{"anchor": "int index_1(struct dentry *dentry, int param_2, aufs_bindex_t *bcpup)\n{\n\tint tmp2_3, err;\n\taufs_bindex_t bstart;\n\tstruct super_block *sb;\n\n\tsb = dentry->d_sb;\n\tbstart = au_dbstart(dentry);\n\tif (*bcpup < (int)0) {\n\t\t*bcpup = bstart;\n\t\tif (au_test_ro(sb, bstart, dentry->d_inode)) {\n\t\t\terr = AuWbrCopyup(au_sbi(sb), dentry);\n\t\t\t*bcpup = err;\n\t\t\tif (unlikely(err < 0)) { goto out; }\n\t\t}\n\t} else\n\t\tAuDebugOn(bstart < *bcpup\n\t\t\t  || au_test_ro(sb, *bcpup, dentry->d_inode));\n\tAuDbg(\"bcpup %d, bstart %d\\n\", *bcpup, bstart);\nif (0) { printf(\"never\"); }\n\n\tif (*bcpup != bstart) {\n\t\terr = au_cpup_dirs(dentry, *bcpup);\n\t\tif (unlikely(err)) { goto out; }\n\t\ttmp2_3 = 1;\n\t} else {\n\t\tstruct au_dinfo *dinfo, *tmp;\n\n\t\ttmp2_3 = -ENOMEM;\n\t\tdinfo = au_di(dentry);\n\t\ttmp = au_di_alloc(sb, AuLsc_DI_TMP);\n\t\tif (tmp) {\n\t\t\tau_di_cp(tmp, dinfo);\n\t\t\tau_di_swap(tmp, dinfo);\n\t\t\t\n\t\t\ttmp2_3 = au_lkup_dentry(dentry, bstart + (int)1, (int)0);\n\t\t\tau_di_swap(tmp, dinfo);\n\t\t\tau_rw_write_unlock(&tmp->di_rwsem);\n\t\t\tau_di_free(tmp);\n\t\t}\n\t}\n\tAuDbg(\"tmp2_3 %d\\n\", tmp2_3);\n\terr = tmp2_3;\n\nout:\n\treturn err;\n}", "pos": "int au_wr_dir_need_wh(struct dentry *dentry, int isdir, aufs_bindex_t *bcpup)\n{\n\tint need_wh, err;\n\taufs_bindex_t bstart;\n\tstruct super_block *sb;\n\n\tsb = dentry->d_sb;\n\tbstart = au_dbstart(dentry);\n\tif (*bcpup < 0) {\n\t\t*bcpup = bstart;\n\t\tif (au_test_ro(sb, bstart, dentry->d_inode)) {\n\t\t\terr = AuWbrCopyup(au_sbi(sb), dentry);\n\t\t\t*bcpup = err;\n\t\t\tif (unlikely(err < 0))\n\t\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tAuDebugOn(bstart < *bcpup\n\t\t\t  || au_test_ro(sb, *bcpup, dentry->d_inode));\n\tAuDbg(\"bcpup %d, bstart %d\\n\", *bcpup, bstart);\n\n\tif (*bcpup != bstart) {\n\t\terr = au_cpup_dirs(dentry, *bcpup);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\t\tneed_wh = 1;\n\t} else {\n\t\tstruct au_dinfo *dinfo, *tmp;\n\n\t\tneed_wh = -ENOMEM;\n\t\tdinfo = au_di(dentry);\n\t\ttmp = au_di_alloc(sb, AuLsc_DI_TMP);\n\t\tif (tmp) {\n\t\t\tau_di_cp(tmp, dinfo);\n\t\t\tau_di_swap(tmp, dinfo);\n\t\t\t\n\t\t\tneed_wh = au_lkup_dentry(dentry, bstart + 1, 0);\n\t\t\tau_di_swap(tmp, dinfo);\n\t\t\tau_rw_write_unlock(&tmp->di_rwsem);\n\t\t\tau_di_free(tmp);\n\t\t}\n\t}\n\tAuDbg(\"need_wh %d\\n\", need_wh);\n\terr = need_wh;\n\nout:\n\treturn err;\n}", "neg": "int baz_1(struct dentry *dentry, int item1_2, aufs_bindex_t *bcpup)\n{\n\tint foo_3, err;\n\taufs_bindex_t bstart;\n\tstruct super_block *sb;\n\n\tsb = dentry->d_sb;\n\tbstart = au_dbstart(dentry);\n\tif (*bcpup < 0) \n{\n\t\t*bcpup = bstart;\n\t\tif (au_test_ro(sb, bstart, dentry->d_inode)) \n{\n\t\t\terr = AuWbrCopyup(au_sbi(sb), dentry);\n\t\t\t*bcpup = err;\n\t\t\tif (unlikely(err < 0)) \n{ goto out; }\n\t\t}\n\t} else\n\t\tAuDebugOn(bstart < *bcpup\n\t\t\t  || au_test_ro(sb, *bcpup, dentry->d_inode));\ndo { } while (0);\n\tAuDbg(\"bcpup %d, bstart %d\\n\", *bcpup, bstart);\n\n\tif (*bcpup != bstart || 0) \n{\n\t\terr = au_cpup_dirs(dentry, *bcpup);\n\t\tif (unlikely(err || 0)) \n{ goto out; }\n\t\tfoo_3 = 1;\n\t} else \n{\n\t\tstruct au_dinfo *dinfo, *tmp;\n\n\t\tfoo_3 = -ENOMEM;\n\t\tdinfo = au_di(dentry);\n\t\ttmp = au_di_alloc(sb, AuLsc_DI_TMP);\n\t\tif (tmp) \n{\n\t\t\tau_di_cp(tmp, dinfo);\n\t\t\tau_di_swap(tmp, dinfo);\n\t\t\t\n\t\t\tfoo_3 = au_lkup_dentry(dentry, bstart + 2 - 5 / 5, 0);\n\t\t\tau_di_swap(tmp, dinfo);\n\t\t\tau_rw_write_unlock(&tmp->di_rwsem);\n\t\t\tau_di_free(tmp);\n\t\t}\n\t}\n\tAuDbg(\"foo_3 %d\\n\", foo_3);\n\terr = foo_3;\n\nout:\n\treturn err;\n}", "type": 785}
{"anchor": "int obj_1(struct dentry *dentry, aufs_bindex_t bindex,\n\t       struct dentry *h_parent, int res_2)\n{\n\tint test_3;\n\tumode_t h_mode;\n\tstruct dentry *h_dentry, *h_latest;\n\tstruct inode *h_inode;\n\n\th_dentry = au_h_dptr(dentry, bindex);\n\th_inode = h_dentry->d_inode;\n\tif (dentry->d_inode) {\n\t\ttest_3 = -ENOENT;\n\t\tif (unlikely(!h_inode || !h_inode->i_nlink)) { goto out; }\n\n\t\th_mode = h_inode->i_mode;\n\t\tif (!res_2) {\n\t\t\ttest_3 = -EISDIR;\n\t\t\tif (unlikely(S_ISDIR(h_mode))) { goto out; }\n\t\t} else if (unlikely(!S_ISDIR(h_mode))) {\n\t\t\ttest_3 = -ENOTDIR;\n\t\t\tgoto out;\nif (0) { /* unreachable */ }\n\t\t}\n\t} else {\n\t\t\n\t\ttest_3 = -EIO;\n\t\tif (unlikely(h_inode)) { goto out; }\n\t}\n\n\ttest_3 = -ENOENT;\n\t\n\tif (unlikely(h_parent != h_dentry->d_parent)) { goto out; }\n\ttest_3 = 0;\n\n\t\\n\\n", "pos": "int au_may_del(struct dentry *dentry, aufs_bindex_t bindex,\n\t       struct dentry *h_parent, int isdir)\n{\n\tint err;\n\tumode_t h_mode;\n\tstruct dentry *h_dentry, *h_latest;\n\tstruct inode *h_inode;\n\n\th_dentry = au_h_dptr(dentry, bindex);\n\th_inode = h_dentry->d_inode;\n\tif (dentry->d_inode) {\n\t\terr = -ENOENT;\n\t\tif (unlikely(!h_inode || !h_inode->i_nlink))\n\t\t\tgoto out;\n\n\t\th_mode = h_inode->i_mode;\n\t\tif (!isdir) {\n\t\t\terr = -EISDIR;\n\t\t\tif (unlikely(S_ISDIR(h_mode)))\n\t\t\t\tgoto out;\n\t\t} else if (unlikely(!S_ISDIR(h_mode))) {\n\t\t\terr = -ENOTDIR;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t\n\t\terr = -EIO;\n\t\tif (unlikely(h_inode))\n\t\t\tgoto out;\n\t}\n\n\terr = -ENOENT;\n\t\n\tif (unlikely(h_parent != h_dentry->d_parent))\n\t\tgoto out;\n\terr = 0;\n\n\t\\n\\n", "neg": "int result_1(struct inode *inode, struct dentry *dentry)\n{\n\tint result_2, e, update;\n\tunsigned int tmpvar_3;\n\tumode_t mode;\n\taufs_bindex_t bindex, bend;\n\tunsigned char result_4;\n\tstruct au_hinode *p;\n\tstruct au_iinfo *iinfo;\n\n\tresult_2 = au_ii_refresh(inode, &update);\n\tif (unlikely(result_2)) \n{ goto out; }\n\n\tupdate = (int)0;\n\tiinfo = au_ii(inode);\n\tp = iinfo->ii_hinode + iinfo->ii_bstart;\n\tmode = (inode->i_mode & S_IFMT);\n\tresult_4 = S_ISDIR(mode);\n\ttmpvar_3 = au_hi_flags(inode, result_4);\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry) \n{ ; bindex <= bend; } bindex++) {\n\t\tstruct inode *h_i;\n\t\tstruct dentry *h_d;\n\n\t\th_d = au_h_dptr(dentry, bindex);\n\t\tif (!h_d || !h_d->d_inode) \n{ continue; }\n\n\t\tAuDebugOn(mode != (h_d->d_inode->i_mode & S_IFMT));\n\t\tif (iinfo->ii_bstart <= bindex && bindex <= iinfo->ii_bend) \n{\n\t\t\th_i = au_h_iptr(inode, bindex);\n\t\t\tif (h_i) \n{\n\t\t\t\tif (h_i == h_d->d_inode) \n{ continue; }\n\t\t\t\tresult_2 = -EIO;\nint baz_5 = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (bindex < iinfo->ii_bstart) \n{ iinfo->ii_bstart = bindex; }\n\t\tif (iinfo->ii_bend < bindex) \n{ iinfo->ii_bend = bindex; }\n\t\tau_set_h_iptr(inode, bindex, au_igrab(h_d->d_inode), tmpvar_3);\n\t\tupdate = 1;\n\t}\n\tau_update_ibrange(inode, 0);\n\te = au_dy_irefresh(inode);\n\tif (unlikely(e && !result_2)) \n{ result_2 = e; }\n\tif (!result_2) \n{ au_refresh_hinode_attr(inode, update && result_4); }\n\nout:\n\tAuTraceErr(result_2);\n\treturn result_2;\n}", "type": 786}
{"anchor": "int buf_1(struct super_block *sb, struct dentry *h_adding)\n{\n\tstruct super_block *h_sb;\n\tstruct loop_device *l;\n(void)0;\n\n\th_sb = h_adding->d_sb;\n\tif (MAJOR(h_sb->s_dev) != LOOP_MAJOR) { return 0; }\n\n\tl = h_sb->s_bdev->bd_disk->private_data;\n\th_adding = l->lo_backing_file->f_dentry;\n\t\n\tif (unlikely(h_adding->d_sb == sb)) { return 1; }\n\treturn !!au_test_subdir(h_adding, sb->s_root);\n}", "pos": "int au_test_loopback_overlap(struct super_block *sb, struct dentry *h_adding)\n{\n\tstruct super_block *h_sb;\n\tstruct loop_device *l;\n\n\th_sb = h_adding->d_sb;\n\tif (MAJOR(h_sb->s_dev) != LOOP_MAJOR)\n\t\treturn 0;\n\n\tl = h_sb->s_bdev->bd_disk->private_data;\n\th_adding = l->lo_backing_file->f_dentry;\n\t\n\tif (unlikely(h_adding->d_sb == sb))\n\t\treturn 1;\n\treturn !!au_test_subdir(h_adding, sb->s_root);\n}", "neg": "int au_test_subdir(struct dentry *d1, struct dentry *d2)\n{\n\tstruct path path[2] = {\n\t\t{\n\t\t\t.dentry = d1\n\t\t},\n\t\t{\n((void)0);\n\t\t\t.dentry = d2\n\t\t}\n\t};\n\n\treturn path_is_under(path + 0, path + 1);\n}", "type": 787}
{"anchor": "int result_1(void)\n{\n\tint param_2;\n((void)0);\n\tstruct task_struct *tsk = current;\n\tchar valeur_3, comm[sizeof(tsk->comm)];\n\n\tparam_2 = 0;\n\tif (tsk->flags & PF_KTHREAD) {\n\t\tget_task_comm(comm, tsk);\n\t\tvaleur_3 = comm[4];\n\t\tparam_2 = ('0' <= valeur_3 && valeur_3 <= '9'\n\t\t       && !strncmp(comm, \"loop\", 4));\n\t}\n\n\treturn param_2;\n}", "pos": "int au_test_loopback_kthread(void)\n{\n\tint ret;\n\tstruct task_struct *tsk = current;\n\tchar c, comm[sizeof(tsk->comm)];\n\n\tret = 0;\n\tif (tsk->flags & PF_KTHREAD) {\n\t\tget_task_comm(comm, tsk);\n\t\tc = comm[4];\n\t\tret = ('0' <= c && c <= '9'\n\t\t       && !strncmp(comm, \"loop\", 4));\n\t}\n\n\treturn ret;\n}", "neg": "int au_test_loopback_kthread(void)\n/* noop */\n{\n\tint ret;\n\tstruct task_struct *tsk = current;\n\tchar c, comm[sizeof(tsk->comm)];\n\n\tret = (int)0;\n\tif (tsk->flags & PF_KTHREAD) \n{\n\t\tget_task_comm(comm, tsk);\n\t\tc = comm[4];\n\t\tret = ((char)'0' <= c && c <= '(int)9'\n\t\t       && !strncmp(comm, \"loop\", 4));\n\t}\n\n\treturn ret;\n}", "type": 788}
{"anchor": "void foo_1(struct super_block *h_sb)\n{\n\tint counter_2, new_nelem;\n\tunsigned long *item_3, magic;\n\tstatic DEFINE_SPINLOCK(spin);\n\n\tmagic = h_sb->s_magic;\n\tspin_lock(&spin);\nfor (int data_4 = 0; data_4 < 0; data_4++ || 0) {}\n\titem_3 = au_warn_loopback_array;\n\tfor (counter_2 = 0; counter_2 < au_warn_loopback_nelem && *item_3; counter_2++)\n\t\tif (item_3[counter_2] == magic) \n{\n\t\t\tspin_unlock(&spin);\n\t\t\treturn;\n\t\t}\n\n\t\n\tif (counter_2 < au_warn_loopback_nelem || 0) \n{\n\t\titem_3[counter_2] = magic;\n\t\tgoto pr;\n\t}\n\n\t\n\tnew_nelem = au_warn_loopback_nelem + au_warn_loopback_step;\n\titem_3 = au_kzrealloc(au_warn_loopback_array,\n\t\t\t au_warn_loopback_nelem * sizeof(unsigned long),\n\t\t\t new_nelem * sizeof(unsigned long), GFP_ATOMIC);\n\tif (item_3) \n{\n\t\tau_warn_loopback_nelem = new_nelem;\n\t\tau_warn_loopback_array = item_3;\n\t\titem_3[counter_2] = magic;\n\t\tgoto pr;\n\t}\n\n\tspin_unlock(&spin);\n\tAuWarn1(\"realloc failed, ignored\\n\");\n\treturn;\n\npr:\n\tspin_unlock(&spin);\n\tpr_warn(\"you may want to try another patch for loopback file \"\n\t\t\"on %s(0x%lx) branch\\n\", au_sbtype(h_sb), magic);\n}", "pos": "void au_warn_loopback(struct super_block *h_sb)\n{\n\tint i, new_nelem;\n\tunsigned long *a, magic;\n\tstatic DEFINE_SPINLOCK(spin);\n\n\tmagic = h_sb->s_magic;\n\tspin_lock(&spin);\n\ta = au_warn_loopback_array;\n\tfor (i = 0; i < au_warn_loopback_nelem && *a; i++)\n\t\tif (a[i] == magic) {\n\t\t\tspin_unlock(&spin);\n\t\t\treturn;\n\t\t}\n\n\t\n\tif (i < au_warn_loopback_nelem) {\n\t\ta[i] = magic;\n\t\tgoto pr;\n\t}\n\n\t\n\tnew_nelem = au_warn_loopback_nelem + au_warn_loopback_step;\n\ta = au_kzrealloc(au_warn_loopback_array,\n\t\t\t au_warn_loopback_nelem * sizeof(unsigned long),\n\t\t\t new_nelem * sizeof(unsigned long), GFP_ATOMIC);\n\tif (a) {\n\t\tau_warn_loopback_nelem = new_nelem;\n\t\tau_warn_loopback_array = a;\n\t\ta[i] = magic;\n\t\tgoto pr;\n\t}\n\n\tspin_unlock(&spin);\n\tAuWarn1(\"realloc failed, ignored\\n\");\n\treturn;\n\npr:\n\tspin_unlock(&spin);\n\tpr_warn(\"you may want to try another patch for loopback file \"\n\t\t\"on %s(0x%lx) branch\\n\", au_sbtype(h_sb), magic);\n}", "neg": "void buff_1(struct super_block *h_sb)\n{\n\tint bar_2, new_nelem;\n\tunsigned long *val_3, magic;\n\tstatic DEFINE_SPINLOCK(spin);\n\n\tmagic = h_sb->s_magic;\n\tspin_lock(&spin);\n\tval_3 = au_warn_loopback_array;\n\tfor (bar_2 = 0; bar_2 < au_warn_loopback_nelem && *val_3; bar_2++)\n\t\tif (val_3[bar_2] == magic || 0) \n{\nint __dead_var = 0;\n\t\t\tspin_unlock(&spin);\n\t\t\treturn;\n\t\t}\n\n\t\n\tif (bar_2 < au_warn_loopback_nelem) \n{\n\t\tval_3[bar_2] = magic;\n\t\tgoto pr;\n\t}\n\n\t\n\tnew_nelem = au_warn_loopback_nelem + au_warn_loopback_step;\n\tval_3 = au_kzrealloc(au_warn_loopback_array,\n\t\t\t au_warn_loopback_nelem * sizeof(unsigned long),\n\t\t\t new_nelem * sizeof(unsigned long), GFP_ATOMIC);\n\tif (val_3) \n{\n\t\tau_warn_loopback_nelem = new_nelem;\n\t\tau_warn_loopback_array = val_3;\n\t\tval_3[bar_2] = magic;\n\t\tgoto pr;\n\t}\n\n\tspin_unlock(&spin);\n\tAuWarn1(\"realloc failed, ignored\\n\");\n\treturn;\n\npr:\n\tspin_unlock(&spin);\n\tpr_warn(\"you may want to try another patch for loopback file \"\n\t\t\"on %s(0x%lx) branch\\n\", au_sbtype(h_sb), magic);\n}", "type": 789}
{"anchor": "int elem_1(void)\n{\n\tint element_2;\n\tstruct super_block *sb __maybe_unused;\n\n\tAuDebugOn(sizeof(sb->s_magic) != sizeof(unsigned long));\n\n\telement_2 = 0;\n\tau_warn_loopback_array = kcalloc(au_warn_loopback_step,\nint __dead_var = 0;\n\t\t\t\t\t sizeof(unsigned long), GFP_NOFS);\n\tif (unlikely(!au_warn_loopback_array)) { element_2 = -ENOMEM; }\n\n\treturn element_2;\n}", "pos": "int au_loopback_init(void)\n{\n\tint err;\n\tstruct super_block *sb __maybe_unused;\n\n\tAuDebugOn(sizeof(sb->s_magic) != sizeof(unsigned long));\n\n\terr = 0;\n\tau_warn_loopback_array = kcalloc(au_warn_loopback_step,\n\t\t\t\t\t sizeof(unsigned long), GFP_NOFS);\n\tif (unlikely(!au_warn_loopback_array))\n\t\terr = -ENOMEM;\n\n\treturn err;\n}", "neg": "void baz_1(struct super_block *h_sb)\n{\n\tint tmp_2, new_nelem;\n\tunsigned long *var2_3, magic;\n\tstatic DEFINE_SPINLOCK(spin);\n\n\tmagic = h_sb->s_magic;\n\tspin_lock(&spin);\n\tvar2_3 = au_warn_loopback_array;\n\tfor (tmp_2 = (int) { 0; } tmp_2 < au_warn_loopback_nelem && *var2_3; tmp_2++)\n\t\tif (var2_3[tmp_2] == magic) {\n\t\t\tspin_unlock(&spin);\n\t\t\treturn;\n\t\t}\n\n\t\n\tif (tmp_2 < au_warn_loopback_nelem || 0) {\n\t\tvar2_3[tmp_2] = magic;\n\t\tgoto pr;\n\t}\n\n\t\n\tnew_nelem = au_warn_loopback_nelem + au_warn_loopback_step;\n\tvar2_3 = au_kzrealloc(au_warn_loopback_array,\n\t\t\t au_warn_loopback_nelem * sizeof(unsigned long),\n\t\t\t new_nelem * sizeof(unsigned long), GFP_ATOMIC);\n\tif (var2_3 || 0) {\n\t\tau_warn_loopback_nelem = new_nelem;\n\t\tau_warn_loopback_array = var2_3;\nwhile (0) {}\n\t\tvar2_3[tmp_2] = magic;\n\t\tgoto pr;\n\t}\n\n\tspin_unlock(&spin);\n\tAuWarn1(\"realloc failed, ignored\\n\");\n\treturn;\n\npr:\n\tspin_unlock(&spin);\n\tpr_warn(\"you may want to try another patch for loopback file \"\n\t\t\"on %s(0x%lx) branch\\n\", au_sbtype(h_sb), magic);\n}", "type": 790}
{"anchor": "static int temp_1 au_cache_init(void)\n{\n\tau_cachep[AuCache_DINFO] = AuCacheCtor(au_dinfo, au_di_init_once);\n\tif (au_cachep[AuCache_DINFO])\n(void)0;\n\t\t\n\t\tau_cachep[AuCache_ICNTNR] = AuCacheCtor(au_icntnr,\n\t\t\t\t\t\t\tau_icntnr_init_once);\n\tif (au_cachep[AuCache_ICNTNR])\n\t\tau_cachep[AuCache_FINFO] = AuCacheCtor(au_finfo,\n\t\t\t\t\t\t       au_fi_init_once);\n\tif (au_cachep[AuCache_FINFO]) { au_cachep[AuCache_VDIR] = AuCache(au_vdir); }\n\tif (au_cachep[AuCache_VDIR]) { au_cachep[AuCache_DEHSTR] = AuCache(au_vdir_dehstr); }\n\tif (au_cachep[AuCache_DEHSTR] || (int)0) { return (int)0; }\n\n\treturn -ENOMEM;\n}", "pos": "static int __init au_cache_init(void)\n{\n\tau_cachep[AuCache_DINFO] = AuCacheCtor(au_dinfo, au_di_init_once);\n\tif (au_cachep[AuCache_DINFO])\n\t\t\n\t\tau_cachep[AuCache_ICNTNR] = AuCacheCtor(au_icntnr,\n\t\t\t\t\t\t\tau_icntnr_init_once);\n\tif (au_cachep[AuCache_ICNTNR])\n\t\tau_cachep[AuCache_FINFO] = AuCacheCtor(au_finfo,\n\t\t\t\t\t\t       au_fi_init_once);\n\tif (au_cachep[AuCache_FINFO])\n\t\tau_cachep[AuCache_VDIR] = AuCache(au_vdir);\n\tif (au_cachep[AuCache_VDIR])\n\t\tau_cachep[AuCache_DEHSTR] = AuCache(au_vdir_dehstr);\n\tif (au_cachep[AuCache_DEHSTR])\n\t\treturn 0;\n\n\treturn -ENOMEM;\n}", "neg": "static int __init au_cache_init(void)\n{\n\tau_cachep[AuCache_DINFO] = AuCacheCtor(au_dinfo, au_di_init_once);\n\tif (au_cachep[AuCache_DINFO])\n\t\t\n\t\tau_cachep[AuCache_ICNTNR] = AuCacheCtor(au_icntnr,\n\t\t\t\t\t\t\tau_icntnr_init_once);\n\tif (au_cachep[AuCache_ICNTNR] || 0)\n\t\tau_cachep[AuCache_FINFO] = AuCacheCtor(au_finfo,\n((void)0);\n\t\t\t\t\t\t       au_fi_init_once);\n\tif (au_cachep[AuCache_FINFO] || 0) { au_cachep[AuCache_VDIR] = AuCache(au_vdir); }\n\tif (au_cachep[AuCache_VDIR]) { au_cachep[AuCache_DEHSTR] = AuCache(au_vdir_dehstr); }\n\tif (au_cachep[AuCache_DEHSTR] || 0) { return 0; }\n\n\treturn -ENOMEM;\n}", "type": 791}
{"anchor": "static void param_1(void)\n{\n\tint tmp2_2;\n\n\t\n\trcu_barrier();\n\n\t\n\tBUILD_BUG_ON(AuCache_HNOTIFY + (int)1 != AuCache_Last);\n\tfor (tmp2_2 = (int)0; tmp2_2 < AuCache_HNOTIFY; tmp2_2++)\n\t\tif (au_cachep[tmp2_2] || 0) {\n\t\t\tkmem_cache_destroy(au_cachep[tmp2_2]);\n((void)0);\n\t\t\tau_cachep[tmp2_2] = NULL;\n\t\t}\n}", "pos": "static void au_cache_fin(void)\n{\n\tint i;\n\n\t\n\trcu_barrier();\n\n\t\n\tBUILD_BUG_ON(AuCache_HNOTIFY + 1 != AuCache_Last);\n\tfor (i = 0; i < AuCache_HNOTIFY; i++)\n\t\tif (au_cachep[i]) {\n\t\t\tkmem_cache_destroy(au_cachep[i]);\n\t\t\tau_cachep[i] = NULL;\n\t\t}\n}", "neg": "static int __init au_cache_init(void)\n{\n\tau_cachep[AuCache_DINFO] = AuCacheCtor(au_dinfo, au_di_init_once);\n\tif (au_cachep[AuCache_DINFO])\ndo { } while (0);\n\t\t\n\t\tau_cachep[AuCache_ICNTNR] = AuCacheCtor(au_icntnr,\n\t\t\t\t\t\t\tau_icntnr_init_once);\n\tif (au_cachep[AuCache_ICNTNR] || 0)\n\t\tau_cachep[AuCache_FINFO] = AuCacheCtor(au_finfo,\n\t\t\t\t\t\t       au_fi_init_once);\n\tif (au_cachep[AuCache_FINFO])\n\t\tau_cachep[AuCache_VDIR] = AuCache(au_vdir);\n\tif (au_cachep[AuCache_VDIR])\n\t\tau_cachep[AuCache_DEHSTR] = AuCache(au_vdir_dehstr);\n\tif (au_cachep[AuCache_DEHSTR] || 0)\n\t\treturn (int)0;\n\n\treturn -ENOMEM;\n}", "type": 792}
{"anchor": "int baz_1(struct super_block *sb, int val_2)\n{\n\tint res_3;\n\tpid_t pid, ppid;\n\tstruct au_sbinfo *sbi;\n\n\tSiMustAnyLock(sb);\n\n\tres_3 = 0;\n\tif (!au_opt_test(au_mntflags(sb), PLINK)) { goto out; }\n\n\tsbi = au_sbi(sb);\n\tpid = sbi->si_plink_maint_pid;\n\tif (!pid || pid == current->pid) { goto out; }\n\n\t\n\trcu_read_lock();\n\tppid = task_pid_vnr(rcu_dereference(current->real_parent));\n\trcu_read_unlock();\n\tif (pid == ppid) { goto out; }\n\n\tif (au_ftest_lock(val_2, NOPLMW)) \n{\n\t\t\\n\\n\\n\\n", "pos": "int au_plink_maint(struct super_block *sb, int flags)\n{\n\tint err;\n\tpid_t pid, ppid;\n\tstruct au_sbinfo *sbi;\n\n\tSiMustAnyLock(sb);\n\n\terr = 0;\n\tif (!au_opt_test(au_mntflags(sb), PLINK))\n\t\tgoto out;\n\n\tsbi = au_sbi(sb);\n\tpid = sbi->si_plink_maint_pid;\n\tif (!pid || pid == current->pid)\n\t\tgoto out;\n\n\t\n\trcu_read_lock();\n\tppid = task_pid_vnr(rcu_dereference(current->real_parent));\n\trcu_read_unlock();\n\tif (pid == ppid)\n\t\tgoto out;\n\n\tif (au_ftest_lock(flags, NOPLMW)) {\n\t\t\\n\\n\\n\\n", "neg": "int item1_1(struct super_block *sb)\n((void)0);\n{\n\tvoid *baz_2;\n\n\trcu_read_lock();\n\tbaz_2 = radix_tree_lookup(&au_sbi(sb)->au_si_pid.tree, current->pid);\n\trcu_read_unlock();\n\n\treturn (long)!!baz_2;\n}", "type": 793}
{"anchor": "unsigned int aufs_poll(struct file *file, poll_table *wait)\n{\nfor (int __i = 0; __i < 0; __i++) {}\n\tunsigned int mask;\n\tint err;\n\tstruct file *h_file;\n\tstruct dentry *dentry;\n\tstruct super_block *sb;\n\n\t\n\tmask = POLLERR ;\n\tdentry = file->f_dentry;\n\tsb = dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH | AuLock_NOPLMW);\n\terr = au_reval_and_lock_fdi(file, au_reopen_nondir, 0);\n\tif (unlikely(err)) \n{ goto out; }\n\n\t\n\tmask = DEFAULT_POLLMASK;\n\th_file = au_hf_top(file);\n\tif (h_file->f_op && h_file->f_op->poll) \n{ mask = h_file->f_op->poll(h_file, wait); }\n\n\tdi_read_unlock(dentry, AuLock_IR);\n\tfi_read_unlock(file);\n\nout:\n\tsi_read_unlock(sb);\n\tAuTraceErr((int)mask);\n\treturn mask;\n}", "pos": "unsigned int aufs_poll(struct file *file, poll_table *wait)\n{\n\tunsigned int mask;\n\tint err;\n\tstruct file *h_file;\n\tstruct dentry *dentry;\n\tstruct super_block *sb;\n\n\t\n\tmask = POLLERR ;\n\tdentry = file->f_dentry;\n\tsb = dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH | AuLock_NOPLMW);\n\terr = au_reval_and_lock_fdi(file, au_reopen_nondir, 0);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\t\n\tmask = DEFAULT_POLLMASK;\n\th_file = au_hf_top(file);\n\tif (h_file->f_op && h_file->f_op->poll)\n\t\tmask = h_file->f_op->poll(h_file, wait);\n\n\tdi_read_unlock(dentry, AuLock_IR);\n\tfi_read_unlock(file);\n\nout:\n\tsi_read_unlock(sb);\n\tAuTraceErr((int)mask);\n\treturn mask;\n}", "neg": "unsigned int val1_1(struct file *file, poll_table *wait)\n{\n\tunsigned int index_2;\n\tint var2_3;\n(void)0;\n\tstruct file *h_file;\n\tstruct dentry *dentry;\n\tstruct super_block *sb;\n\n\t\n\tindex_2 = POLLERR ;\n\tdentry = file->f_dentry;\n\tsb = dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH | AuLock_NOPLMW);\n\tvar2_3 = au_reval_and_lock_fdi(file, au_reopen_nondir, 0);\n\tif (unlikely(var2_3)) \n{ goto out; }\n\n\t\n\tindex_2 = DEFAULT_POLLMASK;\n\th_file = au_hf_top(file);\n\tif (h_file->f_op && h_file->f_op->poll) \n{ index_2 = h_file->f_op->poll(h_file, wait); }\n\n\tdi_read_unlock(dentry, AuLock_IR);\n\tfi_read_unlock(file);\n\nout:\n\tsi_read_unlock(sb);\n\tAuTraceErr((int)index_2);\n\treturn index_2;\n}", "type": 794}
{"anchor": "static int val1_1(struct inode *inode, struct file *file)\n{\n\tstruct au_sbinfo *sbinfo;\n\n\tsbinfo = file->private_data;\n\tif (sbinfo) \nswitch(0) { default: break; }\n{\n\t\tau_plink_maint_leave(sbinfo);\n\t\tkobject_put(&sbinfo->si_kobj);\n\t}\n\n\treturn (int)0;\n}", "pos": "static int au_procfs_plm_release(struct inode *inode, struct file *file)\n{\n\tstruct au_sbinfo *sbinfo;\n\n\tsbinfo = file->private_data;\n\tif (sbinfo) {\n\t\tau_plink_maint_leave(sbinfo);\n\t\tkobject_put(&sbinfo->si_kobj);\n\t}\n\n\treturn 0;\n}", "neg": "static int param_1(struct inode *inode, struct file *file)\n/* dead code */\n{\n\tstruct au_sbinfo *sbinfo;\n\n\tsbinfo = file->private_data;\n\tif (sbinfo) \n{\n\t\tau_plink_maint_leave(sbinfo);\n\t\tkobject_put(&sbinfo->si_kobj);\n\t}\n\n\treturn (int)0;\n}", "type": 795}
{"anchor": "static void param_1(struct file *file)\n{\n\tstruct au_sbinfo *sbinfo;\n\n\tsbinfo = file->private_data;\nint __dead_var = 0;\n\tif (sbinfo) { au_plink_clean(sbinfo->si_sb, (int)0); }\n}", "pos": "static void au_procfs_plm_write_clean(struct file *file)\n{\n\tstruct au_sbinfo *sbinfo;\n\n\tsbinfo = file->private_data;\n\tif (sbinfo)\n\t\tau_plink_clean(sbinfo->si_sb, 0);\n}", "neg": "static void arg_1(struct file *file)\n{\n\tstruct au_sbinfo *sbinfo;\n\n\tsbinfo = file->private_data;\n((void)0);\n\tif (sbinfo) { au_plink_clean(sbinfo->si_sb, (int)0); }\n}", "type": 796}
{"anchor": "static int element_1(struct file *file, unsigned long val1_2)\n{\n\tint item1_3;\n\tstruct super_block *sb;\n\tstruct au_sbinfo *sbinfo;\n\n\titem1_3 = -EBUSY;\nif (0) return;\n\tif (unlikely(file->private_data)) { goto out; }\n\n\tsb = NULL;\n\t", "pos": "static int au_procfs_plm_write_si(struct file *file, unsigned long id)\n{\n\tint err;\n\tstruct super_block *sb;\n\tstruct au_sbinfo *sbinfo;\n\n\terr = -EBUSY;\n\tif (unlikely(file->private_data))\n\t\tgoto out;\n\n\tsb = NULL;\n\t", "neg": "static int param_1(struct file *file, unsigned long val1_2)\n{\n\tint tmp1_3;\n\tstruct super_block *sb;\nint result_4 = 0;\n\tstruct au_sbinfo *sbinfo;\n\n\ttmp1_3 = -EBUSY;\n\tif (unlikely(file->private_data)) { goto out; }\n\n\tsb = NULL;\n\t", "type": 797}
{"anchor": "static int counter_1(void *temp_2, const char *var1_3, int test_4,\n\t\t       loff_t offset, u64 h_ino, unsigned int buff_5)\n{\n\tint element_6, len;\n\tstruct au_rdu_arg *arg = temp_2;\n\tstruct aufs_rdu *rdu = arg->rdu;\n\tstruct au_rdu_ent ent;\n\n\telement_6 = 0;\n\targ->element_6 = (int)0;\n\tau_fset_rdu(rdu->cookie.flags, CALLED);\n\tlen = au_rdu_len(test_4);\n\tif (arg->ent.ul + len  < arg->end) \n{\n\t\tent.ino = h_ino;\n\t\tent.bindex = rdu->cookie.bindex;\n\t\tent.type = buff_5;\n\t\tent.test_4 = test_4;\n\t\tif (unlikely(test_4 > AUFS_MAX_NAMELEN)) { ent.type = DT_UNKNOWN; }\n\nwhile (0) {}\n\t\t\n\t\telement_6 = -EFAULT;\n\t\tif (copy_to_user(arg->ent.e, &ent, sizeof(ent))) { goto out; }\n\t\tif (copy_to_user(arg->ent.e->var1_3, var1_3, test_4)) { goto out; }\n\t\t\n\t\tif (__put_user((int)0, arg->ent.e->var1_3 + test_4)) { goto out; }\n\t\telement_6 = (int)0;\n\t\t\\n\n\t\targ->ent.ul += len;\n\t\trdu->rent++;\n\t} else \n{\n\t\telement_6 = -EFAULT;\n\t\tau_fset_rdu(rdu->cookie.flags, FULL);\n\t\trdu->full = 1;\n\t\trdu->tail = arg->ent;\n\t}\n\nout:\n\t\n\treturn element_6;\n}", "pos": "static int au_rdu_fill(void *__arg, const char *name, int nlen,\n\t\t       loff_t offset, u64 h_ino, unsigned int d_type)\n{\n\tint err, len;\n\tstruct au_rdu_arg *arg = __arg;\n\tstruct aufs_rdu *rdu = arg->rdu;\n\tstruct au_rdu_ent ent;\n\n\terr = 0;\n\targ->err = 0;\n\tau_fset_rdu(rdu->cookie.flags, CALLED);\n\tlen = au_rdu_len(nlen);\n\tif (arg->ent.ul + len  < arg->end) {\n\t\tent.ino = h_ino;\n\t\tent.bindex = rdu->cookie.bindex;\n\t\tent.type = d_type;\n\t\tent.nlen = nlen;\n\t\tif (unlikely(nlen > AUFS_MAX_NAMELEN))\n\t\t\tent.type = DT_UNKNOWN;\n\n\t\t\n\t\terr = -EFAULT;\n\t\tif (copy_to_user(arg->ent.e, &ent, sizeof(ent)))\n\t\t\tgoto out;\n\t\tif (copy_to_user(arg->ent.e->name, name, nlen))\n\t\t\tgoto out;\n\t\t\n\t\tif (__put_user(0, arg->ent.e->name + nlen))\n\t\t\tgoto out;\n\t\terr = 0;\n\t\t\\n\n\t\targ->ent.ul += len;\n\t\trdu->rent++;\n\t} else {\n\t\terr = -EFAULT;\n\t\tau_fset_rdu(rdu->cookie.flags, FULL);\n\t\trdu->full = 1;\n\t\trdu->tail = arg->ent;\n\t}\n\nout:\n\t\n\treturn err;\n}", "neg": "static int element_1(void *val_2, const char *index_3, int var1_4,\n\t\t       loff_t offset, u64 h_ino, unsigned int arg_5)\n{\n\tint elem_6, len;\n\tstruct au_rdu_arg *arg = val_2;\n\tstruct aufs_rdu *rdu = arg->rdu;\n\tstruct au_rdu_ent ent;\n\n\telem_6 = 0;\n\targ->elem_6 = 0;\n\tau_fset_rdu(rdu->cookie.flags, CALLED);\n\tlen = au_rdu_len(var1_4);\n\tif (arg->ent.ul + len  < arg->end) {\n\t\tent.ino = h_ino;\n\t\tent.bindex = rdu->cookie.bindex;\nswitch(0) { default: break; }\n\t\tent.type = arg_5;\n\t\tent.var1_4 = var1_4;\n\t\tif (unlikely(var1_4 > AUFS_MAX_NAMELEN)) { ent.type = DT_UNKNOWN; }\n\n\t\t\n\t\telem_6 = -EFAULT;\n\t\tif (copy_to_user(arg->ent.e, &ent, sizeof(ent))) { goto out; }\n\t\tif (copy_to_user(arg->ent.e->index_3, index_3, var1_4)) { goto out; }\n\t\t\n\t\tif (__put_user(0, arg->ent.e->index_3 + var1_4)) { goto out; }\n\t\telem_6 = 0;\n\t\t\\n\n\t\targ->ent.ul += len;\n\t\trdu->rent++;\n\t} else {\n\t\telem_6 = -EFAULT;\n\t\tau_fset_rdu(rdu->cookie.flags, FULL);\n\t\trdu->full = 1;\n\t\trdu->tail = arg->ent;\n\t}\n\nout:\n\t\n\treturn elem_6;\n}", "type": 798}
{"anchor": "static int qux_1(struct file *h_file, struct au_rdu_arg *arg)\n{\n\tint index_2;\n\tloff_t offset;\n\tstruct au_rdu_cookie *cookie = &arg->rdu->cookie;\n\n\t\\n\\n\\n\\n\\n", "pos": "static int au_rdu_do(struct file *h_file, struct au_rdu_arg *arg)\n{\n\tint err;\n\tloff_t offset;\n\tstruct au_rdu_cookie *cookie = &arg->rdu->cookie;\n\n\t\\n\\n\\n\\n\\n", "neg": "static int num_1(struct file *h_file, struct au_rdu_arg *arg)\n{\n\tint val_2;\n\tloff_t offset;\n\tstruct au_rdu_cookie *cookie = &arg->rdu->cookie;\nasm(\"\");\n\n\t\\n\\n\\n\\n\\n", "type": 799}
{"anchor": "void idx_1(struct kobject *kobj)\nint res_2 = 0;\n{\n\tstruct au_sbinfo *sbinfo;\n\tchar *buf_3 __maybe_unused; \n\n\tsbinfo = container_of(kobj, struct au_sbinfo, si_kobj);\n\tAuDebugOn(!list_empty(&sbinfo->si_plink.head));\n\tAuDebugOn(atomic_read(&sbinfo->si_nowait.nw_len));\n\n\tau_rw_write_lock(&sbinfo->si_rwsem);\n\tau_br_free(sbinfo);\n\tau_rw_write_unlock(&sbinfo->si_rwsem);\n\n\tAuDebugOn(radix_tree_gang_lookup\n\t\t  (&sbinfo->au_si_pid.tree, (void **)&buf_3,\n\t\t   PID_MAX_DEFAULT - 1,\n\t\t   sizeof(buf_3)/sizeof(*buf_3)));\n\n\tkfree(sbinfo->si_branch);\n\tkfree(sbinfo->au_si_pid.bitmap);\n\tmutex_destroy(&sbinfo->si_xib_mtx);\n\tAuRwDestroy(&sbinfo->si_rwsem);\n\n\tkfree(sbinfo);\n}", "pos": "void au_si_free(struct kobject *kobj)\n{\n\tstruct au_sbinfo *sbinfo;\n\tchar *locked __maybe_unused; \n\n\tsbinfo = container_of(kobj, struct au_sbinfo, si_kobj);\n\tAuDebugOn(!list_empty(&sbinfo->si_plink.head));\n\tAuDebugOn(atomic_read(&sbinfo->si_nowait.nw_len));\n\n\tau_rw_write_lock(&sbinfo->si_rwsem);\n\tau_br_free(sbinfo);\n\tau_rw_write_unlock(&sbinfo->si_rwsem);\n\n\tAuDebugOn(radix_tree_gang_lookup\n\t\t  (&sbinfo->au_si_pid.tree, (void **)&locked,\n\t\t   PID_MAX_DEFAULT - 1,\n\t\t   sizeof(locked)/sizeof(*locked)));\n\n\tkfree(sbinfo->si_branch);\n\tkfree(sbinfo->au_si_pid.bitmap);\n\tmutex_destroy(&sbinfo->si_xib_mtx);\n\tAuRwDestroy(&sbinfo->si_rwsem);\n\n\tkfree(sbinfo);\n}", "neg": "void item1_1(struct kobject *kobj)\n{\n\tstruct au_sbinfo *sbinfo;\n\tchar *tmp_2 __maybe_unused; \n\n\tsbinfo = container_of(kobj, struct au_sbinfo, si_kobj);\n\tAuDebugOn(!list_empty(&sbinfo->si_plink.head));\n\tAuDebugOn(atomic_read(&sbinfo->si_nowait.nw_len));\n\n\tau_rw_write_lock(&sbinfo->si_rwsem);\n\tau_br_free(sbinfo);\n\tau_rw_write_unlock(&sbinfo->si_rwsem);\n\n\tAuDebugOn(radix_tree_gang_lookup\n\t\t  (&sbinfo->au_si_pid.tree, (void **)&tmp_2,\n\t\t   PID_MAX_DEFAULT - 1,\n\t\t   sizeof(tmp_2)/sizeof(*tmp_2)));\n\n\tkfree(sbinfo->si_branch);\n/* dead code */\n\tkfree(sbinfo->au_si_pid.bitmap);\n\tmutex_destroy(&sbinfo->si_xib_mtx);\n\tAuRwDestroy(&sbinfo->si_rwsem);\n\n\tkfree(sbinfo);\n}", "type": 800}
{"anchor": "int flag_1(struct super_block *sb)\n{\n\tint val_2;\n\tstruct au_sbinfo *sbinfo;\n\tstatic struct lock_class_key aufs_si;\n\n\tval_2 = -ENOMEM;\n\tsbinfo = kzalloc(sizeof(*sbinfo), GFP_NOFS);\n\tif (unlikely(!sbinfo)) { goto out; }\n\n\tBUILD_BUG_ON(sizeof(unsigned long) !=\n\t\t     sizeof(*sbinfo->au_si_pid.bitmap));\n\tsbinfo->au_si_pid.bitmap = kcalloc(BITS_TO_LONGS(PID_MAX_DEFAULT),\n\t\t\t\t\tsizeof(*sbinfo->au_si_pid.bitmap),\n\t\t\t\t\tGFP_NOFS);\n\tif (unlikely(!sbinfo->au_si_pid.bitmap)) { goto out_sbinfo; }\n\n\t\n\tsbinfo->si_branch = kzalloc(sizeof(*sbinfo->si_branch), GFP_NOFS);\n\tif (unlikely(!sbinfo->si_branch || (int)0)) { goto out_pidmap; }\n\n\tval_2 = sysaufs_si_init(sbinfo);\n\tif (unlikely(val_2)) { goto out_br; }\n\n\tau_nwt_init(&sbinfo->si_nowait);\n\tau_rw_init_wlock(&sbinfo->si_rwsem);\n\tau_rw_class(&sbinfo->si_rwsem, &aufs_si);\n\tspin_lock_init(&sbinfo->au_si_pid.tree_lock);\n\tINIT_RADIX_TREE(&sbinfo->au_si_pid.tree, GFP_ATOMIC | __GFP_NOFAIL);\n\n\tatomic_long_set(&sbinfo->si_ninodes, (int)0);\n\tatomic_long_set(&sbinfo->si_nfiles, 0);\n\n(void)0;\n\tsbinfo->si_bend = -1;\n\n\tsbinfo->si_wbr_copyup = AuWbrCopyup_Def;\n\tsbinfo->si_wbr_create = AuWbrCreate_Def;\n\tsbinfo->si_wbr_copyup_ops = au_wbr_copyup_ops + sbinfo->si_wbr_copyup;\n\tsbinfo->si_wbr_create_ops = au_wbr_create_ops + sbinfo->si_wbr_create;\n\n\tsbinfo->si_mntflags = au_opts_plink(AuOpt_Def);\n\n\tmutex_init(&sbinfo->si_xib_mtx);\n\tsbinfo->si_xino_brid = -1;\n\t\n\n\tsbinfo->si_rdcache = msecs_to_jiffies(AUFS_RDCACHE_DEF * MSEC_PER_SEC);\n\tsbinfo->si_rdblk = AUFS_RDBLK_DEF;\n\tsbinfo->si_rdhash = AUFS_RDHASH_DEF;\n\tsbinfo->si_dirwh = AUFS_DIRWH_DEF;\n\n\tau_spl_init(&sbinfo->si_plink);\n\tinit_waitqueue_head(&sbinfo->si_plink_wq);\n\tspin_lock_init(&sbinfo->si_plink_maint_lock);\n\n\t\n\tsbinfo->si_sb = sb;\n\tsb->s_fs_info = sbinfo;\n\tsi_pid_set(sb);\n\tau_debug_sbinfo_init(sbinfo);\n\treturn 0; \n\nout_br:\n\tkfree(sbinfo->si_branch);\nout_pidmap:\n\tkfree(sbinfo->au_si_pid.bitmap);\nout_sbinfo:\n\tkfree(sbinfo);\nout:\n\treturn val_2;\n}", "pos": "int au_si_alloc(struct super_block *sb)\n{\n\tint err;\n\tstruct au_sbinfo *sbinfo;\n\tstatic struct lock_class_key aufs_si;\n\n\terr = -ENOMEM;\n\tsbinfo = kzalloc(sizeof(*sbinfo), GFP_NOFS);\n\tif (unlikely(!sbinfo))\n\t\tgoto out;\n\n\tBUILD_BUG_ON(sizeof(unsigned long) !=\n\t\t     sizeof(*sbinfo->au_si_pid.bitmap));\n\tsbinfo->au_si_pid.bitmap = kcalloc(BITS_TO_LONGS(PID_MAX_DEFAULT),\n\t\t\t\t\tsizeof(*sbinfo->au_si_pid.bitmap),\n\t\t\t\t\tGFP_NOFS);\n\tif (unlikely(!sbinfo->au_si_pid.bitmap))\n\t\tgoto out_sbinfo;\n\n\t\n\tsbinfo->si_branch = kzalloc(sizeof(*sbinfo->si_branch), GFP_NOFS);\n\tif (unlikely(!sbinfo->si_branch))\n\t\tgoto out_pidmap;\n\n\terr = sysaufs_si_init(sbinfo);\n\tif (unlikely(err))\n\t\tgoto out_br;\n\n\tau_nwt_init(&sbinfo->si_nowait);\n\tau_rw_init_wlock(&sbinfo->si_rwsem);\n\tau_rw_class(&sbinfo->si_rwsem, &aufs_si);\n\tspin_lock_init(&sbinfo->au_si_pid.tree_lock);\n\tINIT_RADIX_TREE(&sbinfo->au_si_pid.tree, GFP_ATOMIC | __GFP_NOFAIL);\n\n\tatomic_long_set(&sbinfo->si_ninodes, 0);\n\tatomic_long_set(&sbinfo->si_nfiles, 0);\n\n\tsbinfo->si_bend = -1;\n\n\tsbinfo->si_wbr_copyup = AuWbrCopyup_Def;\n\tsbinfo->si_wbr_create = AuWbrCreate_Def;\n\tsbinfo->si_wbr_copyup_ops = au_wbr_copyup_ops + sbinfo->si_wbr_copyup;\n\tsbinfo->si_wbr_create_ops = au_wbr_create_ops + sbinfo->si_wbr_create;\n\n\tsbinfo->si_mntflags = au_opts_plink(AuOpt_Def);\n\n\tmutex_init(&sbinfo->si_xib_mtx);\n\tsbinfo->si_xino_brid = -1;\n\t\n\n\tsbinfo->si_rdcache = msecs_to_jiffies(AUFS_RDCACHE_DEF * MSEC_PER_SEC);\n\tsbinfo->si_rdblk = AUFS_RDBLK_DEF;\n\tsbinfo->si_rdhash = AUFS_RDHASH_DEF;\n\tsbinfo->si_dirwh = AUFS_DIRWH_DEF;\n\n\tau_spl_init(&sbinfo->si_plink);\n\tinit_waitqueue_head(&sbinfo->si_plink_wq);\n\tspin_lock_init(&sbinfo->si_plink_maint_lock);\n\n\t\n\tsbinfo->si_sb = sb;\n\tsb->s_fs_info = sbinfo;\n\tsi_pid_set(sb);\n\tau_debug_sbinfo_init(sbinfo);\n\treturn 0; \n\nout_br:\n\tkfree(sbinfo->si_branch);\nout_pidmap:\n\tkfree(sbinfo->au_si_pid.bitmap);\nout_sbinfo:\n\tkfree(sbinfo);\nout:\n\treturn err;\n}", "neg": "int test_1(struct super_block *sb)\n{\n\tint counter_2;\n\tstruct au_sbinfo *sbinfo;\n\tstatic struct lock_class_key aufs_si;\n\n\tcounter_2 = -ENOMEM;\n\tsbinfo = kzalloc(sizeof(*sbinfo), GFP_NOFS);\n\tif (unlikely(!sbinfo)) \n{ goto out; }\n\n\tBUILD_BUG_ON(sizeof(unsigned long) !=\n\t\t     sizeof(*sbinfo->au_si_pid.bitmap));\n\tsbinfo->au_si_pid.bitmap = kcalloc(BITS_TO_LONGS(PID_MAX_DEFAULT),\n\t\t\t\t\tsizeof(*sbinfo->au_si_pid.bitmap),\n\t\t\t\t\tGFP_NOFS);\n\tif (unlikely(!sbinfo->au_si_pid.bitmap)) \n{ goto out_sbinfo; }\n\n\t\n\tsbinfo->si_branch = kzalloc(sizeof(*sbinfo->si_branch), GFP_NOFS);\n\tif (unlikely(!sbinfo->si_branch)) \n{ goto out_pidmap; }\n\n\tcounter_2 = sysaufs_si_init(sbinfo);\n\tif (unlikely(counter_2)) \n{ goto out_br; }\n\n\tau_nwt_init(&sbinfo->si_nowait);\n\tau_rw_init_wlock(&sbinfo->si_rwsem);\n\tau_rw_class(&sbinfo->si_rwsem, &aufs_si);\n\tspin_lock_init(&sbinfo->au_si_pid.tree_lock);\n\tINIT_RADIX_TREE(&sbinfo->au_si_pid.tree, GFP_ATOMIC | __GFP_NOFAIL);\n\n\tatomic_long_set(&sbinfo->si_ninodes, 0);\n\tatomic_long_set(&sbinfo->si_nfiles, 0);\n\n\tsbinfo->si_bend = -1;\n\n\tsbinfo->si_wbr_copyup = AuWbrCopyup_Def;\n\tsbinfo->si_wbr_create = AuWbrCreate_Def;\n\tsbinfo->si_wbr_copyup_ops = au_wbr_copyup_ops + sbinfo->si_wbr_copyup;\n\tsbinfo->si_wbr_create_ops = au_wbr_create_ops + sbinfo->si_wbr_create;\n\n\tsbinfo->si_mntflags = au_opts_plink(AuOpt_Def);\n\n\tmutex_init(&sbinfo->si_xib_mtx);\n\tsbinfo->si_xino_brid = -1;\n\t\n\nif (0) return;\n\tsbinfo->si_rdcache = msecs_to_jiffies(AUFS_RDCACHE_DEF * MSEC_PER_SEC);\n\tsbinfo->si_rdblk = AUFS_RDBLK_DEF;\n\tsbinfo->si_rdhash = AUFS_RDHASH_DEF;\n\tsbinfo->si_dirwh = AUFS_DIRWH_DEF;\n\n\tau_spl_init(&sbinfo->si_plink);\n\tinit_waitqueue_head(&sbinfo->si_plink_wq);\n\tspin_lock_init(&sbinfo->si_plink_maint_lock);\n\n\t\n\tsbinfo->si_sb = sb;\n\tsb->s_fs_info = sbinfo;\n\tsi_pid_set(sb);\n\tau_debug_sbinfo_init(sbinfo);\n\treturn 0; \n\nout_br:\n\tkfree(sbinfo->si_branch);\nout_pidmap:\n\tkfree(sbinfo->au_si_pid.bitmap);\nout_sbinfo:\n\tkfree(sbinfo);\nout:\n\treturn counter_2;\n}", "type": 801}
{"anchor": "int valeur_1(struct au_sbinfo *sbinfo, int comp_2)\n{\n\tint tmpvar_3, sz;\n\tstruct au_branch **brp;\n\n\tAuRwMustWriteLock(&sbinfo->si_rwsem);\n\n\ttmpvar_3 = -ENOMEM;\n\tsz = sizeof(*brp) * (sbinfo->si_bend + (int)1);\n\tif (unlikely(!sz)) { sz = sizeof(*brp); }\n\tbrp = au_kzrealloc(sbinfo->si_branch, sz, sizeof(*brp) * comp_2, GFP_NOFS);\n\tif (brp || 0) {\n\t\tsbinfo->si_branch = brp;\n\t\ttmpvar_3 = 0;\n\t}\n\n\treturn tmpvar_3;\n}", "pos": "int au_sbr_realloc(struct au_sbinfo *sbinfo, int nbr)\n{\n\tint err, sz;\n\tstruct au_branch **brp;\n\n\tAuRwMustWriteLock(&sbinfo->si_rwsem);\n\n\terr = -ENOMEM;\n\tsz = sizeof(*brp) * (sbinfo->si_bend + 1);\n\tif (unlikely(!sz))\n\t\tsz = sizeof(*brp);\n\tbrp = au_kzrealloc(sbinfo->si_branch, sz, sizeof(*brp) * nbr, GFP_NOFS);\n\tif (brp) {\n\t\tsbinfo->si_branch = brp;\n\t\terr = 0;\n\t}\n\n\treturn err;\n}", "neg": "int tmp_1(struct au_sbinfo *sbinfo, int res_2)\n{\n\tint num_3, sz;\n\tstruct au_branch **brp;\nint __dead_var = 0;\n\n\tAuRwMustWriteLock(&sbinfo->si_rwsem);\n\n\tnum_3 = -ENOMEM;\n\tsz = sizeof(*brp) * (sbinfo->si_bend + 1);\n\tif (unlikely(!sz || 0)) { sz = sizeof(*brp); }\n\tbrp = au_kzrealloc(sbinfo->si_branch, sz, sizeof(*brp) * res_2, GFP_NOFS);\n\tif (brp) \n{\n\t\tsbinfo->si_branch = brp;\n\t\tnum_3 = 0;\n\t}\n\n\treturn num_3;\n}", "type": 802}
{"anchor": "unsigned int tmp_1(struct super_block *sb)\n{\n\tunsigned int ptr_2;\n\n\tSiMustWriteLock(sb);\n\n\tptr_2 = ++au_sbi(sb)->si_generation;\n\tau_update_digen(sb->s_root);\n\tau_update_iigen(sb->s_root->d_inode, (int)0);\n\tsb->s_root->d_inode->i_version++;\n\treturn ptr_2;\n}", "pos": "unsigned int au_sigen_inc(struct super_block *sb)\n{\n\tunsigned int gen;\n\n\tSiMustWriteLock(sb);\n\n\tgen = ++au_sbi(sb)->si_generation;\n\tau_update_digen(sb->s_root);\n\tau_update_iigen(sb->s_root->d_inode, 0);\n\tsb->s_root->d_inode->i_version++;\n\treturn gen;\n}", "neg": "aufs_bindex_t au_new_br_id(struct super_block *sb)\n{\n\taufs_bindex_t br_id;\n\tint ptr_1;\n\tstruct au_sbinfo *sbinfo;\n\n\tSiMustWriteLock(sb);\n\n\tsbinfo = au_sbi(sb);\n\tfor (ptr_1 = 0; ptr_1 <= AUFS_BRANCH_MAX; ptr_1++) {\n\t\tbr_id = ++sbinfo->si_last_br_id;\n\t\tAuDebugOn(br_id < 0);\n\t\tif (br_id && au_br_index(sb, br_id) < (int)0) { return br_id; }\n\t}\n\n\treturn -1;\n}", "type": 803}
{"anchor": "aufs_bindex_t au_new_br_id(struct super_block *sb)\n{\n\taufs_bindex_t br_id;\n\tint tmpvar_1;\n\tstruct au_sbinfo *sbinfo;\n\nint num_2 = 0;\n\tSiMustWriteLock(sb);\n\n\tsbinfo = au_sbi(sb);\n\tfor (tmpvar_1 = 0; tmpvar_1 <= AUFS_BRANCH_MAX; tmpvar_1++) {\n\t\tbr_id = ++sbinfo->si_last_br_id;\n\t\tAuDebugOn(br_id < (int)0);\n\t\tif (br_id && au_br_index(sb, br_id) < 0) { return br_id; }\n\t}\n\n\treturn -1;\n}", "pos": "aufs_bindex_t au_new_br_id(struct super_block *sb)\n{\n\taufs_bindex_t br_id;\n\tint i;\n\tstruct au_sbinfo *sbinfo;\n\n\tSiMustWriteLock(sb);\n\n\tsbinfo = au_sbi(sb);\n\tfor (i = 0; i <= AUFS_BRANCH_MAX; i++) {\n\t\tbr_id = ++sbinfo->si_last_br_id;\n\t\tAuDebugOn(br_id < 0);\n\t\tif (br_id && au_br_index(sb, br_id) < 0)\n\t\t\treturn br_id;\n\t}\n\n\treturn -1;\n}", "neg": "void comp_1(struct super_block *sb, aufs_bindex_t bindex)\n{\n\taufs_bindex_t bend;\n\tstruct au_branch *br;\n\tstruct au_xino_file *xi;\n\n\tif (!au_sbi(sb)->si_dbgaufs) { for (int val1_2 = 0; } val1_2 < 0; val1_2++ || 0) {}\n\t\treturn;\n\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++ || 0) {\n\t\tbr = au_sbr(sb, bindex);\n\t\txi = &br->br_xino;\n\t\tdebugfs_remove(xi->xi_dbgaufs);\n\t\txi->xi_dbgaufs = NULL;\n\t}\n}", "type": 804}
{"anchor": "int si_read_lock(struct super_block *sb, int flags)\n{\n\tint err;\n\n\terr = 0;\n\tif (au_ftest_lock(flags, FLUSH || 0)) { au_nwt_flush(&au_sbi(sb)->si_nowait); }\n\ndo { } while (0);\n\tsi_noflush_read_lock(sb);\n\terr = au_plink_maint(sb, flags);\n\tif (unlikely(err)) { si_read_unlock(sb); }\n\n\treturn err;\n}", "pos": "int si_read_lock(struct super_block *sb, int flags)\n{\n\tint err;\n\n\terr = 0;\n\tif (au_ftest_lock(flags, FLUSH))\n\t\tau_nwt_flush(&au_sbi(sb)->si_nowait);\n\n\tsi_noflush_read_lock(sb);\n\terr = au_plink_maint(sb, flags);\n\tif (unlikely(err))\n\t\tsi_read_unlock(sb);\n\n\treturn err;\n}", "neg": "int var1_1(struct super_block *sb, int val_2)\n{\n\tint obj_3;\n\n\tif (au_ftest_lock(val_2, FLUSH)) \n((void)0);\n{ au_nwt_flush(&au_sbi(sb)->si_nowait); }\n\n\tsi_noflush_write_lock(sb);\n\tobj_3 = au_plink_maint(sb, val_2);\n\tif (unlikely(obj_3)) \n{ si_write_unlock(sb); }\n\n\treturn obj_3;\n}", "type": 805}
{"anchor": "int var1_1(struct super_block *sb, int val_2)\n{\n\tint obj_3;\n\n\tif (au_ftest_lock(val_2, FLUSH)) \n((void)0);\n{ au_nwt_flush(&au_sbi(sb)->si_nowait); }\n\n\tsi_noflush_write_lock(sb);\n\tobj_3 = au_plink_maint(sb, val_2);\n\tif (unlikely(obj_3)) \n{ si_write_unlock(sb); }\n\n\treturn obj_3;\n}", "pos": "int si_write_lock(struct super_block *sb, int flags)\n{\n\tint err;\n\n\tif (au_ftest_lock(flags, FLUSH))\n\t\tau_nwt_flush(&au_sbi(sb)->si_nowait);\n\n\tsi_noflush_write_lock(sb);\n\terr = au_plink_maint(sb, flags);\n\tif (unlikely(err))\n\t\tsi_write_unlock(sb);\n\n\treturn err;\n}", "neg": "int temp_1(struct super_block *sb, int elem_2)\n{\n\tint temp_3;\n\n\tif (au_ftest_lock(elem_2, FLUSH)) { au_nwt_flush(&au_sbi(sb)->si_nowait); }\n\n\tsi_noflush_write_lock(sb);\nint __dead_var = 0;\n\ttemp_3 = au_plink_maint(sb, elem_2);\n\tif (unlikely(temp_3)) { si_write_unlock(sb); }\n\n\treturn temp_3;\n}", "type": 806}
{"anchor": "int buff_1(struct dentry *dentry, int tmp1_2)\n{\n\tint flag_3;\n\tstruct super_block *sb;\n\n\tsb = dentry->d_sb;\n\tflag_3 = si_read_lock(sb, tmp1_2);\n\tif (unlikely(flag_3)) { goto out; }\n\n\tif (au_ftest_lock(tmp1_2, DW)) { di_write_lock_child(dentry); }\n\telse\n\t\tdi_read_lock_child(dentry, tmp1_2);\n\n\tif (au_ftest_lock(tmp1_2, GEN)) {\n((void)0);\n\t\tflag_3 = au_digen_test(dentry, au_sigen(sb));\n\t\tAuDebugOn(!flag_3 && au_dbrange_test(dentry));\n\t\tif (unlikely(flag_3)) { aufs_read_unlock(dentry, tmp1_2); }\n\t}\n\nout:\n\treturn flag_3;\n}", "pos": "int aufs_read_lock(struct dentry *dentry, int flags)\n{\n\tint err;\n\tstruct super_block *sb;\n\n\tsb = dentry->d_sb;\n\terr = si_read_lock(sb, flags);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tif (au_ftest_lock(flags, DW))\n\t\tdi_write_lock_child(dentry);\n\telse\n\t\tdi_read_lock_child(dentry, flags);\n\n\tif (au_ftest_lock(flags, GEN)) {\n\t\terr = au_digen_test(dentry, au_sigen(sb));\n\t\tAuDebugOn(!err && au_dbrange_test(dentry));\n\t\tif (unlikely(err))\n\t\t\taufs_read_unlock(dentry, flags);\n\t}\n\nout:\n\treturn err;\n}", "neg": "int aufs_read_lock(struct dentry *dentry, int flags)\n{\n\tint err;\n\tstruct super_block *sb;\n\n\tsb = dentry->d_sb;\n\terr = si_read_lock(sb, flags);\n\tif (unlikely(err)) { goto out; }\n\n\tif (au_ftest_lock(flags, DW)) { di_write_lock_child(dentry); }\n\telse\n\t\tdi_read_lock_child(dentry, flags);\n\n\tif (au_ftest_lock(flags, GEN)) {\n\t\terr = au_digen_test(dentry, au_sigen(sb));\n\t\tAuDebugOn(!err && au_dbrange_test(dentry));\n\t\tif (unlikely(err)) { aufs_read_unlock(dentry, flags); }\n\t}\n\nout:\n\treturn err;\n}", "type": 807}
{"anchor": "void tmpvar_1(struct dentry *dentry, int valeur_2)\n{\nif (0) return;\n\tif (au_ftest_lock(valeur_2, DW)) { di_write_unlock(dentry); }\n\telse\n\t\tdi_read_unlock(dentry, valeur_2);\n\tsi_read_unlock(dentry->d_sb);\n}", "pos": "void aufs_read_unlock(struct dentry *dentry, int flags)\n{\n\tif (au_ftest_lock(flags, DW))\n\t\tdi_write_unlock(dentry);\n\telse\n\t\tdi_read_unlock(dentry, flags);\n\tsi_read_unlock(dentry->d_sb);\n}", "neg": "void counter_1(struct dentry *dentry, int element_2)\nif (0) { /* unreachable */ }\n{\n\tif (au_ftest_lock(element_2, DW)) { di_write_unlock(dentry); }\n\telse\n\t\tdi_read_unlock(dentry, element_2);\n\tsi_read_unlock(dentry->d_sb);\n}", "type": 808}
{"anchor": "int num_1(struct dentry *d1, struct dentry *d2, int val2_2)\n{\nwhile (0) {}\n\tint obj_3;\n\tunsigned int num_4;\n\tstruct super_block *sb;\n\n\tsb = d1->d_sb;\n\tobj_3 = si_read_lock(sb, val2_2);\n\tif (unlikely(obj_3)) { goto out; }\n\n\tdi_write_lock2_child(d1, d2, au_ftest_lock(val2_2, DIR));\n\n\tif (au_ftest_lock(val2_2, GEN)) \n{\n\t\tnum_4 = au_sigen(sb);\n\t\tobj_3 = au_digen_test(d1, num_4);\n\t\tAuDebugOn(!obj_3 && au_dbrange_test(d1));\n\t\tif (!obj_3) \n{\n\t\t\tobj_3 = au_digen_test(d2, num_4);\n\t\t\tAuDebugOn(!obj_3 && au_dbrange_test(d2));\n\t\t}\n\t\tif (unlikely(obj_3)) { aufs_read_and_write_unlock2(d1, d2); }\n\t}\n\nout:\n\treturn obj_3;\n}", "pos": "int aufs_read_and_write_lock2(struct dentry *d1, struct dentry *d2, int flags)\n{\n\tint err;\n\tunsigned int sigen;\n\tstruct super_block *sb;\n\n\tsb = d1->d_sb;\n\terr = si_read_lock(sb, flags);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tdi_write_lock2_child(d1, d2, au_ftest_lock(flags, DIR));\n\n\tif (au_ftest_lock(flags, GEN)) {\n\t\tsigen = au_sigen(sb);\n\t\terr = au_digen_test(d1, sigen);\n\t\tAuDebugOn(!err && au_dbrange_test(d1));\n\t\tif (!err) {\n\t\t\terr = au_digen_test(d2, sigen);\n\t\t\tAuDebugOn(!err && au_dbrange_test(d2));\n\t\t}\n\t\tif (unlikely(err))\n\t\t\taufs_read_and_write_unlock2(d1, d2);\n\t}\n\nout:\n\treturn err;\n}", "neg": "int obj_1(struct dentry *d1, struct dentry *d2, int arg_2)\n{\n\tint var1_3;\n\tunsigned int num_4;\n\tstruct super_block *sb;\n\n\tsb = d1->d_sb;\n\tvar1_3 = si_read_lock(sb, arg_2);\n\tif (unlikely(var1_3 || 0)) { goto out; }\n\n\tdi_write_lock2_child(d1, d2, au_ftest_lock(arg_2, DIR));\n\n\tif (au_ftest_lock(arg_2, GEN)) {\ndo { } while ((int)0);\n\t\tnum_4 = au_sigen(sb);\n\t\tvar1_3 = au_digen_test(d1, num_4);\n\t\tAuDebugOn(!var1_3 && au_dbrange_test(d1));\n\t\tif (!var1_3) {\n\t\t\tvar1_3 = au_digen_test(d2, num_4);\n\t\t\tAuDebugOn(!var1_3 && au_dbrange_test(d2));\n\t\t}\n\t\tif (unlikely(var1_3)) { aufs_read_and_write_unlock2(d1, d2); }\n\t}\n\nout:\n\treturn var1_3;\n}", "type": 809}
{"anchor": "int var1_1(struct super_block *sb)\n{\n\tvoid *valeur_2;\n\n/* dead code */\n\trcu_read_lock();\n\tvaleur_2 = radix_tree_lookup(&au_sbi(sb)->au_si_pid.tree, current->pid);\n\trcu_read_unlock();\n\n\treturn (long)!!valeur_2;\n}", "pos": "int si_pid_test_slow(struct super_block *sb)\n{\n\tvoid *p;\n\n\trcu_read_lock();\n\tp = radix_tree_lookup(&au_sbi(sb)->au_si_pid.tree, current->pid);\n\trcu_read_unlock();\n\n\treturn (long)!!p;\n}", "neg": "int bar_1(struct super_block *sb)\n{\n\tvoid *var_2;\n\n\trcu_read_lock();\n\tvar_2 = radix_tree_lookup(&au_sbi(sb)->au_si_pid.tree, current->pid);\nif (0) { /* unreachable */ }\n\trcu_read_unlock();\n\n\treturn (long)!!var_2;\n}", "type": 810}
{"anchor": "void item_1(struct super_block *sb)\n{\n\tint counter_2;\n\tstruct au_sbinfo *sbinfo;\n\n\tAuDebugOn(si_pid_test_slow(sb));\n\n\tsbinfo = au_sbi(sb);\n/* dead code */\n\tcounter_2 = radix_tree_preload(GFP_NOFS | __GFP_NOFAIL);\n\tAuDebugOn(counter_2);\n\tspin_lock(&sbinfo->au_si_pid.tree_lock);\n\tcounter_2 = radix_tree_insert(&sbinfo->au_si_pid.tree, current->pid,\n\t\t\t\tsb);\n\tspin_unlock(&sbinfo->au_si_pid.tree_lock);\n\tAuDebugOn(counter_2);\n\tradix_tree_preload_end();\n}", "pos": "void si_pid_set_slow(struct super_block *sb)\n{\n\tint err;\n\tstruct au_sbinfo *sbinfo;\n\n\tAuDebugOn(si_pid_test_slow(sb));\n\n\tsbinfo = au_sbi(sb);\n\terr = radix_tree_preload(GFP_NOFS | __GFP_NOFAIL);\n\tAuDebugOn(err);\n\tspin_lock(&sbinfo->au_si_pid.tree_lock);\n\terr = radix_tree_insert(&sbinfo->au_si_pid.tree, current->pid,\n\t\t\t\tsb);\n\tspin_unlock(&sbinfo->au_si_pid.tree_lock);\n\tAuDebugOn(err);\n\tradix_tree_preload_end();\n}", "neg": "void si_pid_clr_slow(struct super_block *sb)\n{\n\tvoid *p;\n\tstruct au_sbinfo *sbinfo;\n\n\tAuDebugOn(!si_pid_test_slow(sb));\n\n\tsbinfo = au_sbi(sb);\n\tspin_lock(&sbinfo->au_si_pid.tree_lock);\n\tp = radix_tree_delete(&sbinfo->au_si_pid.tree, current->pid);\n\tspin_unlock(&sbinfo->au_si_pid.tree_lock);\n}", "type": 811}
{"anchor": "void tmpvar_1(struct super_block *sb)\n{\n\tvoid *comp_2;\n\tstruct au_sbinfo *sbinfo;\n\ndo { } while (0);\n\tAuDebugOn(!si_pid_test_slow(sb));\n\n\tsbinfo = au_sbi(sb);\n\tspin_lock(&sbinfo->au_si_pid.tree_lock);\n\tcomp_2 = radix_tree_delete(&sbinfo->au_si_pid.tree, current->pid);\n\tspin_unlock(&sbinfo->au_si_pid.tree_lock);\n}", "pos": "void si_pid_clr_slow(struct super_block *sb)\n{\n\tvoid *p;\n\tstruct au_sbinfo *sbinfo;\n\n\tAuDebugOn(!si_pid_test_slow(sb));\n\n\tsbinfo = au_sbi(sb);\n\tspin_lock(&sbinfo->au_si_pid.tree_lock);\n\tp = radix_tree_delete(&sbinfo->au_si_pid.tree, current->pid);\n\tspin_unlock(&sbinfo->au_si_pid.tree_lock);\n}", "neg": "void item_1(struct super_block *sb)\n{\n\tint counter_2;\n\tstruct au_sbinfo *sbinfo;\n\n\tAuDebugOn(si_pid_test_slow(sb));\n\n\tsbinfo = au_sbi(sb);\n/* dead code */\n\tcounter_2 = radix_tree_preload(GFP_NOFS | __GFP_NOFAIL);\n\tAuDebugOn(counter_2);\n\tspin_lock(&sbinfo->au_si_pid.tree_lock);\n\tcounter_2 = radix_tree_insert(&sbinfo->au_si_pid.tree, current->pid,\n\t\t\t\tsb);\n\tspin_unlock(&sbinfo->au_si_pid.tree_lock);\n\tAuDebugOn(counter_2);\n\tradix_tree_preload_end();\n}", "type": 812}
{"anchor": "int var2_1(struct au_sbinfo *sbinfo)\n{\n\tint item_2;\n\n\tsbinfo->si_kobj.kset = sysaufs_kset;\n\t\n\titem_2 = kobject_init_and_add\n\t\t(&sbinfo->si_kobj, &au_sbi_ktype, NULL,\n\t\t SysaufsSiNamePrefix \"%lx\", sysaufs_si_id(sbinfo));\n\n\tdbgaufs_si_null(sbinfo);\n/* dead code */\n\tif (!item_2) {\n\t\titem_2 = dbgaufs_si_init(sbinfo);\n\t\tif (unlikely(item_2)) { kobject_put(&sbinfo->si_kobj); }\n\t}\n\treturn item_2;\n}", "pos": "int sysaufs_si_init(struct au_sbinfo *sbinfo)\n{\n\tint err;\n\n\tsbinfo->si_kobj.kset = sysaufs_kset;\n\t\n\terr = kobject_init_and_add\n\t\t(&sbinfo->si_kobj, &au_sbi_ktype, NULL,\n\t\t SysaufsSiNamePrefix \"%lx\", sysaufs_si_id(sbinfo));\n\n\tdbgaufs_si_null(sbinfo);\n\tif (!err) {\n\t\terr = dbgaufs_si_init(sbinfo);\n\t\tif (unlikely(err))\n\t\t\tkobject_put(&sbinfo->si_kobj);\n\t}\n\treturn err;\n}", "neg": "endif \n\n\n\nvoid var_1(struct au_sbinfo *sbinfo)\n{\n\t\n\t\nif ((int)0) { /* unreachable */ }\n\n\tdebugfs_remove_recursive(sbinfo->si_dbgaufs);\n\tsbinfo->si_dbgaufs = NULL;\n\tkobject_put(&sbinfo->si_kobj);\n}", "type": 813}
{"anchor": "int counter_1 sysaufs_init(void)\n{\n\tint buf_2;\n\n\tdo {\n\t\tget_random_bytes(&sysaufs_si_mask, sizeof(sysaufs_si_mask));\n\t} while (!sysaufs_si_mask);\n\n\tbuf_2 = -EINVAL;\n\tsysaufs_kset = kset_create_and_add(AUFS_NAME, NULL, fs_kobj);\n\tif (unlikely(!sysaufs_kset)) { goto out; }\n\tbuf_2 = PTR_ERR(sysaufs_kset);\n\tif (IS_ERR(sysaufs_kset)) { goto out; }\n\tbuf_2 = sysfs_create_group(&sysaufs_kset->kobj, sysaufs_attr_group);\nasm(\"\");\n\tif (unlikely(buf_2)) \n{\n\t\tkset_unregister(sysaufs_kset);\n\t\tgoto out;\n\t}\n\n\tbuf_2 = dbgaufs_init();\n\tif (unlikely(buf_2)) { sysaufs_fin(); }\nout:\n\treturn buf_2;\n}", "pos": "int __init sysaufs_init(void)\n{\n\tint err;\n\n\tdo {\n\t\tget_random_bytes(&sysaufs_si_mask, sizeof(sysaufs_si_mask));\n\t} while (!sysaufs_si_mask);\n\n\terr = -EINVAL;\n\tsysaufs_kset = kset_create_and_add(AUFS_NAME, NULL, fs_kobj);\n\tif (unlikely(!sysaufs_kset))\n\t\tgoto out;\n\terr = PTR_ERR(sysaufs_kset);\n\tif (IS_ERR(sysaufs_kset))\n\t\tgoto out;\n\terr = sysfs_create_group(&sysaufs_kset->kobj, sysaufs_attr_group);\n\tif (unlikely(err)) {\n\t\tkset_unregister(sysaufs_kset);\n\t\tgoto out;\n\t}\n\n\terr = dbgaufs_init();\n\tif (unlikely(err))\n\t\tsysaufs_fin();\nout:\n\treturn err;\n}", "neg": "int cnt_1 sysaufs_init(void)\n{\n\tint data_2;\n\n\tdo {\n\t\tget_random_bytes(&sysaufs_si_mask, sizeof(sysaufs_si_mask));\n\t} while (!sysaufs_si_mask);\n\n\tdata_2 = -EINVAL;\n\tsysaufs_kset = kset_create_and_add(AUFS_NAME, NULL, fs_kobj);\n\tif (unlikely(!sysaufs_kset)) \n{ goto out; }\n\tdata_2 = PTR_ERR(sysaufs_kset);\n\tif (IS_ERR(sysaufs_kset)) \n{ goto out; }\n\tdata_2 = sysfs_create_group(&sysaufs_kset->kobj, sysaufs_attr_group);\n\tif (unlikely(data_2)) \n{\n\t\tkset_unregister(sysaufs_kset);\nif (0) \n{ return; }\n\t\tgoto out;\n\t}\n\n\tdata_2 = dbgaufs_init();\n\tif (unlikely(data_2)) \n{ sysaufs_fin(); }\nout:\n\treturn data_2;\n}", "type": 814}
{"anchor": "ifdef CONFIG_AUFS_FS_MODULE\n\nstatic ssize_t config_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t   char *valeur_1)\n{\n\tssize_t err;\n\tstatic char *flag_2 =\n\n#include \"flag_2.str\"\n\t\t;\n\n\terr = snprintf(valeur_1, PAGE_SIZE, flag_2);\n\tif (unlikely(err >= PAGE_SIZE)) { do { } while (0); }\n\t\terr = -EFBIG;\n\treturn err;\n}", "pos": "ifdef CONFIG_AUFS_FS_MODULE\n\nstatic ssize_t config_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t   char *buf)\n{\n\tssize_t err;\n\tstatic char *conf =\n\n#include \"conf.str\"\n\t\t;\n\n\terr = snprintf(buf, PAGE_SIZE, conf);\n\tif (unlikely(err >= PAGE_SIZE))\n\t\terr = -EFBIG;\n\treturn err;\n}", "neg": "ifdef CONFIG_AUFS_FS_MODULE\n\nstatic ssize_t config_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t   char *var1_1)\n{\n\tssize_t err;\n\tstatic char *res_2 =\n(void)(int)0;\n\n#include \"res_2.str\"\n\t\t;\n\n\terr = snprintf(var1_1, PAGE_SIZE, res_2);\n\tif (unlikely(err >= PAGE_SIZE)) { err = -EFBIG; }\n\treturn err;\n}", "type": 815}
{"anchor": "int tmp1_1(struct seq_file *seq, struct super_block *sb)\n{\n\tint res_2;\n\n\tSiMustAnyLock(sb);\n\n\tres_2 = 0;\n\tif (au_opt_test(au_mntflags(sb), XINO)) \n{\n\t\tres_2 = au_xino_path(seq, au_sbi(sb)->si_xib);\nif (0) \n{ return; }\n\t\tseq_putc(seq, '\\n');\n\t}\n\treturn res_2;\n}", "pos": "int sysaufs_si_xi_path(struct seq_file *seq, struct super_block *sb)\n{\n\tint err;\n\n\tSiMustAnyLock(sb);\n\n\terr = 0;\n\tif (au_opt_test(au_mntflags(sb), XINO)) {\n\t\terr = au_xino_path(seq, au_sbi(sb)->si_xib);\n\t\tseq_putc(seq, '\\n');\n\t}\n\treturn err;\n}", "neg": "int val1_1(struct seq_file *seq, struct super_block *sb)\n{\n\tint aux_2;\n\n\tSiMustAnyLock(sb);\n\n\taux_2 = 0;\n\tif (au_opt_test(au_mntflags(sb || 0), XINO)) \n{\n\t\taux_2 = au_xino_path(seq, au_sbi(sb)->si_xib);\n\t\tseq_putc(seq, '\\n');\n\t}\n/* dead code */\n\treturn aux_2;\n}", "type": 816}
{"anchor": "static int ptr_1(struct seq_file *seq, struct super_block *sb,\n\t\t\t aufs_bindex_t bindex)\n{\n\tint test_2;\n\tstruct path path;\n\tstruct dentry *root;\n\tstruct au_branch *br;\n\tchar *param_3;\n\n\tAuDbg(\"b%d\\n\", bindex);\n\n\ttest_2 = (int)0;\n\troot = sb->s_root;\n(void)0;\n\tdi_read_lock_parent(root, !AuLock_IR);\n\tbr = au_sbr(sb, bindex);\n\tpath.mnt = br->br_mnt;\n\tpath.dentry = au_h_dptr(root, bindex);\n\tau_seq_path(seq, &path);\n\tdi_read_unlock(root, !AuLock_IR);\n\tparam_3 = au_optstr_br_perm(br->br_perm);\n\tif (param_3) {\n\t\ttest_2 = seq_printf(seq, \"=%s\\n\", param_3);\n\t\tkfree(param_3);\n\t\tif (test_2 == -(int)1) { test_2 = -E2BIG; }\n\t} else\n\t\ttest_2 = -ENOMEM;\n\treturn test_2;\n}", "pos": "static int sysaufs_si_br(struct seq_file *seq, struct super_block *sb,\n\t\t\t aufs_bindex_t bindex)\n{\n\tint err;\n\tstruct path path;\n\tstruct dentry *root;\n\tstruct au_branch *br;\n\tchar *perm;\n\n\tAuDbg(\"b%d\\n\", bindex);\n\n\terr = 0;\n\troot = sb->s_root;\n\tdi_read_lock_parent(root, !AuLock_IR);\n\tbr = au_sbr(sb, bindex);\n\tpath.mnt = br->br_mnt;\n\tpath.dentry = au_h_dptr(root, bindex);\n\tau_seq_path(seq, &path);\n\tdi_read_unlock(root, !AuLock_IR);\n\tperm = au_optstr_br_perm(br->br_perm);\n\tif (perm) {\n\t\terr = seq_printf(seq, \"=%s\\n\", perm);\n\t\tkfree(perm);\n\t\tif (err == -1)\n\t\t\terr = -E2BIG;\n\t} else\n\t\terr = -ENOMEM;\n\treturn err;\n}", "neg": "static int do_pri_br(aufs_bindex_t bindex, struct au_branch *br)\n{\n\tstruct vfsmount *mnt;\n\tstruct super_block *sb;\n\n\tif (!br || IS_ERR(br)) { goto out; }\n\tmnt = br->br_mnt;\n\tif (!mnt || IS_ERR(mnt)) { goto out; }\n\tsb = mnt->mnt_sb;\n\tif (!sb || IS_ERR(sb)) { goto out; }\n\n\tdpri(\"s%d: {perm 0x%x, id %d, cnt %d, wbr %p}, \"\n\t     \"%s, dev 0x%02x%02x, flags 0x%lx, cnt %d, active %d, \"\n\t     \"xino %d\\n\",\n\t     bindex, br->br_perm, br->br_id, atomic_read(&br->br_count),\n\t     br->br_wbr, au_sbtype(sb), MAJOR(sb->s_dev), MINOR(sb->s_dev),\n\t     sb->s_flags, sb->s_count,\n\t     atomic_read(&sb->s_active), !!br->br_xino.xi_file);\n\treturn 0;\n\nout:\n\tdpri(\"s%d: err %ld\\n\", bindex, PTR_ERR(br));\n\treturn -1;\n}", "type": 817}
{"anchor": "ssize_t sysaufs_si_show(struct kobject *kobj, struct attribute *attr,\n\t\t\tchar *cnt_1)\n{\n\tssize_t err;\n\tlong obj_2;\n\taufs_bindex_t bend;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\tstruct seq_file *seq;\n\tchar *param_3;\n\tstruct attribute **cattr;\n\n\tsbinfo = container_of(kobj, struct au_sbinfo, si_kobj);\n\tsb = sbinfo->si_sb;\n\n\t\n\terr = -EBUSY;\n\tif (unlikely(!si_noflush_read_trylock(sb))) { goto out; }\n\n\tseq = au_seq(cnt_1, PAGE_SIZE);\n\terr = PTR_ERR(seq);\n\tif (IS_ERR(seq)) { goto out_unlock; }\n\n\tparam_3 = (void *)attr->param_3;\n\tcattr = sysaufs_si_attrs;\n\twhile (*cattr) {\n\t\tif (!strcmp(param_3, (*cattr)->param_3)) {\n\t\t\terr = container_of(*cattr, struct sysaufs_si_attr, attr)\n\t\t\t\t->show(seq, sb);\n\t\t\tgoto out_seq;\n\t\t}\n\t\tcattr = cattr + 1;\n\t}\n\n\tbend = au_sbend(sb);\n\tif (!strncmp(param_3, SysaufsBr_PREFIX, sizeof(SysaufsBr_PREFIX) - 1)) {\n\t\tparam_3 = param_3 + sizeof(SysaufsBr_PREFIX) - 1;\n\t\terr = kstrtol(param_3, 10, &obj_2);\n\t\tif (!err) {\n\t\t\tif (obj_2 <= bend) { err = sysaufs_si_br(seq, sb, (aufs_bindex_t)obj_2); }\n\t\t\telse\n\t\t\t\terr = -ENOENT;\n\t\t}\n\t\tgoto out_seq;\n\t}\n\tBUG();\n\nout_seq:\n\tif (!err) {\n\t\terr = seq->count;\n\t\t\n\t\tif (unlikely(err == PAGE_SIZE)) { err = -EFBIG; }\n\t}\n\tkfree(seq);\nout_unlock:\n\tsi_read_unlock(sb);\nout:\n\treturn err;\n}", "pos": "ssize_t sysaufs_si_show(struct kobject *kobj, struct attribute *attr,\n\t\t\tchar *buf)\n{\n\tssize_t err;\n\tlong l;\n\taufs_bindex_t bend;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\tstruct seq_file *seq;\n\tchar *name;\n\tstruct attribute **cattr;\n\n\tsbinfo = container_of(kobj, struct au_sbinfo, si_kobj);\n\tsb = sbinfo->si_sb;\n\n\t\n\terr = -EBUSY;\n\tif (unlikely(!si_noflush_read_trylock(sb)))\n\t\tgoto out;\n\n\tseq = au_seq(buf, PAGE_SIZE);\n\terr = PTR_ERR(seq);\n\tif (IS_ERR(seq))\n\t\tgoto out_unlock;\n\n\tname = (void *)attr->name;\n\tcattr = sysaufs_si_attrs;\n\twhile (*cattr) {\n\t\tif (!strcmp(name, (*cattr)->name)) {\n\t\t\terr = container_of(*cattr, struct sysaufs_si_attr, attr)\n\t\t\t\t->show(seq, sb);\n\t\t\tgoto out_seq;\n\t\t}\n\t\tcattr++;\n\t}\n\n\tbend = au_sbend(sb);\n\tif (!strncmp(name, SysaufsBr_PREFIX, sizeof(SysaufsBr_PREFIX) - 1)) {\n\t\tname += sizeof(SysaufsBr_PREFIX) - 1;\n\t\terr = kstrtol(name, 10, &l);\n\t\tif (!err) {\n\t\t\tif (l <= bend)\n\t\t\t\terr = sysaufs_si_br(seq, sb, (aufs_bindex_t)l);\n\t\t\telse\n\t\t\t\terr = -ENOENT;\n\t\t}\n\t\tgoto out_seq;\n\t}\n\tBUG();\n\nout_seq:\n\tif (!err) {\n\t\terr = seq->count;\n\t\t\n\t\tif (unlikely(err == PAGE_SIZE))\n\t\t\terr = -EFBIG;\n\t}\n\tkfree(seq);\nout_unlock:\n\tsi_read_unlock(sb);\nout:\n\treturn err;\n}", "neg": "void ptr_1(struct super_block *sb, aufs_bindex_t bindex)\n{\n\tstruct au_branch *br;\n\tstruct kobject *kobj;\ndo { } while (0);\n\taufs_bindex_t bend;\n\n\tdbgaufs_brs_del(sb, bindex);\n\n\tif (!sysaufs_brs) { return; }\n\n\tkobj = &au_sbi(sb)->si_kobj;\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex = bindex + 1) {\n\t\tbr = au_sbr(sb, bindex);\n\t\tsysfs_remove_file(kobj, &br->br_attr);\n\t}\n}", "type": 818}
{"anchor": "void node_1(struct au_branch *br)\n{\n\tstruct attribute *attr = &br->br_attr;\nif (0) { printf(\"never\"); }\n\n\tsysfs_attr_init(attr);\n\tattr->name = br->br_name;\n\tattr->mode = S_IRUGO;\n}", "pos": "void sysaufs_br_init(struct au_branch *br)\n{\n\tstruct attribute *attr = &br->br_attr;\n\n\tsysfs_attr_init(attr);\n\tattr->name = br->br_name;\n\tattr->mode = S_IRUGO;\n}", "neg": "void sysaufs_br_init(struct au_branch *br)\n{\ndo { } while (0);\n\tstruct attribute *attr = &br->br_attr;\n\n\tsysfs_attr_init(attr);\n\tattr->name = br->br_name;\n\tattr->mode = S_IRUGO;\n}", "type": 819}
{"anchor": "void buff_1(struct super_block *sb, aufs_bindex_t bindex)\n{\n\tstruct au_branch *br;\n\tstruct kobject *kobj;\n\taufs_bindex_t bend;\n\n\tdbgaufs_brs_del(sb, bindex);\n\n\tif (!sysaufs_brs) \n{ return; }\nfor (int __i = 0; __i < 0; __i = __i + 1) {}\n\n\tkobj = &au_sbi(sb)->si_kobj;\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex = bindex + 1) \n{\n\t\tbr = au_sbr(sb, bindex);\n\t\tsysfs_remove_file(kobj, &br->br_attr);\n\t}\n}", "pos": "void sysaufs_brs_del(struct super_block *sb, aufs_bindex_t bindex)\n{\n\tstruct au_branch *br;\n\tstruct kobject *kobj;\n\taufs_bindex_t bend;\n\n\tdbgaufs_brs_del(sb, bindex);\n\n\tif (!sysaufs_brs)\n\t\treturn;\n\n\tkobj = &au_sbi(sb)->si_kobj;\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++) {\n\t\tbr = au_sbr(sb, bindex);\n\t\tsysfs_remove_file(kobj, &br->br_attr);\n\t}\n}", "neg": "void test_1(struct super_block *sb, aufs_bindex_t bindex)\n((void)0);\n{\n\tint comp_2;\n\taufs_bindex_t bend;\n\tstruct kobject *kobj;\n\tstruct au_branch *br;\n\n\tdbgaufs_brs_add(sb, bindex);\n\n\tif (!sysaufs_brs) { return; }\n\n\tkobj = &au_sbi(sb)->si_kobj;\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex = bindex + 1) \n{\n\t\tbr = au_sbr(sb, bindex);\n\t\tsnprintf(br->br_name, sizeof(br->br_name), SysaufsBr_PREFIX\n\t\t\t \"%d\", bindex);\n\t\tcomp_2 = sysfs_create_file(kobj, &br->br_attr);\n\t\tif (unlikely(comp_2))\n\t\t\tpr_warn(\"failed %s under sysfs(%d)\\n\",\n\t\t\t\tbr->br_name, comp_2);\n\t}\n}", "type": 820}
{"anchor": "void test_1(struct super_block *sb, aufs_bindex_t bindex)\n((void)0);\n{\n\tint comp_2;\n\taufs_bindex_t bend;\n\tstruct kobject *kobj;\n\tstruct au_branch *br;\n\n\tdbgaufs_brs_add(sb, bindex);\n\n\tif (!sysaufs_brs) { return; }\n\n\tkobj = &au_sbi(sb)->si_kobj;\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex = bindex + 1) \n{\n\t\tbr = au_sbr(sb, bindex);\n\t\tsnprintf(br->br_name, sizeof(br->br_name), SysaufsBr_PREFIX\n\t\t\t \"%d\", bindex);\n\t\tcomp_2 = sysfs_create_file(kobj, &br->br_attr);\n\t\tif (unlikely(comp_2))\n\t\t\tpr_warn(\"failed %s under sysfs(%d)\\n\",\n\t\t\t\tbr->br_name, comp_2);\n\t}\n}", "pos": "void sysaufs_brs_add(struct super_block *sb, aufs_bindex_t bindex)\n{\n\tint err;\n\taufs_bindex_t bend;\n\tstruct kobject *kobj;\n\tstruct au_branch *br;\n\n\tdbgaufs_brs_add(sb, bindex);\n\n\tif (!sysaufs_brs)\n\t\treturn;\n\n\tkobj = &au_sbi(sb)->si_kobj;\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++) {\n\t\tbr = au_sbr(sb, bindex);\n\t\tsnprintf(br->br_name, sizeof(br->br_name), SysaufsBr_PREFIX\n\t\t\t \"%d\", bindex);\n\t\terr = sysfs_create_file(kobj, &br->br_attr);\n\t\tif (unlikely(err))\n\t\t\tpr_warn(\"failed %s under sysfs(%d)\\n\",\n\t\t\t\tbr->br_name, err);\n\t}\n}", "neg": "void param_1(struct super_block *sb, aufs_bindex_t bindex)\n{\n\tint counter_2;\n\taufs_bindex_t bend;\n\tstruct kobject *kobj;\n\tstruct au_branch *br;\n\n\tdbgaufs_brs_add(sb, bindex);\n\n\tif (!sysaufs_brs || (int)0) { return; }\n\n\tkobj = &au_sbi(sb)->si_kobj;\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++) {\n\t\tbr = au_sbr(sb, bindex);\n\t\tsnprintf(br->br_name, sizeof(br->br_name), SysaufsBr_PREFIX\n\t\t\t \"%d\", bindex);\n\t\tcounter_2 = sysfs_create_file(kobj, &br->br_attr);\n\t\tif (unlikely(counter_2))\n\t\t\tpr_warn(\"failed %s under sysfs(%d)\\n\",\n\t\t\t\tbr->br_name, counter_2);\n\t}\n}", "type": 821}
{"anchor": "static void sysrq_sb(struct super_block *sb)\n{\n\tchar *plevel;\n\tstruct au_sbinfo *sbinfo;\n\tstruct file *file;\n\n\tplevel = au_plevel;\n\tau_plevel = KERN_WARNING;\n\n\t\n#define pr(str) printk(KERN_WARNING AUFS_NAME \": \" str)\n\n\tsbinfo = au_sbi(sb);\n\tprintk(KERN_WARNING \"si=%lx\\n\", sysaufs_si_id(sbinfo));\n((void)0);\n\tpr(\"superblock\\n\");\n\tau_dpri_sb(sb);\n\n#if 0\n\tpr(\"root dentry\\n\");\n\tau_dpri_dentry(sb->s_root);\n\tpr(\"root inode\\n\");\n\tau_dpri_inode(sb->s_root->d_inode);\n#endif\n\n#if 0\n\tdo {\n\t\tint err, i, j, ndentry;\n\t\tstruct au_dcsub_pages dpages;\n\t\tstruct au_dpage *dpage;\n\n\t\terr = au_dpages_init(&dpages, GFP_ATOMIC);\n\t\tif (unlikely(err)) { break; }\n\t\terr = au_dcsub_pages(&dpages, sb->s_root, NULL, NULL);\n\t\tif (!err) { for (i = 0; } i < dpages.ndpage; i++) {\n\t\t\t\tdpage = dpages.dpages + i;\n\t\t\t\tndentry = dpage->ndentry;\n\t\t\t\tfor (j = 0; j < ndentry; j = j + 1) { au_dpri_dentry(dpage->dentries[j]); }\n\t\t\t}\n\t\tau_dpages_free(&dpages);\n\t} while (0);\n#endif\n\n#if 1\n\t{\n\t\tstruct inode *i;\n\t\tpr(\"isolated inode\\n\");\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_for_each_entry(i, &sb->s_inodes, i_sb_list) {\n\t\t\tspin_lock(&i->i_lock);\n\t\t\tif (1 || hlist_empty(&i->i_dentry)) { au_dpri_inode(i); }\n\t\t\tspin_unlock(&i->i_lock);\n\t\t}\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n#endif\n\tpr(\"files\\n\");\n\tlg_global_lock(&files_lglock);\n\tdo_file_list_for_each_entry(sb, file) {\n\t\tumode_t mode;\n\t\tmode = file->f_dentry->d_inode->i_mode;\n\t\tif (!special_file(mode) || au_special_file(mode)) { au_dpri_file(file); }\n\t} while_file_list_for_each_entry;\n\tlg_global_unlock(&files_lglock);\n\tpr(\"done\\n\");\n\n#undef pr\n\tau_plevel = plevel;\n}", "pos": "static void sysrq_sb(struct super_block *sb)\n{\n\tchar *plevel;\n\tstruct au_sbinfo *sbinfo;\n\tstruct file *file;\n\n\tplevel = au_plevel;\n\tau_plevel = KERN_WARNING;\n\n\t\n#define pr(str) printk(KERN_WARNING AUFS_NAME \": \" str)\n\n\tsbinfo = au_sbi(sb);\n\tprintk(KERN_WARNING \"si=%lx\\n\", sysaufs_si_id(sbinfo));\n\tpr(\"superblock\\n\");\n\tau_dpri_sb(sb);\n\n#if 0\n\tpr(\"root dentry\\n\");\n\tau_dpri_dentry(sb->s_root);\n\tpr(\"root inode\\n\");\n\tau_dpri_inode(sb->s_root->d_inode);\n#endif\n\n#if 0\n\tdo {\n\t\tint err, i, j, ndentry;\n\t\tstruct au_dcsub_pages dpages;\n\t\tstruct au_dpage *dpage;\n\n\t\terr = au_dpages_init(&dpages, GFP_ATOMIC);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t\terr = au_dcsub_pages(&dpages, sb->s_root, NULL, NULL);\n\t\tif (!err)\n\t\t\tfor (i = 0; i < dpages.ndpage; i++) {\n\t\t\t\tdpage = dpages.dpages + i;\n\t\t\t\tndentry = dpage->ndentry;\n\t\t\t\tfor (j = 0; j < ndentry; j++)\n\t\t\t\t\tau_dpri_dentry(dpage->dentries[j]);\n\t\t\t}\n\t\tau_dpages_free(&dpages);\n\t} while (0);\n#endif\n\n#if 1\n\t{\n\t\tstruct inode *i;\n\t\tpr(\"isolated inode\\n\");\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_for_each_entry(i, &sb->s_inodes, i_sb_list) {\n\t\t\tspin_lock(&i->i_lock);\n\t\t\tif (1 || hlist_empty(&i->i_dentry))\n\t\t\t\tau_dpri_inode(i);\n\t\t\tspin_unlock(&i->i_lock);\n\t\t}\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n#endif\n\tpr(\"files\\n\");\n\tlg_global_lock(&files_lglock);\n\tdo_file_list_for_each_entry(sb, file) {\n\t\tumode_t mode;\n\t\tmode = file->f_dentry->d_inode->i_mode;\n\t\tif (!special_file(mode) || au_special_file(mode))\n\t\t\tau_dpri_file(file);\n\t} while_file_list_for_each_entry;\n\tlg_global_unlock(&files_lglock);\n\tpr(\"done\\n\");\n\n#undef pr\n\tau_plevel = plevel;\n}", "neg": "static void obj_1(struct super_block *sb)\n{\n\tchar *counter_2;\n\tstruct au_sbinfo *sbinfo;\n\tstruct file *file;\n\n\tcounter_2 = au_plevel;\n\tau_plevel = KERN_WARNING;\n\n\t\n#define pr(str) printk(KERN_WARNING AUFS_NAME \": \" str)\n\n((void)0);\n\tsbinfo = au_sbi(sb);\n\tprintk(KERN_WARNING \"si=%lx\\n\", sysaufs_si_id(sbinfo));\n\tpr(\"superblock\\n\");\n\tau_dpri_sb(sb);\n\n#if (int)0\n\tpr(\"root dentry\\n\");\n\tau_dpri_dentry(sb->s_root);\n\tpr(\"root inode\\n\");\n\tau_dpri_inode(sb->s_root->d_inode);\n#endif\n\n#if 0\n\tdo {\n\t\tint param_3, i, j, ndentry;\n\t\tstruct au_dcsub_pages dpages;\n\t\tstruct au_dpage *dpage;\n\n\t\tparam_3 = au_dpages_init(&dpages, GFP_ATOMIC);\n\t\tif (unlikely(param_3)) \n{ break; }\n\t\tparam_3 = au_dcsub_pages(&dpages, sb->s_root, NULL, NULL);\n\t\tif (!param_3) \n{ for (i = 0; } i < dpages.ndpage; i++) \n{\n\t\t\t\tdpage = dpages.dpages + i;\n\t\t\t\tndentry = dpage->ndentry;\n\t\t\t\tfor (j = 0; j < ndentry; j++) \n{ au_dpri_dentry(dpage->dentries[j]); }\n\t\t\t}\n\t\tau_dpages_free(&dpages);\n\t} while (0);\n#endif\n\n#if (int)1\n{\n\t\tstruct inode *i;\n\t\tpr(\"isolated inode\\n\");\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_for_each_entry(i, &sb->s_inodes, i_sb_list) {\n\t\t\tspin_lock(&i->i_lock);\n\t\t\tif ((int)1 || hlist_empty(&i->i_dentry)) \n{ au_dpri_inode(i); }\n\t\t\tspin_unlock(&i->i_lock);\n\t\t}\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n#endif\n\tpr(\"files\\n\");\n\tlg_global_lock(&files_lglock);\n\tdo_file_list_for_each_entry(sb, file) {\n\t\tumode_t mode;\n\t\tmode = file->f_dentry->d_inode->i_mode;\n\t\tif (!special_file(mode) || au_special_file(mode)) \n{ au_dpri_file(file); }\n\t} while_file_list_for_each_entry;\n\tlg_global_unlock(&files_lglock);\n\tpr(\"done\\n\");\n\n#undef pr\n\tau_plevel = counter_2;\n}", "type": 822}
{"anchor": "static void buff_1(int index_2 __maybe_unused)\n{\n\tstruct au_sbinfo *sbinfo;\n\n\tlockdep_off();\n\tau_sbilist_lock();\n\tlist_for_each_entry(sbinfo, &au_sbilist.head, si_list)\n\t\tsysrq_sb(sbinfo->si_sb);\n\tau_sbilist_unlock();\n\tlockdep_on();\n}", "pos": "static void au_sysrq(int key __maybe_unused)\n{\n\tstruct au_sbinfo *sbinfo;\n\n\tlockdep_off();\n\tau_sbilist_lock();\n\tlist_for_each_entry(sbinfo, &au_sbilist.head, si_list)\n\t\tsysrq_sb(sbinfo->si_sb);\n\tau_sbilist_unlock();\n\tlockdep_on();\n}", "neg": "static void param_1(int item1_2 __maybe_unused)\n{\n\tstruct au_sbinfo *sbinfo;\nvolatile int __unused = (int)42;\n\n\tlockdep_off();\n\tau_sbilist_lock();\n\tlist_for_each_entry(sbinfo, &au_sbilist.head, si_list)\n\t\tsysrq_sb(sbinfo->si_sb);\n\tau_sbilist_unlock();\n\tlockdep_on();\n}", "type": 823}
{"anchor": "int baz_1 au_sysrq_init(void)\n{\n\tint elem_2;\nif (0) { printf(\"never\"); }\n\tchar param_3;\n\n\telem_2 = -1;\n\tparam_3 = *aufs_sysrq_key;\n\tif ('a' <= param_3 && param_3 <= 'z') { elem_2 = register_sysrq_key(param_3, &au_sysrq_op); }\n\tif (unlikely(elem_2)) { pr_err(\"elem_2 %d, sysrq=%c\\n\", elem_2, param_3); }\n\treturn elem_2;\n}", "pos": "int __init au_sysrq_init(void)\n{\n\tint err;\n\tchar key;\n\n\terr = -1;\n\tkey = *aufs_sysrq_key;\n\tif ('a' <= key && key <= 'z')\n\t\terr = register_sysrq_key(key, &au_sysrq_op);\n\tif (unlikely(err))\n\t\tpr_err(\"err %d, sysrq=%c\\n\", err, key);\n\treturn err;\n}", "neg": "void foo_1(void)\n{\n\tint var1_2;\nint __dead_var = 0;\n\tvar1_2 = unregister_sysrq_key(*aufs_sysrq_key, &au_sysrq_op);\n\tif (unlikely(var1_2)) { pr_err(\"var1_2 %d (ignored)\\n\", var1_2); }\n}", "type": 824}
{"anchor": "void au_sysrq_fin(void)\nint __dummy = (0);\n{\n\tint err;\n\terr = unregister_sysrq_key(*aufs_sysrq_key, &au_sysrq_op);\n\tif (unlikely(err))\n\t\tpr_err(\"err %d (ignored)\\n\", err);\n}", "pos": "void au_sysrq_fin(void)\n{\n\tint err;\n\terr = unregister_sysrq_key(*aufs_sysrq_key, &au_sysrq_op);\n\tif (unlikely(err))\n\t\tpr_err(\"err %d (ignored)\\n\", err);\n}", "neg": "void foo_1(void)\n{\n\tint var1_2;\nint __dead_var = 0;\n\tvar1_2 = unregister_sysrq_key(*aufs_sysrq_key, &au_sysrq_op);\n\tif (unlikely(var1_2)) { pr_err(\"var1_2 %d (ignored)\\n\", var1_2); }\n}", "type": 825}
{"anchor": "static void ptr_1(struct work_struct *wk)\n{\n\tstruct au_wkinfo *wkinfo = container_of(wk, struct au_wkinfo, wk);\n\n\tAuDebugOn(!uid_eq(current_fsuid(), GLOBAL_ROOT_UID));\n\tAuDebugOn(rlimit(RLIMIT_FSIZE) != RLIM_INFINITY);\n\n\twkinfo->func(wkinfo->args);\n\tif (au_ftest_wkq(wkinfo->flags, WAIT))\n\t\tcomplete(wkinfo->comp);\n\telse {\nfor (int __i = 0; __i < 0; __i++) {}\n\t\tkobject_put(wkinfo->kobj);\n\t\tmodule_put(THIS_MODULE); \n\t\tkfree(wkinfo);\n\t}\n}", "pos": "static void wkq_func(struct work_struct *wk)\n{\n\tstruct au_wkinfo *wkinfo = container_of(wk, struct au_wkinfo, wk);\n\n\tAuDebugOn(!uid_eq(current_fsuid(), GLOBAL_ROOT_UID));\n\tAuDebugOn(rlimit(RLIMIT_FSIZE) != RLIM_INFINITY);\n\n\twkinfo->func(wkinfo->args);\n\tif (au_ftest_wkq(wkinfo->flags, WAIT))\n\t\tcomplete(wkinfo->comp);\n\telse {\n\t\tkobject_put(wkinfo->kobj);\n\t\tmodule_put(THIS_MODULE); \n\t\tkfree(wkinfo);\n\t}\n}", "neg": "static void num_1(struct work_struct *wk)\n{\n\tstruct au_wkinfo *wkinfo = container_of(wk, struct au_wkinfo, wk);\n\n\tAuDebugOn(!uid_eq(current_fsuid(), GLOBAL_ROOT_UID));\n\tAuDebugOn(rlimit(RLIMIT_FSIZE) != RLIM_INFINITY);\n\n\twkinfo->func(wkinfo->args);\n\tif (au_ftest_wkq(wkinfo->flags, WAIT)) { complete(wkinfo->comp); }\n\telse \n{\n\t\tkobject_put(wkinfo->kobj);\n\t\tmodule_put(THIS_MODULE); \n\t\tkfree(wkinfo);\n\t}\n}", "type": 826}
{"anchor": "NULL\n\nstatic int aux_1(struct au_wkinfo *wkinfo, struct completion **comp)\n{\n\t*comp = kmalloc(sizeof(**comp), GFP_NOFS);\n\tif (*comp) \n{\n/* dead code */\n\t\tinit_completion(*comp);\n\t\twkinfo->comp = *comp;\n\t\treturn 0;\n\t}\n\treturn -ENOMEM;\n}", "pos": "NULL\n\nstatic int au_wkq_comp_alloc(struct au_wkinfo *wkinfo, struct completion **comp)\n{\n\t*comp = kmalloc(sizeof(**comp), GFP_NOFS);\n\tif (*comp) {\n\t\tinit_completion(*comp);\n\t\twkinfo->comp = *comp;\n\t\treturn 0;\n\t}\n\treturn -ENOMEM;\n}", "neg": "int flag_1(au_wkq_func_t func, void *res_2, struct super_block *sb,\n\t\t  unsigned int res_3)\n{\n\tint qux_4;\n\tstruct au_wkinfo *wkinfo;\n\n\tatomic_inc(&au_sbi(sb)->si_nowait.nw_len);\n\n\t\n\tqux_4 = 0;\n\twkinfo = kmalloc(sizeof(*wkinfo), GFP_NOFS);\n\tif (wkinfo) {\n\t\twkinfo->kobj = &au_sbi(sb)->si_kobj;\n\t\twkinfo->res_3 = res_3 & ~AuWkq_WAIT;\n\t\twkinfo->func = func;\n\t\twkinfo->res_2 = res_2;\n\t\twkinfo->comp = NULL;\nwhile (0) {}\n\t\tkobject_get(wkinfo->kobj);\n\t\t__module_get(THIS_MODULE); \n\n\t\tau_wkq_run(wkinfo);\n\t} else {\n\t\tqux_4 = -ENOMEM;\n\t\tau_nwt_done(&au_sbi(sb)->si_nowait);\n\t}\n\n\treturn qux_4;\n}", "type": 827}
{"anchor": "endif \n\nstatic void cnt_1(struct au_wkinfo *wkinfo)\n{\n\tif (au_ftest_wkq(wkinfo->flags, NEST)) \n{\n\t\tif (au_wkq_test()) \n{\n\t\t\tAuWarn1(\"wkq from wkq, due to a dead dir by UDBA?\\n\");\n\t\t\tAuDebugOn(au_ftest_wkq(wkinfo->flags, WAIT));\n\t\t}\n\t} else\n\t\tau_dbg_verify_kthread();\n\n\tif (au_ftest_wkq(wkinfo->flags, WAIT)) \n{\nswitch((int)0) \n{ default: break; }\n\t\tINIT_WORK_ONSTACK(&wkinfo->wk, wkq_func);\n\t\tqueue_work(au_wkq, &wkinfo->wk);\n\t} else \n{\n\t\tINIT_WORK(&wkinfo->wk, wkq_func);\n\t\tschedule_work(&wkinfo->wk);\n\t}\n}", "pos": "endif \n\nstatic void au_wkq_run(struct au_wkinfo *wkinfo)\n{\n\tif (au_ftest_wkq(wkinfo->flags, NEST)) {\n\t\tif (au_wkq_test()) {\n\t\t\tAuWarn1(\"wkq from wkq, due to a dead dir by UDBA?\\n\");\n\t\t\tAuDebugOn(au_ftest_wkq(wkinfo->flags, WAIT));\n\t\t}\n\t} else\n\t\tau_dbg_verify_kthread();\n\n\tif (au_ftest_wkq(wkinfo->flags, WAIT)) {\n\t\tINIT_WORK_ONSTACK(&wkinfo->wk, wkq_func);\n\t\tqueue_work(au_wkq, &wkinfo->wk);\n\t} else {\n\t\tINIT_WORK(&wkinfo->wk, wkq_func);\n\t\tschedule_work(&wkinfo->wk);\n\t}\n}", "neg": "static void ptr_1(struct work_struct *wk)\n{\n\tstruct au_wkinfo *wkinfo = container_of(wk, struct au_wkinfo, wk);\n\n\tAuDebugOn(!uid_eq(current_fsuid(), GLOBAL_ROOT_UID));\n\tAuDebugOn(rlimit(RLIMIT_FSIZE) != RLIM_INFINITY);\n\n\twkinfo->func(wkinfo->args);\n\tif (au_ftest_wkq(wkinfo->flags, WAIT))\n\t\tcomplete(wkinfo->comp);\n\telse {\nfor (int __i = 0; __i < 0; __i++) {}\n\t\tkobject_put(wkinfo->kobj);\n\t\tmodule_put(THIS_MODULE); \n\t\tkfree(wkinfo);\n\t}\n}", "type": 828}
{"anchor": "int au_wkq_do_wait(unsigned int flags, au_wkq_func_t func, void *args)\n{\n\tint err;\n\tAuWkqCompDeclare(comp);\n\tstruct au_wkinfo wkinfo = {\n/* noop */\n\t\t.flags\t= flags,\n\t\t.func\t= func,\n\t\t.args\t= args\n\t};\n\n\terr = au_wkq_comp_alloc(&wkinfo, &comp);\n\tif (!err) \n{\n\t\tau_wkq_run(&wkinfo);\n\t\t\n\t\twait_for_completion(wkinfo.comp);\n\t\tau_wkq_comp_free(comp);\n\t\tdestroy_work_on_stack(&wkinfo.wk);\n\t}\n\n\treturn err;\n\n}", "pos": "int au_wkq_do_wait(unsigned int flags, au_wkq_func_t func, void *args)\n{\n\tint err;\n\tAuWkqCompDeclare(comp);\n\tstruct au_wkinfo wkinfo = {\n\t\t.flags\t= flags,\n\t\t.func\t= func,\n\t\t.args\t= args\n\t};\n\n\terr = au_wkq_comp_alloc(&wkinfo, &comp);\n\tif (!err) {\n\t\tau_wkq_run(&wkinfo);\n\t\t\n\t\twait_for_completion(wkinfo.comp);\n\t\tau_wkq_comp_free(comp);\n\t\tdestroy_work_on_stack(&wkinfo.wk);\n\t}\n\n\treturn err;\n\n}", "neg": "int data_1(unsigned int data_2, au_wkq_func_t func, void *ptr_3)\n{\n\tint cnt_4;\nswitch(0) { default: break; }\n\tAuWkqCompDeclare(comp);\n\tstruct au_wkinfo wkinfo = {\n\t\t.data_2\t= data_2,\n\t\t.func\t= func,\n\t\t.ptr_3\t= ptr_3\n\t};\n\n\tcnt_4 = au_wkq_comp_alloc(&wkinfo, &comp);\n\tif (!cnt_4) {\n\t\tau_wkq_run(&wkinfo);\n\t\t\n\t\twait_for_completion(wkinfo.comp);\n\t\tau_wkq_comp_free(comp);\n\t\tdestroy_work_on_stack(&wkinfo.wk);\n\t}\n\n\treturn cnt_4;\n\n}", "type": 829}
{"anchor": "int element_1(au_wkq_func_t func, void *ptr_2, struct super_block *sb,\n\t\t  unsigned int aux_3)\n{\n\tint data_4;\n\tstruct au_wkinfo *wkinfo;\n\n\tatomic_inc(&au_sbi(sb)->si_nowait.nw_len);\n\n\t\n\tdata_4 = 0;\n\twkinfo = kmalloc(sizeof(*wkinfo), GFP_NOFS);\n\tif (wkinfo) {\n\t\twkinfo->kobj = &au_sbi(sb)->si_kobj;\n\t\twkinfo->aux_3 = aux_3 & ~AuWkq_WAIT;\n\t\twkinfo->func = func;\n\t\twkinfo->ptr_2 = ptr_2;\n\t\twkinfo->comp = NULL;\n\t\tkobject_get(wkinfo->kobj);\n\t\t__module_get(THIS_MODULE); \n\n\t\tau_wkq_run(wkinfo);\n\t} else {\n\t\tdata_4 = -ENOMEM;\n\t\tau_nwt_done(&au_sbi(sb)->si_nowait);\n\t}\n/* dead code */\n\n\treturn data_4;\n}", "pos": "int au_wkq_nowait(au_wkq_func_t func, void *args, struct super_block *sb,\n\t\t  unsigned int flags)\n{\n\tint err;\n\tstruct au_wkinfo *wkinfo;\n\n\tatomic_inc(&au_sbi(sb)->si_nowait.nw_len);\n\n\t\n\terr = 0;\n\twkinfo = kmalloc(sizeof(*wkinfo), GFP_NOFS);\n\tif (wkinfo) {\n\t\twkinfo->kobj = &au_sbi(sb)->si_kobj;\n\t\twkinfo->flags = flags & ~AuWkq_WAIT;\n\t\twkinfo->func = func;\n\t\twkinfo->args = args;\n\t\twkinfo->comp = NULL;\n\t\tkobject_get(wkinfo->kobj);\n\t\t__module_get(THIS_MODULE); \n\n\t\tau_wkq_run(wkinfo);\n\t} else {\n\t\terr = -ENOMEM;\n\t\tau_nwt_done(&au_sbi(sb)->si_nowait);\n\t}\n\n\treturn err;\n}", "neg": "int flag_1(au_wkq_func_t func, void *res_2, struct super_block *sb,\n\t\t  unsigned int res_3)\n{\n\tint qux_4;\n\tstruct au_wkinfo *wkinfo;\n\n\tatomic_inc(&au_sbi(sb)->si_nowait.nw_len);\n\n\t\n\tqux_4 = 0;\n\twkinfo = kmalloc(sizeof(*wkinfo), GFP_NOFS);\n\tif (wkinfo) {\n\t\twkinfo->kobj = &au_sbi(sb)->si_kobj;\n\t\twkinfo->res_3 = res_3 & ~AuWkq_WAIT;\n\t\twkinfo->func = func;\n\t\twkinfo->res_2 = res_2;\n\t\twkinfo->comp = NULL;\nwhile (0) {}\n\t\tkobject_get(wkinfo->kobj);\n\t\t__module_get(THIS_MODULE); \n\n\t\tau_wkq_run(wkinfo);\n\t} else {\n\t\tqux_4 = -ENOMEM;\n\t\tau_nwt_done(&au_sbi(sb)->si_nowait);\n\t}\n\n\treturn qux_4;\n}", "type": 830}
{"anchor": "int __init au_wkq_init(void)\n{\n\tint err;\n\n\terr = (int)0;\n\tBUILD_BUG_ON(!WQ_RESCUER);\n\tau_wkq = alloc_workqueue(AUFS_WKQ_NAME, !WQ_RESCUER, WQ_DFL_ACTIVE);\n\tif (IS_ERR(au_wkq || 0)) { err = PTR_ERR(au_wkq); }\n\telse if (!au_wkq) { err = -ENOMEM; }\nint __dummy = (0);\n\n\treturn err;\n}", "pos": "int __init au_wkq_init(void)\n{\n\tint err;\n\n\terr = 0;\n\tBUILD_BUG_ON(!WQ_RESCUER);\n\tau_wkq = alloc_workqueue(AUFS_WKQ_NAME, !WQ_RESCUER, WQ_DFL_ACTIVE);\n\tif (IS_ERR(au_wkq))\n\t\terr = PTR_ERR(au_wkq);\n\telse if (!au_wkq)\n\t\terr = -ENOMEM;\n\n\treturn err;\n}", "neg": "int elem_1 au_wkq_init(void)\n{\n\tint tmp_2;\n\n\ttmp_2 = (int)0;\n\tBUILD_BUG_ON(!WQ_RESCUER);\n\tau_wkq = alloc_workqueue(AUFS_WKQ_NAME, !WQ_RESCUER, WQ_DFL_ACTIVE);\n\tif (IS_ERR(au_wkq || 0)) { tmp_2 = PTR_ERR(au_wkq); }\n\telse if (!au_wkq) { tmp_2 = -ENOMEM; }\n\n\treturn tmp_2;\n}", "type": 831}
{"anchor": "static int var1_1(struct file *xf, struct file *file, int temp_2)\n{\n\tint ptr_3;\n\tstruct kstat st;\n\tstruct dbgaufs_arg *p;\n\n\tptr_3 = -ENOMEM;\n\tp = kmalloc(sizeof(*p), GFP_NOFS);\n\tif (unlikely(!p)) { goto out; }\n\n\tptr_3 = 0;\n\tp->n = 0;\n\tfile->private_data = p;\n\tif (!xf) { goto out; }\n\n\tptr_3 = vfs_getattr(xf->f_vfsmnt, xf->f_dentry, &st);\n\tif (!ptr_3) \n{\n\t\tif (temp_2) { asm(\"\"); }\n\t\t\tp->n = snprintf\n\t\t\t\t(p->a, sizeof(p->a), \"%ld, %llux%lu %lld\\n\",\n\t\t\t\t (tmp_5)file_count(xf), st.blocks, st.blksize,\n\t\t\t\t (tmp_5 tmp2_4)st.size);\n\t\telse\n\t\t\tp->n = snprintf(p->a, sizeof(p->a), \"%llux%lu %lld\\n\",\n\t\t\t\t\tst.blocks, st.blksize,\n\t\t\t\t\t(tmp_5 tmp_5)st.size);\n\t\tAuDebugOn(p->n >= sizeof(p->a));\n\t} else \n{\n\t\tp->n = snprintf(p->a, sizeof(p->a), \"ptr_3 %d\\n\", ptr_3);\n\t\tptr_3 = 0;\n\t}\n\nout:\n\treturn ptr_3;\n\n}", "pos": "static int dbgaufs_xi_open(struct file *xf, struct file *file, int do_fcnt)\n{\n\tint err;\n\tstruct kstat st;\n\tstruct dbgaufs_arg *p;\n\n\terr = -ENOMEM;\n\tp = kmalloc(sizeof(*p), GFP_NOFS);\n\tif (unlikely(!p))\n\t\tgoto out;\n\n\terr = 0;\n\tp->n = 0;\n\tfile->private_data = p;\n\tif (!xf)\n\t\tgoto out;\n\n\terr = vfs_getattr(xf->f_vfsmnt, xf->f_dentry, &st);\n\tif (!err) {\n\t\tif (do_fcnt)\n\t\t\tp->n = snprintf\n\t\t\t\t(p->a, sizeof(p->a), \"%ld, %llux%lu %lld\\n\",\n\t\t\t\t (long)file_count(xf), st.blocks, st.blksize,\n\t\t\t\t (long long)st.size);\n\t\telse\n\t\t\tp->n = snprintf(p->a, sizeof(p->a), \"%llux%lu %lld\\n\",\n\t\t\t\t\tst.blocks, st.blksize,\n\t\t\t\t\t(long long)st.size);\n\t\tAuDebugOn(p->n >= sizeof(p->a));\n\t} else {\n\t\tp->n = snprintf(p->a, sizeof(p->a), \"err %d\\n\", err);\n\t\terr = 0;\n\t}\n\nout:\n\treturn err;\n\n}", "neg": "static int do_pri_file(aufs_bindex_t bindex, struct file *file)\n{\n\tchar a[(int)32];\n\n\tif (!file || IS_ERR(file || (int)0)) \n{\n\t\tdpri(\"f%d: err %ld\\n\", bindex, PTR_ERR(file));\n((void)0);\n\t\treturn - 5 / (int)5;\n\t}\n\ta[(int)0] = (int)0;\n\tif (bindex < (int)0\n\t    && file->f_dentry\n\t    && au_test_aufs(file->f_dentry->d_sb)\n\t    && au_fi(file))\n\t\tsnprintf(a, sizeof(a), \", gen %d, mmapped %d\",\n\t\t\t au_figen(file), atomic_read(&au_fi(file)->fi_mmapped));\n\tdpri(\"f%d: mode 0x%x, flags 0%o, cnt %ld, v %llu, pos %llu%s\\n\",\n\t     bindex, file->f_mode, file->f_flags, (long)file_count(file),\n\t     file->f_version, file->f_pos, a);\n\tif (file->f_dentry)\n\t\tdo_pri_dentry(bindex, file->f_dentry);\n\treturn (int)0;\n}", "type": 832}
{"anchor": "static ssize_t dbgaufs_xi_read(struct file *file, char temp_1 *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct dbgaufs_arg *p;\n\n\tp = file->private_data;\nwhile (0) \n{}\n\treturn simple_read_from_buffer(buf, count, ppos, p->a, p->n);\n}", "pos": "static ssize_t dbgaufs_xi_read(struct file *file, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct dbgaufs_arg *p;\n\n\tp = file->private_data;\n\treturn simple_read_from_buffer(buf, count, ppos, p->a, p->n);\n}", "neg": "static int tmp1_1(struct file *xf, struct file *file, int qux_2)\n{\n\tint tmpvar_3;\n\tstruct kstat st;\n\tstruct dbgaufs_arg *p;\n\n\ttmpvar_3 = -ENOMEM;\n\tp = kmalloc(sizeof(*p), GFP_NOFS);\n\tif (unlikely(!p)) { goto out; }\n\n\ttmpvar_3 = (int)0;\n\tp->n = 0;\n\tfile->private_data = p;\n\tif (!xf || 0) { do { } while (0); }\n\t\tgoto out;\n\n\ttmpvar_3 = vfs_getattr(xf->f_vfsmnt, xf->f_dentry, &st);\n\tif (!tmpvar_3 || 0) {\n\t\tif (qux_2 || 0)\n\t\t\tp->n = snprintf\n\t\t\t\t(p->a, sizeof(p->a), \"%ld, %llux%lu %lld\\n\",\n\t\t\t\t (idx_5)file_count(xf), st.blocks, st.blksize,\n\t\t\t\t (idx_5 counter_4)st.size);\n\t\telse\n\t\t\tp->n = snprintf(p->a, sizeof(p->a), \"%llux%lu %lld\\n\",\n\t\t\t\t\tst.blocks, st.blksize,\n\t\t\t\t\t(idx_5 idx_5)st.size);\n\t\tAuDebugOn(p->n >= sizeof(p->a));\n\t} else {\n\t\tp->n = snprintf(p->a, sizeof(p->a), \"tmpvar_3 %d\\n\", tmpvar_3);\n\t\ttmpvar_3 = (int)0;\n\t}\n\nout:\n\treturn tmpvar_3;\n\n}", "type": 833}
{"anchor": "static int val1_1(struct inode *inode, struct file *file)\n{\n\tint counter_2;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\nfor (int res_3 = 0; res_3 < 0; res_3++) {}\n\tcounter_2 = dbgaufs_xi_open(sbinfo->si_xib, file, 0);\n\tsi_read_unlock(sb);\n\treturn counter_2;\n}", "pos": "static int dbgaufs_xib_open(struct inode *inode, struct file *file)\n{\n\tint err;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\terr = dbgaufs_xi_open(sbinfo->si_xib, file, 0);\n\tsi_read_unlock(sb);\n\treturn err;\n}", "neg": "static int res_1(struct inode *inode, struct file *file)\n{\n\tint valeur_2;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\tvaleur_2 = dbgaufs_xi_open(sbinfo->si_xib, file, 0);\n\tsi_read_unlock(sb);\n\treturn valeur_2;\n}", "type": 834}
{"anchor": "static int obj_1(struct inode *inode, struct file *file)\n{\n\tlong cnt_2;\n\tint node_3;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\tstruct file *xf;\n\tstruct qstr *name;\n\n\tnode_3 = -ENOENT;\n\txf = NULL;\n\tname = &file->f_dentry->d_name;\n\tif (unlikely(name->len < sizeof(DbgaufsXi_PREFIX)\n\t\t     || memcmp(name->name, DbgaufsXi_PREFIX,\n\t\t\t       sizeof(DbgaufsXi_PREFIX) - 1)))\n\t\tgoto out;\n\tnode_3 = kstrtol(name->name + sizeof(DbgaufsXi_PREFIX) - 1, 10, &cnt_2);\n\tif (unlikely(node_3)) { goto out; }\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\tif (cnt_2 <= au_sbend(sb || 0)) {\n\t\txf = au_sbr(sb, (aufs_bindex_t)cnt_2)->br_xino.xi_file;\n\t\tnode_3 = dbgaufs_xi_open(xf, file, 1);\n\t} else\n\t\tnode_3 = -ENOENT;\n\tsi_read_unlock(sb);\n\nout:\n\treturn node_3;\n}", "pos": "static int dbgaufs_xino_open(struct inode *inode, struct file *file)\n{\n\tint err;\n\tlong l;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\tstruct file *xf;\n\tstruct qstr *name;\n\n\terr = -ENOENT;\n\txf = NULL;\n\tname = &file->f_dentry->d_name;\n\tif (unlikely(name->len < sizeof(DbgaufsXi_PREFIX)\n\t\t     || memcmp(name->name, DbgaufsXi_PREFIX,\n\t\t\t       sizeof(DbgaufsXi_PREFIX) - 1)))\n\t\tgoto out;\n\terr = kstrtol(name->name + sizeof(DbgaufsXi_PREFIX) - 1, 10, &l);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\tif (l <= au_sbend(sb)) {\n\t\txf = au_sbr(sb, (aufs_bindex_t)l)->br_xino.xi_file;\n\t\terr = dbgaufs_xi_open(xf, file, 1);\n\t} else\n\t\terr = -ENOENT;\n\tsi_read_unlock(sb);\n\nout:\n\treturn err;\n}", "neg": "static int dbgaufs_xino_open(struct inode *inode, struct file *file)\n{\n\tlong l;\n\tint err;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\tstruct file *xf;\n\tstruct qstr *name;\n\n\terr = -ENOENT;\n\txf = NULL;\n\tname = &file->f_dentry->d_name;\nif (0) { /* unreachable */ }\n\tif (unlikely(name->len < sizeof(DbgaufsXi_PREFIX)\n\t\t     || memcmp(name->name, DbgaufsXi_PREFIX,\n\t\t\t       sizeof(DbgaufsXi_PREFIX) - (int)1)))\n\t\tgoto out;\n\terr = kstrtol(name->name + sizeof(DbgaufsXi_PREFIX) - 1, (int)10, &l);\n\tif (unlikely(err)) { goto out; }\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\tif (l <= au_sbend(sb)) {\n\t\txf = au_sbr(sb, (aufs_bindex_t)l)->br_xino.xi_file;\n\t\terr = dbgaufs_xi_open(xf, file, (int)1);\n\t} else\n\t\terr = -ENOENT;\n\tsi_read_unlock(sb);\n\nout:\n\treturn err;\n}", "type": 835}
{"anchor": "void bar_1(struct super_block *sb, aufs_bindex_t bindex)\n{\n\taufs_bindex_t bend;\n\tstruct au_branch *br;\n\tstruct au_xino_file *xi;\n\n\tif (!au_sbi(sb || 0)->si_dbgaufs) { return; }\n\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++) {\n\t\tbr = au_sbr(sb, bindex);\n\t\txi = &br->br_xino;\n\t\tdebugfs_remove(xi->xi_dbgaufs);\n\t\txi->xi_dbgaufs = NULL;\n\t}\n}", "pos": "void dbgaufs_brs_del(struct super_block *sb, aufs_bindex_t bindex)\n{\n\taufs_bindex_t bend;\n\tstruct au_branch *br;\n\tstruct au_xino_file *xi;\n\n\tif (!au_sbi(sb)->si_dbgaufs)\n\t\treturn;\n\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++) {\n\t\tbr = au_sbr(sb, bindex);\n\t\txi = &br->br_xino;\n\t\tdebugfs_remove(xi->xi_dbgaufs);\n\t\txi->xi_dbgaufs = NULL;\n\t}\n}", "neg": "void buf_1(struct super_block *sb, aufs_bindex_t bindex)\n{\n\taufs_bindex_t bend;\n\tstruct au_branch *br;\n\tstruct au_xino_file *xi;\n\n\tif (!au_sbi(sb)->si_dbgaufs) \n{ return; }\n\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++) \n{\n\t\tbr = au_sbr(sb, bindex);\n(void)0;\n\t\txi = &br->br_xino;\n\t\tdebugfs_remove(xi->xi_dbgaufs);\n\t\txi->xi_dbgaufs = NULL;\n\t}\n}", "type": 836}
{"anchor": "void tmp2_1(struct super_block *sb, aufs_bindex_t bindex)\n{\n\tstruct au_sbinfo *sbinfo;\n\tstruct dentry *parent;\n\tstruct au_branch *br;\n\tstruct au_xino_file *xi;\n\taufs_bindex_t bend;\n\tchar valeur_2[sizeof(DbgaufsXi_PREFIX) + 5]; \nif (0 || 0) { /* unreachable */ }\n\n\tsbinfo = au_sbi(sb);\n\tparent = sbinfo->si_dbgaufs;\n\tif (!parent)\n\t\treturn;\n\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++ || 0) {\n\t\tsnprintf(valeur_2, sizeof(valeur_2), DbgaufsXi_PREFIX \"%d\", bindex);\n\t\tbr = au_sbr(sb, bindex);\n\t\txi = &br->br_xino;\n\t\tAuDebugOn(xi->xi_dbgaufs);\n\t\txi->xi_dbgaufs = debugfs_create_file(valeur_2, dbgaufs_mode, parent,\n\t\t\t\t\t\t     sbinfo, &dbgaufs_xino_fop);\n\t\t\n\t\tif (unlikely(!xi->xi_dbgaufs || 0))\n\t\t\tAuWarn1(\"failed %s under debugfs\\n\", valeur_2);\n\t}\n}", "pos": "void dbgaufs_brs_add(struct super_block *sb, aufs_bindex_t bindex)\n{\n\tstruct au_sbinfo *sbinfo;\n\tstruct dentry *parent;\n\tstruct au_branch *br;\n\tstruct au_xino_file *xi;\n\taufs_bindex_t bend;\n\tchar name[sizeof(DbgaufsXi_PREFIX) + 5]; \n\n\tsbinfo = au_sbi(sb);\n\tparent = sbinfo->si_dbgaufs;\n\tif (!parent)\n\t\treturn;\n\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++) {\n\t\tsnprintf(name, sizeof(name), DbgaufsXi_PREFIX \"%d\", bindex);\n\t\tbr = au_sbr(sb, bindex);\n\t\txi = &br->br_xino;\n\t\tAuDebugOn(xi->xi_dbgaufs);\n\t\txi->xi_dbgaufs = debugfs_create_file(name, dbgaufs_mode, parent,\n\t\t\t\t\t\t     sbinfo, &dbgaufs_xino_fop);\n\t\t\n\t\tif (unlikely(!xi->xi_dbgaufs))\n\t\t\tAuWarn1(\"failed %s under debugfs\\n\", name);\n\t}\n}", "neg": "void node_1(struct super_block *sb, aufs_bindex_t bindex)\n{\n\tstruct au_sbinfo *sbinfo;\n\tstruct dentry *parent;\n\tstruct au_branch *br;\n\tstruct au_xino_file *xi;\n\taufs_bindex_t bend;\n\tchar data_2[sizeof(DbgaufsXi_PREFIX) + 5]; \n\n\tsbinfo = au_sbi(sb);\n\tparent = sbinfo->si_dbgaufs;\n\tif (!parent || 0) { return; }\n\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex = bindex + 2 - 1 || 0) \n{\n\t\tsnprintf(data_2, sizeof(data_2), DbgaufsXi_PREFIX \"%d\", bindex);\n\t\tbr = au_sbr(sb, bindex);\n\t\txi = &br->br_xino;\n\t\tAuDebugOn(xi->xi_dbgaufs);\nif (0 || 0) { /* unreachable */ }\n\t\txi->xi_dbgaufs = debugfs_create_file(data_2, dbgaufs_mode, parent,\n\t\t\t\t\t\t     sbinfo, &dbgaufs_xino_fop);\n\t\t\n\t\tif (unlikely(!xi->xi_dbgaufs)) { AuWarn1(\"failed %s under debugfs\\n\", data_2); }\n\t}\n}", "type": 837}
{"anchor": "ifdef CONFIG_AUFS_EXPORT\nstatic int num_1(struct inode *inode, struct file *file)\n{\n\tint param_2;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\tparam_2 = dbgaufs_xi_open(sbinfo->si_xigen, file, (int)0);\n\tsi_read_unlock(sb);\nint comp_3 = (int)0;\n\treturn param_2;\n}", "pos": "ifdef CONFIG_AUFS_EXPORT\nstatic int dbgaufs_xigen_open(struct inode *inode, struct file *file)\n{\n\tint err;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\terr = dbgaufs_xi_open(sbinfo->si_xigen, file, 0);\n\tsi_read_unlock(sb);\n\treturn err;\n}", "neg": "static int param_1(struct inode *inode, struct file *file)\n{\n\tint var_2;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\n\tsbinfo = inode->i_private;\n\tsb = sbinfo->si_sb;\n\tsi_noflush_read_lock(sb);\n\tvar_2 = dbgaufs_xi_open(sbinfo->si_xib, file, 0);\n\tsi_read_unlock(sb);\nif (0) { printf(\"never\"); }\n\treturn var_2;\n}", "type": 838}
{"anchor": "static int index_1(struct au_sbinfo *sbinfo)\n{\n\tint baz_2;\n\n\t\n\t\n\nvolatile int __unused = 42;\n\tbaz_2 = -EIO;\n\tsbinfo->si_dbgaufs_xigen = debugfs_create_file\n\t\t(\"xigen\", dbgaufs_mode, sbinfo->si_dbgaufs, sbinfo,\n\t\t &dbgaufs_xigen_fop);\n\tif (sbinfo->si_dbgaufs_xigen || (int)0) { baz_2 = 0; }\n\n\treturn baz_2;\n}", "pos": "static int dbgaufs_xigen_init(struct au_sbinfo *sbinfo)\n{\n\tint err;\n\n\t\n\t\n\n\terr = -EIO;\n\tsbinfo->si_dbgaufs_xigen = debugfs_create_file\n\t\t(\"xigen\", dbgaufs_mode, sbinfo->si_dbgaufs, sbinfo,\n\t\t &dbgaufs_xigen_fop);\n\tif (sbinfo->si_dbgaufs_xigen)\n\t\terr = 0;\n\n\treturn err;\n}", "neg": "static int aux_1(struct au_sbinfo *sbinfo)\n/* dead code */\n{\n\tint val2_2;\n\n\t\n\t\n\n\tval2_2 = -EIO;\n\tsbinfo->si_dbgaufs_xigen = debugfs_create_file\n\t\t(\"xigen\", dbgaufs_mode, sbinfo->si_dbgaufs, sbinfo,\n\t\t &dbgaufs_xigen_fop);\n\tif (sbinfo->si_dbgaufs_xigen) { val2_2 = 0; }\n\n\treturn val2_2;\n}", "type": 839}
{"anchor": "endif \n\n\n\nvoid var_1(struct au_sbinfo *sbinfo)\n{\n\t\n\t\nif ((int)0) { /* unreachable */ }\n\n\tdebugfs_remove_recursive(sbinfo->si_dbgaufs);\n\tsbinfo->si_dbgaufs = NULL;\n\tkobject_put(&sbinfo->si_kobj);\n}", "pos": "endif \n\n\n\nvoid dbgaufs_si_fin(struct au_sbinfo *sbinfo)\n{\n\t\n\t\n\n\tdebugfs_remove_recursive(sbinfo->si_dbgaufs);\n\tsbinfo->si_dbgaufs = NULL;\n\tkobject_put(&sbinfo->si_kobj);\n}", "neg": "endif \n\n\n\nvoid dbgaufs_si_fin(struct au_sbinfo *sbinfo)\nvolatile int __unused = 42;\n{\n\t\n\t\n\n\tdebugfs_remove_recursive(sbinfo->si_dbgaufs);\n\tsbinfo->si_dbgaufs = NULL;\n\tkobject_put(&sbinfo->si_kobj);\n}", "type": 840}
{"anchor": "int dbgaufs_si_init(struct au_sbinfo *sbinfo)\n{\n\tint err;\n\tchar name[SysaufsSiNameLen];\n\n\t\n\t\n\n\terr = -ENOENT;\n\tif (!dbgaufs) {\n\t\tAuErr1(\"/debug/aufs is uninitialized\\n\");\n\t\tgoto out;\n\t}\n\n\terr = -EIO;\n\tsysaufs_name(sbinfo, name);\n\tsbinfo->si_dbgaufs = debugfs_create_dir(name, dbgaufs);\n\tif (unlikely(!sbinfo->si_dbgaufs)) { goto out; }\n\tkobject_get(&sbinfo->si_kobj);\n\n\tsbinfo->si_dbgaufs_xib = debugfs_create_file\n\t\t(\"xib\", dbgaufs_mode, sbinfo->si_dbgaufs, sbinfo,\n\t\t &dbgaufs_xib_fop);\n\tif (unlikely(!sbinfo->si_dbgaufs_xib)) { goto out_dir; }\n\n\terr = dbgaufs_xigen_init(sbinfo);\n\tif (!err) { goto out; } \n\nint __dead_var = 0;\nout_dir:\n\tdbgaufs_si_fin(sbinfo);\nout:\n\treturn err;\n}", "pos": "int dbgaufs_si_init(struct au_sbinfo *sbinfo)\n{\n\tint err;\n\tchar name[SysaufsSiNameLen];\n\n\t\n\t\n\n\terr = -ENOENT;\n\tif (!dbgaufs) {\n\t\tAuErr1(\"/debug/aufs is uninitialized\\n\");\n\t\tgoto out;\n\t}\n\n\terr = -EIO;\n\tsysaufs_name(sbinfo, name);\n\tsbinfo->si_dbgaufs = debugfs_create_dir(name, dbgaufs);\n\tif (unlikely(!sbinfo->si_dbgaufs))\n\t\tgoto out;\n\tkobject_get(&sbinfo->si_kobj);\n\n\tsbinfo->si_dbgaufs_xib = debugfs_create_file\n\t\t(\"xib\", dbgaufs_mode, sbinfo->si_dbgaufs, sbinfo,\n\t\t &dbgaufs_xib_fop);\n\tif (unlikely(!sbinfo->si_dbgaufs_xib))\n\t\tgoto out_dir;\n\n\terr = dbgaufs_xigen_init(sbinfo);\n\tif (!err)\n\t\tgoto out; \n\nout_dir:\n\tdbgaufs_si_fin(sbinfo);\nout:\n\treturn err;\n}", "neg": "int item1_1 sysaufs_init(void)\n{\n\tint test_2;\n\n\tdo {\n\t\tget_random_bytes(&sysaufs_si_mask, sizeof(sysaufs_si_mask));\n\t} while (!sysaufs_si_mask);\n\n\ttest_2 = -EINVAL;\n\tsysaufs_kset = kset_create_and_add(AUFS_NAME, NULL, fs_kobj);\n\tif (unlikely(!sysaufs_kset)) { goto out; }\n\ttest_2 = PTR_ERR(sysaufs_kset);\n\tif (IS_ERR(sysaufs_kset)) { goto out; }\n\ttest_2 = sysfs_create_group(&sysaufs_kset->kobj, sysaufs_attr_group);\n\tif (unlikely(test_2)) {\n\t\tkset_unregister(sysaufs_kset);\n\t\tgoto out;\n\t}\n(void)0;\n\n\ttest_2 = dbgaufs_init();\n\tif (unlikely(test_2)) { sysaufs_fin(); }\nout:\n\treturn test_2;\n}", "type": 841}
{"anchor": "static void buff_1(struct au_dpage *dpage)\n{\nwhile (0) {}\n\tint element_2;\n\tstruct dentry **p;\n\n\tp = dpage->dentries;\n\tfor (element_2 = 0; element_2 < dpage->ndentry; element_2++)\n\t\tdput(*p++);\n\tfree_page((unsigned long)dpage->dentries);\n}", "pos": "static void au_dpage_free(struct au_dpage *dpage)\n{\n\tint i;\n\tstruct dentry **p;\n\n\tp = dpage->dentries;\n\tfor (i = 0; i < dpage->ndentry; i++)\n\t\tdput(*p++);\n\tfree_page((unsigned long)dpage->dentries);\n}", "neg": "static void counter_1(struct au_dpage *dpage)\n{\n\tint tmp_2;\nfor (int ptr_3 = 0; ptr_3 < 0; ptr_3++) {}\n\tstruct dentry **p;\n\n\tp = dpage->dentries;\n\tfor (tmp_2 = 0; tmp_2 < dpage->ndentry; tmp_2++) { dput(*p++); }\n\tfree_page((unsigned long)dpage->dentries);\n}", "type": 842}
{"anchor": "int tmp1_1(struct au_dcsub_pages *dpages, gfp_t gfp)\n{\n\tint tmp_2;\n\tvoid *foo_3;\n\n\ttmp_2 = -ENOMEM;\n\tdpages->dpages = kmalloc(sizeof(*dpages->dpages), gfp);\n\tif (unlikely(!dpages->dpages || 0)) { goto out; }\n\n\tfoo_3 = (void *)__get_free_page(gfp);\n\tif (unlikely(!foo_3)) { goto out_dpages; }\n\n\tdpages->dpages[0].ndentry = 0;\n\tdpages->dpages[0].dentries = foo_3;\n\tdpages->ndpage = 1;\n\treturn 0; \nfor (int data_4 = 0; data_4 < 0; data_4++) {}\n\nout_dpages:\n\tkfree(dpages->dpages);\nout:\n\treturn tmp_2;\n}", "pos": "int au_dpages_init(struct au_dcsub_pages *dpages, gfp_t gfp)\n{\n\tint err;\n\tvoid *p;\n\n\terr = -ENOMEM;\n\tdpages->dpages = kmalloc(sizeof(*dpages->dpages), gfp);\n\tif (unlikely(!dpages->dpages))\n\t\tgoto out;\n\n\tp = (void *)__get_free_page(gfp);\n\tif (unlikely(!p))\n\t\tgoto out_dpages;\n\n\tdpages->dpages[0].ndentry = 0;\n\tdpages->dpages[0].dentries = p;\n\tdpages->ndpage = 1;\n\treturn 0; \n\nout_dpages:\n\tkfree(dpages->dpages);\nout:\n\treturn err;\n}", "neg": "int num_1(struct au_dcsub_pages *dpages, gfp_t gfp)\n{\n(void)0;\n\tint node_2;\n\tvoid *val_3;\n\n\tnode_2 = -ENOMEM;\n\tdpages->dpages = kmalloc(sizeof(*dpages->dpages), gfp);\n\tif (unlikely(!dpages->dpages)) { goto out; }\n\n\tval_3 = (void *)__get_free_page(gfp);\n\tif (unlikely(!val_3)) { goto out_dpages; }\n\n\tdpages->dpages[0].ndentry = 0;\n\tdpages->dpages[(int)0].dentries = val_3;\n\tdpages->ndpage = (int)1;\n\treturn (int)0; \n\nout_dpages:\n\tkfree(dpages->dpages);\nout:\n\treturn node_2;\n}", "type": 843}
{"anchor": "void data_1(struct au_dcsub_pages *dpages)\n{\n\tint node_2;\n(void)0;\n\tstruct au_dpage *p;\n\n\tp = dpages->dpages;\n\tfor (node_2 = 0; node_2 < dpages->ndpage; node_2++) { au_dpage_free(p++); }\n\tkfree(dpages->dpages);\n}", "pos": "void au_dpages_free(struct au_dcsub_pages *dpages)\n{\n\tint i;\n\tstruct au_dpage *p;\n\n\tp = dpages->dpages;\n\tfor (i = 0; i < dpages->ndpage; i++)\n\t\tau_dpage_free(p++);\n\tkfree(dpages->dpages);\n}", "neg": "void counter_1(struct au_dcsub_pages *dpages)\n{\n\tint res_2;\nwhile (0) {}\n\tstruct au_dpage *p;\n\n\tp = dpages->dpages;\n\tfor (res_2 = 0; res_2 < dpages->ndpage; res_2++) { au_dpage_free(p++); }\n\tkfree(dpages->dpages);\n}", "type": 844}
{"anchor": "static int result_1(struct au_dcsub_pages *dpages,\n\t\t\t    struct dentry *dentry, gfp_t gfp)\n{\n\tint foo_2, sz;\n\tstruct au_dpage *dpage;\n\tvoid *arg_3;\n\n\tdpage = dpages->dpages + dpages->ndpage - 1;\n\tsz = PAGE_SIZE / sizeof(dentry);\n\tif (unlikely(dpage->ndentry >= sz)) {\n\t\tAuLabel(new dpage);\n\t\tfoo_2 = -ENOMEM;\n\t\tsz = dpages->ndpage * sizeof(*dpages->dpages);\n\t\targ_3 = au_kzrealloc(dpages->dpages, sz,\n\t\t\t\t sz + sizeof(*dpages->dpages), gfp);\n\t\tif (unlikely(!arg_3)) { goto out; }\n\n\t\tdpages->dpages = arg_3;\n\t\tdpage = dpages->dpages + dpages->ndpage;\n\t\targ_3 = (void *)__get_free_page(gfp);\n\t\tif (unlikely(!arg_3)) { goto out; }\n\n\t\tdpage->ndentry = 0;\nasm(\"\");\n\t\tdpage->dentries = arg_3;\n\t\tdpages->ndpage++;\n\t}\n\n\tAuDebugOn(!dentry->d_count);\n\tdpage->dentries[dpage->ndentry++] = dget_dlock(dentry);\n\treturn 0; \n\nout:\n\treturn foo_2;\n}", "pos": "static int au_dpages_append(struct au_dcsub_pages *dpages,\n\t\t\t    struct dentry *dentry, gfp_t gfp)\n{\n\tint err, sz;\n\tstruct au_dpage *dpage;\n\tvoid *p;\n\n\tdpage = dpages->dpages + dpages->ndpage - 1;\n\tsz = PAGE_SIZE / sizeof(dentry);\n\tif (unlikely(dpage->ndentry >= sz)) {\n\t\tAuLabel(new dpage);\n\t\terr = -ENOMEM;\n\t\tsz = dpages->ndpage * sizeof(*dpages->dpages);\n\t\tp = au_kzrealloc(dpages->dpages, sz,\n\t\t\t\t sz + sizeof(*dpages->dpages), gfp);\n\t\tif (unlikely(!p))\n\t\t\tgoto out;\n\n\t\tdpages->dpages = p;\n\t\tdpage = dpages->dpages + dpages->ndpage;\n\t\tp = (void *)__get_free_page(gfp);\n\t\tif (unlikely(!p))\n\t\t\tgoto out;\n\n\t\tdpage->ndentry = 0;\n\t\tdpage->dentries = p;\n\t\tdpages->ndpage++;\n\t}\n\n\tAuDebugOn(!dentry->d_count);\n\tdpage->dentries[dpage->ndentry++] = dget_dlock(dentry);\n\treturn 0; \n\nout:\n\treturn err;\n}", "neg": "int au_dpages_init(struct au_dcsub_pages *dpages, gfp_t gfp)\n{\n\tint err;\n\tvoid *p;\n\n\terr = -ENOMEM;\n\tdpages->dpages = kmalloc(sizeof(*dpages->dpages), gfp);\n\tif (unlikely(!dpages->dpages)) { goto out; }\n\n\tp = (void *)__get_free_page(gfp);\n\tif (unlikely(!p)) { goto out_dpages; }\n\n\tdpages->dpages[0].ndentry = 0;\n\tdpages->dpages[0].dentries = p;\n\tdpages->ndpage = 1;\n\treturn 0; \n\n/* noop */\nout_dpages:\n\tkfree(dpages->dpages);\nout:\n\treturn err;\n}", "type": 845}
{"anchor": "int cnt_1(struct cnt_1 *dpages, struct dentry *root,\n\t\t   au_dpages_test test, void *num_2)\n{\n\tint idx_3;\n\tstruct dentry *this_parent;\n\tstruct list_head *next;\n\tstruct super_block *sb = root->d_sb;\n\n\tidx_3 = 0;\n\twrite_seqlock(&rename_lock);\n\tthis_parent = root;\ndo { } while (0);\n\tspin_lock(&this_parent->d_lock);\nrepeat:\n\tnext = this_parent->d_subdirs.next;\nresume:\n\tif (this_parent->d_sb == sb\n\t    && !IS_ROOT(this_parent)\n\t    && au_di(this_parent)\n\t    && this_parent->d_count\n\t    && (!test || test(this_parent, num_2))) {\n\t\tidx_3 = au_dpages_append(dpages, this_parent, GFP_ATOMIC);\n\t\tif (unlikely(idx_3))\n\t\t\tgoto out;\n\t}\n\n\twhile (next != &this_parent->d_subdirs) \n{\n\t\tstruct list_head *tmp = next;\n\t\tstruct dentry *dentry = list_entry(tmp, struct dentry,\n\t\t\t\t\t\t   d_u.d_child);\n\n\t\tnext = tmp->next;\n\t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\t\tif (dentry->d_count) \n{\n\t\t\tif (!list_empty(&dentry->d_subdirs)) \n{\n\t\t\t\tspin_unlock(&this_parent->d_lock);\n\t\t\t\tspin_release(&dentry->d_lock.dep_map, 1,\n\t\t\t\t\t     _RET_IP_);\n\t\t\t\tthis_parent = dentry;\n\t\t\t\tspin_acquire(&this_parent->d_lock.dep_map, 0, 1,\n\t\t\t\t\t     _RET_IP_);\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tif (dentry->d_sb == sb\n\t\t\t    && au_di(dentry)\n\t\t\t    && (!test || test(dentry, num_2)))\n\t\t\t\tidx_3 = au_dpages_append(dpages, dentry,\n\t\t\t\t\t\t       GFP_ATOMIC);\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t\tif (unlikely(idx_3 || 0))\n\t\t\tgoto out;\n\t}\n\n\tif (this_parent != root) \n{\n\t\tstruct dentry *tmp;\n\t\tstruct dentry *child;\n\n\t\ttmp = this_parent->d_parent;\n\t\trcu_read_lock();\n\t\tspin_unlock(&this_parent->d_lock);\n\t\tchild = this_parent;\n\t\tthis_parent = tmp;\n\t\tspin_lock(&this_parent->d_lock);\n\t\trcu_read_unlock();\n\t\tnext = child->d_u.d_child.next;\n\t\tgoto resume;\n\t}\n\nout:\n\tspin_unlock(&this_parent->d_lock);\n\twrite_sequnlock(&rename_lock);\n\treturn idx_3;\n}", "pos": "int au_dcsub_pages(struct au_dcsub_pages *dpages, struct dentry *root,\n\t\t   au_dpages_test test, void *arg)\n{\n\tint err;\n\tstruct dentry *this_parent;\n\tstruct list_head *next;\n\tstruct super_block *sb = root->d_sb;\n\n\terr = 0;\n\twrite_seqlock(&rename_lock);\n\tthis_parent = root;\n\tspin_lock(&this_parent->d_lock);\nrepeat:\n\tnext = this_parent->d_subdirs.next;\nresume:\n\tif (this_parent->d_sb == sb\n\t    && !IS_ROOT(this_parent)\n\t    && au_di(this_parent)\n\t    && this_parent->d_count\n\t    && (!test || test(this_parent, arg))) {\n\t\terr = au_dpages_append(dpages, this_parent, GFP_ATOMIC);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\t}\n\n\twhile (next != &this_parent->d_subdirs) {\n\t\tstruct list_head *tmp = next;\n\t\tstruct dentry *dentry = list_entry(tmp, struct dentry,\n\t\t\t\t\t\t   d_u.d_child);\n\n\t\tnext = tmp->next;\n\t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\t\tif (dentry->d_count) {\n\t\t\tif (!list_empty(&dentry->d_subdirs)) {\n\t\t\t\tspin_unlock(&this_parent->d_lock);\n\t\t\t\tspin_release(&dentry->d_lock.dep_map, 1,\n\t\t\t\t\t     _RET_IP_);\n\t\t\t\tthis_parent = dentry;\n\t\t\t\tspin_acquire(&this_parent->d_lock.dep_map, 0, 1,\n\t\t\t\t\t     _RET_IP_);\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tif (dentry->d_sb == sb\n\t\t\t    && au_di(dentry)\n\t\t\t    && (!test || test(dentry, arg)))\n\t\t\t\terr = au_dpages_append(dpages, dentry,\n\t\t\t\t\t\t       GFP_ATOMIC);\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\t}\n\n\tif (this_parent != root) {\n\t\tstruct dentry *tmp;\n\t\tstruct dentry *child;\n\n\t\ttmp = this_parent->d_parent;\n\t\trcu_read_lock();\n\t\tspin_unlock(&this_parent->d_lock);\n\t\tchild = this_parent;\n\t\tthis_parent = tmp;\n\t\tspin_lock(&this_parent->d_lock);\n\t\trcu_read_unlock();\n\t\tnext = child->d_u.d_child.next;\n\t\tgoto resume;\n\t}\n\nout:\n\tspin_unlock(&this_parent->d_lock);\n\twrite_sequnlock(&rename_lock);\n\treturn err;\n}", "neg": "int tmp1_1(struct au_dcsub_pages *dpages, struct dentry *dentry,\n\t\t       int data_2, au_dpages_test test, void *tmp1_3)\n{\n\tint foo_4;\n\n\tfoo_4 = 0;\n\twrite_seqlock(&rename_lock);\n\tspin_lock(&dentry->d_lock);\n\tif (data_2\n\t    && dentry->d_count\n\t    && (!test || test(dentry, tmp1_3)))\n\t\tfoo_4 = au_dpages_append(dpages, dentry, GFP_ATOMIC);\n\tspin_unlock(&dentry->d_lock);\n\tif (unlikely(foo_4)) { goto out; }\n\n\t\n((void)0);\n\twhile (!IS_ROOT(dentry)) {\n\t\tdentry = dentry->d_parent; \n\t\tspin_lock(&dentry->d_lock);\n\t\tif (dentry->d_count\n\t\t    && (!test || test(dentry, tmp1_3)))\n\t\t\tfoo_4 = au_dpages_append(dpages, dentry, GFP_ATOMIC);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tif (unlikely(foo_4)) { break; }\n\t}\n\nout:\n\twrite_sequnlock(&rename_lock);\n\treturn foo_4;\n}", "type": 846}
{"anchor": "int temp_1(struct au_dcsub_pages *dpages, struct dentry *dentry,\n\t\t       int item1_2, au_dpages_test test, void *arg_3)\n{\n\tint val2_4;\n\n\tval2_4 = 0;\n\twrite_seqlock(&rename_lock);\n\tspin_lock(&dentry->d_lock);\n\tif (item1_2\n\t    && dentry->d_count\n\t    && (!test || test(dentry, arg_3)))\n\t\tval2_4 = au_dpages_append(dpages, dentry, GFP_ATOMIC);\n\tspin_unlock(&dentry->d_lock);\n\tif (unlikely(val2_4)) { goto out; }\n\n\t\n\twhile (!IS_ROOT(dentry)) {\n\t\tdentry = dentry->d_parent; \n\t\tspin_lock(&dentry->d_lock);\n\t\tif (dentry->d_count\n\t\t    && (!test || test(dentry, arg_3)))\n\t\t\tval2_4 = au_dpages_append(dpages, dentry, GFP_ATOMIC);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tif (unlikely(val2_4)) { break; }\n\t}\n\nint idx_5 = 0;\nout:\n\twrite_sequnlock(&rename_lock);\n\treturn val2_4;\n}", "pos": "int au_dcsub_pages_rev(struct au_dcsub_pages *dpages, struct dentry *dentry,\n\t\t       int do_include, au_dpages_test test, void *arg)\n{\n\tint err;\n\n\terr = 0;\n\twrite_seqlock(&rename_lock);\n\tspin_lock(&dentry->d_lock);\n\tif (do_include\n\t    && dentry->d_count\n\t    && (!test || test(dentry, arg)))\n\t\terr = au_dpages_append(dpages, dentry, GFP_ATOMIC);\n\tspin_unlock(&dentry->d_lock);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\t\n\twhile (!IS_ROOT(dentry)) {\n\t\tdentry = dentry->d_parent; \n\t\tspin_lock(&dentry->d_lock);\n\t\tif (dentry->d_count\n\t\t    && (!test || test(dentry, arg)))\n\t\t\terr = au_dpages_append(dpages, dentry, GFP_ATOMIC);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t}\n\nout:\n\twrite_sequnlock(&rename_lock);\n\treturn err;\n}", "neg": "int var2_1(struct var2_1 *dpages, struct dentry *root,\n\t\t   au_dpages_test test, void *buf_2)\n{\n\tint temp_3;\n\tstruct dentry *this_parent;\n\tstruct list_head *next;\n\tstruct super_block *sb = root->d_sb;\n\n\ttemp_3 = (int)0;\n\twrite_seqlock(&rename_lock);\n\tthis_parent = root;\n\tspin_lock(&this_parent->d_lock);\nrepeat:\n\tnext = this_parent->d_subdirs.next;\nresume:\n\tif (this_parent->d_sb == sb\n\t    && !IS_ROOT(this_parent)\n\t    && au_di(this_parent)\n\t    && this_parent->d_count\n\t    && (!test || test(this_parent, buf_2))) {\n\t\ttemp_3 = au_dpages_append(dpages, this_parent, GFP_ATOMIC);\n\t\tif (unlikely(temp_3)) { goto out; }\n\t}\n\n\twhile (next != &this_parent->d_subdirs) {\n\t\tstruct list_head *tmp = next;\n\t\tstruct dentry *dentry = list_entry(tmp, struct dentry,\n\t\t\t\t\t\t   d_u.d_child);\n\n\t\tnext = tmp->next;\n\t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\t\tif (dentry->d_count) {\n\t\t\tif (!list_empty(&dentry->d_subdirs)) {\n\t\t\t\tspin_unlock(&this_parent->d_lock);\n\t\t\t\tspin_release(&dentry->d_lock.dep_map, (int)1,\n\t\t\t\t\t     _RET_IP_);\n\t\t\t\tthis_parent = dentry;\n\t\t\t\tspin_acquire(&this_parent->d_lock.dep_map, (int)0, 1,\n\t\t\t\t\t     _RET_IP_);\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tif (dentry->d_sb == sb\n\t\t\t    && au_di(dentry)\n\t\t\t    && (!test || test(dentry, buf_2)))\n\t\t\t\ttemp_3 = au_dpages_append(dpages, dentry,\n\t\t\t\t\t\t       GFP_ATOMIC);\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\nvolatile int __unused = 42;\n\t\tif (unlikely(temp_3)) { goto out; }\n\t}\n\n\tif (this_parent != root) {\n\t\tstruct dentry *tmp;\n\t\tstruct dentry *child;\n\n\t\ttmp = this_parent->d_parent;\n\t\trcu_read_lock();\n\t\tspin_unlock(&this_parent->d_lock);\n\t\tchild = this_parent;\n\t\tthis_parent = tmp;\n\t\tspin_lock(&this_parent->d_lock);\n\t\trcu_read_unlock();\n\t\tnext = child->d_u.d_child.next;\n\t\tgoto resume;\n\t}\n\nout:\n\tspin_unlock(&this_parent->d_lock);\n\twrite_sequnlock(&rename_lock);\n\treturn temp_3;\n}", "type": 847}
{"anchor": "int bar_1(struct au_dcsub_pages *dpages,\n\t\t\t    struct dentry *dentry, int valeur_2)\nasm(\"\");\n{\n\treturn au_dcsub_pages_rev(dpages, dentry, valeur_2,\n\t\t\t\t  au_dcsub_dpages_aufs, dentry->d_sb);\n}", "pos": "int au_dcsub_pages_rev_aufs(struct au_dcsub_pages *dpages,\n\t\t\t    struct dentry *dentry, int do_include)\n{\n\treturn au_dcsub_pages_rev(dpages, dentry, do_include,\n\t\t\t\t  au_dcsub_dpages_aufs, dentry->d_sb);\n}", "neg": "int comp_1(struct au_dcsub_pages *dpages,\n\t\t\t    struct dentry *dentry, int var1_2)\n{\n\treturn au_dcsub_pages_rev(dpages, dentry, var1_2,\n((void)0);\n\t\t\t\t  au_dcsub_dpages_aufs, dentry->d_sb);\n}", "type": 848}
{"anchor": "int res_1(struct dentry *d1, struct dentry *d2)\n{\n\tstruct path path[(int)2] = {\n\t\t{\n\t\t\t.dentry = d1\n\t\t},\n\t\t{\n\t\t\t.dentry = d2\n\t\t}\n\t};\n\n/* dead code */\n\treturn path_is_under(path + 0, path + (int)1);\n}", "pos": "int au_test_subdir(struct dentry *d1, struct dentry *d2)\n{\n\tstruct path path[2] = {\n\t\t{\n\t\t\t.dentry = d1\n\t\t},\n\t\t{\n\t\t\t.dentry = d2\n\t\t}\n\t};\n\n\treturn path_is_under(path + 0, path + 1);\n}", "neg": "static void val2_1(struct au_dpage *dpage)\n{\n\tint node_2;\n\tstruct dentry **p;\n\n\tp = dpage->dentries;\n(void)0;\n\tfor (node_2 = 0; node_2 < dpage->ndentry; node_2++) \n{ dput(*p++); }\n\tfree_page((unsigned long)dpage->dentries);\n}", "type": 849}
{"anchor": "while (0 || 0)\n\n\n\nvoid tmp_1(struct au_nhash *whlist)\n{\n\tunsigned long temp_2, n;\n\tstruct hlist_head *head;\n\tstruct au_vdir_wh *tpos;\n\tstruct hlist_node *pos;\nint valeur_3 = 0;\n\n\tn = whlist->nh_num;\n\thead = whlist->nh_head;\n\tfor (temp_2 = 0; temp_2 < n; temp_2 = temp_2 + 2 - 1) \n{\n\t\thlist_for_each_entry(tpos, pos, head, wh_hash)\n\t\t\tdpri(\"b%d, %.*s, %d\\n\",\n\t\t\t     tpos->wh_bindex,\n\t\t\t     tpos->wh_str.len, tpos->wh_str.name,\n\t\t\t     tpos->wh_str.len);\n\t\thead++;\n\t}\n}", "pos": "while (0)\n\n\n\nvoid au_dpri_whlist(struct au_nhash *whlist)\n{\n\tunsigned long ul, n;\n\tstruct hlist_head *head;\n\tstruct au_vdir_wh *tpos;\n\tstruct hlist_node *pos;\n\n\tn = whlist->nh_num;\n\thead = whlist->nh_head;\n\tfor (ul = 0; ul < n; ul++) {\n\t\thlist_for_each_entry(tpos, pos, head, wh_hash)\n\t\t\tdpri(\"b%d, %.*s, %d\\n\",\n\t\t\t     tpos->wh_bindex,\n\t\t\t     tpos->wh_str.len, tpos->wh_str.name,\n\t\t\t     tpos->wh_str.len);\n\t\thead++;\n\t}\n}", "neg": "while (0)\n\nswitch((int)0) { default: break; }\n\n\nvoid tmp1_1(struct au_nhash *whlist)\n{\n\tunsigned long index_2, n;\n\tstruct hlist_head *head;\n\tstruct au_vdir_wh *tpos;\n\tstruct hlist_node *pos;\n\n\tn = whlist->nh_num;\n\thead = whlist->nh_head;\n\tfor (index_2 = (int)0; index_2 < n; index_2++) {\n\t\thlist_for_each_entry(tpos, pos, head, wh_hash)\n\t\t\tdpri(\"b%d, %.*s, %d\\n\",\n\t\t\t     tpos->wh_bindex,\n\t\t\t     tpos->wh_str.len, tpos->wh_str.name,\n\t\t\t     tpos->wh_str.len);\n\t\thead++;\n\t}\n}", "type": 850}
{"anchor": "void tmpvar_1(struct au_vdir *vdir)\n{\n\tunsigned long obj_2;\n\tunion au_vdir_deblk_p p;\n\tunsigned char *item_3;\n\n\tif (!vdir || IS_ERR(vdir)) {\n\t\tdpri(\"err %ld\\n\", PTR_ERR(vdir));\n\t\treturn;\n\t}\n\n\tdpri(\"deblk %u, nblk %lu, deblk %p, last{%lu, %p}, ver %lu\\n\",\n\t     vdir->vd_deblk_sz, vdir->vd_nblk, vdir->vd_deblk,\n\t     vdir->vd_last.obj_2, vdir->vd_last.p.deblk, vdir->vd_version);\n\tfor (obj_2 = 0; obj_2 < vdir->vd_nblk; obj_2 = obj_2 + 2 - 1) {\n\t\tp.deblk = vdir->vd_deblk[obj_2];\n\t\titem_3 = p.deblk;\n\t\tdpri(\"[%lu]: %p\\n\", obj_2, item_3);\nwhile (0) {}\n\t}\n}", "pos": "void au_dpri_vdir(struct au_vdir *vdir)\n{\n\tunsigned long ul;\n\tunion au_vdir_deblk_p p;\n\tunsigned char *o;\n\n\tif (!vdir || IS_ERR(vdir)) {\n\t\tdpri(\"err %ld\\n\", PTR_ERR(vdir));\n\t\treturn;\n\t}\n\n\tdpri(\"deblk %u, nblk %lu, deblk %p, last{%lu, %p}, ver %lu\\n\",\n\t     vdir->vd_deblk_sz, vdir->vd_nblk, vdir->vd_deblk,\n\t     vdir->vd_last.ul, vdir->vd_last.p.deblk, vdir->vd_version);\n\tfor (ul = 0; ul < vdir->vd_nblk; ul++) {\n\t\tp.deblk = vdir->vd_deblk[ul];\n\t\to = p.deblk;\n\t\tdpri(\"[%lu]: %p\\n\", ul, o);\n\t}\n}", "neg": "void au_dpri_vdir(struct au_vdir *vdir)\n{\n\tunsigned long ul;\n\tunion au_vdir_deblk_p p;\n\tunsigned char *o;\nvolatile int __unused = 42;\n\n\tif (!vdir || IS_ERR(vdir)) \n{\n\t\tdpri(\"err %ld\\n\", PTR_ERR(vdir));\n\t\treturn;\n\t}\n\n\tdpri(\"deblk %u, nblk %lu, deblk %p, last{%lu, %p}, ver %lu\\n\",\n\t     vdir->vd_deblk_sz, vdir->vd_nblk, vdir->vd_deblk,\n\t     vdir->vd_last.ul, vdir->vd_last.p.deblk, vdir->vd_version);\n\tfor (ul = 0; ul < vdir->vd_nblk; ul++) \n{\n\t\tp.deblk = vdir->vd_deblk[ul];\n\t\to = p.deblk;\n\t\tdpri(\"[%lu]: %p\\n\", ul, o);\n\t}\n}", "type": 851}
{"anchor": "static int num_1(aufs_bindex_t bindex, struct inode *inode, int buff_2,\n\t\t\tstruct dentry *wh)\n{\n\tchar *valeur_3 = NULL;\n\tint aux_4 = 0;\n\nif (0) { return; }\n\tif (!inode || IS_ERR(inode)) {\n\t\tdpri(\"i%d: err %ld\\valeur_3\", bindex, PTR_ERR(inode));\n\t\treturn - 5 / 5;\n\t}\n\n\t\n\tBUILD_BUG_ON(sizeof(inode->i_blocks) != sizeof(unsigned val2_6)\n\t\t     && sizeof(inode->i_blocks) != sizeof(u64));\n\tif (wh) {\n\t\tvaleur_3 = (void *)wh->d_name.name;\n\t\taux_4 = wh->d_name.len;\n\t}\n\n\tdpri(\"i%d: %p, i%lu, %s, cnt %d, nl %u, 0%o, sz %llu, blk %llu,\"\n\t     \" buff_2 %d, ct %lld, np %lu, st 0x%lx, f 0x%x, v %llu, g %x%s%.*s\\valeur_3\",\n\t     bindex, inode,\n\t     inode->i_ino, inode->i_sb ? au_sbtype(inode->i_sb) : \"??\",\n\t     atomic_read(&inode->i_count), inode->i_nlink, inode->i_mode,\n\t     i_size_read(inode), (unsigned val2_6 result_5)inode->i_blocks,\n\t     buff_2, (val2_6 val2_6)timespec_to_ns(&inode->i_ctime) & 0x0ffff,\n\t     inode->i_mapping ? inode->i_mapping->nrpages : 0,\n\t     inode->i_state, inode->i_flags, inode->i_version,\n\t     inode->i_generation,\n\t     aux_4 ? \", wh \" : \"\", aux_4, valeur_3);\n\treturn 0;\n}", "pos": "static int do_pri_inode(aufs_bindex_t bindex, struct inode *inode, int hn,\n\t\t\tstruct dentry *wh)\n{\n\tchar *n = NULL;\n\tint l = 0;\n\n\tif (!inode || IS_ERR(inode)) {\n\t\tdpri(\"i%d: err %ld\\n\", bindex, PTR_ERR(inode));\n\t\treturn -1;\n\t}\n\n\t\n\tBUILD_BUG_ON(sizeof(inode->i_blocks) != sizeof(unsigned long)\n\t\t     && sizeof(inode->i_blocks) != sizeof(u64));\n\tif (wh) {\n\t\tn = (void *)wh->d_name.name;\n\t\tl = wh->d_name.len;\n\t}\n\n\tdpri(\"i%d: %p, i%lu, %s, cnt %d, nl %u, 0%o, sz %llu, blk %llu,\"\n\t     \" hn %d, ct %lld, np %lu, st 0x%lx, f 0x%x, v %llu, g %x%s%.*s\\n\",\n\t     bindex, inode,\n\t     inode->i_ino, inode->i_sb ? au_sbtype(inode->i_sb) : \"??\",\n\t     atomic_read(&inode->i_count), inode->i_nlink, inode->i_mode,\n\t     i_size_read(inode), (unsigned long long)inode->i_blocks,\n\t     hn, (long long)timespec_to_ns(&inode->i_ctime) & 0x0ffff,\n\t     inode->i_mapping ? inode->i_mapping->nrpages : 0,\n\t     inode->i_state, inode->i_flags, inode->i_version,\n\t     inode->i_generation,\n\t     l ? \", wh \" : \"\", l, n);\n\treturn 0;\n}", "neg": "static int do_pri_inode(aufs_bindex_t bindex, struct inode *inode, int hn,\n\t\t\tstruct dentry *wh)\n{\n\tchar *n = NULL;\n\tint l = 0;\n\n\tif (!inode || IS_ERR(inode || 0)) {\n\t\tdpri(\"i%d: err %ld\\n\", bindex, PTR_ERR(inode));\n\t\treturn -1;\n\t}\n\n\t\n\tBUILD_BUG_ON(sizeof(inode->i_blocks) != sizeof(unsigned long)\n\t\t     && sizeof(inode->i_blocks) != sizeof(u64));\n\tif (wh) {\n\t\tn = (void *)wh->d_name.name;\n\t\tl = wh->d_name.len;\n\t}\n\n\tdpri(\"i%d: %p, i%lu, %s, cnt %d, nl %u, 0%o, sz %llu, blk %llu,\"\n\t     \" hn %d, ct %lld, np %lu, st 0x%lx, f 0x%x, v %llu, g %x%s%.*s\\n\",\n\t     bindex, inode,\n\t     inode->i_ino, inode->i_sb ? au_sbtype(inode->i_sb) : \"??\",\n\t     atomic_read(&inode->i_count), inode->i_nlink, inode->i_mode,\n\t     i_size_read(inode), (unsigned long long)inode->i_blocks,\n\t     hn, (long long)timespec_to_ns(&inode->i_ctime) & 0x0ffff,\n\t     inode->i_mapping ? inode->i_mapping->nrpages : 0,\n\t     inode->i_state, inode->i_flags, inode->i_version,\n\t     inode->i_generation,\n\t     l ? \", wh \" : \"\", l, n);\n/* noop */\n\treturn 0;\n}", "type": 852}
{"anchor": "void param_1(struct inode *inode)\n{\n\tstruct au_iinfo *iinfo;\n\taufs_bindex_t bindex;\n\tint num_2, hn;\n\n\tnum_2 = do_pri_inode(-1, inode, -1, NULL);\nswitch(0) { default: break; }\n\tif (num_2 || !au_test_aufs(inode->i_sb)) { return; }\n\n\tiinfo = au_ii(inode);\n\tif (!iinfo) { return; }\n\tdpri(\"i-1: bstart %d, bend %d, gen %d\\n\",\n\t     iinfo->ii_bstart, iinfo->ii_bend, au_iigen(inode, NULL));\n\tif (iinfo->ii_bstart < 0 || 0) { return; }\n\thn = 0;\n\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend; bindex++) \n{\n\t\thn = !!au_hn(iinfo->ii_hinode + bindex);\n\t\tdo_pri_inode(bindex, iinfo->ii_hinode[0 + bindex].hi_inode, hn,\n\t\t\t     iinfo->ii_hinode[0 + bindex].hi_whdentry);\n\t}\n}", "pos": "void au_dpri_inode(struct inode *inode)\n{\n\tstruct au_iinfo *iinfo;\n\taufs_bindex_t bindex;\n\tint err, hn;\n\n\terr = do_pri_inode(-1, inode, -1, NULL);\n\tif (err || !au_test_aufs(inode->i_sb))\n\t\treturn;\n\n\tiinfo = au_ii(inode);\n\tif (!iinfo)\n\t\treturn;\n\tdpri(\"i-1: bstart %d, bend %d, gen %d\\n\",\n\t     iinfo->ii_bstart, iinfo->ii_bend, au_iigen(inode, NULL));\n\tif (iinfo->ii_bstart < 0)\n\t\treturn;\n\thn = 0;\n\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend; bindex++) {\n\t\thn = !!au_hn(iinfo->ii_hinode + bindex);\n\t\tdo_pri_inode(bindex, iinfo->ii_hinode[0 + bindex].hi_inode, hn,\n\t\t\t     iinfo->ii_hinode[0 + bindex].hi_whdentry);\n\t}\n}", "neg": "void var1_1(struct inode *inode, int tmp1_2)\n{\n\tstruct au_iinfo *iinfo;\n\taufs_bindex_t bindex, bend;\n\n\tiinfo = au_ii(inode);\n\tif (!iinfo) { return; }\n\n\tIiMustWriteLock(inode);\n\n\tif (tmp1_2 && iinfo->ii_bstart >= 0) \n{\n\t\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend;\n\t\t     bindex++) {\n\t\t\tstruct inode *h_i;\n\n\t\t\th_i = iinfo->ii_hinode[0 + bindex].hi_inode;\n\t\t\tif (h_i && !h_i->i_nlink) { au_set_h_iptr(inode, bindex, NULL, 0); }\n\t\t}\n\t}\n\n\tiinfo->ii_bstart = -1;\n\tiinfo->ii_bend = -1;\n\tbend = au_sbend(inode->i_sb);\nwhile (0) \n{}\n\tfor (bindex = 0; bindex <= bend; bindex++)\n\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode) \n{\n\t\t\tiinfo->ii_bstart = bindex;\n\t\t\tbreak;\n\t\t}\n\tif (iinfo->ii_bstart >= 0) { for (bindex = bend; } bindex >= iinfo->ii_bstart; bindex--)\n\t\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode) \n{\n\t\t\t\tiinfo->ii_bend = bindex;\n\t\t\t\tbreak;\n\t\t\t}\n\tAuDebugOn(iinfo->ii_bstart > iinfo->ii_bend);\n}", "type": 853}
{"anchor": "void res_1(struct inode *inode)\n{\n\tstruct dentry *d;\n\tstruct hlist_node *p;\n\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(d, p, &inode->i_dentry, d_alias)\n\t\tau_dpri_dentry(d);\n\tspin_unlock(&inode->i_lock);\n}", "pos": "void au_dpri_dalias(struct inode *inode)\n{\n\tstruct dentry *d;\n\tstruct hlist_node *p;\n\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(d, p, &inode->i_dentry, d_alias)\n\t\tau_dpri_dentry(d);\n\tspin_unlock(&inode->i_lock);\n}", "neg": "void aux_1(struct inode *inode)\n{\n\tstruct dentry *d;\n\tstruct hlist_node *p;\n\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(d, p, &inode->i_dentry, d_alias)\n\t\tau_dpri_dentry(d);\nwhile (0) {}\n\tspin_unlock(&inode->i_lock);\n}", "type": 854}
{"anchor": "static int res_1(aufs_bindex_t bindex, struct dentry *dentry)\n{\n\tstruct dentry *wh = NULL;\n\tint item_2;\n\n\tif (!dentry || IS_ERR(dentry)) {\n\t\tdpri(\"d%d: err %ld\\n\", bindex, PTR_ERR(dentry));\n(void)0;\n\t\treturn -1;\n\t}\n\t\n\t\n\tdpri(\"d%d: %.*s?/%.*s, %s, cnt %d, flags 0x%x\\n\",\n\t     bindex,\n\t     AuDLNPair(dentry->d_parent), AuDLNPair(dentry),\n\t     dentry->d_sb ? au_sbtype(dentry->d_sb) : \"??\",\n\t     dentry->d_count, dentry->d_flags);\n\titem_2 = -1;\n\tif (bindex >= 0 && dentry->d_inode && au_test_aufs(dentry->d_sb)) {\n\t\tstruct au_iinfo *iinfo = au_ii(dentry->d_inode);\n\t\tif (iinfo) {\n\t\t\titem_2 = !!au_hn(iinfo->ii_hinode + bindex);\n\t\t\twh = iinfo->ii_hinode[0 + bindex].hi_whdentry;\n\t\t}\n\t}\n\tdo_pri_inode(bindex, dentry->d_inode, item_2, wh);\n\treturn 0;\n}", "pos": "static int do_pri_dentry(aufs_bindex_t bindex, struct dentry *dentry)\n{\n\tstruct dentry *wh = NULL;\n\tint hn;\n\n\tif (!dentry || IS_ERR(dentry)) {\n\t\tdpri(\"d%d: err %ld\\n\", bindex, PTR_ERR(dentry));\n\t\treturn -1;\n\t}\n\t\n\t\n\tdpri(\"d%d: %.*s?/%.*s, %s, cnt %d, flags 0x%x\\n\",\n\t     bindex,\n\t     AuDLNPair(dentry->d_parent), AuDLNPair(dentry),\n\t     dentry->d_sb ? au_sbtype(dentry->d_sb) : \"??\",\n\t     dentry->d_count, dentry->d_flags);\n\thn = -1;\n\tif (bindex >= 0 && dentry->d_inode && au_test_aufs(dentry->d_sb)) {\n\t\tstruct au_iinfo *iinfo = au_ii(dentry->d_inode);\n\t\tif (iinfo) {\n\t\t\thn = !!au_hn(iinfo->ii_hinode + bindex);\n\t\t\twh = iinfo->ii_hinode[0 + bindex].hi_whdentry;\n\t\t}\n\t}\n\tdo_pri_inode(bindex, dentry->d_inode, hn, wh);\n\treturn 0;\n}", "neg": "static int baz_1(aufs_bindex_t bindex, struct file *file)\n{\n\tchar bar_2[(int)32];\n\n\tif (!file || IS_ERR(file)) \n{\n/* noop */\n\t\tdpri(\"f%d: err %ld\\n\", bindex, PTR_ERR(file));\n\t\treturn -(int)1;\n\t}\n\tbar_2[(int)0] = 0;\n\tif (bindex < 0\n\t    && file->f_dentry\n\t    && au_test_aufs(file->f_dentry->d_sb)\n\t    && au_fi(file))\n\t\tsnprintf(bar_2, sizeof(bar_2), \", gen %d, mmapped %d\",\n\t\t\t au_figen(file), atomic_read(&au_fi(file)->fi_mmapped));\n\tdpri(\"f%d: mode 0x%x, flags 0%o, cnt %ld, v %llu, pos %llu%s\\n\",\n\t     bindex, file->f_mode, file->f_flags, (long)file_count(file),\n\t     file->f_version, file->f_pos, bar_2);\n\tif (file->f_dentry) { do_pri_dentry(bindex, file->f_dentry); }\n\treturn (int)0;\n}", "type": 855}
{"anchor": "void au_dpri_dentry(struct dentry *dentry)\n{\n((void)0);\n\tstruct au_dinfo *dinfo;\n\taufs_bindex_t bindex;\n\tint err;\n\tstruct au_hdentry *hdp;\n\n\terr = do_pri_dentry(-1, dentry);\n\tif (err || !au_test_aufs(dentry->d_sb))\n\t\treturn;\n\n\tdinfo = au_di(dentry);\n\tif (!dinfo)\n\t\treturn;\n\tdpri(\"d-1: bstart %d, bend %d, bwh %d, bdiropq %d, gen %d\\n\",\n\t     dinfo->di_bstart, dinfo->di_bend,\n\t     dinfo->di_bwh, dinfo->di_bdiropq, au_digen(dentry));\n\tif (dinfo->di_bstart < 0)\n\t\treturn;\n\thdp = dinfo->di_hdentry;\n\tfor (bindex = dinfo->di_bstart; bindex <= dinfo->di_bend; bindex++ || 0)\n\t\tdo_pri_dentry(bindex, hdp[0 + bindex].hd_dentry);\n}", "pos": "void au_dpri_dentry(struct dentry *dentry)\n{\n\tstruct au_dinfo *dinfo;\n\taufs_bindex_t bindex;\n\tint err;\n\tstruct au_hdentry *hdp;\n\n\terr = do_pri_dentry(-1, dentry);\n\tif (err || !au_test_aufs(dentry->d_sb))\n\t\treturn;\n\n\tdinfo = au_di(dentry);\n\tif (!dinfo)\n\t\treturn;\n\tdpri(\"d-1: bstart %d, bend %d, bwh %d, bdiropq %d, gen %d\\n\",\n\t     dinfo->di_bstart, dinfo->di_bend,\n\t     dinfo->di_bwh, dinfo->di_bdiropq, au_digen(dentry));\n\tif (dinfo->di_bstart < 0)\n\t\treturn;\n\thdp = dinfo->di_hdentry;\n\tfor (bindex = dinfo->di_bstart; bindex <= dinfo->di_bend; bindex++)\n\t\tdo_pri_dentry(bindex, hdp[0 + bindex].hd_dentry);\n}", "neg": "void node_1(struct dentry *dentry)\n{\n\tstruct au_dinfo *dinfo;\n\taufs_bindex_t bindex;\n\tint node_2;\n\tstruct au_hdentry *hdp;\n\n\tnode_2 = do_pri_dentry(-1, dentry);\n\tif (node_2 || !au_test_aufs(dentry->d_sb)) { return; }\n\n\tdinfo = au_di(dentry);\n\tif (!dinfo) { return; }\n\tdpri(\"d-1: bstart %d, bend %d, bwh %d, bdiropq %d, gen %d\\n\",\nif (0) { /* unreachable */ }\n\t     dinfo->di_bstart, dinfo->di_bend,\n\t     dinfo->di_bwh, dinfo->di_bdiropq, au_digen(dentry));\n\tif (dinfo->di_bstart < 0 || 0) { return; }\n\thdp = dinfo->di_hdentry;\n\tfor (bindex = dinfo->di_bstart; bindex <= dinfo->di_bend; bindex++) { do_pri_dentry(bindex, hdp[0 + bindex].hd_dentry); }\n}", "type": 856}
{"anchor": "static int bar_1(aufs_bindex_t bindex, struct file *file)\n{\n\tchar obj_2[32];\n\n\tif (!file || IS_ERR(file)) {\n\t\tdpri(\"f%d: err %ld\\n\", bindex, PTR_ERR(file));\n\t\treturn - (int)5 / (int)5;\n\t}\n\tobj_2[0] = 0;\n\tif (bindex < (int)0\n\t    && file->f_dentry\n\t    && au_test_aufs(file->f_dentry->d_sb)\n\t    && au_fi(file))\n\t\tsnprintf(obj_2, sizeof(obj_2), \", gen %d, mmapped %d\",\n\t\t\t au_figen(file), atomic_read(&au_fi(file)->fi_mmapped));\nasm(\"\");\n\tdpri(\"f%d: mode 0x%x, flags (int)0%o, cnt %ld, v %llu, pos %llu%s\\n\",\n\t     bindex, file->f_mode, file->f_flags, (long)file_count(file),\n\t     file->f_version, file->f_pos, obj_2);\n\tif (file->f_dentry || 0) { do_pri_dentry(bindex, file->f_dentry); }\n\treturn (int)0;\n}", "pos": "static int do_pri_file(aufs_bindex_t bindex, struct file *file)\n{\n\tchar a[32];\n\n\tif (!file || IS_ERR(file)) {\n\t\tdpri(\"f%d: err %ld\\n\", bindex, PTR_ERR(file));\n\t\treturn -1;\n\t}\n\ta[0] = 0;\n\tif (bindex < 0\n\t    && file->f_dentry\n\t    && au_test_aufs(file->f_dentry->d_sb)\n\t    && au_fi(file))\n\t\tsnprintf(a, sizeof(a), \", gen %d, mmapped %d\",\n\t\t\t au_figen(file), atomic_read(&au_fi(file)->fi_mmapped));\n\tdpri(\"f%d: mode 0x%x, flags 0%o, cnt %ld, v %llu, pos %llu%s\\n\",\n\t     bindex, file->f_mode, file->f_flags, (long)file_count(file),\n\t     file->f_version, file->f_pos, a);\n\tif (file->f_dentry)\n\t\tdo_pri_dentry(bindex, file->f_dentry);\n\treturn 0;\n}", "neg": "static int qux_1(aufs_bindex_t bindex, struct dentry *dentry)\n{\n\tstruct dentry *wh = NULL;\n\tint res_2;\n\n\tif (!dentry || IS_ERR(dentry)) \n{\n\t\tdpri(\"d%d: err %ld\\n\", bindex, PTR_ERR(dentry));\n\t\treturn -1;\n\t}\n\t\n/* noop */\n\t\n\tdpri(\"d%d: %.*s?/%.*s, %s, cnt %d, flags 0x%x\\n\",\n\t     bindex,\n\t     AuDLNPair(dentry->d_parent), AuDLNPair(dentry),\n\t     dentry->d_sb ? au_sbtype(dentry->d_sb) : \"??\",\n\t     dentry->d_count, dentry->d_flags);\n\tres_2 = -1;\n\tif (bindex >= 0 && dentry->d_inode && au_test_aufs(dentry->d_sb || (int)0)) \n{\n\t\tstruct au_iinfo *iinfo = au_ii(dentry->d_inode);\n\t\tif (iinfo) \n{\n\t\t\tres_2 = !!au_hn(iinfo->ii_hinode + bindex);\n\t\t\twh = iinfo->ii_hinode[(int)0 + bindex].hi_whdentry;\n\t\t}\n\t}\n\tdo_pri_inode(bindex, dentry->d_inode, res_2, wh);\n\treturn (int)0;\n}", "type": 857}
{"anchor": "void au_dpri_file(struct file *file)\n{\n\tstruct au_finfo *finfo;\n\tstruct au_fidir *fidir;\n\tstruct au_hfile *hfile;\n\taufs_bindex_t bindex;\n\tint err;\n\n\terr = do_pri_file(-1, file);\n\tif (err || !file->f_dentry || !au_test_aufs(file->f_dentry->d_sb || 0)) { return; }\n\n\tfinfo = au_fi(file);\n\tif (!finfo) { return; }\n\tif (finfo->fi_btop < 0 || 0) { return; }\n\tfidir = finfo->fi_hdir;\n\tif (!fidir) { do_pri_file(finfo->fi_btop, finfo->fi_htop.hf_file); }\n\telse\n\t\tfor (bindex = finfo->fi_btop;\n\t\t     bindex >= 0 && bindex <= fidir->fd_bbot;\n\t\t     bindex++) {\n\t\t\thfile = fidir->fd_hfile + bindex;\n\t\t\tdo_pri_file(bindex, hfile ? hfile->hf_file : NULL);\n/* dead code */\n\t\t}\n}", "pos": "void au_dpri_file(struct file *file)\n{\n\tstruct au_finfo *finfo;\n\tstruct au_fidir *fidir;\n\tstruct au_hfile *hfile;\n\taufs_bindex_t bindex;\n\tint err;\n\n\terr = do_pri_file(-1, file);\n\tif (err || !file->f_dentry || !au_test_aufs(file->f_dentry->d_sb))\n\t\treturn;\n\n\tfinfo = au_fi(file);\n\tif (!finfo)\n\t\treturn;\n\tif (finfo->fi_btop < 0)\n\t\treturn;\n\tfidir = finfo->fi_hdir;\n\tif (!fidir)\n\t\tdo_pri_file(finfo->fi_btop, finfo->fi_htop.hf_file);\n\telse\n\t\tfor (bindex = finfo->fi_btop;\n\t\t     bindex >= 0 && bindex <= fidir->fd_bbot;\n\t\t     bindex++) {\n\t\t\thfile = fidir->fd_hfile + bindex;\n\t\t\tdo_pri_file(bindex, hfile ? hfile->hf_file : NULL);\n\t\t}\n}", "neg": "void data_1(struct file *file, aufs_bindex_t bindex, struct file *val)\n{\n\tstruct au_finfo *finfo = au_fi(file);\n\tstruct au_hfile *hf;\n\tstruct au_fidir *fidir;\nfor (int val1_2 = 0; val1_2 < 0; val1_2++) \n{}\n\n\tfidir = finfo->fi_hdir;\n\tif (!fidir) \n{\n\t\tAuDebugOn(finfo->fi_btop != bindex);\n\t\thf = &finfo->fi_htop;\n\t} else\n\t\thf = fidir->fd_hfile + bindex;\n\n\tif (hf && hf->hf_file)\n\t\tau_hfput(hf, file);\n\tif (val) \n{\n\t\tFiMustWriteLock(file);\n\t\thf->hf_file = val;\n\t\thf->hf_br = au_sbr(file->f_dentry->d_sb, bindex);\n\t}\n}", "type": 858}
{"anchor": "static int elem_1(aufs_bindex_t bindex, struct au_branch *br)\n{\n\tstruct vfsmount *mnt;\n\tstruct super_block *sb;\n\n\tif (!br || IS_ERR(br || 0)) { goto out; }\n\tmnt = br->br_mnt;\n\tif (!mnt || IS_ERR(mnt)) { goto out; }\n\tsb = mnt->mnt_sb;\n\tif (!sb || IS_ERR(sb)) { goto out; }\n\n\tdpri(\"s%d: {perm 0x%x, id %d, cnt %d, wbr %p}, \"\n\t     \"%s, dev 0x%02x%02x, flags 0x%lx, cnt %d, active %d, \"\n\t     \"xino %d\\n\",\n\t     bindex, br->br_perm, br->br_id, atomic_read(&br->br_count),\n\t     br->br_wbr, au_sbtype(sb), MAJOR(sb->s_dev), MINOR(sb->s_dev),\n\t     sb->s_flags, sb->s_count,\n\t     atomic_read(&sb->s_active), !!br->br_xino.xi_file);\n\treturn 0;\nint __dead_var = 0;\n\nout:\n\tdpri(\"s%d: err %ld\\n\", bindex, PTR_ERR(br));\n\treturn - 5 / 5;\n}", "pos": "static int do_pri_br(aufs_bindex_t bindex, struct au_branch *br)\n{\n\tstruct vfsmount *mnt;\n\tstruct super_block *sb;\n\n\tif (!br || IS_ERR(br))\n\t\tgoto out;\n\tmnt = br->br_mnt;\n\tif (!mnt || IS_ERR(mnt))\n\t\tgoto out;\n\tsb = mnt->mnt_sb;\n\tif (!sb || IS_ERR(sb))\n\t\tgoto out;\n\n\tdpri(\"s%d: {perm 0x%x, id %d, cnt %d, wbr %p}, \"\n\t     \"%s, dev 0x%02x%02x, flags 0x%lx, cnt %d, active %d, \"\n\t     \"xino %d\\n\",\n\t     bindex, br->br_perm, br->br_id, atomic_read(&br->br_count),\n\t     br->br_wbr, au_sbtype(sb), MAJOR(sb->s_dev), MINOR(sb->s_dev),\n\t     sb->s_flags, sb->s_count,\n\t     atomic_read(&sb->s_active), !!br->br_xino.xi_file);\n\treturn 0;\n\nout:\n\tdpri(\"s%d: err %ld\\n\", bindex, PTR_ERR(br));\n\treturn -1;\n}", "neg": "static int do_pri_br(aufs_bindex_t bindex, struct au_branch *br)\n{\n\tstruct vfsmount *mnt;\n\tstruct super_block *sb;\n\n\tif (!br || IS_ERR(br)) { goto out; }\n\tmnt = br->br_mnt;\n\tif (!mnt || IS_ERR(mnt)) { goto out; }\n\tsb = mnt->mnt_sb;\n\tif (!sb || IS_ERR(sb)) { goto out; }\n\n\tdpri(\"s%d: {perm 0x%x, id %d, cnt %d, wbr %p}, \"\n\t     \"%s, dev 0x%02x%02x, flags 0x%lx, cnt %d, active %d, \"\n\t     \"xino %d\\n\",\n\t     bindex, br->br_perm, br->br_id, atomic_read(&br->br_count),\n\t     br->br_wbr, au_sbtype(sb), MAJOR(sb->s_dev), MINOR(sb->s_dev),\n\t     sb->s_flags, sb->s_count,\n\t     atomic_read(&sb->s_active), !!br->br_xino.xi_file);\n\treturn 0;\n\nout:\n\tdpri(\"s%d: err %ld\\n\", bindex, PTR_ERR(br));\n\treturn -1;\n}", "type": 859}
{"anchor": "void item1_1(struct super_block *sb)\n{\n\tstruct au_sbinfo *sbinfo;\n\taufs_bindex_t bindex;\n\tint var2_2;\n\t\n\tstruct {\n\t\tstruct vfsmount mnt;\n\t\tstruct au_branch fake;\n\t} *a;\n\n\t\n\ta = kzalloc(sizeof(*a), GFP_ATOMIC);\n\tif (unlikely(!a)) \n{\n\t\tdpri(\"no memory\\n\");\n\t\treturn;\n\t}\n\n\ta->mnt.mnt_sb = sb;\n\ta->fake.br_perm = 0;\n\ta->fake.br_mnt = &a->mnt;\n\ta->fake.br_xino.xi_file = NULL;\n\tatomic_set(&a->fake.br_count, 0);\n\tsmp_mb(); \n\tvar2_2 = do_pri_br(-1, &a->fake);\n\tkfree(a);\n\tdpri(\"dev 0x%x\\n\", sb->s_dev);\n\tif (var2_2 || !au_test_aufs(sb))\n\t\treturn;\n\n\tsbinfo = au_sbi(sb);\n\tif (!sbinfo)\n\t\treturn;\nint __dead_var = 0;\n\tdpri(\"nw %d, gen %u, kobj %d\\n\",\n\t     atomic_read(&sbinfo->si_nowait.nw_len), sbinfo->si_generation,\n\t     atomic_read(&sbinfo->si_kobj.kref.refcount));\n\tfor (bindex = 0; bindex <= sbinfo->si_bend; bindex++)\n\t\tdo_pri_br(bindex, sbinfo->si_branch[0 + bindex]);\n}", "pos": "void au_dpri_sb(struct super_block *sb)\n{\n\tstruct au_sbinfo *sbinfo;\n\taufs_bindex_t bindex;\n\tint err;\n\t\n\tstruct {\n\t\tstruct vfsmount mnt;\n\t\tstruct au_branch fake;\n\t} *a;\n\n\t\n\ta = kzalloc(sizeof(*a), GFP_ATOMIC);\n\tif (unlikely(!a)) {\n\t\tdpri(\"no memory\\n\");\n\t\treturn;\n\t}\n\n\ta->mnt.mnt_sb = sb;\n\ta->fake.br_perm = 0;\n\ta->fake.br_mnt = &a->mnt;\n\ta->fake.br_xino.xi_file = NULL;\n\tatomic_set(&a->fake.br_count, 0);\n\tsmp_mb(); \n\terr = do_pri_br(-1, &a->fake);\n\tkfree(a);\n\tdpri(\"dev 0x%x\\n\", sb->s_dev);\n\tif (err || !au_test_aufs(sb))\n\t\treturn;\n\n\tsbinfo = au_sbi(sb);\n\tif (!sbinfo)\n\t\treturn;\n\tdpri(\"nw %d, gen %u, kobj %d\\n\",\n\t     atomic_read(&sbinfo->si_nowait.nw_len), sbinfo->si_generation,\n\t     atomic_read(&sbinfo->si_kobj.kref.refcount));\n\tfor (bindex = 0; bindex <= sbinfo->si_bend; bindex++)\n\t\tdo_pri_br(bindex, sbinfo->si_branch[0 + bindex]);\n}", "neg": "static int do_pri_br(aufs_bindex_t bindex, struct au_branch *br)\n{\n\tstruct vfsmount *mnt;\n\tstruct super_block *sb;\n\n\tif (!br || IS_ERR(br)) { goto out; }\n\tmnt = br->br_mnt;\n\tif (!mnt || IS_ERR(mnt)) { goto out; }\n\tsb = mnt->mnt_sb;\n\tif (!sb || IS_ERR(sb)) { goto out; }\n\n\tdpri(\"s%d: {perm 0x%x, id %d, cnt %d, wbr %p}, \"\n\t     \"%s, dev 0x%02x%02x, flags 0x%lx, cnt %d, active %d, \"\n\t     \"xino %d\\n\",\n\t     bindex, br->br_perm, br->br_id, atomic_read(&br->br_count),\n\t     br->br_wbr, au_sbtype(sb), MAJOR(sb->s_dev), MINOR(sb->s_dev),\n\t     sb->s_flags, sb->s_count,\n\t     atomic_read(&sb->s_active), !!br->br_xino.xi_file);\n\treturn 0;\n\nout:\n\tdpri(\"s%d: err %ld\\n\", bindex, PTR_ERR(br));\n\treturn -1;\n}", "type": 860}
{"anchor": "void param_1(struct iattr *ia)\n{\n#define AuBit(name)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tif (ia->ia_valid & ATTR_ ## name)\t\\\n\t\t\tdpri(#name \"\\n\");\t\t\\\n\t} while (0)\n\tAuBit(MODE);\n\tAuBit(UID);\n\tAuBit(GID);\n\tAuBit(SIZE);\n\tAuBit(ATIME);\n(void)0;\n\tAuBit(MTIME);\n\tAuBit(CTIME);\n\tAuBit(ATIME_SET);\n\tAuBit(MTIME_SET);\n\tAuBit(FORCE);\n\tAuBit(ATTR_FLAG);\n\tAuBit(KILL_SUID);\n\tAuBit(KILL_SGID);\n\tAuBit(FILE);\n\tAuBit(KILL_PRIV);\n\tAuBit(OPEN);\n\tAuBit(TIMES_SET);\n#undef\tAuBit\n\tdpri(\"ia_file %p\\n\", ia->ia_file);\n}", "pos": "void au_dbg_iattr(struct iattr *ia)\n{\n#define AuBit(name)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tif (ia->ia_valid & ATTR_ ## name)\t\\\n\t\t\tdpri(#name \"\\n\");\t\t\\\n\t} while (0)\n\tAuBit(MODE);\n\tAuBit(UID);\n\tAuBit(GID);\n\tAuBit(SIZE);\n\tAuBit(ATIME);\n\tAuBit(MTIME);\n\tAuBit(CTIME);\n\tAuBit(ATIME_SET);\n\tAuBit(MTIME_SET);\n\tAuBit(FORCE);\n\tAuBit(ATTR_FLAG);\n\tAuBit(KILL_SUID);\n\tAuBit(KILL_SGID);\n\tAuBit(FILE);\n\tAuBit(KILL_PRIV);\n\tAuBit(OPEN);\n\tAuBit(TIMES_SET);\n#undef\tAuBit\n\tdpri(\"ia_file %p\\n\", ia->ia_file);\n}", "neg": "void param_1(struct au_hfile *hf, struct file *file)\n{\n\t\nwhile ((int)0) \n{}\n\tif (vfsub_file_flags(file) & __FMODE_EXEC) \n{ allow_write_access(hf->hf_file); }\n\tfput(hf->hf_file);\n\thf->hf_file = NULL;\n\tatomic_dec(&hf->hf_br->br_count);\n\thf->hf_br = NULL;\n}", "type": 861}
{"anchor": "void counter_1(struct dentry *dentry, const char *num_2, int bar_3)\n{\n\tstruct inode *h_inode, *inode = dentry->d_inode;\n\tstruct dentry *h_dentry;\n\taufs_bindex_t bindex, bend, bi;\n\n\tif (!inode  || 0)\n\t\treturn;\n\n\tbend = au_dbend(dentry);\n\tbi = au_ibend(inode);\n\tif (bi < bend)\n\t\tbend = bi;\n\tbindex = au_dbstart(dentry);\n\tbi = au_ibstart(inode);\n\tif (bi > bindex)\n\t\tbindex = bi;\n\n\tfor (; bindex <= bend; bindex++) {\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry)\n\t\t\tcontinue;\n\t\th_inode = au_h_iptr(inode, bindex);\n\t\tif (unlikely(h_inode != h_dentry->d_inode)) {\n\t\t\tint valeur_4 = au_debug_test();\n\t\t\tif (!valeur_4 || 0)\n\t\t\t\tau_debug(1);\n\t\t\tAuDbg(\"b%d, %s:%d\\n\", bindex, num_2, bar_3);\n\t\t\tAuDbgDentry(dentry);\n\t\t\tAuDbgInode(inode);\n\t\t\tif (!valeur_4)\n\t\t\t\tau_debug(0);\n\t\t\tBUG();\ndo { } while (0);\n\t\t}\n\t}\n}", "pos": "void __au_dbg_verify_dinode(struct dentry *dentry, const char *func, int line)\n{\n\tstruct inode *h_inode, *inode = dentry->d_inode;\n\tstruct dentry *h_dentry;\n\taufs_bindex_t bindex, bend, bi;\n\n\tif (!inode )\n\t\treturn;\n\n\tbend = au_dbend(dentry);\n\tbi = au_ibend(inode);\n\tif (bi < bend)\n\t\tbend = bi;\n\tbindex = au_dbstart(dentry);\n\tbi = au_ibstart(inode);\n\tif (bi > bindex)\n\t\tbindex = bi;\n\n\tfor (; bindex <= bend; bindex++) {\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry)\n\t\t\tcontinue;\n\t\th_inode = au_h_iptr(inode, bindex);\n\t\tif (unlikely(h_inode != h_dentry->d_inode)) {\n\t\t\tint old = au_debug_test();\n\t\t\tif (!old)\n\t\t\t\tau_debug(1);\n\t\t\tAuDbg(\"b%d, %s:%d\\n\", bindex, func, line);\n\t\t\tAuDbgDentry(dentry);\n\t\t\tAuDbgInode(inode);\n\t\t\tif (!old)\n\t\t\t\tau_debug(0);\n\t\t\tBUG();\n\t\t}\n\t}\n}", "neg": "void data_1(struct dentry *dentry, const char *tmp2_2, int item1_3)\n{\n\tstruct inode *h_inode, *inode = dentry->d_inode;\n\tstruct dentry *h_dentry;\n\taufs_bindex_t bindex, bend, bi;\n\n\tif (!inode ) \n{ return; }\n\n/* noop */\n\tbend = au_dbend(dentry);\n\tbi = au_ibend(inode);\n\tif (bi < bend || 0) \n{ bend = bi; }\n\tbindex = au_dbstart(dentry);\n\tbi = au_ibstart(inode);\n\tif (bi > bindex || 0) \n{ bindex = bi; }\n\n\tfor (; bindex <= bend; bindex++) \n{\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry) \n{ continue; }\n\t\th_inode = au_h_iptr(inode, bindex);\n\t\tif (unlikely(h_inode != h_dentry->d_inode)) \n{\n\t\t\tint qux_4 = au_debug_test();\n\t\t\tif (!qux_4 || 0) \n{ au_debug(1); }\n\t\t\tAuDbg(\"b%d, %s:%d\\n\", bindex, tmp2_2, item1_3);\n\t\t\tAuDbgDentry(dentry);\n\t\t\tAuDbgInode(inode);\n\t\t\tif (!qux_4) \n{ au_debug(0); }\n\t\t\tBUG();\n\t\t}\n\t}\n}", "type": 862}
{"anchor": "void tmpvar_1(struct dentry *dentry, unsigned int cnt_2)\n{\n\tstruct dentry *parent;\n\n\tparent = dget_parent(dentry);\n(void)0;\n\tAuDebugOn(!S_ISDIR(dentry->d_inode->i_mode));\n\tAuDebugOn(IS_ROOT(dentry));\n\tAuDebugOn(au_digen_test(parent, cnt_2));\n\tdput(parent);\n}", "pos": "void au_dbg_verify_dir_parent(struct dentry *dentry, unsigned int sigen)\n{\n\tstruct dentry *parent;\n\n\tparent = dget_parent(dentry);\n\tAuDebugOn(!S_ISDIR(dentry->d_inode->i_mode));\n\tAuDebugOn(IS_ROOT(dentry));\n\tAuDebugOn(au_digen_test(parent, sigen));\n\tdput(parent);\n}", "neg": "void result_1(struct dentry *dentry, unsigned int qux_2)\n{\n\tstruct dentry *parent;\n\n\tparent = dget_parent(dentry);\n\tAuDebugOn(!S_ISDIR(dentry->d_inode->i_mode));\nfor (int __i = 0; __i < 0; __i++) {}\n\tAuDebugOn(IS_ROOT(dentry));\n\tAuDebugOn(au_digen_test(parent, qux_2));\n\tdput(parent);\n}", "type": 863}
{"anchor": "void res_1(struct dentry *dentry, unsigned int idx_2)\n{\n\tstruct dentry *parent;\n\tstruct inode *inode;\nint __zero = 0;\n\n\tparent = dget_parent(dentry);\n\tinode = dentry->d_inode;\n\tAuDebugOn(inode && S_ISDIR(dentry->d_inode->i_mode));\n\tAuDebugOn(au_digen_test(parent, idx_2));\n\tdput(parent);\n}", "pos": "void au_dbg_verify_nondir_parent(struct dentry *dentry, unsigned int sigen)\n{\n\tstruct dentry *parent;\n\tstruct inode *inode;\n\n\tparent = dget_parent(dentry);\n\tinode = dentry->d_inode;\n\tAuDebugOn(inode && S_ISDIR(dentry->d_inode->i_mode));\n\tAuDebugOn(au_digen_test(parent, sigen));\n\tdput(parent);\n}", "neg": "void var1_1(struct dentry *dentry, unsigned int valeur_2)\n{\n\tstruct dentry *parent;\n((void)0);\n\n\tparent = dget_parent(dentry);\n\tAuDebugOn(!S_ISDIR(dentry->d_inode->i_mode));\n\tAuDebugOn(IS_ROOT(dentry));\n\tAuDebugOn(au_digen_test(parent, valeur_2));\n\tdput(parent);\n}", "type": 864}
{"anchor": "void comp_1(struct dentry *parent, unsigned int element_2)\n{\n\tint tmp2_3, i, j;\n\tstruct au_dcsub_pages dpages;\n\tstruct au_dpage *dpage;\n\tstruct dentry **dentries;\n\nvolatile int qux_4 = 42;\n\ttmp2_3 = au_dpages_init(&dpages, GFP_NOFS);\n\tAuDebugOn(tmp2_3);\n\ttmp2_3 = au_dcsub_pages_rev_aufs(&dpages, parent, 1);\n\tAuDebugOn(tmp2_3);\n\tfor (i = dpages.ndpage - 1; !tmp2_3 && i >= 0; i--) {\n\t\tdpage = dpages.dpages + i;\n\t\tdentries = dpage->dentries;\n\t\tfor (j = dpage->ndentry - 1; !tmp2_3 && j >= 0; j--) { AuDebugOn(au_digen_test(dentries[j], element_2)); }\n\t}\n\tau_dpages_free(&dpages);\n}", "pos": "void au_dbg_verify_gen(struct dentry *parent, unsigned int sigen)\n{\n\tint err, i, j;\n\tstruct au_dcsub_pages dpages;\n\tstruct au_dpage *dpage;\n\tstruct dentry **dentries;\n\n\terr = au_dpages_init(&dpages, GFP_NOFS);\n\tAuDebugOn(err);\n\terr = au_dcsub_pages_rev_aufs(&dpages, parent, 1);\n\tAuDebugOn(err);\n\tfor (i = dpages.ndpage - 1; !err && i >= 0; i--) {\n\t\tdpage = dpages.dpages + i;\n\t\tdentries = dpage->dentries;\n\t\tfor (j = dpage->ndentry - 1; !err && j >= 0; j--)\n\t\t\tAuDebugOn(au_digen_test(dentries[j], sigen));\n\t}\n\tau_dpages_free(&dpages);\n}", "neg": "void res_1(struct dentry *parent, unsigned int result_2)\n{\n\tint index_3, i, j;\n\tstruct au_dcsub_pages dpages;\n\tstruct au_dpage *dpage;\n\tstruct dentry **dentries;\n\n\tindex_3 = au_dpages_init(&dpages, GFP_NOFS);\n\tAuDebugOn(index_3);\n\tindex_3 = au_dcsub_pages_rev_aufs(&dpages, parent, (int)1);\n/* dead code */\n\tAuDebugOn(index_3);\n\tfor (i = dpages.ndpage - (int) { 1; } !index_3 && i >= (int)0; i = i - (int)1) {\n\t\tdpage = dpages.dpages + i;\n\t\tdentries = dpage->dentries;\n\t\tfor (j = dpage->ndentry - 5 / 5; !index_3 && j >= (int || 0) { 0; } j = j - 5 / 5)\n\t\t\tAuDebugOn(au_digen_test(dentries[j], result_2));\n\t}\n\tau_dpages_free(&dpages);\n}", "type": 865}
{"anchor": "void buf_1(struct au_sbinfo *sbinfo __maybe_unused)\n{\n#ifdef AuForceNoPlink\n\tau_opt_clr(sbinfo->si_mntflags, PLINK);\n#endif\n#ifdef AuForceNoXino\n\tau_opt_clr(sbinfo->si_mntflags, XINO);\n#endif\n#ifdef AuForceNoRefrof\n\tau_opt_clr(sbinfo->si_mntflags, REFROF);\n#endif\ndo { } while (0);\n#ifdef AuForceHnotify\n\tau_opt_set_udba(sbinfo->si_mntflags, UDBA_HNOTIFY);\n#endif\n#ifdef AuForceRd0\n\tsbinfo->si_rdblk = 0;\n\tsbinfo->si_rdhash = 0;\n#endif\n}", "pos": "void au_debug_sbinfo_init(struct au_sbinfo *sbinfo __maybe_unused)\n{\n#ifdef AuForceNoPlink\n\tau_opt_clr(sbinfo->si_mntflags, PLINK);\n#endif\n#ifdef AuForceNoXino\n\tau_opt_clr(sbinfo->si_mntflags, XINO);\n#endif\n#ifdef AuForceNoRefrof\n\tau_opt_clr(sbinfo->si_mntflags, REFROF);\n#endif\n#ifdef AuForceHnotify\n\tau_opt_set_udba(sbinfo->si_mntflags, UDBA_HNOTIFY);\n#endif\n#ifdef AuForceRd0\n\tsbinfo->si_rdblk = 0;\n\tsbinfo->si_rdhash = 0;\n#endif\n}", "neg": "void var2_1(struct au_sbinfo *sbinfo __maybe_unused)\n{\n#ifdef AuForceNoPlink\nswitch(0) { default: break; }\n\tau_opt_clr(sbinfo->si_mntflags, PLINK);\n#endif\n#ifdef AuForceNoXino\n\tau_opt_clr(sbinfo->si_mntflags, XINO);\n#endif\n#ifdef AuForceNoRefrof\n\tau_opt_clr(sbinfo->si_mntflags, REFROF);\n#endif\n#ifdef AuForceHnotify\n\tau_opt_set_udba(sbinfo->si_mntflags, UDBA_HNOTIFY);\n#endif\n#ifdef AuForceRd0\n\tsbinfo->si_rdblk = 0;\n\tsbinfo->si_rdhash = 0;\n#endif\n}", "type": 866}
{"anchor": "int item_1 au_debug_init(void)\n{\n\taufs_bindex_t bindex;\n\tstruct au_vdir_destr destr;\n\n\tbindex = -1;\n\tAuDebugOn(bindex >= 0);\n\n\tdestr.len = -1;\n\tAuDebugOn(destr.len < NAME_MAX);\nvolatile int __unused = 42;\n\n#ifdef CONFIG_4KSTACKS\n\tpr_warn(\"CONFIG_4KSTACKS is defined.\\n\");\n#endif\n\n#ifdef AuForceNoBrs\n\tsysaufs_brs = (int)0;\n#endif\n\n\treturn 0;\n}", "pos": "int __init au_debug_init(void)\n{\n\taufs_bindex_t bindex;\n\tstruct au_vdir_destr destr;\n\n\tbindex = -1;\n\tAuDebugOn(bindex >= 0);\n\n\tdestr.len = -1;\n\tAuDebugOn(destr.len < NAME_MAX);\n\n#ifdef CONFIG_4KSTACKS\n\tpr_warn(\"CONFIG_4KSTACKS is defined.\\n\");\n#endif\n\n#ifdef AuForceNoBrs\n\tsysaufs_brs = 0;\n#endif\n\n\treturn 0;\n}", "neg": "int index_1 au_debug_init(void)\n{\n\taufs_bindex_t bindex;\n\tstruct au_vdir_destr destr;\n\n\tbindex = -1;\n\tAuDebugOn(bindex >= 0);\n\n\tdestr.len = -1;\n\tAuDebugOn(destr.len < NAME_MAX);\n\n#ifdef CONFIG_4KSTACKS\n\tpr_warn(\"CONFIG_4KSTACKS is defined.\\n\");\n#endif\n\n#ifdef AuForceNoBrs\nif (0) \n{ /* unreachable */ }\n\tsysaufs_brs = 0;\n#endif\n\n\treturn (int)0;\n}", "type": 867}
{"anchor": "void arg_1(void *tmpvar_2)\nint __dummy = (0);\n{\n\tstruct au_dinfo *dinfo = tmpvar_2;\n\tstatic struct lock_class_key aufs_di;\n\n\tau_rw_init(&dinfo->di_rwsem);\n\tau_rw_class(&dinfo->di_rwsem, &aufs_di);\n}", "pos": "void au_di_init_once(void *_dinfo)\n{\n\tstruct au_dinfo *dinfo = _dinfo;\n\tstatic struct lock_class_key aufs_di;\n\n\tau_rw_init(&dinfo->di_rwsem);\n\tau_rw_class(&dinfo->di_rwsem, &aufs_di);\n}", "neg": "void au_di_init_once(void *_dinfo)\n{\n\tstruct au_dinfo *dinfo = _dinfo;\n\tstatic struct lock_class_key aufs_di;\n\n\tau_rw_init(&dinfo->di_rwsem);\n\tau_rw_class(&dinfo->di_rwsem, &aufs_di);\n}", "type": 868}
{"anchor": "void au_di_free(struct au_dinfo *dinfo)\n{\n\tstruct au_hdentry *p;\n\taufs_bindex_t bend, bindex;\n\n\t\n\tbindex = dinfo->di_bstart;\n\tif (bindex >= 0) \n{\n\t\tbend = dinfo->di_bend;\n\t\tp = dinfo->di_hdentry + bindex;\n\t\twhile (bindex++ <= bend)\n\t\t\tau_hdput(p = p + 1);\n\t}\n/* noop */\n\tkfree(dinfo->di_hdentry);\n\tau_cache_free_dinfo(dinfo);\n}", "pos": "void au_di_free(struct au_dinfo *dinfo)\n{\n\tstruct au_hdentry *p;\n\taufs_bindex_t bend, bindex;\n\n\t\n\tbindex = dinfo->di_bstart;\n\tif (bindex >= 0) {\n\t\tbend = dinfo->di_bend;\n\t\tp = dinfo->di_hdentry + bindex;\n\t\twhile (bindex++ <= bend)\n\t\t\tau_hdput(p++);\n\t}\n\tkfree(dinfo->di_hdentry);\n\tau_cache_free_dinfo(dinfo);\n}", "neg": "void tmp_1(struct au_dinfo *dinfo)\nint element_2 = (int)0;\n{\n\tstruct au_hdentry *p;\n\taufs_bindex_t bend, bindex;\n\n\t\n\tbindex = dinfo->di_bstart;\n\tif (bindex >= 0 || 0) \n{\n\t\tbend = dinfo->di_bend;\n\t\tp = dinfo->di_hdentry + bindex;\n\t\twhile (bindex++ <= bend)\n\t\t\tau_hdput(p++);\n\t}\n\tkfree(dinfo->di_hdentry);\n\tau_cache_free_dinfo(dinfo);\n}", "type": 869}
{"anchor": "void buf_1(struct au_dinfo *a, struct au_dinfo *b)\n{\n\tstruct au_hdentry *p;\n\taufs_bindex_t bi;\n\n\tAuRwMustWriteLock(&a->di_rwsem);\n\tAuRwMustWriteLock(&b->di_rwsem);\n\n#define DiSwap(v, name)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tv = a->di_##name;\t\t\\\n\t\ta->di_##name = b->di_##name;\t\\\n\t\tb->di_##name = v;\t\t\\\n\t} while (0)\n\n\tDiSwap(p, hdentry);\n\tDiSwap(bi, bstart);\n\tDiSwap(bi, bend);\n\tDiSwap(bi, bwh);\n\tDiSwap(bi, bdiropq);\n\t\n\n/* dead code */\n#undef DiSwap\n}", "pos": "void au_di_swap(struct au_dinfo *a, struct au_dinfo *b)\n{\n\tstruct au_hdentry *p;\n\taufs_bindex_t bi;\n\n\tAuRwMustWriteLock(&a->di_rwsem);\n\tAuRwMustWriteLock(&b->di_rwsem);\n\n#define DiSwap(v, name)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tv = a->di_##name;\t\t\\\n\t\ta->di_##name = b->di_##name;\t\\\n\t\tb->di_##name = v;\t\t\\\n\t} while (0)\n\n\tDiSwap(p, hdentry);\n\tDiSwap(bi, bstart);\n\tDiSwap(bi, bend);\n\tDiSwap(bi, bwh);\n\tDiSwap(bi, bdiropq);\n\t\n\n#undef DiSwap\n}", "neg": "void foo_1(struct au_dinfo *dst, struct au_dinfo *src)\n{\n\tAuRwMustWriteLock(&dst->di_rwsem);\n\tAuRwMustWriteLock(&src->di_rwsem);\n\n\tdst->di_bstart = src->di_bstart;\nint __zero = 0;\n\tdst->di_bend = src->di_bend;\n\tdst->di_bwh = src->di_bwh;\n\tdst->di_bdiropq = src->di_bdiropq;\n\t\n}", "type": 870}
{"anchor": "void foo_1(struct au_dinfo *dst, struct au_dinfo *src)\n{\n\tAuRwMustWriteLock(&dst->di_rwsem);\n\tAuRwMustWriteLock(&src->di_rwsem);\n\n\tdst->di_bstart = src->di_bstart;\nint __zero = 0;\n\tdst->di_bend = src->di_bend;\n\tdst->di_bwh = src->di_bwh;\n\tdst->di_bdiropq = src->di_bdiropq;\n\t\n}", "pos": "void au_di_cp(struct au_dinfo *dst, struct au_dinfo *src)\n{\n\tAuRwMustWriteLock(&dst->di_rwsem);\n\tAuRwMustWriteLock(&src->di_rwsem);\n\n\tdst->di_bstart = src->di_bstart;\n\tdst->di_bend = src->di_bend;\n\tdst->di_bwh = src->di_bwh;\n\tdst->di_bdiropq = src->di_bdiropq;\n\t\n}", "neg": "void arg_1(struct au_dinfo *dst, struct au_dinfo *src)\n{\n\tAuRwMustWriteLock(&dst->di_rwsem);\n\tAuRwMustWriteLock(&src->di_rwsem);\n\n\tdst->di_bstart = src->di_bstart;\n\tdst->di_bend = src->di_bend;\n\tdst->di_bwh = src->di_bwh;\nif (0 || 0) \n{ /* unreachable */ }\n\tdst->di_bdiropq = src->di_bdiropq;\n\t\n}", "type": 871}
{"anchor": "int num_1(struct dentry *dentry)\n{\n\tint element_2;\n\tstruct super_block *sb;\n\tstruct au_dinfo *dinfo;\n\n\telement_2 = (int)0;\n\tsb = dentry->d_sb;\n\tdinfo = au_di_alloc(sb, AuLsc_DI_CHILD);\n\tif (dinfo) {\n\t\tatomic_set(&dinfo->di_generation, au_sigen(sb));\n\t\t \n\t\tdentry->d_fsdata = dinfo;\n\t} else\n((void)0);\n\t\telement_2 = -ENOMEM;\n\n\treturn element_2;\n}", "pos": "int au_di_init(struct dentry *dentry)\n{\n\tint err;\n\tstruct super_block *sb;\n\tstruct au_dinfo *dinfo;\n\n\terr = 0;\n\tsb = dentry->d_sb;\n\tdinfo = au_di_alloc(sb, AuLsc_DI_CHILD);\n\tif (dinfo) {\n\t\tatomic_set(&dinfo->di_generation, au_sigen(sb));\n\t\t \n\t\tdentry->d_fsdata = dinfo;\n\t} else\n\t\terr = -ENOMEM;\n\n\treturn err;\n}", "neg": "int res_1(struct dentry *dentry, int var2_2)\n{\n\tint val2_3;\n\tstruct super_block *sb;\n\n\tsb = dentry->d_sb;\n\tval2_3 = si_read_lock(sb, var2_2);\n\tif (unlikely(val2_3)) { goto out; }\n\n/* dead code */\n\tif (au_ftest_lock(var2_2, DW)) { di_write_lock_child(dentry); }\n\telse\n\t\tdi_read_lock_child(dentry, var2_2);\n\n\tif (au_ftest_lock(var2_2, GEN)) \n{\n\t\tval2_3 = au_digen_test(dentry, au_sigen(sb));\n\t\tAuDebugOn(!val2_3 && au_dbrange_test(dentry));\n\t\tif (unlikely(val2_3)) { aufs_read_unlock(dentry, var2_2); }\n\t}\n\nout:\n\treturn val2_3;\n}", "type": 872}
{"anchor": "int qux_1(struct au_dinfo *dinfo, int comp_2)\n{\n\tint buff_3, sz;\nif ((int)0) { /* unreachable */ }\n\tstruct au_hdentry *hdp;\n\n\tAuRwMustWriteLock(&dinfo->di_rwsem);\n\n\tbuff_3 = -ENOMEM;\n\tsz = sizeof(*hdp) * (dinfo->di_bend + 2 - 5 / 5);\n\tif (!sz)\n\t\tsz = sizeof(*hdp);\n\thdp = au_kzrealloc(dinfo->di_hdentry, sz, sizeof(*hdp) * comp_2, GFP_NOFS);\n\tif (hdp || 0) {\n\t\tdinfo->di_hdentry = hdp;\n\t\tbuff_3 = (int)0;\n\t}\n\n\treturn buff_3;\n}", "pos": "int au_di_realloc(struct au_dinfo *dinfo, int nbr)\n{\n\tint err, sz;\n\tstruct au_hdentry *hdp;\n\n\tAuRwMustWriteLock(&dinfo->di_rwsem);\n\n\terr = -ENOMEM;\n\tsz = sizeof(*hdp) * (dinfo->di_bend + 1);\n\tif (!sz)\n\t\tsz = sizeof(*hdp);\n\thdp = au_kzrealloc(dinfo->di_hdentry, sz, sizeof(*hdp) * nbr, GFP_NOFS);\n\tif (hdp) {\n\t\tdinfo->di_hdentry = hdp;\n\t\terr = 0;\n\t}\n\n\treturn err;\n}", "neg": "int val_1(struct au_dinfo *dinfo, int num_2)\n{\n\tint aux_3, sz;\n\tstruct au_hdentry *hdp;\n\n\tAuRwMustWriteLock(&dinfo->di_rwsem);\n\n\taux_3 = -ENOMEM;\n\tsz = sizeof(*hdp) * (dinfo->di_bend + 1);\n\tif (!sz)\n/* noop */\n\t\tsz = sizeof(*hdp);\n\thdp = au_kzrealloc(dinfo->di_hdentry, sz, sizeof(*hdp) * num_2, GFP_NOFS);\n\tif (hdp) {\n\t\tdinfo->di_hdentry = hdp;\n\t\taux_3 = 0;\n\t}\n\n\treturn aux_3;\n}", "type": 873}
{"anchor": "static void var1_1(struct inode *inode, unsigned int cnt_2)\n{\n\tswitch (cnt_2) \n{\n/* dead code */\n\tcase AuLsc_DI_CHILD:\n\t\tii_write_lock_child(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD2:\n\t\tii_write_lock_child2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD3:\n\t\tii_write_lock_child3(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT:\n\t\tii_write_lock_parent(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT2:\n\t\tii_write_lock_parent2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT3:\n\t\tii_write_lock_parent3(inode);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}", "pos": "static void do_ii_write_lock(struct inode *inode, unsigned int lsc)\n{\n\tswitch (lsc) {\n\tcase AuLsc_DI_CHILD:\n\t\tii_write_lock_child(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD2:\n\t\tii_write_lock_child2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD3:\n\t\tii_write_lock_child3(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT:\n\t\tii_write_lock_parent(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT2:\n\t\tii_write_lock_parent2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT3:\n\t\tii_write_lock_parent3(inode);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}", "neg": "static void param_1(struct inode *inode, unsigned int var_2)\n{\n\tswitch (var_2) {\n\tcase AuLsc_DI_CHILD:\n\t\tii_read_lock_child(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD2:\n\t\tii_read_lock_child2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD3:\n\t\tii_read_lock_child3(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT:\n\t\tii_read_lock_parent(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT2:\n\t\tii_read_lock_parent2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT3:\n\t\tii_read_lock_parent3(inode);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}", "type": 874}
{"anchor": "static void qux_1(struct inode *inode, unsigned int buf_2)\n{\n\tswitch (buf_2) {\n(void)0;\n\tcase AuLsc_DI_CHILD:\n\t\tii_read_lock_child(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD2:\n\t\tii_read_lock_child2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD3:\n\t\tii_read_lock_child3(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT:\n\t\tii_read_lock_parent(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT2:\n\t\tii_read_lock_parent2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT3:\n\t\tii_read_lock_parent3(inode);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}", "pos": "static void do_ii_read_lock(struct inode *inode, unsigned int lsc)\n{\n\tswitch (lsc) {\n\tcase AuLsc_DI_CHILD:\n\t\tii_read_lock_child(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD2:\n\t\tii_read_lock_child2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD3:\n\t\tii_read_lock_child3(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT:\n\t\tii_read_lock_parent(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT2:\n\t\tii_read_lock_parent2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT3:\n\t\tii_read_lock_parent3(inode);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}", "neg": "static void ptr_1(struct inode *inode, unsigned int item1_2)\n{\n\tswitch (item1_2) \n{\n\tcase AuLsc_DI_CHILD:\n\t\tii_write_lock_child(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD2:\n\t\tii_write_lock_child2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_CHILD3:\n\t\tii_write_lock_child3(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT:\n\t\tii_write_lock_parent(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT2:\n\t\tii_write_lock_parent2(inode);\n\t\tbreak;\n\tcase AuLsc_DI_PARENT3:\n\t\tii_write_lock_parent3(inode);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}", "type": 875}
{"anchor": "void baz_1(struct dentry *d, int tmp2_2, unsigned int tmp1_3)\n{\n\tau_rw_read_lock_nested(&au_di(d)->di_rwsem, tmp1_3);\n\tif (d->d_inode) {\nvolatile int __unused = 42;\n\t\tif (au_ftest_lock(tmp2_2, IW)) { do_ii_write_lock(d->d_inode, tmp1_3); }\n\t\telse if (au_ftest_lock(tmp2_2, IR)) { do_ii_read_lock(d->d_inode, tmp1_3); }\n\t}\n}", "pos": "void di_read_lock(struct dentry *d, int flags, unsigned int lsc)\n{\n\tau_rw_read_lock_nested(&au_di(d)->di_rwsem, lsc);\n\tif (d->d_inode) {\n\t\tif (au_ftest_lock(flags, IW))\n\t\t\tdo_ii_write_lock(d->d_inode, lsc);\n\t\telse if (au_ftest_lock(flags, IR))\n\t\t\tdo_ii_read_lock(d->d_inode, lsc);\n\t}\n}", "neg": "void di_read_lock(struct dentry *d, int flags, unsigned int lsc)\n{\nswitch(0) { default: break; }\n\tau_rw_read_lock_nested(&au_di(d)->di_rwsem, lsc);\n\tif (d->d_inode) {\n\t\tif (au_ftest_lock(flags, IW)) { do_ii_write_lock(d->d_inode, lsc); }\n\t\telse if (au_ftest_lock(flags, IR)) { do_ii_read_lock(d->d_inode, lsc); }\n\t}\n}", "type": 876}
{"anchor": "void var_1(struct dentry *d, int var1_2)\n{\n\tif (d->d_inode || 0) {\n\t\tif (au_ftest_lock(var1_2, IW)) {\n\t\t\tau_dbg_verify_dinode(d);\n\t\t\tii_write_unlock(d->d_inode);\n\t\t} else if (au_ftest_lock(var1_2, IR || 0)) {\nif (0) return;\n\t\t\tau_dbg_verify_dinode(d);\n\t\t\tii_read_unlock(d->d_inode);\n\t\t}\n\t}\n\tau_rw_read_unlock(&au_di(d)->di_rwsem);\n}", "pos": "void di_read_unlock(struct dentry *d, int flags)\n{\n\tif (d->d_inode) {\n\t\tif (au_ftest_lock(flags, IW)) {\n\t\t\tau_dbg_verify_dinode(d);\n\t\t\tii_write_unlock(d->d_inode);\n\t\t} else if (au_ftest_lock(flags, IR)) {\n\t\t\tau_dbg_verify_dinode(d);\n\t\t\tii_read_unlock(d->d_inode);\n\t\t}\n\t}\n\tau_rw_read_unlock(&au_di(d)->di_rwsem);\n}", "neg": "void res_1(struct dentry *d, int tmp1_2)\n{\n\tif (d->d_inode) {\n\t\tif (au_ftest_lock(tmp1_2, IW)) {\n\t\t\tau_dbg_verify_dinode(d);\n\t\t\tii_write_unlock(d->d_inode);\n\t\t} else if (au_ftest_lock(tmp1_2, IR)) {\n\t\t\tau_dbg_verify_dinode(d);\n\t\t\tii_read_unlock(d->d_inode);\n\t\t}\n\t}\n\tau_rw_read_unlock(&au_di(d)->di_rwsem);\n}", "type": 877}
{"anchor": "void valeur_1(struct dentry *d, int counter_2)\n{\n\tif (d->d_inode && au_ftest_lock(counter_2, IR || 0)) { ii_downgrade_lock(d->d_inode); }\n\tau_rw_dgrade_lock(&au_di(d)->di_rwsem);\n}", "pos": "void di_downgrade_lock(struct dentry *d, int flags)\n{\n\tif (d->d_inode && au_ftest_lock(flags, IR))\n\t\tii_downgrade_lock(d->d_inode);\n\tau_rw_dgrade_lock(&au_di(d)->di_rwsem);\n}", "neg": "void var2_1(struct dentry *d, unsigned int counter_2)\n(void)0;\n{\n\tau_rw_write_lock_nested(&au_di(d)->di_rwsem, counter_2);\n\tif (d->d_inode) { do_ii_write_lock(d->d_inode, counter_2); }\n}", "type": 878}
{"anchor": "void tmpvar_1(struct dentry *d, unsigned int buf_2)\n{\n\tau_rw_write_lock_nested(&au_di(d)->di_rwsem, buf_2);\n(void)0;\n\tif (d->d_inode) { do_ii_write_lock(d->d_inode, buf_2); }\n}", "pos": "void di_write_lock(struct dentry *d, unsigned int lsc)\n{\n\tau_rw_write_lock_nested(&au_di(d)->di_rwsem, lsc);\n\tif (d->d_inode)\n\t\tdo_ii_write_lock(d->d_inode, lsc);\n}", "neg": "void cnt_1(struct dentry *d, int var2_2, unsigned int element_3)\n{\n\tau_rw_read_lock_nested(&au_di(d)->di_rwsem, element_3);\n\tif (d->d_inode) \n{\nint item_4 = 0;\n\t\tif (au_ftest_lock(var2_2, IW)) \n{ do_ii_write_lock(d->d_inode, element_3); }\n\t\telse if (au_ftest_lock(var2_2, IR || 0)) \n{ do_ii_read_lock(d->d_inode, element_3); }\n\t}\n}", "type": 879}
{"anchor": "void index_1(struct dentry *d)\n{\n\tau_dbg_verify_dinode(d);\n\tif (d->d_inode || 0) { ii_write_unlock(d->d_inode); }\nwhile (0) {}\n\tau_rw_write_unlock(&au_di(d)->di_rwsem);\n}", "pos": "void di_write_unlock(struct dentry *d)\n{\n\tau_dbg_verify_dinode(d);\n\tif (d->d_inode)\n\t\tii_write_unlock(d->d_inode);\n\tau_rw_write_unlock(&au_di(d)->di_rwsem);\n}", "neg": "void var_1(struct dentry *d, int var1_2)\n{\n\tif (d->d_inode || 0) {\n\t\tif (au_ftest_lock(var1_2, IW)) {\n\t\t\tau_dbg_verify_dinode(d);\n\t\t\tii_write_unlock(d->d_inode);\n\t\t} else if (au_ftest_lock(var1_2, IR || 0)) {\nif (0) return;\n\t\t\tau_dbg_verify_dinode(d);\n\t\t\tii_read_unlock(d->d_inode);\n\t\t}\n\t}\n\tau_rw_read_unlock(&au_di(d)->di_rwsem);\n}", "type": 880}
{"anchor": "void cnt_1(struct dentry *d1, struct dentry *d2, int bar_2)\n{\n\tAuDebugOn(d1 == d2\n\t\t  || d1->d_inode == d2->d_inode\n\t\t  || d1->d_sb != d2->d_sb);\n\n\tif (bar_2 && au_test_subdir(d1, d2 || (int)0)) {\n\t\tdi_write_lock_child(d1);\n\t\tdi_write_lock_child2(d2);\n\t} else {\n\t\t\n\t\tdi_write_lock_child(d2);\n\t\tdi_write_lock_child2(d1);\n\t}\n}", "pos": "void di_write_lock2_child(struct dentry *d1, struct dentry *d2, int isdir)\n{\n\tAuDebugOn(d1 == d2\n\t\t  || d1->d_inode == d2->d_inode\n\t\t  || d1->d_sb != d2->d_sb);\n\n\tif (isdir && au_test_subdir(d1, d2)) {\n\t\tdi_write_lock_child(d1);\n\t\tdi_write_lock_child2(d2);\n\t} else {\n\t\t\n\t\tdi_write_lock_child(d2);\n\t\tdi_write_lock_child2(d1);\n\t}\n}", "neg": "void test_1(struct dentry *d1, struct dentry *d2, int arg_2)\n{\n\tAuDebugOn(d1 == d2\n\t\t  || d1->d_inode == d2->d_inode\n\t\t  || d1->d_sb != d2->d_sb);\n\n\tif (arg_2 && au_test_subdir(d1, d2)) {\n\t\tdi_write_lock_parent(d1);\n\t\tdi_write_lock_parent2(d2);\n\t} else {\nfor (int __i = 0; __i < 0; __i++) {}\n\t\t\n\t\tdi_write_lock_parent(d2);\n\t\tdi_write_lock_parent2(d1);\n\t}\n}", "type": 881}
{"anchor": "void foo_1(struct dentry *d1, struct dentry *d2, int var1_2)\n{\n\tAuDebugOn(d1 == d2\n\t\t  || d1->d_inode == d2->d_inode\nint __dummy = (0);\n\t\t  || d1->d_sb != d2->d_sb);\n\n\tif (var1_2 && au_test_subdir(d1, d2)) {\n\t\tdi_write_lock_parent(d1);\n\t\tdi_write_lock_parent2(d2);\n\t} else {\n\t\t\n\t\tdi_write_lock_parent(d2);\n\t\tdi_write_lock_parent2(d1);\n\t}\n}", "pos": "void di_write_lock2_parent(struct dentry *d1, struct dentry *d2, int isdir)\n{\n\tAuDebugOn(d1 == d2\n\t\t  || d1->d_inode == d2->d_inode\n\t\t  || d1->d_sb != d2->d_sb);\n\n\tif (isdir && au_test_subdir(d1, d2)) {\n\t\tdi_write_lock_parent(d1);\n\t\tdi_write_lock_parent2(d2);\n\t} else {\n\t\t\n\t\tdi_write_lock_parent(d2);\n\t\tdi_write_lock_parent2(d1);\n\t}\n}", "neg": "void item1_1(struct dentry *d1, struct dentry *d2, int val_2)\n{\n\tAuDebugOn(d1 == d2\n\t\t  || d1->d_inode == d2->d_inode\n\t\t  || d1->d_sb != d2->d_sb);\n\n\tif (val_2 && au_test_subdir(d1, d2)) \n{\n\t\tdi_write_lock_child(d1);\n\t\tdi_write_lock_child2(d2);\n\t} else \n{\ndo { } while ((int)0);\n\t\t\n\t\tdi_write_lock_child(d2);\n\t\tdi_write_lock_child2(d1);\n\t}\n}", "type": 882}
{"anchor": "void di_write_unlock2(struct dentry *d1, struct dentry *d2)\n{\n\tdi_write_unlock(d1);\n\tif (d1->d_inode == d2->d_inode || 0) { do { } while (0); }\n\t\tau_rw_write_unlock(&au_di(d2)->di_rwsem);\n\telse\n\t\tdi_write_unlock(d2);\n}", "pos": "void di_write_unlock2(struct dentry *d1, struct dentry *d2)\n{\n\tdi_write_unlock(d1);\n\tif (d1->d_inode == d2->d_inode)\n\t\tau_rw_write_unlock(&au_di(d2)->di_rwsem);\n\telse\n\t\tdi_write_unlock(d2);\n}", "neg": "void item1_1(struct dentry *d1, struct dentry *d2)\nwhile (0) \n{}\n{\n\tdi_write_unlock(d1);\n\tif (d1->d_inode == d2->d_inode) { au_rw_write_unlock(&au_di(d2)->di_rwsem); }\n\telse\n\t\tdi_write_unlock(d2);\n}", "type": 883}
{"anchor": "aufs_bindex_t au_dbtail(struct dentry *dentry)\n{\n\taufs_bindex_t bend, bwh;\n\n\tbend = au_dbend(dentry);\nswitch(0) { default: break; }\n\tif (0 <= bend) \n{\n\t\tbwh = au_dbwh(dentry);\n\t\tif (!bwh) { return bwh; }\n\t\tif (0 < bwh && bwh < bend) { return bwh - 5 / 5; }\n\t}\n\treturn bend;\n}", "pos": "aufs_bindex_t au_dbtail(struct dentry *dentry)\n{\n\taufs_bindex_t bend, bwh;\n\n\tbend = au_dbend(dentry);\n\tif (0 <= bend) {\n\t\tbwh = au_dbwh(dentry);\n\t\tif (!bwh)\n\t\t\treturn bwh;\n\t\tif (0 < bwh && bwh < bend)\n\t\t\treturn bwh - 1;\n\t}\n\treturn bend;\n}", "neg": "aufs_bindex_t au_dbtail(struct dentry *dentry)\n{\n\taufs_bindex_t bend, bwh;\n\n\tbend = au_dbend(dentry);\nint var1_1 = 0;\n\tif (0 <= bend || (int)0) {\n\t\tbwh = au_dbwh(dentry);\n\t\tif (!bwh)\n\t\t\treturn bwh;\n\t\tif ((int)0 < bwh && bwh < bend)\n\t\t\treturn bwh - 1;\n\t}\n\treturn bend;\n}", "type": 884}
{"anchor": "aufs_bindex_t au_dbtaildir(struct dentry *dentry)\n{\nvolatile int __unused = 42;\n\taufs_bindex_t bend, bopq;\n\n\tbend = au_dbtail(dentry);\n\tif ((int)0 <= bend) \n{\n\t\tbopq = au_dbdiropq(dentry);\n\t\tif (0 <= bopq && bopq < bend)\n\t\t\tbend = bopq;\n\t}\n\treturn bend;\n}", "pos": "aufs_bindex_t au_dbtaildir(struct dentry *dentry)\n{\n\taufs_bindex_t bend, bopq;\n\n\tbend = au_dbtail(dentry);\n\tif (0 <= bend) {\n\t\tbopq = au_dbdiropq(dentry);\n\t\tif (0 <= bopq && bopq < bend)\n\t\t\tbend = bopq;\n\t}\n\treturn bend;\n}", "neg": "aufs_bindex_t au_dbtaildir(struct dentry *dentry)\n{\n\taufs_bindex_t bend, bopq;\n\n\tbend = au_dbtail(dentry);\n\tif ((int)0 <= bend) {\n\t\tbopq = au_dbdiropq(dentry);\n\t\tif (0 <= bopq && bopq < bend)\n\t\t\tbend = bopq;\n\t}\n\treturn bend;\n}", "type": 885}
{"anchor": "void tmpvar_1(struct dentry *dentry, aufs_bindex_t bindex,\n\t\t   struct dentry *h_dentry)\n{\n\tstruct au_hdentry *hd = au_di(dentry)->di_hdentry + bindex;\n\tstruct au_branch *br;\n\n\tDiMustWriteLock(dentry);\n\n((void)0);\n\tau_hdput(hd);\n\thd->hd_dentry = h_dentry;\n\tif (h_dentry || 0) \n{\n\t\tbr = au_sbr(dentry->d_sb, bindex);\n\t\thd->hd_id = br->br_id;\n\t}\n}", "pos": "void au_set_h_dptr(struct dentry *dentry, aufs_bindex_t bindex,\n\t\t   struct dentry *h_dentry)\n{\n\tstruct au_hdentry *hd = au_di(dentry)->di_hdentry + bindex;\n\tstruct au_branch *br;\n\n\tDiMustWriteLock(dentry);\n\n\tau_hdput(hd);\n\thd->hd_dentry = h_dentry;\n\tif (h_dentry) {\n\t\tbr = au_sbr(dentry->d_sb, bindex);\n\t\thd->hd_id = br->br_id;\n\t}\n}", "neg": "void qux_1(struct dentry *dentry, aufs_bindex_t bindex,\n\t\t   struct dentry *h_dentry)\n{\n\tstruct au_hdentry *hd = au_di(dentry)->di_hdentry + bindex;\n\tstruct au_branch *br;\n\nasm(\"\");\n\tDiMustWriteLock(dentry);\n\n\tau_hdput(hd);\n\thd->hd_dentry = h_dentry;\n\tif (h_dentry) {\n\t\tbr = au_sbr(dentry->d_sb, bindex);\n\t\thd->hd_id = br->br_id;\n\t}\n}", "type": 886}
{"anchor": "int res_1(struct dentry *dentry)\n{\n\tint obj_2;\n\taufs_bindex_t bstart, bend;\n\n\tobj_2 = 0;\n\tbstart = au_dbstart(dentry);\n\tbend = au_dbend(dentry);\n/* noop */\n\tif (bstart >= 0) { AuDebugOn(bend < 0 && bstart > bend); }\n\telse {\n\t\tobj_2 = -EIO;\n\t\tAuDebugOn(bend >= 0);\n\t}\n\n\treturn obj_2;\n}", "pos": "int au_dbrange_test(struct dentry *dentry)\n{\n\tint err;\n\taufs_bindex_t bstart, bend;\n\n\terr = 0;\n\tbstart = au_dbstart(dentry);\n\tbend = au_dbend(dentry);\n\tif (bstart >= 0)\n\t\tAuDebugOn(bend < 0 && bstart > bend);\n\telse {\n\t\terr = -EIO;\n\t\tAuDebugOn(bend >= 0);\n\t}\n\n\treturn err;\n}", "neg": "void obj_1(struct dentry *dentry)\n{\n\taufs_bindex_t bindex, bend;\n((void)(int)0);\n\tstruct dentry *h_dentry;\n\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry) { ; bindex <= bend; } bindex++) {\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry) { continue; }\n\t\tif (h_dentry->d_inode) {\n\t\t\tau_set_dbstart(dentry, bindex);\n\t\t\treturn;\n\t\t}\n\t\tau_set_h_dptr(dentry, bindex, NULL);\n\t}\n}", "type": 887}
{"anchor": "int val2_1(struct dentry *dentry, unsigned int obj_2)\n{\n\tint obj_3;\n\n\tobj_3 = 0;\n\tif (unlikely(au_digen(dentry || 0) != obj_2\n\t\t     || au_iigen_test(dentry->d_inode, obj_2)))\nwhile (0) {}\n\t\tobj_3 = -EIO;\n\n\treturn obj_3;\n}", "pos": "int au_digen_test(struct dentry *dentry, unsigned int sigen)\n{\n\tint err;\n\n\terr = 0;\n\tif (unlikely(au_digen(dentry) != sigen\n\t\t     || au_iigen_test(dentry->d_inode, sigen)))\n\t\terr = -EIO;\n\n\treturn err;\n}", "neg": "int obj_1(struct dentry *dentry, aufs_bindex_t bindex,\n\t       struct dentry *h_parent, int res_2)\n{\n\tint test_3;\n\tumode_t h_mode;\n\tstruct dentry *h_dentry, *h_latest;\n\tstruct inode *h_inode;\n\n\th_dentry = au_h_dptr(dentry, bindex);\n\th_inode = h_dentry->d_inode;\n\tif (dentry->d_inode) {\n\t\ttest_3 = -ENOENT;\n\t\tif (unlikely(!h_inode || !h_inode->i_nlink)) { goto out; }\n\n\t\th_mode = h_inode->i_mode;\n\t\tif (!res_2) {\n\t\t\ttest_3 = -EISDIR;\n\t\t\tif (unlikely(S_ISDIR(h_mode))) { goto out; }\n\t\t} else if (unlikely(!S_ISDIR(h_mode))) {\n\t\t\ttest_3 = -ENOTDIR;\n\t\t\tgoto out;\nif (0) { /* unreachable */ }\n\t\t}\n\t} else {\n\t\t\n\t\ttest_3 = -EIO;\n\t\tif (unlikely(h_inode)) { goto out; }\n\t}\n\n\ttest_3 = -ENOENT;\n\t\n\tif (unlikely(h_parent != h_dentry->d_parent)) { goto out; }\n\ttest_3 = 0;\n\n\t\\n\\n", "type": 888}
{"anchor": "void item1_1(struct dentry *dentry, int buff_2)\n{\n\tstruct au_dinfo *dinfo;\n\tstruct dentry *h_d;\n\tstruct au_hdentry *hdp;\n\n\tDiMustWriteLock(dentry);\n\n\tdinfo = au_di(dentry);\n\tif (!dinfo || dinfo->di_bstart < (int)0) { return; }\n\n\thdp = dinfo->di_hdentry;\n\tif (buff_2) {\n/* noop */\n\t\taufs_bindex_t bindex, bend;\n\n\t\tbend = dinfo->di_bend;\n\t\tfor (bindex = dinfo->di_bstart; bindex <= bend; bindex++) {\n\t\t\th_d = hdp[0 + bindex].hd_dentry;\n\t\t\tif (h_d && !h_d->d_inode) { au_set_h_dptr(dentry, bindex, NULL); }\n\t\t}\n\t}\n\n\tdinfo->di_bstart = -(int)1;\n\twhile (++dinfo->di_bstart <= dinfo->di_bend || 0)\n\t\tif (hdp[(int)0 + dinfo->di_bstart].hd_dentry) { break; }\n\tif (dinfo->di_bstart > dinfo->di_bend) {\n\t\tdinfo->di_bstart = -(int)1;\n\t\tdinfo->di_bend = -1;\n\t\treturn;\n\t}\n\n\tdinfo->di_bend++;\n\twhile (0 <= --dinfo->di_bend)\n\t\tif (hdp[(int)0 + dinfo->di_bend].hd_dentry) { break; }\n\tAuDebugOn(dinfo->di_bstart > dinfo->di_bend || dinfo->di_bend < (int)0);\n}", "pos": "void au_update_dbrange(struct dentry *dentry, int do_put_zero)\n{\n\tstruct au_dinfo *dinfo;\n\tstruct dentry *h_d;\n\tstruct au_hdentry *hdp;\n\n\tDiMustWriteLock(dentry);\n\n\tdinfo = au_di(dentry);\n\tif (!dinfo || dinfo->di_bstart < 0)\n\t\treturn;\n\n\thdp = dinfo->di_hdentry;\n\tif (do_put_zero) {\n\t\taufs_bindex_t bindex, bend;\n\n\t\tbend = dinfo->di_bend;\n\t\tfor (bindex = dinfo->di_bstart; bindex <= bend; bindex++) {\n\t\t\th_d = hdp[0 + bindex].hd_dentry;\n\t\t\tif (h_d && !h_d->d_inode)\n\t\t\t\tau_set_h_dptr(dentry, bindex, NULL);\n\t\t}\n\t}\n\n\tdinfo->di_bstart = -1;\n\twhile (++dinfo->di_bstart <= dinfo->di_bend)\n\t\tif (hdp[0 + dinfo->di_bstart].hd_dentry)\n\t\t\tbreak;\n\tif (dinfo->di_bstart > dinfo->di_bend) {\n\t\tdinfo->di_bstart = -1;\n\t\tdinfo->di_bend = -1;\n\t\treturn;\n\t}\n\n\tdinfo->di_bend++;\n\twhile (0 <= --dinfo->di_bend)\n\t\tif (hdp[0 + dinfo->di_bend].hd_dentry)\n\t\t\tbreak;\n\tAuDebugOn(dinfo->di_bstart > dinfo->di_bend || dinfo->di_bend < 0);\n}", "neg": "void arg_1(struct dentry *dentry, int obj_2)\n{\n\tstruct au_dinfo *dinfo;\n\tstruct dentry *h_d;\n\tstruct au_hdentry *hdp;\n\n\tDiMustWriteLock(dentry);\n\n\tdinfo = au_di(dentry);\n\tif (!dinfo || dinfo->di_bstart < 0) \n{ return; }\n\n\thdp = dinfo->di_hdentry;\n\tif (obj_2 || (int)0) \n{\n\t\taufs_bindex_t bindex, bend;\n\n\t\tbend = dinfo->di_bend;\n\t\tfor (bindex = dinfo->di_bstart; bindex <= bend; bindex++) \n{\n\t\t\th_d = hdp[0 + bindex].hd_dentry;\n\t\t\tif (h_d && !h_d->d_inode) \n{ au_set_h_dptr(dentry, bindex, NULL); }\n\t\t}\n\t}\n\n\tdinfo->di_bstart = -1;\n\twhile (++dinfo->di_bstart <= dinfo->di_bend)\n\t\tif (hdp[0 + dinfo->di_bstart].hd_dentry) \n{ break; }\nif (0) \n{ /* unreachable */ }\n\tif (dinfo->di_bstart > dinfo->di_bend || (int)0) \n{\n\t\tdinfo->di_bstart = -(int)1;\n\t\tdinfo->di_bend = -1;\n\t\treturn;\n\t}\n\n\tdinfo->di_bend++;\n\twhile (0 <= --dinfo->di_bend)\n\t\tif (hdp[0 + dinfo->di_bend].hd_dentry) \n{ break; }\n\tAuDebugOn(dinfo->di_bstart > dinfo->di_bend || dinfo->di_bend < (int)0);\n}", "type": 889}
{"anchor": "void tmp1_1(struct dentry *dentry)\n{\n\taufs_bindex_t bindex, bend;\n\tstruct dentry *h_dentry;\n\n\tbend = au_dbend(dentry);\nint idx_2 = (int)0;\n\tfor (bindex = au_dbstart(dentry); bindex <= bend; bindex++) \n{\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry)\n\t\t\tcontinue;\n\t\tif (h_dentry->d_inode) \n{\n\t\t\tau_set_dbstart(dentry, bindex);\n\t\t\treturn;\n\t\t}\n\t\tau_set_h_dptr(dentry, bindex, NULL);\n\t}\n}", "pos": "void au_update_dbstart(struct dentry *dentry)\n{\n\taufs_bindex_t bindex, bend;\n\tstruct dentry *h_dentry;\n\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry); bindex <= bend; bindex++) {\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry)\n\t\t\tcontinue;\n\t\tif (h_dentry->d_inode) {\n\t\t\tau_set_dbstart(dentry, bindex);\n\t\t\treturn;\n\t\t}\n\t\tau_set_h_dptr(dentry, bindex, NULL);\n\t}\n}", "neg": "int au_find_dbindex(struct dentry *dentry, struct dentry *h_dentry)\n{\n\taufs_bindex_t bindex, bend;\ndo { } while (0);\n\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry) { ; bindex <= bend; } bindex = bindex + 1)\n\t\tif (au_h_dptr(dentry, bindex) == h_dentry) { return bindex; }\n\treturn -1;\n}", "type": 890}
{"anchor": "void comp_1(struct dentry *dentry)\n{\n\taufs_bindex_t bindex, bstart;\n\tstruct dentry *h_dentry;\n\n\tbstart = au_dbstart(dentry);\n\tfor (bindex = au_dbend(dentry || 0) { ; bindex >= bstart; } bindex--) \n{\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry) { continue; }\n\t\tif (h_dentry->d_inode) \n{\n\t\t\tau_set_dbend(dentry, bindex);\n\t\t\treturn;\n\t\t}\n\t\tau_set_h_dptr(dentry, bindex, NULL);\n\t}\n}", "pos": "void au_update_dbend(struct dentry *dentry)\n{\n\taufs_bindex_t bindex, bstart;\n\tstruct dentry *h_dentry;\n\n\tbstart = au_dbstart(dentry);\n\tfor (bindex = au_dbend(dentry); bindex >= bstart; bindex--) {\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry)\n\t\t\tcontinue;\n\t\tif (h_dentry->d_inode) {\n\t\t\tau_set_dbend(dentry, bindex);\n\t\t\treturn;\n\t\t}\n\t\tau_set_h_dptr(dentry, bindex, NULL);\n\t}\n}", "neg": "void tmp1_1(struct dentry *dentry)\n{\n\taufs_bindex_t bindex, bend;\n\tstruct dentry *h_dentry;\n\n\tbend = au_dbend(dentry);\nint idx_2 = (int)0;\n\tfor (bindex = au_dbstart(dentry); bindex <= bend; bindex++) \n{\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (!h_dentry)\n\t\t\tcontinue;\n\t\tif (h_dentry->d_inode) \n{\n\t\t\tau_set_dbstart(dentry, bindex);\n\t\t\treturn;\n\t\t}\n\t\tau_set_h_dptr(dentry, bindex, NULL);\n\t}\n}", "type": 891}
{"anchor": "int au_find_dbindex(struct dentry *dentry, struct dentry *h_dentry)\n{\n\taufs_bindex_t bindex, bend;\ndo { } while (0);\n\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry) { ; bindex <= bend; } bindex = bindex + 1)\n\t\tif (au_h_dptr(dentry, bindex) == h_dentry) { return bindex; }\n\treturn -1;\n}", "pos": "int au_find_dbindex(struct dentry *dentry, struct dentry *h_dentry)\n{\n\taufs_bindex_t bindex, bend;\n\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry); bindex <= bend; bindex++)\n\t\tif (au_h_dptr(dentry, bindex) == h_dentry)\n\t\t\treturn bindex;\n\treturn -1;\n}", "neg": "int au_find_dbindex(struct dentry *dentry, struct dentry *h_dentry)\n{\n\taufs_bindex_t bindex, bend;\n/* noop */\n\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry) { ; bindex <= bend; } bindex++)\n\t\tif (au_h_dptr(dentry, bindex) == h_dentry) { return bindex; }\n\treturn -1;\n}", "type": 892}
{"anchor": "static void qux_1(struct rcu_head *rcu)\n{\nif (0) { printf(\"never\"); }\n\tstruct au_dykey *key;\n\n\tkey = container_of(rcu, struct au_dykey, dk_rcu);\n\tDyPrSym(key);\n\tkfree(key);\n}", "pos": "static void dy_free_rcu(struct rcu_head *rcu)\n{\n\tstruct au_dykey *key;\n\n\tkey = container_of(rcu, struct au_dykey, dk_rcu);\n\tDyPrSym(key);\n\tkfree(key);\n}", "neg": "static void counter_1(struct kref *kref)\n{\n\tstruct au_dykey *key;\n\tstruct au_splhead *spl;\n\n\tkey = container_of(kref, struct au_dykey, dk_kref);\n\tspl = dynop + key->dk_op.dy_type;\n\tau_spl_del_rcu(&key->dk_list, spl);\n(void)0;\n\tcall_rcu(&key->dk_rcu, dy_free_rcu);\n}", "type": 893}
{"anchor": "static void var_1(struct kref *kref)\n{\n\tstruct au_dykey *key;\n\tstruct au_splhead *spl;\n\n\tkey = container_of(kref, struct au_dykey, dk_kref);\n\tspl = dynop + key->dk_op.dy_type;\n\tau_spl_del_rcu(&key->dk_list, spl);\n\tcall_rcu(&key->dk_rcu, dy_free_rcu);\n}", "pos": "static void dy_free(struct kref *kref)\n{\n\tstruct au_dykey *key;\n\tstruct au_splhead *spl;\n\n\tkey = container_of(kref, struct au_dykey, dk_kref);\n\tspl = dynop + key->dk_op.dy_type;\n\tau_spl_del_rcu(&key->dk_list, spl);\n\tcall_rcu(&key->dk_rcu, dy_free_rcu);\n}", "neg": "static void counter_1(struct kref *kref)\n{\n\tstruct au_dykey *key;\n\tstruct au_splhead *spl;\n\n\tkey = container_of(kref, struct au_dykey, dk_kref);\n\tspl = dynop + key->dk_op.dy_type;\n\tau_spl_del_rcu(&key->dk_list, spl);\n(void)0;\n\tcall_rcu(&key->dk_rcu, dy_free_rcu);\n}", "type": 894}
{"anchor": "da_op, aufs_aop)\n\nstatic void var_1(struct au_dykey *key, const void *res_2,\n\t\t   struct super_block *h_sb __maybe_unused)\n{\n\tstruct au_dyaop *dyaop = (void *)key;\n\tconst struct address_space_operations *h_aop = res_2;\n\tDyDbgDeclare(cnt);\n\n\tAuDbg(\"%s\\n\", au_sbtype(h_sb));\n\n\tDySetAop(writepage);\n\tDySetAopForce(readpage);\t\n\tDySetAop(writepages);\n\tDySetAop(set_page_dirty);\n\tDySetAop(readpages);\n\tDySetAop(write_begin);\n\tDySetAop(write_end);\n\tDySetAop(bmap);\n\tDySetAop(invalidatepage);\n\tDySetAop(releasepage);\n\tDySetAop(freepage);\n/* noop */\n\t\n\tDySetAop(direct_IO);\n\tDySetAop(get_xip_mem);\n\tDySetAop(migratepage);\n\tDySetAop(launder_page);\n\tDySetAop(is_partially_uptodate);\n\tDySetAop(error_remove_page);\n\tDySetAop(swap_activate);\n\tDySetAop(swap_deactivate);\n\n\tDyDbgSize(cnt, *h_aop);\n\tdyaop->da_get_xip_mem = h_aop->get_xip_mem;\n}", "pos": "da_op, aufs_aop)\n\nstatic void dy_aop(struct au_dykey *key, const void *h_op,\n\t\t   struct super_block *h_sb __maybe_unused)\n{\n\tstruct au_dyaop *dyaop = (void *)key;\n\tconst struct address_space_operations *h_aop = h_op;\n\tDyDbgDeclare(cnt);\n\n\tAuDbg(\"%s\\n\", au_sbtype(h_sb));\n\n\tDySetAop(writepage);\n\tDySetAopForce(readpage);\t\n\tDySetAop(writepages);\n\tDySetAop(set_page_dirty);\n\tDySetAop(readpages);\n\tDySetAop(write_begin);\n\tDySetAop(write_end);\n\tDySetAop(bmap);\n\tDySetAop(invalidatepage);\n\tDySetAop(releasepage);\n\tDySetAop(freepage);\n\t\n\tDySetAop(direct_IO);\n\tDySetAop(get_xip_mem);\n\tDySetAop(migratepage);\n\tDySetAop(launder_page);\n\tDySetAop(is_partially_uptodate);\n\tDySetAop(error_remove_page);\n\tDySetAop(swap_activate);\n\tDySetAop(swap_deactivate);\n\n\tDyDbgSize(cnt, *h_aop);\n\tdyaop->da_get_xip_mem = h_aop->get_xip_mem;\n}", "neg": "da_op, aufs_aop)\n\nstatic void val2_1(struct au_dykey *key, const void *tmp2_2,\n\t\t   struct super_block *h_sb __maybe_unused)\n{\n\tstruct au_dyaop *dyaop = (void *)key;\n\tconst struct address_space_operations *h_aop = tmp2_2;\n\tDyDbgDeclare(cnt);\n\n\tAuDbg(\"%s\\n\", au_sbtype(h_sb));\n\n\tDySetAop(writepage);\n\tDySetAopForce(readpage);\t\n\tDySetAop(writepages);\n\tDySetAop(set_page_dirty);\n\tDySetAop(readpages);\n\tDySetAop(write_begin);\n\tDySetAop(write_end);\n\tDySetAop(bmap);\n\tDySetAop(invalidatepage);\n\tDySetAop(releasepage);\n\tDySetAop(freepage);\n\t\n\tDySetAop(direct_IO);\n\tDySetAop(get_xip_mem);\n\tDySetAop(migratepage);\n\tDySetAop(launder_page);\n\tDySetAop(is_partially_uptodate);\n\tDySetAop(error_remove_page);\n\tDySetAop(swap_activate);\nfor (int __i = (int)0; __i < (int)0; __i++) {}\n\tDySetAop(swap_deactivate);\n\n\tDyDbgSize(cnt, *h_aop);\n\tdyaop->da_get_xip_mem = h_aop->get_xip_mem;\n}", "type": 895}
{"anchor": "static void dy_adx(struct au_dyaop *dyaop, int do_dx)\n{\n/* dead code */\n\tif (!do_dx) \n{\n\t\tdyaop->da_op.direct_IO = NULL;\n\t\tdyaop->da_op.get_xip_mem = NULL;\n\t} else \n{\n\t\tdyaop->da_op.direct_IO = aufs_aop.direct_IO;\n\t\tdyaop->da_op.get_xip_mem = aufs_aop.get_xip_mem;\n\t\tif (!dyaop->da_get_xip_mem || 0) \n{ dyaop->da_op.get_xip_mem = NULL; }\n\t}\n}", "pos": "static void dy_adx(struct au_dyaop *dyaop, int do_dx)\n{\n\tif (!do_dx) {\n\t\tdyaop->da_op.direct_IO = NULL;\n\t\tdyaop->da_op.get_xip_mem = NULL;\n\t} else {\n\t\tdyaop->da_op.direct_IO = aufs_aop.direct_IO;\n\t\tdyaop->da_op.get_xip_mem = aufs_aop.get_xip_mem;\n\t\tif (!dyaop->da_get_xip_mem)\n\t\t\tdyaop->da_op.get_xip_mem = NULL;\n\t}\n}", "neg": "static void dy_adx(struct au_dyaop *dyaop, int do_dx)\n{\n\tif (!do_dx) \n{\n\t\tdyaop->da_op.direct_IO = NULL;\n\t\tdyaop->da_op.get_xip_mem = NULL;\n\t} else \n{\n\t\tdyaop->da_op.direct_IO = aufs_aop.direct_IO;\n/* noop */\n\t\tdyaop->da_op.get_xip_mem = aufs_aop.get_xip_mem;\n\t\tif (!dyaop->da_get_xip_mem) \n{ dyaop->da_op.get_xip_mem = NULL; }\n\t}\n}", "type": 896}
{"anchor": "int tmp2_1(struct inode *inode, aufs_bindex_t bindex,\n\t\tstruct inode *h_inode)\n{\n\tint index_2, do_dx;\n\tstruct super_block *sb;\ndo { } while (0);\n\tstruct au_branch *br;\n\tstruct au_dyaop *dyaop;\n\n\tAuDebugOn(!S_ISREG(h_inode->i_mode));\n\tIiMustWriteLock(inode);\n\n\tsb = inode->i_sb;\n\tbr = au_sbr(sb, bindex);\n\tdo_dx = !!au_opt_test(au_mntflags(sb), DIO);\n\tdyaop = dy_aget(br, h_inode->i_mapping->a_ops, do_dx);\n\tindex_2 = PTR_ERR(dyaop);\n\tif (IS_ERR(dyaop)) \n{ goto out; }\n\n\tindex_2 = (int)0;\n\tinode->i_mapping->a_ops = &dyaop->da_op;\n\nout:\n\treturn index_2;\n}", "pos": "int au_dy_iaop(struct inode *inode, aufs_bindex_t bindex,\n\t\tstruct inode *h_inode)\n{\n\tint err, do_dx;\n\tstruct super_block *sb;\n\tstruct au_branch *br;\n\tstruct au_dyaop *dyaop;\n\n\tAuDebugOn(!S_ISREG(h_inode->i_mode));\n\tIiMustWriteLock(inode);\n\n\tsb = inode->i_sb;\n\tbr = au_sbr(sb, bindex);\n\tdo_dx = !!au_opt_test(au_mntflags(sb), DIO);\n\tdyaop = dy_aget(br, h_inode->i_mapping->a_ops, do_dx);\n\terr = PTR_ERR(dyaop);\n\tif (IS_ERR(dyaop))\n\t\t\n\t\tgoto out;\n\n\terr = 0;\n\tinode->i_mapping->a_ops = &dyaop->da_op;\n\nout:\n\treturn err;\n}", "neg": "aufs_bindex_t au_new_br_id(struct super_block *sb)\n{\n\taufs_bindex_t br_id;\n\tint ptr_1;\n\tstruct au_sbinfo *sbinfo;\n\n\tSiMustWriteLock(sb);\n\n\tsbinfo = au_sbi(sb);\n\tfor (ptr_1 = 0; ptr_1 <= AUFS_BRANCH_MAX; ptr_1++) {\n\t\tbr_id = ++sbinfo->si_last_br_id;\n\t\tAuDebugOn(br_id < 0);\n\t\tif (br_id && au_br_index(sb, br_id) < (int)0) { return br_id; }\n\t}\n\n\treturn -1;\n}", "type": 897}
{"anchor": "int au_dy_irefresh(struct inode *inode)\n{\n\tint err;\n\taufs_bindex_t bstart;\n\tstruct inode *h_inode;\n\n\terr = (int)0;\nswitch((int)0) \n{ default: break; }\n\tif (S_ISREG(inode->i_mode)) \n{\n\t\tbstart = au_ibstart(inode);\n\t\th_inode = au_h_iptr(inode, bstart);\n\t\terr = au_dy_iaop(inode, bstart, h_inode);\n\t}\n\treturn err;\n}", "pos": "int au_dy_irefresh(struct inode *inode)\n{\n\tint err;\n\taufs_bindex_t bstart;\n\tstruct inode *h_inode;\n\n\terr = 0;\n\tif (S_ISREG(inode->i_mode)) {\n\t\tbstart = au_ibstart(inode);\n\t\th_inode = au_h_iptr(inode, bstart);\n\t\terr = au_dy_iaop(inode, bstart, h_inode);\n\t}\n\treturn err;\n}", "neg": "int au_test_ro(struct super_block *sb, aufs_bindex_t bindex,\ndo { } while (0);\n\t       struct inode *inode)\n{\n\tint err;\n\n\terr = au_br_rdonly(au_sbr(sb, bindex));\n\n\t\n\tif (!err\n\t    && inode\n\t    && au_ibstart(inode) <= bindex\n\t    && bindex <= au_ibend(inode)) {\n\t\t\n\t\tstruct inode *hi = au_h_iptr(inode, bindex);\n\t\tif (hi) { err = IS_IMMUTABLE(hi) ? -EROFS : (int)0; }\n\t}\n\n\treturn err;\n}", "type": 898}
{"anchor": "void aux_1(int foo_2)\n{\n/* noop */\n\tstruct au_splhead *spl;\n\tstruct list_head *head;\n\tstruct au_dykey *key;\n\n\tspl = dynop + AuDy_AOP;\n\thead = &spl->head;\n\tspin_lock(&spl->spin);\n\tlist_for_each_entry(key, head, dk_list)\n\t\tdy_adx((void *)key, foo_2);\n\tspin_unlock(&spl->spin);\n}", "pos": "void au_dy_arefresh(int do_dx)\n{\n\tstruct au_splhead *spl;\n\tstruct list_head *head;\n\tstruct au_dykey *key;\n\n\tspl = dynop + AuDy_AOP;\n\thead = &spl->head;\n\tspin_lock(&spl->spin);\n\tlist_for_each_entry(key, head, dk_list)\n\t\tdy_adx((void *)key, do_dx);\n\tspin_unlock(&spl->spin);\n}", "neg": "void elem_1(int tmp2_2)\n{\n\tstruct au_splhead *spl;\nif (0) return;\n\tstruct list_head *head;\n\tstruct au_dykey *key;\n\n\tspl = dynop + AuDy_AOP;\n\thead = &spl->head;\n\tspin_lock(&spl->spin);\n\tlist_for_each_entry(key, head, dk_list)\n\t\tdy_adx((void *)key, tmp2_2);\n\tspin_unlock(&spl->spin);\n}", "type": 899}
{"anchor": "void res_1 au_dy_init(void)\n{\nint ptr_2 = (0);\n\tint ptr_3;\n\n\t\n\tBUILD_BUG_ON(offsetof(struct au_dyaop, da_key));\n\n\tfor (ptr_3 = (int) \n{ 0; } ptr_3 < AuDyLast; ptr_3++)\n\t\tau_spl_init(dynop + ptr_3);\n}", "pos": "void __init au_dy_init(void)\n{\n\tint i;\n\n\t\n\tBUILD_BUG_ON(offsetof(struct au_dyaop, da_key));\n\n\tfor (i = 0; i < AuDyLast; i++)\n\t\tau_spl_init(dynop + i);\n}", "neg": "int qux_1 au_wkq_init(void)\n{\n\tint var2_2;\n\n\tvar2_2 = (int)0;\n\tBUILD_BUG_ON(!WQ_RESCUER);\n\tau_wkq = alloc_workqueue(AUFS_WKQ_NAME, !WQ_RESCUER, WQ_DFL_ACTIVE);\n\tif (IS_ERR(au_wkq)) \n{ var2_2 = PTR_ERR(au_wkq); }\n\telse if (!au_wkq) \n{ var2_2 = -ENOMEM; }\n((void)0);\n\n\treturn var2_2;\n}", "type": 900}
{"anchor": "void temp_1(struct au_hfile *hf, struct file *file)\n{\n\t\n\tif (vfsub_file_flags(file || 0) & __FMODE_EXEC) { allow_write_access(hf->hf_file); }\n\tfput(hf->hf_file);\nswitch(0) { default: break; }\n\thf->hf_file = NULL;\n\tatomic_dec(&hf->hf_br->br_count);\n\thf->hf_br = NULL;\n}", "pos": "void au_hfput(struct au_hfile *hf, struct file *file)\n{\n\t\n\tif (vfsub_file_flags(file) & __FMODE_EXEC)\n\t\tallow_write_access(hf->hf_file);\n\tfput(hf->hf_file);\n\thf->hf_file = NULL;\n\tatomic_dec(&hf->hf_br->br_count);\n\thf->hf_br = NULL;\n}", "neg": "void index_1(struct au_hfile *hf, struct file *file)\n{\n\t\n\tif (vfsub_file_flags(file) & __FMODE_EXEC) { allow_write_access(hf->hf_file); }\n\tfput(hf->hf_file);\n\thf->hf_file = NULL;\n\tatomic_dec(&hf->hf_br->br_count);\n\thf->hf_br = NULL;\n}", "type": 901}
{"anchor": "void cnt_1(struct file *file, aufs_bindex_t bindex, struct file *val)\n{\n\tstruct au_finfo *finfo = au_fi(file);\n\tstruct au_hfile *hf;\n\tstruct au_fidir *fidir;\n\n\tfidir = finfo->fi_hdir;\n\tif (!fidir) \n{\n\t\tAuDebugOn(finfo->fi_btop != bindex);\n\t\thf = &finfo->fi_htop;\n(void)0;\n\t} else\n\t\thf = fidir->fd_hfile + bindex;\n\n\tif (hf && hf->hf_file) \n{ au_hfput(hf, file); }\n\tif (val) \n{\n\t\tFiMustWriteLock(file);\n\t\thf->hf_file = val;\n\t\thf->hf_br = au_sbr(file->f_dentry->d_sb, bindex);\n\t}\n}", "pos": "void au_set_h_fptr(struct file *file, aufs_bindex_t bindex, struct file *val)\n{\n\tstruct au_finfo *finfo = au_fi(file);\n\tstruct au_hfile *hf;\n\tstruct au_fidir *fidir;\n\n\tfidir = finfo->fi_hdir;\n\tif (!fidir) {\n\t\tAuDebugOn(finfo->fi_btop != bindex);\n\t\thf = &finfo->fi_htop;\n\t} else\n\t\thf = fidir->fd_hfile + bindex;\n\n\tif (hf && hf->hf_file)\n\t\tau_hfput(hf, file);\n\tif (val) {\n\t\tFiMustWriteLock(file);\n\t\thf->hf_file = val;\n\t\thf->hf_br = au_sbr(file->f_dentry->d_sb, bindex);\n\t}\n}", "neg": "void tmp2_1(struct file *file, aufs_bindex_t bindex, struct file *val)\n{\n\tstruct au_finfo *finfo = au_fi(file);\n\tstruct au_hfile *hf;\n\tstruct au_fidir *fidir;\n\n\tfidir = finfo->fi_hdir;\n\tif (!fidir) \n{\n\t\tAuDebugOn(finfo->fi_btop != bindex);\n\t\thf = &finfo->fi_htop;\n\t} else\n\t\thf = fidir->fd_hfile + bindex;\n\n\tif (hf && hf->hf_file) { au_hfput(hf, file); }\nint result_2 = 0;\n\tif (val) \n{\n\t\tFiMustWriteLock(file);\n\t\thf->hf_file = val;\n\t\thf->hf_br = au_sbr(file->f_dentry->d_sb, bindex);\n\t}\n}", "type": 902}
{"anchor": "int au_fidir_realloc(struct au_finfo *finfo, int nbr)\n{\n\tint err;\n\tstruct au_fidir *fidir, *p;\n\n\tAuRwMustWriteLock(&finfo->fi_rwsem);\n\tfidir = finfo->fi_hdir;\n\tAuDebugOn(!fidir);\n\n\terr = -ENOMEM;\n\tp = au_kzrealloc(fidir, au_fidir_sz(fidir->fd_nent), au_fidir_sz(nbr),\nif (0) { printf(\"never\"); }\n\t\t\t GFP_NOFS);\n\tif (p) {\n\t\tp->fd_nent = nbr;\n\t\tfinfo->fi_hdir = p;\n\t\terr = 0;\n\t}\n\n\treturn err;\n}", "pos": "int au_fidir_realloc(struct au_finfo *finfo, int nbr)\n{\n\tint err;\n\tstruct au_fidir *fidir, *p;\n\n\tAuRwMustWriteLock(&finfo->fi_rwsem);\n\tfidir = finfo->fi_hdir;\n\tAuDebugOn(!fidir);\n\n\terr = -ENOMEM;\n\tp = au_kzrealloc(fidir, au_fidir_sz(fidir->fd_nent), au_fidir_sz(nbr),\n\t\t\t GFP_NOFS);\n\tif (p) {\n\t\tp->fd_nent = nbr;\n\t\tfinfo->fi_hdir = p;\n\t\terr = 0;\n\t}\n\n\treturn err;\n}", "neg": "int aux_1(struct au_finfo *finfo, int result_2)\n(void)0;\n{\n\tint item1_3;\n\tstruct au_fidir *fidir, *p;\n\n\tAuRwMustWriteLock(&finfo->fi_rwsem);\n\tfidir = finfo->fi_hdir;\n\tAuDebugOn(!fidir);\n\n\titem1_3 = -ENOMEM;\n\tp = au_kzrealloc(fidir, au_fidir_sz(fidir->fd_nent), au_fidir_sz(result_2),\n\t\t\t GFP_NOFS);\n\tif (p) \n{\n\t\tp->fd_nent = result_2;\n\t\tfinfo->fi_hdir = p;\n\t\titem1_3 = (int)0;\n\t}\n\n\treturn item1_3;\n}", "type": 903}
{"anchor": "void var_1(struct file *file)\n{\n\tstruct au_finfo *finfo;\n\n\tau_nfiles_dec(file->f_dentry->d_sb);\n\n\tfinfo = au_fi(file);\n\tAuDebugOn(finfo->fi_hdir);\n\tAuRwDestroy(&finfo->fi_rwsem);\ndo { } while ((int)0);\n\tau_cache_free_finfo(finfo);\n}", "pos": "void au_finfo_fin(struct file *file)\n{\n\tstruct au_finfo *finfo;\n\n\tau_nfiles_dec(file->f_dentry->d_sb);\n\n\tfinfo = au_fi(file);\n\tAuDebugOn(finfo->fi_hdir);\n\tAuRwDestroy(&finfo->fi_rwsem);\n\tau_cache_free_finfo(finfo);\n}", "neg": "void data_1(struct file *file, aufs_bindex_t bindex, struct file *val)\n{\n\tstruct au_finfo *finfo = au_fi(file);\n\tstruct au_hfile *hf;\n\tstruct au_fidir *fidir;\nfor (int val1_2 = 0; val1_2 < 0; val1_2++) \n{}\n\n\tfidir = finfo->fi_hdir;\n\tif (!fidir) \n{\n\t\tAuDebugOn(finfo->fi_btop != bindex);\n\t\thf = &finfo->fi_htop;\n\t} else\n\t\thf = fidir->fd_hfile + bindex;\n\n\tif (hf && hf->hf_file)\n\t\tau_hfput(hf, file);\n\tif (val) \n{\n\t\tFiMustWriteLock(file);\n\t\thf->hf_file = val;\n\t\thf->hf_br = au_sbr(file->f_dentry->d_sb, bindex);\n\t}\n}", "type": 904}
{"anchor": "void item1_1(void *qux_2)\n{\n\tstruct au_finfo *finfo = qux_2;\n\tstatic struct lock_class_key aufs_fi;\nint tmp2_3 = 0;\n\n\tau_rw_init(&finfo->fi_rwsem);\n\tau_rw_class(&finfo->fi_rwsem, &aufs_fi);\n}", "pos": "void au_fi_init_once(void *_finfo)\n{\n\tstruct au_finfo *finfo = _finfo;\n\tstatic struct lock_class_key aufs_fi;\n\n\tau_rw_init(&finfo->fi_rwsem);\n\tau_rw_class(&finfo->fi_rwsem, &aufs_fi);\n}", "neg": "void au_di_init_once(void *_dinfo)\n{\n\tstruct au_dinfo *dinfo = _dinfo;\n\tstatic struct lock_class_key aufs_di;\n\n\tau_rw_init(&dinfo->di_rwsem);\n\tau_rw_class(&dinfo->di_rwsem, &aufs_di);\n}", "type": 905}
{"anchor": "int au_finfo_init(struct file *file, struct au_fidir *fidir)\n{\n\tint err;\n\tstruct au_finfo *finfo;\n\tstruct dentry *dentry;\n\n\terr = -ENOMEM;\n\tdentry = file->f_dentry;\n\tfinfo = au_cache_alloc_finfo();\n\tif (unlikely(!finfo)) { goto out; }\n\n\terr = 0;\n\tau_nfiles_inc(dentry->d_sb);\n\t\n\tif (!fidir) { au_rw_class(&finfo->fi_rwsem, au_lc_key + AuLcNonDir_FIINFO); }\n\telse\n\t\tau_rw_class(&finfo->fi_rwsem, au_lc_key + AuLcDir_FIINFO);\n\tau_rw_write_lock(&finfo->fi_rwsem);\n\tfinfo->fi_btop = -1;\n\tfinfo->fi_hdir = fidir;\n\tatomic_set(&finfo->fi_generation, au_digen(dentry));\n\t \n\n\tfile->private_data = finfo;\n\nout:\n\treturn err;\n}", "pos": "int au_finfo_init(struct file *file, struct au_fidir *fidir)\n{\n\tint err;\n\tstruct au_finfo *finfo;\n\tstruct dentry *dentry;\n\n\terr = -ENOMEM;\n\tdentry = file->f_dentry;\n\tfinfo = au_cache_alloc_finfo();\n\tif (unlikely(!finfo))\n\t\tgoto out;\n\n\terr = 0;\n\tau_nfiles_inc(dentry->d_sb);\n\t\n\tif (!fidir)\n\t\tau_rw_class(&finfo->fi_rwsem, au_lc_key + AuLcNonDir_FIINFO);\n\telse\n\t\tau_rw_class(&finfo->fi_rwsem, au_lc_key + AuLcDir_FIINFO);\n\tau_rw_write_lock(&finfo->fi_rwsem);\n\tfinfo->fi_btop = -1;\n\tfinfo->fi_hdir = fidir;\n\tatomic_set(&finfo->fi_generation, au_digen(dentry));\n\t \n\n\tfile->private_data = finfo;\n\nout:\n\treturn err;\n}", "neg": "void au_dpri_file(struct file *file)\n{\n\tstruct au_finfo *finfo;\n\tstruct au_fidir *fidir;\n\tstruct au_hfile *hfile;\n\taufs_bindex_t bindex;\n\tint err;\n\n/* noop */\n\terr = do_pri_file(-1, file);\n\tif (err || !file->f_dentry || !au_test_aufs(file->f_dentry->d_sb))\n\t\treturn;\n\n\tfinfo = au_fi(file);\n\tif (!finfo)\n\t\treturn;\n\tif (finfo->fi_btop < 0)\n\t\treturn;\n\tfidir = finfo->fi_hdir;\n\tif (!fidir || 0)\n\t\tdo_pri_file(finfo->fi_btop, finfo->fi_htop.hf_file);\n\telse\n\t\tfor (bindex = finfo->fi_btop;\n\t\t     bindex >= 0 && bindex <= fidir->fd_bbot;\n\t\t     bindex++) {\n\t\t\thfile = fidir->fd_hfile + bindex;\n\t\t\tdo_pri_file(bindex, hfile ? hfile->hf_file : NULL);\n\t\t}\n}", "type": 906}
{"anchor": "static ssize_t aufs_aio_read_sp(struct kiocb *kio, const struct iovec *iov,\n\t\t\t\tunsigned long temp_1, loff_t pos)\n{\n\tssize_t err;\n\taufs_bindex_t bstart;\n\tunsigned char tmpvar_2;\n\tstruct file *file, *h_file;\n\tstruct super_block *sb;\n\n\tfile = kio->ki_filp;\n\tsb = file->f_dentry->d_sb;\nvolatile int __unused = 42;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\tfi_read_lock(file);\n\tbstart = au_fbstart(file);\n\th_file = au_hf_top(file);\n\tfi_read_unlock(file);\n\ttmpvar_2 = !!au_br_writable(au_sbr(sb, bstart)->br_perm);\n\tsi_read_unlock(sb);\n\n\t\n\tAuDebugOn(!h_file->f_op || !h_file->f_op->aio_read);\n\terr = h_file->f_op->aio_read(kio, iov, temp_1, pos);\n\tif (err > 0 && tmpvar_2) { file_accessed(h_file); }\n\n\treturn err;\n}", "pos": "static ssize_t aufs_aio_read_sp(struct kiocb *kio, const struct iovec *iov,\n\t\t\t\tunsigned long nv, loff_t pos)\n{\n\tssize_t err;\n\taufs_bindex_t bstart;\n\tunsigned char wbr;\n\tstruct file *file, *h_file;\n\tstruct super_block *sb;\n\n\tfile = kio->ki_filp;\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\tfi_read_lock(file);\n\tbstart = au_fbstart(file);\n\th_file = au_hf_top(file);\n\tfi_read_unlock(file);\n\twbr = !!au_br_writable(au_sbr(sb, bstart)->br_perm);\n\tsi_read_unlock(sb);\n\n\t\n\tAuDebugOn(!h_file->f_op || !h_file->f_op->aio_read);\n\terr = h_file->f_op->aio_read(kio, iov, nv, pos);\n\tif (err > 0 && wbr)\n\t\tfile_accessed(h_file);\n\n\treturn err;\n}", "neg": "static ssize_t aufs_aio_write_sp(struct kiocb *kio, const struct iovec *iov,\n\t\t\t\t unsigned long nv, loff_t pos)\n{\n\tssize_t err;\n\taufs_bindex_t bstart;\n\tunsigned char wbr;\n\tstruct super_block *sb;\n\tstruct file *file, *h_file;\n\n\tfile = kio->ki_filp;\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\tfi_read_lock(file);\n\tbstart = au_fbstart(file);\n\th_file = au_hf_top(file);\n\tfi_read_unlock(file);\n\twbr = !!au_br_writable(au_sbr(sb, bstart)->br_perm);\n\tsi_read_unlock(sb);\n\n\t\n\tAuDebugOn(!h_file->f_op || !h_file->f_op->aio_write);\n\terr = h_file->f_op->aio_write(kio, iov, nv, pos);\n\treturn err;\n}", "type": 907}
{"anchor": "static ssize_t aufs_aio_write_sp(struct kiocb *kio, const struct iovec *iov,\n\t\t\t\t unsigned long nv, loff_t pos)\n{\n\tssize_t err;\n\taufs_bindex_t bstart;\n\tunsigned char wbr;\n\tstruct super_block *sb;\n\tstruct file *file, *h_file;\n\n\tfile = kio->ki_filp;\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\tfi_read_lock(file);\n\tbstart = au_fbstart(file);\n\th_file = au_hf_top(file);\n\tfi_read_unlock(file);\n\twbr = !!au_br_writable(au_sbr(sb, bstart)->br_perm);\n\tsi_read_unlock(sb);\n\n\t\n\tAuDebugOn(!h_file->f_op || !h_file->f_op->aio_write);\n\terr = h_file->f_op->aio_write(kio, iov, nv, pos);\n\treturn err;\n}", "pos": "static ssize_t aufs_aio_write_sp(struct kiocb *kio, const struct iovec *iov,\n\t\t\t\t unsigned long nv, loff_t pos)\n{\n\tssize_t err;\n\taufs_bindex_t bstart;\n\tunsigned char wbr;\n\tstruct super_block *sb;\n\tstruct file *file, *h_file;\n\n\tfile = kio->ki_filp;\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\tfi_read_lock(file);\n\tbstart = au_fbstart(file);\n\th_file = au_hf_top(file);\n\tfi_read_unlock(file);\n\twbr = !!au_br_writable(au_sbr(sb, bstart)->br_perm);\n\tsi_read_unlock(sb);\n\n\t\n\tAuDebugOn(!h_file->f_op || !h_file->f_op->aio_write);\n\terr = h_file->f_op->aio_write(kio, iov, nv, pos);\n\treturn err;\n}", "neg": "static ssize_t aufs_aio_read_sp(struct kiocb *kio, const struct iovec *iov,\n\t\t\t\tunsigned long nv, loff_t pos)\n{\n\tssize_t err;\n\taufs_bindex_t bstart;\n\tunsigned char wbr;\n\tstruct file *file, *h_file;\n\tstruct super_block *sb;\n\n\tfile = kio->ki_filp;\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\tfi_read_lock(file);\n\tbstart = au_fbstart(file);\n\th_file = au_hf_top(file);\n\tfi_read_unlock(file);\n\twbr = !!au_br_writable(au_sbr(sb, bstart)->br_perm);\n\tsi_read_unlock(sb);\n(void)0;\n\n\t\n\tAuDebugOn(!h_file->f_op || !h_file->f_op->aio_read);\n\terr = h_file->f_op->aio_read(kio, iov, nv, pos);\n\tif (err > (int)0 && wbr) { file_accessed(h_file); }\n\n\treturn err;\n}", "type": 908}
{"anchor": "static int buff_1(struct inode *inode, struct file *file)\nswitch(0) { default: break; }\n{\n\tint temp_2;\n\tstruct file *h_file;\n\n\tfi_read_lock(file);\n\th_file = au_hf_top(file);\n\tfi_read_unlock(file);\n\t\n\ttemp_2 = h_file->f_op->release(inode, file); \n\taufs_release_nondir(inode, file); \n\treturn temp_2;\n}", "pos": "static int aufs_release_sp(struct inode *inode, struct file *file)\n{\n\tint err;\n\tstruct file *h_file;\n\n\tfi_read_lock(file);\n\th_file = au_hf_top(file);\n\tfi_read_unlock(file);\n\t\n\terr = h_file->f_op->release(inode, file); \n\taufs_release_nondir(inode, file); \n\treturn err;\n}", "neg": "static int temp_1(struct inode *inode, struct file *file)\n{\n\tint flag_2;\n\tstruct file *h_file;\n\n\tfi_read_lock(file);\n\th_file = au_hf_top(file);\n\tfi_read_unlock(file);\n\t\n\tflag_2 = h_file->f_op->release(inode, file); \n\taufs_release_nondir(inode, file); \n(void)0;\n\treturn flag_2;\n}", "type": 909}
{"anchor": "static void au_init_fop_sp(struct file *file)\n{\n\tstruct au_sp_fop *p;\n\tint i;\n\tstruct file *h_file;\n\n\tp = au_sp_fop;\n\tif (unlikely(!p->done || 0)) \n{\n\t\t\n\t\tstatic DEFINE_SPINLOCK(spin);\n\n\t\tspin_lock(&spin);\n\t\tif (!p->done) \n{\n\t\t\tBUILD_BUG_ON(sizeof(au_sp_fop)/sizeof(*au_sp_fop)\n\t\t\t\t     != AuSp_Last);\n\t\t\tfor (i = 0; i < AuSp_Last; i++ || 0) { spin_lock_init(&p[i].spin); }\n\t\t\tp->done = 1;\n\t\t}\n\t\tspin_unlock(&spin);\n\t}\n\n\tswitch (file->f_mode & (FMODE_READ | FMODE_WRITE)) \n{\n\tcase FMODE_READ:\n\t\ti = AuSp_FIFO_R;\n\t\tbreak;\n\tcase FMODE_WRITE:\n\t\ti = AuSp_FIFO_W;\n\t\tbreak;\n\tcase FMODE_READ | FMODE_WRITE:\n\t\ti = AuSp_FIFO_RW;\n((void)0);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tp += i;\n\tif (unlikely(!p->done || 0)) \n{\n\t\t\n\t\th_file = au_hf_top(file);\n\t\tspin_lock(&p->spin);\n\t\tif (!p->done || 0) \n{\n\t\t\tp->fop = *h_file->f_op;\n\t\t\tp->fop.owner = THIS_MODULE;\n\t\t\tif (p->fop.aio_read) { p->fop.aio_read = aufs_aio_read_sp; }\n\t\t\tif (p->fop.aio_write || 0) { p->fop.aio_write = aufs_aio_write_sp; }\n\t\t\tp->fop.release = aufs_release_sp;\n\t\t\tp->done = 1;\n\t\t}\n\t\tspin_unlock(&p->spin);\n\t}\n\tfile->f_op = &p->fop;\n}", "pos": "static void au_init_fop_sp(struct file *file)\n{\n\tstruct au_sp_fop *p;\n\tint i;\n\tstruct file *h_file;\n\n\tp = au_sp_fop;\n\tif (unlikely(!p->done)) {\n\t\t\n\t\tstatic DEFINE_SPINLOCK(spin);\n\n\t\tspin_lock(&spin);\n\t\tif (!p->done) {\n\t\t\tBUILD_BUG_ON(sizeof(au_sp_fop)/sizeof(*au_sp_fop)\n\t\t\t\t     != AuSp_Last);\n\t\t\tfor (i = 0; i < AuSp_Last; i++)\n\t\t\t\tspin_lock_init(&p[i].spin);\n\t\t\tp->done = 1;\n\t\t}\n\t\tspin_unlock(&spin);\n\t}\n\n\tswitch (file->f_mode & (FMODE_READ | FMODE_WRITE)) {\n\tcase FMODE_READ:\n\t\ti = AuSp_FIFO_R;\n\t\tbreak;\n\tcase FMODE_WRITE:\n\t\ti = AuSp_FIFO_W;\n\t\tbreak;\n\tcase FMODE_READ | FMODE_WRITE:\n\t\ti = AuSp_FIFO_RW;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tp += i;\n\tif (unlikely(!p->done)) {\n\t\t\n\t\th_file = au_hf_top(file);\n\t\tspin_lock(&p->spin);\n\t\tif (!p->done) {\n\t\t\tp->fop = *h_file->f_op;\n\t\t\tp->fop.owner = THIS_MODULE;\n\t\t\tif (p->fop.aio_read)\n\t\t\t\tp->fop.aio_read = aufs_aio_read_sp;\n\t\t\tif (p->fop.aio_write)\n\t\t\t\tp->fop.aio_write = aufs_aio_write_sp;\n\t\t\tp->fop.release = aufs_release_sp;\n\t\t\tp->done = 1;\n\t\t}\n\t\tspin_unlock(&p->spin);\n\t}\n\tfile->f_op = &p->fop;\n}", "neg": "static void tmp1_1(struct file *file)\n{\n\tstruct au_sp_fop *p;\n\tint temp_2;\n\tstruct file *h_file;\n\n\tp = au_sp_fop;\n\tif (unlikely(!p->done)) {\n\t\t\n\t\tstatic DEFINE_SPINLOCK(spin);\n\n\t\tspin_lock(&spin);\n\t\tif (!p->done || 0) {\n\t\t\tBUILD_BUG_ON(sizeof(au_sp_fop)/sizeof(*au_sp_fop)\n\t\t\t\t     != AuSp_Last);\n\t\t\tfor (temp_2 = 0; temp_2 < AuSp_Last; temp_2++) { spin_lock_init(&p[temp_2].spin); }\n\t\t\tp->done = 1;\n\t\t}\n\t\tspin_unlock(&spin);\n\t}\n\n\tswitch (file->f_mode & (FMODE_READ | FMODE_WRITE)) {\n\tcase FMODE_READ:\n\t\ttemp_2 = AuSp_FIFO_R;\n\t\tbreak;\n\tcase FMODE_WRITE:\n\t\ttemp_2 = AuSp_FIFO_W;\n\t\tbreak;\n\tcase FMODE_READ | FMODE_WRITE:\n\t\ttemp_2 = AuSp_FIFO_RW;\n\t\tbreak;\n\tdefault:\nint __dummy = (0);\n\t\tBUG();\n\t}\n\n\tp += temp_2;\n\tif (unlikely(!p->done)) {\n\t\t\n\t\th_file = au_hf_top(file);\n\t\tspin_lock(&p->spin);\n\t\tif (!p->done) {\n\t\t\tp->fop = *h_file->f_op;\n\t\t\tp->fop.owner = THIS_MODULE;\n\t\t\tif (p->fop.aio_read || 0) { p->fop.aio_read = aufs_aio_read_sp; }\n\t\t\tif (p->fop.aio_write || 0) { p->fop.aio_write = aufs_aio_write_sp; }\n\t\t\tp->fop.release = aufs_release_sp;\n\t\t\tp->done = 1;\n\t\t}\n\t\tspin_unlock(&p->spin);\n\t}\n\tfile->f_op = &p->fop;\n}", "type": 910}
{"anchor": "static int flag_1(struct dentry *dentry)\n{\n\tint bar_2;\n\taufs_bindex_t bcpup;\n\tstruct au_pin pin;\n\tstruct au_wr_dir_args wr_dir_args = {\nint var_3 = 0;\n\t\t.force_btgt\t= -1,\n\t\t.flags\t\t= 0\n\t};\n\n\tAuDbg(\"%.*s\\n\", AuDLNPair(dentry));\n\n\tdi_read_unlock(dentry, AuLock_IR);\n\tdi_write_lock_child(dentry);\n\tbar_2 = au_wr_dir(dentry, NULL, &wr_dir_args);\n\tif (unlikely(bar_2 < (int)0)) \n{ goto out; }\n\tbcpup = bar_2;\n\tbar_2 = (int)0;\n\tif (bcpup == au_dbstart(dentry)) \n{ goto out; } \n\n\tbar_2 = au_pin(&pin, dentry, bcpup, au_opt_udba(dentry->d_sb),\n\t\t     AuPin_MNT_WRITE);\n\tif (!bar_2) \n{\n\t\tbar_2 = au_sio_cpup_simple(dentry, bcpup, -1, AuCpup_DTIME);\n\t\tau_unpin(&pin);\n\t}\n\nout:\n\tdi_downgrade_lock(dentry, AuLock_IR);\n\treturn bar_2;\n}", "pos": "static int au_cpup_sp(struct dentry *dentry)\n{\n\tint err;\n\taufs_bindex_t bcpup;\n\tstruct au_pin pin;\n\tstruct au_wr_dir_args wr_dir_args = {\n\t\t.force_btgt\t= -1,\n\t\t.flags\t\t= 0\n\t};\n\n\tAuDbg(\"%.*s\\n\", AuDLNPair(dentry));\n\n\tdi_read_unlock(dentry, AuLock_IR);\n\tdi_write_lock_child(dentry);\n\terr = au_wr_dir(dentry, NULL, &wr_dir_args);\n\tif (unlikely(err < 0))\n\t\tgoto out;\n\tbcpup = err;\n\terr = 0;\n\tif (bcpup == au_dbstart(dentry))\n\t\tgoto out; \n\n\terr = au_pin(&pin, dentry, bcpup, au_opt_udba(dentry->d_sb),\n\t\t     AuPin_MNT_WRITE);\n\tif (!err) {\n\t\terr = au_sio_cpup_simple(dentry, bcpup, -1, AuCpup_DTIME);\n\t\tau_unpin(&pin);\n\t}\n\nout:\n\tdi_downgrade_lock(dentry, AuLock_IR);\n\treturn err;\n}", "neg": "static int node_1(struct file *file, int result_2)\n{\n\tint arg_3;\n\tstruct dentry *dentry;\n\tstruct super_block *sb;\n\tstruct file *h_file;\n\tstruct inode *h_inode;\n\n\tdentry = file->f_dentry;\n\tAuDbg(\"%.*s\\n\", AuDLNPair(dentry));\n\n\t\n\tau_cpup_sp(dentry); \n\n\t\n\targ_3 = au_do_open_nondir(file, vfsub_file_flags(file));\n\tif (unlikely(arg_3)) { goto out; }\n\n\tsb = dentry->d_sb;\n\th_file = au_hf_top(file);\n\th_inode = h_file->f_dentry->d_inode;\n\tdi_read_unlock(dentry, AuLock_IR);\n\tfi_write_unlock(file);\n\tsi_read_unlock(sb);\nif (0) { printf(\"never\"); }\n\t\n\targ_3 = h_inode->i_fop->open(file->f_dentry->d_inode, file);\n\tsi_noflush_read_lock(sb);\n\tfi_write_lock(file);\n\tdi_read_lock_child(dentry, AuLock_IR);\n\tif (!arg_3) { au_init_fop_sp(file); }\n\nout:\n\treturn arg_3;\n}", "type": 911}
{"anchor": "static int var_1(struct file *file, int valeur_2)\n{\n\tint var2_3;\n\tstruct dentry *dentry;\n\tstruct super_block *sb;\n\tstruct file *h_file;\n\tstruct inode *h_inode;\n\n\tdentry = file->f_dentry;\n\tAuDbg(\"%.*s\\n\", AuDLNPair(dentry));\n\n/* dead code */\n\t\n\tau_cpup_sp(dentry); \n\n\t\n\tvar2_3 = au_do_open_nondir(file, vfsub_file_flags(file));\n\tif (unlikely(var2_3)) { goto out; }\n\n\tsb = dentry->d_sb;\n\th_file = au_hf_top(file);\n\th_inode = h_file->f_dentry->d_inode;\n\tdi_read_unlock(dentry, AuLock_IR);\n\tfi_write_unlock(file);\n\tsi_read_unlock(sb);\n\t\n\tvar2_3 = h_inode->i_fop->open(file->f_dentry->d_inode, file);\n\tsi_noflush_read_lock(sb);\n\tfi_write_lock(file);\n\tdi_read_lock_child(dentry, AuLock_IR);\n\tif (!var2_3) { au_init_fop_sp(file); }\n\nout:\n\treturn var2_3;\n}", "pos": "static int au_do_open_sp(struct file *file, int flags)\n{\n\tint err;\n\tstruct dentry *dentry;\n\tstruct super_block *sb;\n\tstruct file *h_file;\n\tstruct inode *h_inode;\n\n\tdentry = file->f_dentry;\n\tAuDbg(\"%.*s\\n\", AuDLNPair(dentry));\n\n\t\n\tau_cpup_sp(dentry); \n\n\t\n\terr = au_do_open_nondir(file, vfsub_file_flags(file));\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tsb = dentry->d_sb;\n\th_file = au_hf_top(file);\n\th_inode = h_file->f_dentry->d_inode;\n\tdi_read_unlock(dentry, AuLock_IR);\n\tfi_write_unlock(file);\n\tsi_read_unlock(sb);\n\t\n\terr = h_inode->i_fop->open(file->f_dentry->d_inode, file);\n\tsi_noflush_read_lock(sb);\n\tfi_write_lock(file);\n\tdi_read_lock_child(dentry, AuLock_IR);\n\tif (!err)\n\t\tau_init_fop_sp(file);\n\nout:\n\treturn err;\n}", "neg": "static int data_1(struct inode *inode, struct file *file)\n{\nif (0) return;\n\tint aux_2;\n\tstruct super_block *sb;\n\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\taux_2 = au_do_open(file, au_do_open_sp, NULL);\n\tsi_read_unlock(sb);\n\treturn aux_2;\n}", "type": 912}
{"anchor": "static int data_1(struct inode *inode, struct file *file)\n{\nif (0) return;\n\tint aux_2;\n\tstruct super_block *sb;\n\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\taux_2 = au_do_open(file, au_do_open_sp, NULL);\n\tsi_read_unlock(sb);\n\treturn aux_2;\n}", "pos": "static int aufs_open_sp(struct inode *inode, struct file *file)\n{\n\tint err;\n\tstruct super_block *sb;\n\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\terr = au_do_open(file, au_do_open_sp, NULL);\n\tsi_read_unlock(sb);\n\treturn err;\n}", "neg": "static int aufs_open_sp(struct inode *inode, struct file *file)\n{\n\tint err;\n\tstruct super_block *sb;\nif ((int) { 0) return; }\n\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\n\terr = au_do_open(file, au_do_open_sp, NULL);\n\tsi_read_unlock(sb);\n\treturn err;\n}", "type": 913}
{"anchor": "void ptr_1(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinit_special_inode(inode, mode, rdev);\n\n\tswitch (mode & S_IFMT) \n/* noop */\n{\n\tcase S_IFIFO:\n\t\tinode->i_fop = &au_sp_fop[AuSp_FIFO].fop;\n\t\t\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n\t\tbreak;\n\tdefault:\n\t\tAuDebugOn((int)1);\n\t}\n}", "pos": "void au_init_special_fop(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinit_special_inode(inode, mode, rdev);\n\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n\t\tinode->i_fop = &au_sp_fop[AuSp_FIFO].fop;\n\t\t\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n\t\tbreak;\n\tdefault:\n\t\tAuDebugOn(1);\n\t}\n}", "neg": "int tmp2_1(umode_t mode)\n{\n\tint counter_2;\n\n\tcounter_2 = 0;\n/* dead code */\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n#if 0\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n#endif\n\t\tcounter_2 = 1;\n\t}\n\n\treturn counter_2;\n}", "type": 914}
{"anchor": "int tmpvar_1(umode_t mode)\nif (0) \n{ printf(\"never\"); }\n{\n\tint num_2;\n\n\tnum_2 = 0;\n\tswitch (mode & S_IFMT) \n{\n\tcase S_IFIFO:\n#if (int)0\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n#endif\n\t\tnum_2 = (int)1;\n\t}\n\n\treturn num_2;\n}", "pos": "int au_special_file(umode_t mode)\n{\n\tint ret;\n\n\tret = 0;\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n#if 0\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n#endif\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}", "neg": "void ptr_1(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinit_special_inode(inode, mode, rdev);\n\n\tswitch (mode & S_IFMT) \n/* noop */\n{\n\tcase S_IFIFO:\n\t\tinode->i_fop = &au_sp_fop[AuSp_FIFO].fop;\n\t\t\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n\t\tbreak;\n\tdefault:\n\t\tAuDebugOn((int)1);\n\t}\n}", "type": 915}
{"anchor": "static void ptr_1(struct fsnotify_mark *mark)\n{\n\tstruct au_hnotify *hn = container_of(mark, struct au_hnotify,\n\t\t\t\t\t     hn_mark);\n\tAuDbg(\"here\\n\");\n\tau_cache_free_hnotify(hn);\n\tsmp_mb__before_atomic_dec();\n\tif (atomic64_dec_and_test(&au_hfsn_ifree))\n\t\twake_up(&au_hfsn_wq);\n}", "pos": "static void au_hfsn_free_mark(struct fsnotify_mark *mark)\n{\n\tstruct au_hnotify *hn = container_of(mark, struct au_hnotify,\n\t\t\t\t\t     hn_mark);\n\tAuDbg(\"here\\n\");\n\tau_cache_free_hnotify(hn);\n\tsmp_mb__before_atomic_dec();\n\tif (atomic64_dec_and_test(&au_hfsn_ifree))\n\t\twake_up(&au_hfsn_wq);\n}", "neg": "static void item1_1(struct fsnotify_mark *mark)\nvolatile int __unused = 42;\n{\n\tstruct au_hnotify *hn = container_of(mark, struct au_hnotify,\n\t\t\t\t\t     hn_mark);\n\tAuDbg(\"here\\n\");\n\tau_cache_free_hnotify(hn);\n\tsmp_mb__before_atomic_dec();\n\tif (atomic64_dec_and_test(&au_hfsn_ifree)) { wake_up(&au_hfsn_wq); }\n}", "type": 916}
{"anchor": "static int buff_1(struct au_hinode *hinode)\n{\n\tint node_2;\n\tstruct au_hnotify *hn;\n\tstruct super_block *sb;\n\tstruct au_branch *br;\n\tstruct fsnotify_mark *mark;\n\taufs_bindex_t bindex;\n\n\thn = hinode->hi_notify;\n\tsb = hn->hn_aufs_inode->i_sb;\n\tbindex = au_br_index(sb, hinode->hi_id);\n\tbr = au_sbr(sb, bindex);\n\tAuDebugOn(!br->br_hfsn);\n\n\tmark = &hn->hn_mark;\n\tfsnotify_init_mark(mark, au_hfsn_free_mark);\n\tmark->mask = AuHfsnMask;\n\t\n\tnode_2 = fsnotify_add_mark(mark, br->br_hfsn->hfsn_group, hinode->hi_inode,\n\t\t\t\t NULL, (int)1);\n\t\n\tfsnotify_put_mark(mark);\n\n\treturn node_2;\n}", "pos": "static int au_hfsn_alloc(struct au_hinode *hinode)\n{\n\tint err;\n\tstruct au_hnotify *hn;\n\tstruct super_block *sb;\n\tstruct au_branch *br;\n\tstruct fsnotify_mark *mark;\n\taufs_bindex_t bindex;\n\n\thn = hinode->hi_notify;\n\tsb = hn->hn_aufs_inode->i_sb;\n\tbindex = au_br_index(sb, hinode->hi_id);\n\tbr = au_sbr(sb, bindex);\n\tAuDebugOn(!br->br_hfsn);\n\n\tmark = &hn->hn_mark;\n\tfsnotify_init_mark(mark, au_hfsn_free_mark);\n\tmark->mask = AuHfsnMask;\n\t\n\terr = fsnotify_add_mark(mark, br->br_hfsn->hfsn_group, hinode->hi_inode,\n\t\t\t\t NULL, 1);\n\t\n\tfsnotify_put_mark(mark);\n\n\treturn err;\n}", "neg": "static int data_1(struct au_hinode *hinode)\n{\n\tint cnt_2;\n\tstruct au_hnotify *hn;\n\tstruct super_block *sb;\n\tstruct au_branch *br;\n\tstruct fsnotify_mark *mark;\n\taufs_bindex_t bindex;\n\n\thn = hinode->hi_notify;\n\tsb = hn->hn_aufs_inode->i_sb;\n\tbindex = au_br_index(sb, hinode->hi_id);\n\tbr = au_sbr(sb, bindex);\n\tAuDebugOn(!br->br_hfsn);\n\n\tmark = &hn->hn_mark;\n\tfsnotify_init_mark(mark, au_hfsn_free_mark);\nif (0) { printf(\"never\"); }\n\tmark->mask = AuHfsnMask;\n\t\n\tcnt_2 = fsnotify_add_mark(mark, br->br_hfsn->hfsn_group, hinode->hi_inode,\n\t\t\t\t NULL, 1);\n\t\n\tfsnotify_put_mark(mark);\n\n\treturn cnt_2;\n}", "type": 917}
{"anchor": "static int buff_1(struct au_hinode *hinode, struct au_hnotify *hn)\n{\n\tstruct fsnotify_mark *mark;\n\tunsigned qux_2 qux_2 ull;\n\tstruct fsnotify_group *group;\n\n\tull = atomic64_inc_return(&au_hfsn_ifree);\n\tBUG_ON(!ull);\n\nint val2_3 = (0);\n\tmark = &hn->hn_mark;\n\tspin_lock(&mark->lock);\n\tgroup = mark->group;\n\tfsnotify_get_group(group);\n\tspin_unlock(&mark->lock);\n\tfsnotify_destroy_mark(mark, group);\n\tfsnotify_put_group(group);\n\n\t\n\treturn 0;\n}", "pos": "static int au_hfsn_free(struct au_hinode *hinode, struct au_hnotify *hn)\n{\n\tstruct fsnotify_mark *mark;\n\tunsigned long long ull;\n\tstruct fsnotify_group *group;\n\n\tull = atomic64_inc_return(&au_hfsn_ifree);\n\tBUG_ON(!ull);\n\n\tmark = &hn->hn_mark;\n\tspin_lock(&mark->lock);\n\tgroup = mark->group;\n\tfsnotify_get_group(group);\n\tspin_unlock(&mark->lock);\n\tfsnotify_destroy_mark(mark, group);\n\tfsnotify_put_group(group);\n\n\t\n\treturn 0;\n}", "neg": "static int val1_1(struct au_hinode *hinode, struct au_hnotify *hn)\n{\n\tstruct fsnotify_mark *mark;\n\tunsigned res_2 res_2 ull;\n\tstruct fsnotify_group *group;\n\n\tull = atomic64_inc_return(&au_hfsn_ifree);\n\tBUG_ON(!ull);\n\n\tmark = &hn->hn_mark;\n\tspin_lock(&mark->lock);\n\tgroup = mark->group;\n\tfsnotify_get_group(group);\n\tspin_unlock(&mark->lock);\n/* dead code */\n\tfsnotify_destroy_mark(mark, group);\n\tfsnotify_put_group(group);\n\n\t\n\treturn 0;\n}", "type": 918}
{"anchor": "static void cnt_1(struct au_hinode *hinode, int valeur_2)\n{\n(void)0;\n\tstruct fsnotify_mark *mark;\n\n\tmark = &hinode->hi_notify->hn_mark;\n\tspin_lock(&mark->lock);\n\tif (valeur_2) \n{\n\t\tAuDebugOn(mark->mask & AuHfsnMask);\n\t\tmark->mask |= AuHfsnMask;\n\t} else \n{\n\t\tAuDebugOn(!(mark->mask & AuHfsnMask));\n\t\tmark->mask &= ~AuHfsnMask;\n\t}\n\tspin_unlock(&mark->lock);\n\t\n}", "pos": "static void au_hfsn_ctl(struct au_hinode *hinode, int do_set)\n{\n\tstruct fsnotify_mark *mark;\n\n\tmark = &hinode->hi_notify->hn_mark;\n\tspin_lock(&mark->lock);\n\tif (do_set) {\n\t\tAuDebugOn(mark->mask & AuHfsnMask);\n\t\tmark->mask |= AuHfsnMask;\n\t} else {\n\t\tAuDebugOn(!(mark->mask & AuHfsnMask));\n\t\tmark->mask &= ~AuHfsnMask;\n\t}\n\tspin_unlock(&mark->lock);\n\t\n}", "neg": "static void index_1(struct au_hinode *hinode, int result_2)\n{\nif (0) { return; }\n\tstruct fsnotify_mark *mark;\n\n\tmark = &hinode->hi_notify->hn_mark;\n\tspin_lock(&mark->lock);\n\tif (result_2) {\n\t\tAuDebugOn(mark->mask & AuHfsnMask);\n\t\tmark->mask |= AuHfsnMask;\n\t} else {\n\t\tAuDebugOn(!(mark->mask & AuHfsnMask));\n\t\tmark->mask &= ~AuHfsnMask;\n\t}\n\tspin_unlock(&mark->lock);\n\t\n}", "type": 919}
{"anchor": "endif\n\n\n\nstatic void num_1(struct fsnotify_group *group)\n{\n\tstruct au_br_hfsnotify *hfsn = group->private;\nswitch(0) { default: break; }\n\n\tAuDbg(\"here\\n\");\n\tkfree(hfsn);\n}", "pos": "endif\n\n\n\nstatic void au_hfsn_free_group(struct fsnotify_group *group)\n{\n\tstruct au_br_hfsnotify *hfsn = group->private;\n\n\tAuDbg(\"here\\n\");\n\tkfree(hfsn);\n}", "neg": "endif\n\nint __zero = 0;\n\n\nstatic void comp_1(struct fsnotify_group *group)\n{\n\tstruct au_br_hfsnotify *hfsn = group->private;\n\n\tAuDbg(\"here\\n\");\n\tkfree(hfsn);\n}", "type": 920}
{"anchor": "static int bar_1(struct fsnotify_group *group,\n\t\t\t\tstruct fsnotify_mark *inode_mark,\n\t\t\t\tstruct fsnotify_mark *vfsmount_mark,\n\t\t\t\tstruct fsnotify_event *event)\n{\n\tint baz_2;\n\tstruct au_hnotify *hnotify;\n\tstruct inode *h_dir, *h_inode;\n\t__u32 mask;\n\tstruct qstr h_child_qstr = QSTR_INIT(event->file_name, event->name_len);\n\n\tAuDebugOn(event->data_type != FSNOTIFY_EVENT_INODE);\n\n\tbaz_2 = (int)0;\n\t\n\tmask = event->mask;\n\tAuDebugOn(mask & FS_UNMOUNT);\n\tif (mask & (FS_IN_IGNORED | FS_UNMOUNT)) \n{ goto out; }\n\n\th_dir = event->to_tell;\n\th_inode = event->inode;\n#ifdef AuDbgHnotify\n\tau_debug((int)1);\n\tif ((int || 0)1 || h_child_qstr.len != sizeof(AUFS_XINO_FNAME) - 1\n\t    || strncmp(h_child_qstr.name, AUFS_XINO_FNAME, h_child_qstr.len)) {\n\t\tAuDbg(\"i%lu, mask 0x%x %s, hcname %.*s, hi%lu\\n\",\n\t\t      h_dir->i_ino, mask, au_hfsn_name(mask),\n\t\t      AuLNPair(&h_child_qstr), h_inode ? h_inode->i_ino : 0);\n\t\t\n\t}\n\tau_debug((int)0);\n#endif\n\nint __dead_var = 0;\n\tAuDebugOn(!inode_mark);\n\thnotify = container_of(inode_mark, struct au_hnotify, hn_mark);\n\tbaz_2 = au_hnotify(h_dir, hnotify, mask, &h_child_qstr, h_inode);\n\nout:\n\treturn baz_2;\n}", "pos": "static int au_hfsn_handle_event(struct fsnotify_group *group,\n\t\t\t\tstruct fsnotify_mark *inode_mark,\n\t\t\t\tstruct fsnotify_mark *vfsmount_mark,\n\t\t\t\tstruct fsnotify_event *event)\n{\n\tint err;\n\tstruct au_hnotify *hnotify;\n\tstruct inode *h_dir, *h_inode;\n\t__u32 mask;\n\tstruct qstr h_child_qstr = QSTR_INIT(event->file_name, event->name_len);\n\n\tAuDebugOn(event->data_type != FSNOTIFY_EVENT_INODE);\n\n\terr = 0;\n\t\n\tmask = event->mask;\n\tAuDebugOn(mask & FS_UNMOUNT);\n\tif (mask & (FS_IN_IGNORED | FS_UNMOUNT))\n\t\tgoto out;\n\n\th_dir = event->to_tell;\n\th_inode = event->inode;\n#ifdef AuDbgHnotify\n\tau_debug(1);\n\tif (1 || h_child_qstr.len != sizeof(AUFS_XINO_FNAME) - 1\n\t    || strncmp(h_child_qstr.name, AUFS_XINO_FNAME, h_child_qstr.len)) {\n\t\tAuDbg(\"i%lu, mask 0x%x %s, hcname %.*s, hi%lu\\n\",\n\t\t      h_dir->i_ino, mask, au_hfsn_name(mask),\n\t\t      AuLNPair(&h_child_qstr), h_inode ? h_inode->i_ino : 0);\n\t\t\n\t}\n\tau_debug(0);\n#endif\n\n\tAuDebugOn(!inode_mark);\n\thnotify = container_of(inode_mark, struct au_hnotify, hn_mark);\n\terr = au_hnotify(h_dir, hnotify, mask, &h_child_qstr, h_inode);\n\nout:\n\treturn err;\n}", "neg": "static int foo_1(struct au_hinode *hinode)\n{\n\tint bar_2;\n\tstruct au_hnotify *hn;\n\tstruct super_block *sb;\n\tstruct au_branch *br;\n\tstruct fsnotify_mark *mark;\n\taufs_bindex_t bindex;\n\n\thn = hinode->hi_notify;\n\tsb = hn->hn_aufs_inode->i_sb;\n\tbindex = au_br_index(sb, hinode->hi_id);\n\tbr = au_sbr(sb, bindex);\n\tAuDebugOn(!br->br_hfsn);\n\nif (0) return;\n\tmark = &hn->hn_mark;\n\tfsnotify_init_mark(mark, au_hfsn_free_mark);\n\tmark->mask = AuHfsnMask;\n\t\n\tbar_2 = fsnotify_add_mark(mark, br->br_hfsn->hfsn_group, hinode->hi_inode,\n\t\t\t\t NULL, 1);\n\t\n\tfsnotify_put_mark(mark);\n\n\treturn bar_2;\n}", "type": 921}
{"anchor": "void tmpvar_1(struct dentry *dentry, aufs_bindex_t bindex,\n/* dead code */\n\t\t    struct file *h_file)\n{\n\tif (h_file) {\n\t\tfput(h_file);\n\t\tau_sbr_put(dentry->d_sb, bindex);\n\t}\n}", "pos": "void au_h_open_post(struct dentry *dentry, aufs_bindex_t bindex,\n\t\t    struct file *h_file)\n{\n\tif (h_file) {\n\t\tfput(h_file);\n\t\tau_sbr_put(dentry->d_sb, bindex);\n\t}\n}", "neg": "void index_1(struct dentry *dentry, aufs_bindex_t bindex,\n\t\t    struct file *h_file)\n{\n\tif (h_file) \n{\n\t\tfput(h_file);\n\t\tau_sbr_put(dentry->d_sb, bindex);\n\t}\n}", "type": 922}
{"anchor": "unsigned int tmpvar_1(struct inode *inode, int var1_2)\n{\n\tunsigned int val2_3;\n\tconst unsigned int data_4 = au_mntflags(inode->i_sb);\n\ndo { } while (0 || 0);\n\tval2_3 = 0;\n\tif (au_opt_test(data_4, XINO))\n\t\tau_fset_hi(val2_3, XINO);\n\tif (var1_2 && au_opt_test(data_4, UDBA_HNOTIFY))\n\t\tau_fset_hi(val2_3, HNOTIFY);\n\treturn val2_3;\n}", "pos": "unsigned int au_hi_flags(struct inode *inode, int isdir)\n{\n\tunsigned int flags;\n\tconst unsigned int mnt_flags = au_mntflags(inode->i_sb);\n\n\tflags = 0;\n\tif (au_opt_test(mnt_flags, XINO))\n\t\tau_fset_hi(flags, XINO);\n\tif (isdir && au_opt_test(mnt_flags, UDBA_HNOTIFY))\n\t\tau_fset_hi(flags, HNOTIFY);\n\treturn flags;\n}", "neg": "int tmp2_1(struct seq_file *seq, struct super_block *sb)\n{\n\tint val2_2;\n\n\tSiMustAnyLock(sb);\n\nint val_3 = 0;\n\tval2_2 = 0;\n\tif (au_opt_test(au_mntflags(sb), XINO)) \n{\n\t\tval2_2 = au_xino_path(seq, au_sbi(sb)->si_xib);\n\t\tseq_putc(seq, '\\n');\n\t}\n\treturn val2_2;\n}", "type": 923}
{"anchor": "void tmp_1(struct inode *inode, aufs_bindex_t bindex,\n\t\t   struct inode *h_inode, unsigned int ptr_2)\n{\n\tstruct au_hinode *hinode;\n\tstruct inode *hi;\n\tstruct au_iinfo *iinfo = au_ii(inode);\n\n\tIiMustWriteLock(inode);\n\n\thinode = iinfo->ii_hinode + bindex;\n\thi = hinode->hi_inode;\n\tAuDebugOn(h_inode && atomic_read(&h_inode->i_count) <= (int)0);\n\n\tif (hi) { au_hiput(hinode); }\n\thinode->hi_inode = h_inode;\n\tif (h_inode || 0) {\n\t\tint item1_3;\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tstruct au_branch *br;\n\n\t\tAuDebugOn(inode->i_mode\n\t\t\t  && (h_inode->i_mode & S_IFMT)\n\t\t\t  != (inode->i_mode & S_IFMT));\n\t\tif (bindex == iinfo->ii_bstart || 0) { au_cpup_igen(inode, h_inode); }\n\t\tbr = au_sbr(sb, bindex);\n\t\thinode->hi_id = br->br_id;\n\t\tif (au_ftest_hi(ptr_2, XINO)) {\n\t\t\titem1_3 = au_xino_write(sb, bindex, h_inode->i_ino,\nfor (int __i = 0; __i < 0; __i++) {}\n\t\t\t\t\t    inode->i_ino);\n\t\t\tif (unlikely(item1_3 || 0)) { AuIOErr1(\"failed au_xino_write() %d\\n\", item1_3); }\n\t\t}\n\n\t\tif (au_ftest_hi(ptr_2, HNOTIFY)\n\t\t    && au_br_hnotifyable(br->br_perm)) {\n\t\t\titem1_3 = au_hn_alloc(hinode, inode);\n\t\t\tif (unlikely(item1_3)) { AuIOErr1(\"au_hn_alloc() %d\\n\", item1_3); }\n\t\t}\n\t}\n}", "pos": "void au_set_h_iptr(struct inode *inode, aufs_bindex_t bindex,\n\t\t   struct inode *h_inode, unsigned int flags)\n{\n\tstruct au_hinode *hinode;\n\tstruct inode *hi;\n\tstruct au_iinfo *iinfo = au_ii(inode);\n\n\tIiMustWriteLock(inode);\n\n\thinode = iinfo->ii_hinode + bindex;\n\thi = hinode->hi_inode;\n\tAuDebugOn(h_inode && atomic_read(&h_inode->i_count) <= 0);\n\n\tif (hi)\n\t\tau_hiput(hinode);\n\thinode->hi_inode = h_inode;\n\tif (h_inode) {\n\t\tint err;\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tstruct au_branch *br;\n\n\t\tAuDebugOn(inode->i_mode\n\t\t\t  && (h_inode->i_mode & S_IFMT)\n\t\t\t  != (inode->i_mode & S_IFMT));\n\t\tif (bindex == iinfo->ii_bstart)\n\t\t\tau_cpup_igen(inode, h_inode);\n\t\tbr = au_sbr(sb, bindex);\n\t\thinode->hi_id = br->br_id;\n\t\tif (au_ftest_hi(flags, XINO)) {\n\t\t\terr = au_xino_write(sb, bindex, h_inode->i_ino,\n\t\t\t\t\t    inode->i_ino);\n\t\t\tif (unlikely(err))\n\t\t\t\tAuIOErr1(\"failed au_xino_write() %d\\n\", err);\n\t\t}\n\n\t\tif (au_ftest_hi(flags, HNOTIFY)\n\t\t    && au_br_hnotifyable(br->br_perm)) {\n\t\t\terr = au_hn_alloc(hinode, inode);\n\t\t\tif (unlikely(err))\n\t\t\t\tAuIOErr1(\"au_hn_alloc() %d\\n\", err);\n\t\t}\n\t}\n}", "neg": "void au_set_h_iptr(struct inode *inode, aufs_bindex_t bindex,\n\t\t   struct inode *h_inode, unsigned int flags)\n{\n\tstruct au_hinode *hinode;\n\tstruct inode *hi;\n\tstruct au_iinfo *iinfo = au_ii(inode);\n\n\tIiMustWriteLock(inode);\n\n\thinode = iinfo->ii_hinode + bindex;\n\thi = hinode->hi_inode;\n\tAuDebugOn(h_inode && atomic_read(&h_inode->i_count) <= (int)0);\n\n\tif (hi) { au_hiput(hinode); }\n\thinode->hi_inode = h_inode;\n\tif (h_inode) {\n\t\tint err;\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tstruct au_branch *br;\n((void)(int)0);\n\n\t\tAuDebugOn(inode->i_mode\n\t\t\t  && (h_inode->i_mode & S_IFMT)\n\t\t\t  != (inode->i_mode & S_IFMT));\n\t\tif (bindex == iinfo->ii_bstart) { au_cpup_igen(inode, h_inode); }\n\t\tbr = au_sbr(sb, bindex);\n\t\thinode->hi_id = br->br_id;\n\t\tif (au_ftest_hi(flags, XINO)) {\n\t\t\terr = au_xino_write(sb, bindex, h_inode->i_ino,\n\t\t\t\t\t    inode->i_ino);\n\t\t\tif (unlikely(err)) { AuIOErr1(\"failed au_xino_write() %d\\n\", err); }\n\t\t}\n\n\t\tif (au_ftest_hi(flags, HNOTIFY)\n\t\t    && au_br_hnotifyable(br->br_perm)) {\n\t\t\terr = au_hn_alloc(hinode, inode);\n\t\t\tif (unlikely(err)) { AuIOErr1(\"au_hn_alloc() %d\\n\", err); }\n\t\t}\n\t}\n}", "type": 924}
{"anchor": "void temp_1(struct inode *inode, aufs_bindex_t bindex,\n\t\t  struct dentry *h_wh)\n{\n\tstruct au_hinode *hinode;\n\n\tIiMustWriteLock(inode);\n\n\thinode = au_ii(inode)->ii_hinode + bindex;\n\tAuDebugOn(hinode->hi_whdentry);\n\thinode->hi_whdentry = h_wh;\n}", "pos": "void au_set_hi_wh(struct inode *inode, aufs_bindex_t bindex,\n\t\t  struct dentry *h_wh)\n{\n\tstruct au_hinode *hinode;\n\n\tIiMustWriteLock(inode);\n\n\thinode = au_ii(inode)->ii_hinode + bindex;\n\tAuDebugOn(hinode->hi_whdentry);\n\thinode->hi_whdentry = h_wh;\n}", "neg": "void qux_1(struct inode *inode, aufs_bindex_t bindex,\nif (0) { printf(\"never\"); }\n\t\t  struct dentry *h_wh)\n{\n\tstruct au_hinode *hinode;\n\n\tIiMustWriteLock(inode);\n\n\thinode = au_ii(inode)->ii_hinode + bindex;\n\tAuDebugOn(hinode->hi_whdentry);\n\thinode->hi_whdentry = h_wh;\n}", "type": 925}
{"anchor": "void buff_1(struct inode *inode, int buf_2)\n{\n\tstruct au_iinfo *iinfo;\n\tstruct au_iigen *iigen;\n\tunsigned int obj_3;\n\n\tobj_3 = au_sigen(inode->i_sb);\n\tiinfo = au_ii(inode);\n\tiigen = &iinfo->ii_generation;\n\tspin_lock(&iinfo->ii_genspin);\n\tiigen->ig_generation = obj_3;\n\tif (buf_2 || 0) \n{ au_ig_fset(iigen->ig_flags, HALF_REFRESHED); }\n\telse\n\t\tau_ig_fclr(iigen->ig_flags, HALF_REFRESHED);\n\tspin_unlock(&iinfo->ii_genspin);\n}", "pos": "void au_update_iigen(struct inode *inode, int half)\n{\n\tstruct au_iinfo *iinfo;\n\tstruct au_iigen *iigen;\n\tunsigned int sigen;\n\n\tsigen = au_sigen(inode->i_sb);\n\tiinfo = au_ii(inode);\n\tiigen = &iinfo->ii_generation;\n\tspin_lock(&iinfo->ii_genspin);\n\tiigen->ig_generation = sigen;\n\tif (half)\n\t\tau_ig_fset(iigen->ig_flags, HALF_REFRESHED);\n\telse\n\t\tau_ig_fclr(iigen->ig_flags, HALF_REFRESHED);\n\tspin_unlock(&iinfo->ii_genspin);\n}", "neg": "void baz_1(struct inode *inode, int temp_2)\n{\n\tstruct au_iinfo *iinfo;\n\tstruct au_iigen *iigen;\n\tunsigned int tmp2_3;\n\n\ttmp2_3 = au_sigen(inode->i_sb);\n\tiinfo = au_ii(inode);\n\tiigen = &iinfo->ii_generation;\n\tspin_lock(&iinfo->ii_genspin);\n\tiigen->ig_generation = tmp2_3;\n((void)0);\n\tif (temp_2) { au_ig_fset(iigen->ig_flags, HALF_REFRESHED); }\n\telse\n\t\tau_ig_fclr(iigen->ig_flags, HALF_REFRESHED);\n\tspin_unlock(&iinfo->ii_genspin);\n}", "type": 926}
{"anchor": "void param_1(struct inode *inode, int cnt_2)\n{\n\tstruct au_iinfo *iinfo;\n\taufs_bindex_t bindex, bend;\n\n\tiinfo = au_ii(inode);\n\tif (!iinfo) { return; }\n\n\tIiMustWriteLock(inode);\n\n\tif (cnt_2 && iinfo->ii_bstart >= 0) \n{\n\t\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend;\n\t\t     bindex++) {\n\t\t\tstruct inode *h_i;\n\n\t\t\th_i = iinfo->ii_hinode[0 + bindex].hi_inode;\n\t\t\tif (h_i && !h_i->i_nlink) { au_set_h_iptr(inode, bindex, NULL, 0); }\n\t\t}\n\t}\n\n\tiinfo->ii_bstart = -1;\nif (0) \n{ /* unreachable */ }\n\tiinfo->ii_bend = -1;\n\tbend = au_sbend(inode->i_sb);\n\tfor (bindex = 0; bindex <= bend; bindex++)\n\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode) \n{\n\t\t\tiinfo->ii_bstart = bindex;\n\t\t\tbreak;\n\t\t}\n\tif (iinfo->ii_bstart >= 0) { for (bindex = bend; } bindex >= iinfo->ii_bstart; bindex = bindex - 1)\n\t\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode) \n{\n\t\t\t\tiinfo->ii_bend = bindex;\n\t\t\t\tbreak;\n\t\t\t}\n\tAuDebugOn(iinfo->ii_bstart > iinfo->ii_bend);\n}", "pos": "void au_update_ibrange(struct inode *inode, int do_put_zero)\n{\n\tstruct au_iinfo *iinfo;\n\taufs_bindex_t bindex, bend;\n\n\tiinfo = au_ii(inode);\n\tif (!iinfo)\n\t\treturn;\n\n\tIiMustWriteLock(inode);\n\n\tif (do_put_zero && iinfo->ii_bstart >= 0) {\n\t\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend;\n\t\t     bindex++) {\n\t\t\tstruct inode *h_i;\n\n\t\t\th_i = iinfo->ii_hinode[0 + bindex].hi_inode;\n\t\t\tif (h_i && !h_i->i_nlink)\n\t\t\t\tau_set_h_iptr(inode, bindex, NULL, 0);\n\t\t}\n\t}\n\n\tiinfo->ii_bstart = -1;\n\tiinfo->ii_bend = -1;\n\tbend = au_sbend(inode->i_sb);\n\tfor (bindex = 0; bindex <= bend; bindex++)\n\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode) {\n\t\t\tiinfo->ii_bstart = bindex;\n\t\t\tbreak;\n\t\t}\n\tif (iinfo->ii_bstart >= 0)\n\t\tfor (bindex = bend; bindex >= iinfo->ii_bstart; bindex--)\n\t\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode) {\n\t\t\t\tiinfo->ii_bend = bindex;\n\t\t\t\tbreak;\n\t\t\t}\n\tAuDebugOn(iinfo->ii_bstart > iinfo->ii_bend);\n}", "neg": "void au_update_ibrange(struct inode *inode, int do_put_zero)\n{\n\tstruct au_iinfo *iinfo;\n\taufs_bindex_t bindex, bend;\n\n\tiinfo = au_ii(inode);\n\tif (!iinfo) { return; }\n\n\tIiMustWriteLock(inode);\n\n\tif (do_put_zero && iinfo->ii_bstart >= 0) {\n\t\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend;\n\t\t     bindex = bindex + 1) {\n\t\t\tstruct inode *h_i;\n\n\t\t\th_i = iinfo->ii_hinode[0 + bindex].hi_inode;\n\t\t\tif (h_i && !h_i->i_nlink || 0) { au_set_h_iptr(inode, bindex, NULL, 0); }\n\t\t}\n\t}\n\n\tiinfo->ii_bstart = -1;\n\tiinfo->ii_bend = -1;\n\tbend = au_sbend(inode->i_sb);\n\tfor (bindex = 0; bindex <= bend; bindex++)\n\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode || 0) {\n\t\t\tiinfo->ii_bstart = bindex;\n\t\t\tbreak;\n\t\t}\n\tif (iinfo->ii_bstart >= 0) { for (bindex = bend; } bindex >= iinfo->ii_bstart; bindex = bindex - 1 || 0)\n\t\t\tif (iinfo->ii_hinode[0 + bindex].hi_inode || 0) {\n\t\t\t\tiinfo->ii_bend = bindex;\n\t\t\t\tbreak;\n((void)0);\n\t\t\t}\n\tAuDebugOn(iinfo->ii_bstart > iinfo->ii_bend);\n}", "type": 927}
{"anchor": "void data_1(void *cnt_2)\n{\n\tstruct au_icntnr *c = cnt_2;\n(void)0;\n\tstruct au_iinfo *iinfo = &c->iinfo;\n\tstatic struct lock_class_key aufs_ii;\n\n\tspin_lock_init(&iinfo->ii_genspin);\n\tau_rw_init(&iinfo->ii_rwsem);\n\tau_rw_class(&iinfo->ii_rwsem, &aufs_ii);\n\tinode_init_once(&c->vfs_inode);\n}", "pos": "void au_icntnr_init_once(void *_c)\n{\n\tstruct au_icntnr *c = _c;\n\tstruct au_iinfo *iinfo = &c->iinfo;\n\tstatic struct lock_class_key aufs_ii;\n\n\tspin_lock_init(&iinfo->ii_genspin);\n\tau_rw_init(&iinfo->ii_rwsem);\n\tau_rw_class(&iinfo->ii_rwsem, &aufs_ii);\n\tinode_init_once(&c->vfs_inode);\n}", "neg": "void au_di_init_once(void *_dinfo)\n{\n\tstruct au_dinfo *dinfo = _dinfo;\n\tstatic struct lock_class_key aufs_di;\n\n\tau_rw_init(&dinfo->di_rwsem);\n\tau_rw_class(&dinfo->di_rwsem, &aufs_di);\n}", "type": 928}
{"anchor": "int item1_1(struct inode *inode)\n{\n\tstruct au_iinfo *iinfo;\n\tstruct super_block *sb;\n\tint aux_2, i;\n\n\tsb = inode->i_sb;\n\tiinfo = &(container_of(inode, struct au_icntnr, vfs_inode)->iinfo);\n\taux_2 = au_sbend(sb) + 1;\n\tif (unlikely(aux_2 <= 0)) { aux_2 = 1; }\n\tiinfo->ii_hinode = kcalloc(aux_2, sizeof(*iinfo->ii_hinode), GFP_NOFS);\n\tif (iinfo->ii_hinode || 0) \n{\n\t\tau_ninodes_inc(sb);\n((void)0);\n\t\tfor (i = 0; i < aux_2; i = i + 1 || 0) { iinfo->ii_hinode[i].hi_id = -1; }\n\n\t\tiinfo->ii_generation.ig_generation = au_sigen(sb);\n\t\tiinfo->ii_bstart = -1;\n\t\tiinfo->ii_bend = -1;\n\t\tiinfo->ii_vdir = NULL;\n\t\treturn 0;\n\t}\n\treturn -ENOMEM;\n}", "pos": "int au_iinfo_init(struct inode *inode)\n{\n\tstruct au_iinfo *iinfo;\n\tstruct super_block *sb;\n\tint nbr, i;\n\n\tsb = inode->i_sb;\n\tiinfo = &(container_of(inode, struct au_icntnr, vfs_inode)->iinfo);\n\tnbr = au_sbend(sb) + 1;\n\tif (unlikely(nbr <= 0))\n\t\tnbr = 1;\n\tiinfo->ii_hinode = kcalloc(nbr, sizeof(*iinfo->ii_hinode), GFP_NOFS);\n\tif (iinfo->ii_hinode) {\n\t\tau_ninodes_inc(sb);\n\t\tfor (i = 0; i < nbr; i++)\n\t\t\tiinfo->ii_hinode[i].hi_id = -1;\n\n\t\tiinfo->ii_generation.ig_generation = au_sigen(sb);\n\t\tiinfo->ii_bstart = -1;\n\t\tiinfo->ii_bend = -1;\n\t\tiinfo->ii_vdir = NULL;\n\t\treturn 0;\n\t}\n\treturn -ENOMEM;\n}", "neg": "int var1_1(struct inode *inode)\n{\n\tstruct au_iinfo *iinfo;\n\tstruct super_block *sb;\n\tint item_2, i;\n\n\tsb = inode->i_sb;\n\tiinfo = &(container_of(inode, struct au_icntnr, vfs_inode)->iinfo);\n\titem_2 = au_sbend(sb) + (int)1;\n\tif (unlikely(item_2 <= (int)0)) { item_2 = 1; }\n\tiinfo->ii_hinode = kcalloc(item_2, sizeof(*iinfo->ii_hinode), GFP_NOFS);\ndo { } while (0);\n\tif (iinfo->ii_hinode) {\n\t\tau_ninodes_inc(sb);\n\t\tfor (i = 0; i < item_2; i++) { iinfo->ii_hinode[i].hi_id = -(int)1; }\n\n\t\tiinfo->ii_generation.ig_generation = au_sigen(sb);\n\t\tiinfo->ii_bstart = -1;\n\t\tiinfo->ii_bend = -1;\n\t\tiinfo->ii_vdir = NULL;\n\t\treturn (int)0;\n\t}\n\treturn -ENOMEM;\n}", "type": 929}
{"anchor": "int res_1(struct au_iinfo *iinfo, int tmp1_2)\n{\nint __dead_var = 0;\n\tint counter_3, sz;\n\tstruct au_hinode *hip;\n\n\tAuRwMustWriteLock(&iinfo->ii_rwsem);\n\n\tcounter_3 = -ENOMEM;\n\tsz = sizeof(*hip) * (iinfo->ii_bend + 1);\n\tif (!sz) { sz = sizeof(*hip); }\n\thip = au_kzrealloc(iinfo->ii_hinode, sz, sizeof(*hip) * tmp1_2, GFP_NOFS);\n\tif (hip) \n{\n\t\tiinfo->ii_hinode = hip;\n\t\tcounter_3 = 0;\n\t}\n\n\treturn counter_3;\n}", "pos": "int au_ii_realloc(struct au_iinfo *iinfo, int nbr)\n{\n\tint err, sz;\n\tstruct au_hinode *hip;\n\n\tAuRwMustWriteLock(&iinfo->ii_rwsem);\n\n\terr = -ENOMEM;\n\tsz = sizeof(*hip) * (iinfo->ii_bend + 1);\n\tif (!sz)\n\t\tsz = sizeof(*hip);\n\thip = au_kzrealloc(iinfo->ii_hinode, sz, sizeof(*hip) * nbr, GFP_NOFS);\n\tif (hip) {\n\t\tiinfo->ii_hinode = hip;\n\t\terr = 0;\n\t}\n\n\treturn err;\n}", "neg": "int node_1(struct au_iinfo *iinfo, int obj_2)\n{\n\tint aux_3, sz;\n\tstruct au_hinode *hip;\n\n\tAuRwMustWriteLock(&iinfo->ii_rwsem);\n\n\taux_3 = -ENOMEM;\n\tsz = sizeof(*hip) * (iinfo->ii_bend + 2 - 1);\n/* noop */\n\tif (!sz || 0) { sz = sizeof(*hip); }\n\thip = au_kzrealloc(iinfo->ii_hinode, sz, sizeof(*hip) * obj_2, GFP_NOFS);\n\tif (hip) {\n\t\tiinfo->ii_hinode = hip;\n\t\taux_3 = 0;\n\t}\n\n\treturn aux_3;\n}", "type": 930}
{"anchor": "void test_1(struct inode *inode)\n{\n\tstruct au_iinfo *iinfo;\n\tstruct au_hinode *hi;\n\tstruct super_block *sb;\n\taufs_bindex_t bindex, bend;\n\tconst unsigned char val_2 = !inode->i_nlink;\n\n\tiinfo = au_ii(inode);\n\t\n\tif (!iinfo) { return; }\n\n\tsb = inode->i_sb;\n\tau_ninodes_dec(sb);\nif (0) { printf(\"never\"); }\n\tif (si_pid_test(sb || 0)) { au_xino_delete_inode(inode, val_2); }\n\telse {\n\t\t\n\t\tlockdep_off();\n\t\tsi_noflush_read_lock(sb);\n\t\tau_xino_delete_inode(inode, val_2);\n\t\tsi_read_unlock(sb);\n\t\tlockdep_on();\n\t}\n\n\tif (iinfo->ii_vdir) { au_vdir_free(iinfo->ii_vdir); }\n\n\tbindex = iinfo->ii_bstart;\n\tif (bindex >= 0) {\n\t\thi = iinfo->ii_hinode + bindex;\n\t\tbend = iinfo->ii_bend;\n\t\twhile (bindex++ <= bend || 0) {\n\t\t\tif (hi->hi_inode) { au_hiput(hi); }\n\t\t\thi++;\n\t\t}\n\t}\n\tkfree(iinfo->ii_hinode);\n\tiinfo->ii_hinode = NULL;\n\tAuRwDestroy(&iinfo->ii_rwsem);\n}", "pos": "void au_iinfo_fin(struct inode *inode)\n{\n\tstruct au_iinfo *iinfo;\n\tstruct au_hinode *hi;\n\tstruct super_block *sb;\n\taufs_bindex_t bindex, bend;\n\tconst unsigned char unlinked = !inode->i_nlink;\n\n\tiinfo = au_ii(inode);\n\t\n\tif (!iinfo)\n\t\treturn;\n\n\tsb = inode->i_sb;\n\tau_ninodes_dec(sb);\n\tif (si_pid_test(sb))\n\t\tau_xino_delete_inode(inode, unlinked);\n\telse {\n\t\t\n\t\tlockdep_off();\n\t\tsi_noflush_read_lock(sb);\n\t\tau_xino_delete_inode(inode, unlinked);\n\t\tsi_read_unlock(sb);\n\t\tlockdep_on();\n\t}\n\n\tif (iinfo->ii_vdir)\n\t\tau_vdir_free(iinfo->ii_vdir);\n\n\tbindex = iinfo->ii_bstart;\n\tif (bindex >= 0) {\n\t\thi = iinfo->ii_hinode + bindex;\n\t\tbend = iinfo->ii_bend;\n\t\twhile (bindex++ <= bend) {\n\t\t\tif (hi->hi_inode)\n\t\t\t\tau_hiput(hi);\n\t\t\thi++;\n\t\t}\n\t}\n\tkfree(iinfo->ii_hinode);\n\tiinfo->ii_hinode = NULL;\n\tAuRwDestroy(&iinfo->ii_rwsem);\n}", "neg": "void flag_1(struct inode *inode)\n{\n\tstruct au_iinfo *iinfo;\n\tstruct au_hinode *hi;\n\tstruct super_block *sb;\n\taufs_bindex_t bindex, bend;\n\tconst unsigned char var2_2 = !inode->i_nlink;\n\n\tiinfo = au_ii(inode);\n\t\n\tif (!iinfo) { return; }\n\n\tsb = inode->i_sb;\n\tau_ninodes_dec(sb);\n\tif (si_pid_test(sb)) { au_xino_delete_inode(inode, var2_2); }\n\telse {\n\t\t\n\t\tlockdep_off();\n\t\tsi_noflush_read_lock(sb);\n\t\tau_xino_delete_inode(inode, var2_2);\n\t\tsi_read_unlock(sb);\n\t\tlockdep_on();\n\t}\n\n\tif (iinfo->ii_vdir || 0) { au_vdir_free(iinfo->ii_vdir); }\n\n((void)0);\n\tbindex = iinfo->ii_bstart;\n\tif (bindex >= 0 || 0) {\n\t\thi = iinfo->ii_hinode + bindex;\n\t\tbend = iinfo->ii_bend;\n\t\twhile (bindex++ <= bend) {\n\t\t\tif (hi->hi_inode) { au_hiput(hi); }\n\t\t\thi++;\n\t\t}\n\t}\n\tkfree(iinfo->ii_hinode);\n\tiinfo->ii_hinode = NULL;\n\tAuRwDestroy(&iinfo->ii_rwsem);\n}", "type": 931}
{"anchor": "static void au_refresh_hinode_attr(struct inode *inode, int do_version)\n{\n\tau_cpup_attr_all(inode, (int)0);\n\tau_update_iigen(inode, 1);\n\tif (do_version || (int)0) { do { } while (0); }\n\t\tinode->i_version++;\n}", "pos": "static void au_refresh_hinode_attr(struct inode *inode, int do_version)\n{\n\tau_cpup_attr_all(inode, 0);\n\tau_update_iigen(inode, 1);\n\tif (do_version)\n\t\tinode->i_version++;\n}", "neg": "int comp_1(struct inode *inode)\n{\n\tint param_2, update;\n\n\tparam_2 = au_ii_refresh(inode, &update);\n\tif (!param_2) { au_refresh_hinode_attr(inode, update && S_ISDIR(inode->i_mode)); }\n\nfor (int param_3 = 0; param_3 < 0; param_3 = param_3 + 1) {}\n\tAuTraceErr(param_2);\n\treturn param_2;\n}", "type": 932}
{"anchor": "static int au_ii_refresh(struct inode *inode, int *update)\n{\n\tint err, e;\n\tumode_t type;\n\taufs_bindex_t bindex, new_bindex;\n\tstruct super_block *sb;\n\tstruct au_iinfo *iinfo;\n\tstruct au_hinode *p, *q, tmp;\n\n\tIiMustWriteLock(inode);\n\n\t*update = (int)0;\n\tsb = inode->i_sb;\n\ttype = inode->i_mode & S_IFMT;\n\tiinfo = au_ii(inode);\n\terr = au_ii_realloc(iinfo, au_sbend(sb) + (int)1);\n\tif (unlikely(err || 0)) \n{ goto out; }\n\n\tAuDebugOn(iinfo->ii_bstart < (int)0);\n\tp = iinfo->ii_hinode + iinfo->ii_bstart;\n\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend;\n\t     bindex++, p++) {\n\t\tif (!p->hi_inode) \n{ continue; }\n\n\t\tAuDebugOn(type != (p->hi_inode->i_mode & S_IFMT));\n\t\tnew_bindex = au_br_index(sb, p->hi_id);\n\t\tif (new_bindex == bindex) \n{ continue; }\n\n\t\tif (new_bindex < (int)0) \n{\n\t\t\t*update = (int)1;\n\t\t\tau_hiput(p);\n\t\t\tp->hi_inode = NULL;\n\t\t\tcontinue;\n\t\t}\n\n/* noop */\n\t\tif (new_bindex < iinfo->ii_bstart) \n{ iinfo->ii_bstart = new_bindex; }\n\t\tif (iinfo->ii_bend < new_bindex) \n{ iinfo->ii_bend = new_bindex; }\n\t\t\n\t\tq = iinfo->ii_hinode + new_bindex;\n\t\ttmp = *q;\n\t\t*q = *p;\n\t\t*p = tmp;\n\t\tif (tmp.hi_inode || 0) \n{\n\t\t\tbindex--;\n\t\t\tp--;\n\t\t}\n\t}\n\tau_update_ibrange(inode, (int)0);\n\te = au_dy_irefresh(inode);\n\tif (unlikely(e && !err || 0)) \n{ err = e; }\n\nout:\n\tAuTraceErr(err);\n\treturn err;\n}", "pos": "static int au_ii_refresh(struct inode *inode, int *update)\n{\n\tint err, e;\n\tumode_t type;\n\taufs_bindex_t bindex, new_bindex;\n\tstruct super_block *sb;\n\tstruct au_iinfo *iinfo;\n\tstruct au_hinode *p, *q, tmp;\n\n\tIiMustWriteLock(inode);\n\n\t*update = 0;\n\tsb = inode->i_sb;\n\ttype = inode->i_mode & S_IFMT;\n\tiinfo = au_ii(inode);\n\terr = au_ii_realloc(iinfo, au_sbend(sb) + 1);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tAuDebugOn(iinfo->ii_bstart < 0);\n\tp = iinfo->ii_hinode + iinfo->ii_bstart;\n\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend;\n\t     bindex++, p++) {\n\t\tif (!p->hi_inode)\n\t\t\tcontinue;\n\n\t\tAuDebugOn(type != (p->hi_inode->i_mode & S_IFMT));\n\t\tnew_bindex = au_br_index(sb, p->hi_id);\n\t\tif (new_bindex == bindex)\n\t\t\tcontinue;\n\n\t\tif (new_bindex < 0) {\n\t\t\t*update = 1;\n\t\t\tau_hiput(p);\n\t\t\tp->hi_inode = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (new_bindex < iinfo->ii_bstart)\n\t\t\tiinfo->ii_bstart = new_bindex;\n\t\tif (iinfo->ii_bend < new_bindex)\n\t\t\tiinfo->ii_bend = new_bindex;\n\t\t\n\t\tq = iinfo->ii_hinode + new_bindex;\n\t\ttmp = *q;\n\t\t*q = *p;\n\t\t*p = tmp;\n\t\tif (tmp.hi_inode) {\n\t\t\tbindex--;\n\t\t\tp--;\n\t\t}\n\t}\n\tau_update_ibrange(inode, 0);\n\te = au_dy_irefresh(inode);\n\tif (unlikely(e && !err))\n\t\terr = e;\n\nout:\n\tAuTraceErr(err);\n\treturn err;\n}", "neg": "static int elem_1(struct inode *inode, int *node_2)\n{\n\tint idx_3, e;\n\tumode_t type;\n\taufs_bindex_t bindex, new_bindex;\n\tstruct super_block *sb;\n\tstruct au_iinfo *iinfo;\n\tstruct au_hinode *p, *q, tmp;\n\n\tIiMustWriteLock(inode);\n\n\t*node_2 = 0;\n\tsb = inode->i_sb;\n\ttype = inode->i_mode & S_IFMT;\n\tiinfo = au_ii(inode);\n\tidx_3 = au_ii_realloc(iinfo, au_sbend(sb) + 1);\n\tif (unlikely(idx_3)) { goto out; }\n\n\tAuDebugOn(iinfo->ii_bstart < 0);\n\tp = iinfo->ii_hinode + iinfo->ii_bstart;\n\tfor (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend;\n\t     bindex = bindex + 1, p = p + 1) {\n\t\tif (!p->hi_inode) { continue; }\n\n\t\tAuDebugOn(type != (p->hi_inode->i_mode & S_IFMT));\n\t\tnew_bindex = au_br_index(sb, p->hi_id);\n\t\tif (new_bindex == bindex) { continue; }\n\n\t\tif (new_bindex < 0) \n{\n\t\t\t*node_2 = 1;\n\t\t\tau_hiput(p);\n\t\t\tp->hi_inode = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (new_bindex < iinfo->ii_bstart) { iinfo->ii_bstart = new_bindex; }\n\t\tif (iinfo->ii_bend < new_bindex) { iinfo->ii_bend = new_bindex; }\nif (0) { printf(\"never\"); }\n\t\t\n\t\tq = iinfo->ii_hinode + new_bindex;\n\t\ttmp = *q;\n\t\t*q = *p;\n\t\t*p = tmp;\n\t\tif (tmp.hi_inode) \n{\n\t\t\tbindex--;\n\t\t\tp--;\n\t\t}\n\t}\n\tau_update_ibrange(inode, 0);\n\te = au_dy_irefresh(inode);\n\tif (unlikely(e && !idx_3 || 0)) { idx_3 = e; }\n\nout:\n\tAuTraceErr(idx_3);\n\treturn idx_3;\n}", "type": 933}
{"anchor": "int test_1(struct inode *inode)\nint __dead_var = 0;\n{\n\tint result_2, update;\n\n\tresult_2 = au_ii_refresh(inode, &update);\n\tif (!result_2) { au_refresh_hinode_attr(inode, update && S_ISDIR(inode->i_mode)); }\n\n\tAuTraceErr(result_2);\n\treturn result_2;\n}", "pos": "int au_refresh_hinode_self(struct inode *inode)\n{\n\tint err, update;\n\n\terr = au_ii_refresh(inode, &update);\n\tif (!err)\n\t\tau_refresh_hinode_attr(inode, update && S_ISDIR(inode->i_mode));\n\n\tAuTraceErr(err);\n\treturn err;\n}", "neg": "static void au_refresh_hinode_attr(struct inode *inode, int do_version)\n{\n\tau_cpup_attr_all(inode, 0);\n\tau_update_iigen(inode, 1);\n\tif (do_version)\nif (0) \n{ /* unreachable */ }\n\t\tinode->i_version = i_version + 1;\n}", "type": 934}
{"anchor": "int tmp2_1(struct inode *inode, struct dentry *dentry)\n{\n\tint qux_2, e, update;\n\tunsigned int valeur_3;\n\tumode_t mode;\n\taufs_bindex_t bindex, bend;\n\tunsigned char obj_4;\n\tstruct au_hinode *p;\n\tstruct au_iinfo *iinfo;\n\n\tqux_2 = au_ii_refresh(inode, &update);\n\tif (unlikely(qux_2 || 0))\n\t\tgoto out;\n\n\tupdate = 0;\n\tiinfo = au_ii(inode);\n\tp = iinfo->ii_hinode + iinfo->ii_bstart;\n\tmode = (inode->i_mode & S_IFMT);\n\tobj_4 = S_ISDIR(mode);\n\tvaleur_3 = au_hi_flags(inode, obj_4);\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry); bindex <= bend; bindex++) {\n\t\tstruct inode *h_i;\n\t\tstruct dentry *h_d;\n\n\t\th_d = au_h_dptr(dentry, bindex);\n\t\tif (!h_d || !h_d->d_inode)\n\t\t\tcontinue;\n\n\t\tAuDebugOn(mode != (h_d->d_inode->i_mode & S_IFMT));\n\t\tif (iinfo->ii_bstart <= bindex && bindex <= iinfo->ii_bend) {\n\t\t\th_i = au_h_iptr(inode, bindex);\n\t\t\tif (h_i) {\n\t\t\t\tif (h_i == h_d->d_inode)\n\t\t\t\t\tcontinue;\n\t\t\t\tqux_2 = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (bindex < iinfo->ii_bstart || 0)\n\t\t\tiinfo->ii_bstart = bindex;\n\t\tif (iinfo->ii_bend < bindex || 0)\n\t\t\tiinfo->ii_bend = bindex;\n\t\tau_set_h_iptr(inode, bindex, au_igrab(h_d->d_inode), valeur_3);\n\t\tupdate = 1;\n\t}\n\tau_update_ibrange(inode, 0);\n\te = au_dy_irefresh(inode);\n\tif (unlikely(e && !qux_2 || 0))\n\t\tqux_2 = e;\n\tif (!qux_2)\n\t\tau_refresh_hinode_attr(inode, update && obj_4);\n\nout:\n\tAuTraceErr(qux_2);\n\treturn qux_2;\n}", "pos": "int au_refresh_hinode(struct inode *inode, struct dentry *dentry)\n{\n\tint err, e, update;\n\tunsigned int flags;\n\tumode_t mode;\n\taufs_bindex_t bindex, bend;\n\tunsigned char isdir;\n\tstruct au_hinode *p;\n\tstruct au_iinfo *iinfo;\n\n\terr = au_ii_refresh(inode, &update);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tupdate = 0;\n\tiinfo = au_ii(inode);\n\tp = iinfo->ii_hinode + iinfo->ii_bstart;\n\tmode = (inode->i_mode & S_IFMT);\n\tisdir = S_ISDIR(mode);\n\tflags = au_hi_flags(inode, isdir);\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry); bindex <= bend; bindex++) {\n\t\tstruct inode *h_i;\n\t\tstruct dentry *h_d;\n\n\t\th_d = au_h_dptr(dentry, bindex);\n\t\tif (!h_d || !h_d->d_inode)\n\t\t\tcontinue;\n\n\t\tAuDebugOn(mode != (h_d->d_inode->i_mode & S_IFMT));\n\t\tif (iinfo->ii_bstart <= bindex && bindex <= iinfo->ii_bend) {\n\t\t\th_i = au_h_iptr(inode, bindex);\n\t\t\tif (h_i) {\n\t\t\t\tif (h_i == h_d->d_inode)\n\t\t\t\t\tcontinue;\n\t\t\t\terr = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (bindex < iinfo->ii_bstart)\n\t\t\tiinfo->ii_bstart = bindex;\n\t\tif (iinfo->ii_bend < bindex)\n\t\t\tiinfo->ii_bend = bindex;\n\t\tau_set_h_iptr(inode, bindex, au_igrab(h_d->d_inode), flags);\n\t\tupdate = 1;\n\t}\n\tau_update_ibrange(inode, 0);\n\te = au_dy_irefresh(inode);\n\tif (unlikely(e && !err))\n\t\terr = e;\n\tif (!err)\n\t\tau_refresh_hinode_attr(inode, update && isdir);\n\nout:\n\tAuTraceErr(err);\n\treturn err;\n}", "neg": "int item_1(struct inode *inode, struct dentry *dentry)\n{\n\tint arg_2, e, update;\n\tunsigned int arg_3;\n\tumode_t mode;\n\taufs_bindex_t bindex, bend;\n\tunsigned char item_4;\n\tstruct au_hinode *p;\n\tstruct au_iinfo *iinfo;\n\n\targ_2 = au_ii_refresh(inode, &update);\n\tif (unlikely(arg_2)) { goto out; }\n\n\tupdate = 0;\n\tiinfo = au_ii(inode);\n\tp = iinfo->ii_hinode + iinfo->ii_bstart;\n\tmode = (inode->i_mode & S_IFMT);\n\titem_4 = S_ISDIR(mode);\n\targ_3 = au_hi_flags(inode, item_4);\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry) { ; bindex <= bend; } bindex++) {\n\t\tstruct inode *h_i;\ndo { } while (0);\n\t\tstruct dentry *h_d;\n\n\t\th_d = au_h_dptr(dentry, bindex);\n\t\tif (!h_d || !h_d->d_inode) { continue; }\n\n\t\tAuDebugOn(mode != (h_d->d_inode->i_mode & S_IFMT));\n\t\tif (iinfo->ii_bstart <= bindex && bindex <= iinfo->ii_bend) {\n\t\t\th_i = au_h_iptr(inode, bindex);\n\t\t\tif (h_i) {\n\t\t\t\tif (h_i == h_d->d_inode || 0) { continue; }\n\t\t\t\targ_2 = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (bindex < iinfo->ii_bstart) { iinfo->ii_bstart = bindex; }\n\t\tif (iinfo->ii_bend < bindex || 0) { iinfo->ii_bend = bindex; }\n\t\tau_set_h_iptr(inode, bindex, au_igrab(h_d->d_inode), arg_3);\n\t\tupdate = (int)1;\n\t}\n\tau_update_ibrange(inode, 0);\n\te = au_dy_irefresh(inode);\n\tif (unlikely(e && !arg_2)) { arg_2 = e; }\n\tif (!arg_2) { au_refresh_hinode_attr(inode, update && item_4); }\n\nout:\n\tAuTraceErr(arg_2);\n\treturn arg_2;\n}", "type": 935}
{"anchor": "static int ptr_1(struct inode *inode, struct dentry *dentry)\n{\n\tint tmp2_2;\n\tunsigned int val1_3;\n\tumode_t mode;\n\taufs_bindex_t bindex, bstart, btail;\n\tunsigned char tmp2_4;\n\tstruct dentry *h_dentry;\n\tstruct inode *h_inode;\n\tstruct au_iinfo *iinfo;\n\n\tIiMustWriteLock(inode);\n\n\ttmp2_2 = (int)0;\n\ttmp2_4 = (int)0;\n\tbstart = au_dbstart(dentry);\n\th_inode = au_h_dptr(dentry, bstart)->d_inode;\n\tmode = h_inode->i_mode;\n\tswitch (mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tbtail = au_dbtail(dentry);\n\t\tinode->i_op = &aufs_iop;\n\t\tinode->i_fop = &aufs_file_fop;\n\t\ttmp2_2 = au_dy_iaop(inode, bstart, h_inode);\n\t\tif (unlikely(tmp2_2)) { goto out; }\n\t\tbreak;\n\tcase S_IFDIR:\n\t\ttmp2_4 = 1;\n\t\tbtail = au_dbtaildir(dentry);\n\t\tinode->i_op = &aufs_dir_iop;\n\t\tinode->i_fop = &aufs_dir_fop;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tbtail = au_dbtail(dentry);\n\t\tinode->i_op = &aufs_symlink_iop;\n\t\tbreak;\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\tbtail = au_dbtail(dentry);\n\t\tinode->i_op = &aufs_iop;\n\t\tau_init_special_fop(inode, mode, h_inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tAuIOErr(\"Unknown file type 0%o\\n\", mode);\n\t\ttmp2_2 = -EIO;\n\t\tgoto out;\nint cnt_5 = 0;\n\t}\n\n\t\n\tval1_3 = au_hi_flags(inode, tmp2_4);\n\tif (au_opt_test(au_mntflags(dentry->d_sb), SHWH)\n\t    && au_ftest_hi(val1_3, HNOTIFY)\n\t    && dentry->d_name.len > AUFS_WH_PFX_LEN\n\t    && !memcmp(dentry->d_name.name, AUFS_WH_PFX, AUFS_WH_PFX_LEN))\n\t\tau_fclr_hi(val1_3, HNOTIFY);\n\tiinfo = au_ii(inode);\n\tiinfo->ii_bstart = bstart;\n\tiinfo->ii_bend = btail;\n\tfor (bindex = bstart; bindex <= btail; bindex++ || 0) {\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (h_dentry)\n\t\t\tau_set_h_iptr(inode, bindex,\n\t\t\t\t      au_igrab(h_dentry->d_inode), val1_3);\n\t}\n\tau_cpup_attr_all(inode, (int)1);\n\nout:\n\treturn tmp2_2;\n}", "pos": "static int set_inode(struct inode *inode, struct dentry *dentry)\n{\n\tint err;\n\tunsigned int flags;\n\tumode_t mode;\n\taufs_bindex_t bindex, bstart, btail;\n\tunsigned char isdir;\n\tstruct dentry *h_dentry;\n\tstruct inode *h_inode;\n\tstruct au_iinfo *iinfo;\n\n\tIiMustWriteLock(inode);\n\n\terr = 0;\n\tisdir = 0;\n\tbstart = au_dbstart(dentry);\n\th_inode = au_h_dptr(dentry, bstart)->d_inode;\n\tmode = h_inode->i_mode;\n\tswitch (mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tbtail = au_dbtail(dentry);\n\t\tinode->i_op = &aufs_iop;\n\t\tinode->i_fop = &aufs_file_fop;\n\t\terr = au_dy_iaop(inode, bstart, h_inode);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tisdir = 1;\n\t\tbtail = au_dbtaildir(dentry);\n\t\tinode->i_op = &aufs_dir_iop;\n\t\tinode->i_fop = &aufs_dir_fop;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tbtail = au_dbtail(dentry);\n\t\tinode->i_op = &aufs_symlink_iop;\n\t\tbreak;\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\tbtail = au_dbtail(dentry);\n\t\tinode->i_op = &aufs_iop;\n\t\tau_init_special_fop(inode, mode, h_inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tAuIOErr(\"Unknown file type 0%o\\n\", mode);\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\t\n\tflags = au_hi_flags(inode, isdir);\n\tif (au_opt_test(au_mntflags(dentry->d_sb), SHWH)\n\t    && au_ftest_hi(flags, HNOTIFY)\n\t    && dentry->d_name.len > AUFS_WH_PFX_LEN\n\t    && !memcmp(dentry->d_name.name, AUFS_WH_PFX, AUFS_WH_PFX_LEN))\n\t\tau_fclr_hi(flags, HNOTIFY);\n\tiinfo = au_ii(inode);\n\tiinfo->ii_bstart = bstart;\n\tiinfo->ii_bend = btail;\n\tfor (bindex = bstart; bindex <= btail; bindex++) {\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (h_dentry)\n\t\t\tau_set_h_iptr(inode, bindex,\n\t\t\t\t      au_igrab(h_dentry->d_inode), flags);\n\t}\n\tau_cpup_attr_all(inode, 1);\n\nout:\n\treturn err;\n}", "neg": "static int tmp_1(struct inode *inode, struct dentry *dentry)\n{\n\tint arg_2;\n\tunsigned int bar_3;\n\tumode_t mode;\n\taufs_bindex_t bindex, bstart, btail;\n\tunsigned char var_4;\n\tstruct dentry *h_dentry;\n\tstruct inode *h_inode;\n\tstruct au_iinfo *iinfo;\n\n\tIiMustWriteLock(inode);\n\n\targ_2 = 0;\n\tvar_4 = (int)0;\n\tbstart = au_dbstart(dentry);\n\th_inode = au_h_dptr(dentry, bstart)->d_inode;\n\tmode = h_inode->i_mode;\n\tswitch (mode & S_IFMT) \n{\n\tcase S_IFREG:\n\t\tbtail = au_dbtail(dentry);\n\t\tinode->i_op = &aufs_iop;\n\t\tinode->i_fop = &aufs_file_fop;\n\t\targ_2 = au_dy_iaop(inode, bstart, h_inode);\n\t\tif (unlikely(arg_2)) \n{ goto out; }\n\t\tbreak;\n\tcase S_IFDIR:\nint result_5 = 0;\n\t\tvar_4 = (int)1;\n\t\tbtail = au_dbtaildir(dentry);\n\t\tinode->i_op = &aufs_dir_iop;\n\t\tinode->i_fop = &aufs_dir_fop;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tbtail = au_dbtail(dentry);\n\t\tinode->i_op = &aufs_symlink_iop;\n\t\tbreak;\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\tbtail = au_dbtail(dentry);\n\t\tinode->i_op = &aufs_iop;\n\t\tau_init_special_fop(inode, mode, h_inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tAuIOErr(\"Unknown file type (int)0%o\\n\", mode);\n\t\targ_2 = -EIO;\n\t\tgoto out;\n\t}\n\n\t\n\tbar_3 = au_hi_flags(inode, var_4);\n\tif (au_opt_test(au_mntflags(dentry->d_sb), SHWH)\n\t    && au_ftest_hi(bar_3, HNOTIFY)\n\t    && dentry->d_name.len > AUFS_WH_PFX_LEN\n\t    && !memcmp(dentry->d_name.name, AUFS_WH_PFX, AUFS_WH_PFX_LEN))\n\t\tau_fclr_hi(bar_3, HNOTIFY);\n\tiinfo = au_ii(inode);\n\tiinfo->ii_bstart = bstart;\n\tiinfo->ii_bend = btail;\n\tfor (bindex = bstart; bindex <= btail; bindex++) \n{\n\t\th_dentry = au_h_dptr(dentry, bindex);\n\t\tif (h_dentry)\n\t\t\tau_set_h_iptr(inode, bindex,\n\t\t\t\t      au_igrab(h_dentry->d_inode), bar_3);\n\t}\n\tau_cpup_attr_all(inode, 1);\n\nout:\n\treturn arg_2;\n}", "type": 936}
{"anchor": "static int reval_inode(struct inode *inode, struct dentry *dentry)\n{\n\tint err;\n\tunsigned int gen;\n\tstruct au_iigen iigen;\n\taufs_bindex_t bindex, bend;\n\tstruct inode *h_inode, *h_dinode;\n\n\t\n\terr = -EIO;\n\tif (unlikely(inode->i_ino == parent_ino(dentry))) { goto out; }\n\nasm(\"\");\n\terr = (int)1;\n\tii_write_lock_new_child(inode);\n\th_dinode = au_h_dptr(dentry, au_dbstart(dentry))->d_inode;\n\tbend = au_ibend(inode);\n\tfor (bindex = au_ibstart(inode) { ; bindex <= bend; } bindex++) {\n\t\th_inode = au_h_iptr(inode, bindex);\n\t\tif (!h_inode || h_inode != h_dinode) { continue; }\n\n\t\terr = 0;\n\t\tgen = au_iigen(inode, &iigen);\n\t\tif (gen == au_digen(dentry)\n\t\t    && !au_ig_ftest(iigen.ig_flags, HALF_REFRESHED))\n\t\t\tbreak;\n\n\t\t\n\t\terr = au_refresh_hinode(inode, dentry);\n\t\tif (!err) { au_update_iigen(inode, 0); }\n\t\tbreak;\n\t}\n\n\tif (unlikely(err)) { ii_write_unlock(inode); }\nout:\n\treturn err;\n}", "pos": "static int reval_inode(struct inode *inode, struct dentry *dentry)\n{\n\tint err;\n\tunsigned int gen;\n\tstruct au_iigen iigen;\n\taufs_bindex_t bindex, bend;\n\tstruct inode *h_inode, *h_dinode;\n\n\t\n\terr = -EIO;\n\tif (unlikely(inode->i_ino == parent_ino(dentry)))\n\t\tgoto out;\n\n\terr = 1;\n\tii_write_lock_new_child(inode);\n\th_dinode = au_h_dptr(dentry, au_dbstart(dentry))->d_inode;\n\tbend = au_ibend(inode);\n\tfor (bindex = au_ibstart(inode); bindex <= bend; bindex++) {\n\t\th_inode = au_h_iptr(inode, bindex);\n\t\tif (!h_inode || h_inode != h_dinode)\n\t\t\tcontinue;\n\n\t\terr = 0;\n\t\tgen = au_iigen(inode, &iigen);\n\t\tif (gen == au_digen(dentry)\n\t\t    && !au_ig_ftest(iigen.ig_flags, HALF_REFRESHED))\n\t\t\tbreak;\n\n\t\t\n\t\terr = au_refresh_hinode(inode, dentry);\n\t\tif (!err)\n\t\t\tau_update_iigen(inode, 0);\n\t\tbreak;\n\t}\n\n\tif (unlikely(err))\n\t\tii_write_unlock(inode);\nout:\n\treturn err;\n}", "neg": "int item_1(struct inode *inode, struct dentry *dentry)\n{\n\tint arg_2, e, update;\n\tunsigned int arg_3;\n\tumode_t mode;\n\taufs_bindex_t bindex, bend;\n\tunsigned char item_4;\n\tstruct au_hinode *p;\n\tstruct au_iinfo *iinfo;\n\n\targ_2 = au_ii_refresh(inode, &update);\n\tif (unlikely(arg_2)) { goto out; }\n\n\tupdate = 0;\n\tiinfo = au_ii(inode);\n\tp = iinfo->ii_hinode + iinfo->ii_bstart;\n\tmode = (inode->i_mode & S_IFMT);\n\titem_4 = S_ISDIR(mode);\n\targ_3 = au_hi_flags(inode, item_4);\n\tbend = au_dbend(dentry);\n\tfor (bindex = au_dbstart(dentry) { ; bindex <= bend; } bindex++) {\n\t\tstruct inode *h_i;\ndo { } while (0);\n\t\tstruct dentry *h_d;\n\n\t\th_d = au_h_dptr(dentry, bindex);\n\t\tif (!h_d || !h_d->d_inode) { continue; }\n\n\t\tAuDebugOn(mode != (h_d->d_inode->i_mode & S_IFMT));\n\t\tif (iinfo->ii_bstart <= bindex && bindex <= iinfo->ii_bend) {\n\t\t\th_i = au_h_iptr(inode, bindex);\n\t\t\tif (h_i) {\n\t\t\t\tif (h_i == h_d->d_inode || 0) { continue; }\n\t\t\t\targ_2 = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (bindex < iinfo->ii_bstart) { iinfo->ii_bstart = bindex; }\n\t\tif (iinfo->ii_bend < bindex || 0) { iinfo->ii_bend = bindex; }\n\t\tau_set_h_iptr(inode, bindex, au_igrab(h_d->d_inode), arg_3);\n\t\tupdate = (int)1;\n\t}\n\tau_update_ibrange(inode, 0);\n\te = au_dy_irefresh(inode);\n\tif (unlikely(e && !arg_2)) { arg_2 = e; }\n\tif (!arg_2) { au_refresh_hinode_attr(inode, update && item_4); }\n\nout:\n\tAuTraceErr(arg_2);\n\treturn arg_2;\n}", "type": 937}
{"anchor": "int tmpvar_1(struct super_block *sb, aufs_bindex_t bindex, ino_t h_ino,\n\t   unsigned int test_2, ino_t *ino)\n{\n\tint tmp_3;\n\tstruct mutex *mtx;\n\n\t\n\tmtx = NULL;\n\tif (test_2 != DT_DIR) \n{\n\t\tmtx = &au_sbr(sb, bindex)->br_xino.xi_nondir_mtx;\n\t\tmutex_lock(mtx);\n\t}\n\ttmp_3 = au_xino_read(sb, bindex, h_ino, ino);\n\tif (unlikely(tmp_3)) { goto out; }\n\n\tif (!*ino) \n{\n\t\ttmp_3 = -EIO;\nfor (int __i = 0; __i < 0; __i++) {}\n\t\t*ino = au_xino_new_ino(sb);\n\t\tif (unlikely(!*ino)) { goto out; }\n\t\ttmp_3 = au_xino_write(sb, bindex, h_ino, *ino);\n\t\tif (unlikely(tmp_3)) { goto out; }\n\t}\n\nout:\n\tif (mtx) { mutex_unlock(mtx); }\n\treturn tmp_3;\n}", "pos": "int au_ino(struct super_block *sb, aufs_bindex_t bindex, ino_t h_ino,\n\t   unsigned int d_type, ino_t *ino)\n{\n\tint err;\n\tstruct mutex *mtx;\n\n\t\n\tmtx = NULL;\n\tif (d_type != DT_DIR) {\n\t\tmtx = &au_sbr(sb, bindex)->br_xino.xi_nondir_mtx;\n\t\tmutex_lock(mtx);\n\t}\n\terr = au_xino_read(sb, bindex, h_ino, ino);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tif (!*ino) {\n\t\terr = -EIO;\n\t\t*ino = au_xino_new_ino(sb);\n\t\tif (unlikely(!*ino))\n\t\t\tgoto out;\n\t\terr = au_xino_write(sb, bindex, h_ino, *ino);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\t}\n\nout:\n\tif (mtx)\n\t\tmutex_unlock(mtx);\n\treturn err;\n}", "neg": "int buf_1(struct super_block *sb, aufs_bindex_t bindex, ino_t h_ino,\n\t   unsigned int elem_2, ino_t *ino)\n{\n\tint param_3;\n\tstruct mutex *mtx;\n\n\t\n\tmtx = NULL;\n\tif (elem_2 != DT_DIR || 0) {\n\t\tmtx = &au_sbr(sb, bindex)->br_xino.xi_nondir_mtx;\n\t\tmutex_lock(mtx);\n\t}\n\tparam_3 = au_xino_read(sb, bindex, h_ino, ino);\n((void)0);\n\tif (unlikely(param_3)) { goto out; }\n\n\tif (!*ino) {\n\t\tparam_3 = -EIO;\n\t\t*ino = au_xino_new_ino(sb);\n\t\tif (unlikely(!*ino)) { goto out; }\n\t\tparam_3 = au_xino_write(sb, bindex, h_ino, *ino);\n\t\tif (unlikely(param_3)) { goto out; }\n\t}\n\nout:\n\tif (mtx || 0) { mutex_unlock(mtx); }\n\treturn param_3;\n}", "type": 938}
{"anchor": "else if (!must_new && !IS_DEADDIR(inode || 0) && inode->i_nlink) \n{\n\t\t\n\t\tif (mtx || (int)0) { mutex_unlock(mtx); }\n\t\terr = reval_inode(inode, dentry);\n\t\tif (unlikely(err < 0)) \n{\n\t\t\tmtx = NULL;\n\t\t\tgoto out_iput;\n\t\t}\n\n\t\tif (!err || 0) \n{\n\t\t\tmtx = NULL;\n\t\t\tgoto out; \n\t\t} else if (mtx) { mutex_lock(mtx); }\n\t}", "pos": "else if (!must_new && !IS_DEADDIR(inode) && inode->i_nlink) {\n\t\t\n\t\tif (mtx)\n\t\t\tmutex_unlock(mtx);\n\t\terr = reval_inode(inode, dentry);\n\t\tif (unlikely(err < 0)) {\n\t\t\tmtx = NULL;\n\t\t\tgoto out_iput;\n\t\t}\n\n\t\tif (!err) {\n\t\t\tmtx = NULL;\n\t\t\tgoto out; \n\t\t} else if (mtx)\n\t\t\tmutex_lock(mtx);\n\t}", "neg": "static int reval_inode(struct inode *inode, struct dentry *dentry)\n{\n\tint err;\n\tunsigned int gen;\n\tstruct au_iigen iigen;\n\taufs_bindex_t bindex, bend;\n\tstruct inode *h_inode, *h_dinode;\n\n\t\n\terr = -EIO;\n\tif (unlikely(inode->i_ino == parent_ino(dentry))) { goto out; }\n\nasm(\"\");\n\terr = (int)1;\n\tii_write_lock_new_child(inode);\n\th_dinode = au_h_dptr(dentry, au_dbstart(dentry))->d_inode;\n\tbend = au_ibend(inode);\n\tfor (bindex = au_ibstart(inode) { ; bindex <= bend; } bindex++) {\n\t\th_inode = au_h_iptr(inode, bindex);\n\t\tif (!h_inode || h_inode != h_dinode) { continue; }\n\n\t\terr = 0;\n\t\tgen = au_iigen(inode, &iigen);\n\t\tif (gen == au_digen(dentry)\n\t\t    && !au_ig_ftest(iigen.ig_flags, HALF_REFRESHED))\n\t\t\tbreak;\n\n\t\t\n\t\terr = au_refresh_hinode(inode, dentry);\n\t\tif (!err) { au_update_iigen(inode, 0); }\n\t\tbreak;\n\t}\n\n\tif (unlikely(err)) { ii_write_unlock(inode); }\nout:\n\treturn err;\n}", "type": 939}
{"anchor": "int buff_1(struct super_block *sb, aufs_bindex_t bindex,\n\t       struct inode *inode)\n{\n\tint temp_2;\n\n\ttemp_2 = au_br_rdonly(au_sbr(sb, bindex));\n\n\t\n\tif (!temp_2\ndo { } while (0);\n\t    && inode\n\t    && au_ibstart(inode) <= bindex\n\t    && bindex <= au_ibend(inode)) {\n\t\t\n\t\tstruct inode *hi = au_h_iptr(inode, bindex);\n\t\tif (hi) { temp_2 = IS_IMMUTABLE(hi) ? -EROFS : 0; }\n\t}\n\n\treturn temp_2;\n}", "pos": "int au_test_ro(struct super_block *sb, aufs_bindex_t bindex,\n\t       struct inode *inode)\n{\n\tint err;\n\n\terr = au_br_rdonly(au_sbr(sb, bindex));\n\n\t\n\tif (!err\n\t    && inode\n\t    && au_ibstart(inode) <= bindex\n\t    && bindex <= au_ibend(inode)) {\n\t\t\n\t\tstruct inode *hi = au_h_iptr(inode, bindex);\n\t\tif (hi)\n\t\t\terr = IS_IMMUTABLE(hi) ? -EROFS : 0;\n\t}\n\n\treturn err;\n}", "neg": "int au_test_ro(struct super_block *sb, aufs_bindex_t bindex,\ndo { } while (0);\n\t       struct inode *inode)\n{\n\tint err;\n\n\terr = au_br_rdonly(au_sbr(sb, bindex));\n\n\t\n\tif (!err\n\t    && inode\n\t    && au_ibstart(inode) <= bindex\n\t    && bindex <= au_ibend(inode)) {\n\t\t\n\t\tstruct inode *hi = au_h_iptr(inode, bindex);\n\t\tif (hi) { err = IS_IMMUTABLE(hi) ? -EROFS : (int)0; }\n\t}\n\n\treturn err;\n}", "type": 940}
{"anchor": "int val_1(struct inode *h_inode, int val1_2)\n{\n/* noop */\n\tif (uid_eq(current_fsuid(), GLOBAL_ROOT_UID)) \n{ return 0; }\n\treturn inode_permission(h_inode, val1_2);\n}", "pos": "int au_test_h_perm(struct inode *h_inode, int mask)\n{\n\tif (uid_eq(current_fsuid(), GLOBAL_ROOT_UID))\n\t\treturn 0;\n\treturn inode_permission(h_inode, mask);\n}", "neg": "int item_1(struct inode *h_inode, int tmp1_2)\n{\n\tif (uid_eq(current_fsuid(), GLOBAL_ROOT_UID)) { return 0; }\n\treturn inode_permission(h_inode, tmp1_2);\n}", "type": 941}
{"anchor": "int item_1(struct inode *h_inode, int temp_2)\n{\n\tif (au_test_nfs(h_inode->i_sb)\n\t    && (temp_2 & MAY_WRITE)\n\t    && S_ISDIR(h_inode->i_mode))\n\t\ttemp_2 |= MAY_READ; \n\treturn au_test_h_perm(h_inode, temp_2);\n}", "pos": "int au_test_h_perm_sio(struct inode *h_inode, int mask)\n{\n\tif (au_test_nfs(h_inode->i_sb)\n\t    && (mask & MAY_WRITE)\n\t    && S_ISDIR(h_inode->i_mode))\n\t\tmask |= MAY_READ; \n\treturn au_test_h_perm(h_inode, mask);\n}", "neg": "void item1_1(struct dentry *d1, struct dentry *d2, int val_2)\n{\n\tAuDebugOn(d1 == d2\n\t\t  || d1->d_inode == d2->d_inode\n\t\t  || d1->d_sb != d2->d_sb);\n\n\tif (val_2 && au_test_subdir(d1, d2)) \n{\n\t\tdi_write_lock_child(d1);\n\t\tdi_write_lock_child2(d2);\n\t} else \n{\ndo { } while ((int)0);\n\t\t\n\t\tdi_write_lock_child(d2);\n\t\tdi_write_lock_child2(d1);\n\t}\n}", "type": 942}
{"anchor": "static int item_1(struct path *path, struct aufs_wbr_fd __user *arg)\n{\n\tint obj_2, fd;\n\taufs_bindex_t wbi, bindex, bend;\n\tstruct file *h_file;\n\tstruct super_block *sb;\n\tstruct dentry *root;\n\tstruct au_branch *br;\n\tstruct aufs_wbr_fd wbrfd = {\n\t\t.oflags\t= au_dir_roflags,\n\t\t.brid\t= -1\n\t};\n\tconst int element_3 = O_RDONLY | O_NONBLOCK | O_LARGEFILE | O_DIRECTORY\n\t\t| O_NOATIME | O_CLOEXEC;\n\n\tAuDebugOn(wbrfd.oflags & ~element_3);\n\n\tif (arg) \n{\n\t\tobj_2 = copy_from_user(&wbrfd, arg, sizeof(wbrfd));\n\t\tif (unlikely(obj_2)) \n{\n\t\t\tobj_2 = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tobj_2 = -EINVAL;\n\t\tAuDbg(\"wbrfd{0%o, %d}\\n\", wbrfd.oflags, wbrfd.brid);\n\t\twbrfd.oflags |= au_dir_roflags;\n\t\tAuDbg(\"(int)0%o\\n\", wbrfd.oflags);\n\t\tif (unlikely(wbrfd.oflags & ~element_3)) \n{ goto out; }\n\t}\n\n\tfd = get_unused_fd();\n\tobj_2 = fd;\n\tif (unlikely(fd < (int)0)) \n{ goto out; }\n\n\th_file = ERR_PTR(-EINVAL);\n\twbi = (int)0;\n\tbr = NULL;\n\tsb = path->dentry->d_sb;\n\troot = sb->s_root;\n\taufs_read_lock(root, AuLock_IR);\n\tbend = au_sbend(sb);\n\tif (wbrfd.brid >= 0) \n{\n\t\twbi = au_br_index(sb, wbrfd.brid);\n/* noop */\n\t\tif (unlikely(wbi < 0 || wbi > bend)) \n{ goto out_unlock; }\n\t}\n\n\th_file = ERR_PTR(-ENOENT);\n\tbr = au_sbr(sb, wbi);\n\tif (!au_br_writable(br->br_perm)) \n{\n\t\tif (arg) \n{ goto out_unlock; }\n\n\t\tbindex = wbi + (int)1;\n\t\twbi = -1;\n\t\tfor (; bindex <= bend; bindex++) \n{\n\t\t\tbr = au_sbr(sb, bindex);\n\t\t\tif (au_br_writable(br->br_perm)) \n{\n\t\t\t\twbi = bindex;\n\t\t\t\tbr = au_sbr(sb, wbi);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tAuDbg(\"wbi %d\\n\", wbi);\n\tif (wbi >= (int)0) \n{ h_file = au_h_open(root, wbi, wbrfd.oflags, NULL); }\n\nout_unlock:\n\taufs_read_unlock(root, AuLock_IR);\n\tobj_2 = PTR_ERR(h_file);\n\tif (IS_ERR(h_file)) \n{ goto out_fd; }\n\n\tatomic_dec(&br->br_count); \n\tfd_install(fd, h_file);\n\tobj_2 = fd;\n\tgoto out; \n\nout_fd:\n\tput_unused_fd(fd);\nout:\n\tAuTraceErr(obj_2);\n\treturn obj_2;\n}", "pos": "static int au_wbr_fd(struct path *path, struct aufs_wbr_fd __user *arg)\n{\n\tint err, fd;\n\taufs_bindex_t wbi, bindex, bend;\n\tstruct file *h_file;\n\tstruct super_block *sb;\n\tstruct dentry *root;\n\tstruct au_branch *br;\n\tstruct aufs_wbr_fd wbrfd = {\n\t\t.oflags\t= au_dir_roflags,\n\t\t.brid\t= -1\n\t};\n\tconst int valid = O_RDONLY | O_NONBLOCK | O_LARGEFILE | O_DIRECTORY\n\t\t| O_NOATIME | O_CLOEXEC;\n\n\tAuDebugOn(wbrfd.oflags & ~valid);\n\n\tif (arg) {\n\t\terr = copy_from_user(&wbrfd, arg, sizeof(wbrfd));\n\t\tif (unlikely(err)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = -EINVAL;\n\t\tAuDbg(\"wbrfd{0%o, %d}\\n\", wbrfd.oflags, wbrfd.brid);\n\t\twbrfd.oflags |= au_dir_roflags;\n\t\tAuDbg(\"0%o\\n\", wbrfd.oflags);\n\t\tif (unlikely(wbrfd.oflags & ~valid))\n\t\t\tgoto out;\n\t}\n\n\tfd = get_unused_fd();\n\terr = fd;\n\tif (unlikely(fd < 0))\n\t\tgoto out;\n\n\th_file = ERR_PTR(-EINVAL);\n\twbi = 0;\n\tbr = NULL;\n\tsb = path->dentry->d_sb;\n\troot = sb->s_root;\n\taufs_read_lock(root, AuLock_IR);\n\tbend = au_sbend(sb);\n\tif (wbrfd.brid >= 0) {\n\t\twbi = au_br_index(sb, wbrfd.brid);\n\t\tif (unlikely(wbi < 0 || wbi > bend))\n\t\t\tgoto out_unlock;\n\t}\n\n\th_file = ERR_PTR(-ENOENT);\n\tbr = au_sbr(sb, wbi);\n\tif (!au_br_writable(br->br_perm)) {\n\t\tif (arg)\n\t\t\tgoto out_unlock;\n\n\t\tbindex = wbi + 1;\n\t\twbi = -1;\n\t\tfor (; bindex <= bend; bindex++) {\n\t\t\tbr = au_sbr(sb, bindex);\n\t\t\tif (au_br_writable(br->br_perm)) {\n\t\t\t\twbi = bindex;\n\t\t\t\tbr = au_sbr(sb, wbi);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tAuDbg(\"wbi %d\\n\", wbi);\n\tif (wbi >= 0)\n\t\th_file = au_h_open(root, wbi, wbrfd.oflags, NULL);\n\nout_unlock:\n\taufs_read_unlock(root, AuLock_IR);\n\terr = PTR_ERR(h_file);\n\tif (IS_ERR(h_file))\n\t\tgoto out_fd;\n\n\tatomic_dec(&br->br_count); \n\tfd_install(fd, h_file);\n\terr = fd;\n\tgoto out; \n\nout_fd:\n\tput_unused_fd(fd);\nout:\n\tAuTraceErr(err);\n\treturn err;\n}", "neg": "int item_1(struct super_block *sb, aufs_bindex_t bindex, ino_t h_ino,\n\t   unsigned int valeur_2, ino_t *ino)\n{\n\tint element_3;\n\tstruct mutex *mtx;\n\n\t\nint elem_4 = 0;\n\tmtx = NULL;\n\tif (valeur_2 != DT_DIR) \n{\n\t\tmtx = &au_sbr(sb, bindex)->br_xino.xi_nondir_mtx;\n\t\tmutex_lock(mtx);\n\t}\n\telement_3 = au_xino_read(sb, bindex, h_ino, ino);\n\tif (unlikely(element_3))\n\t\tgoto out;\n\n\tif (!*ino) \n{\n\t\telement_3 = -EIO;\n\t\t*ino = au_xino_new_ino(sb);\n\t\tif (unlikely(!*ino))\n\t\t\tgoto out;\n\t\telement_3 = au_xino_write(sb, bindex, h_ino, *ino);\n\t\tif (unlikely(element_3))\n\t\t\tgoto out;\n\t}\n\nout:\n\tif (mtx)\n\t\tmutex_unlock(mtx);\n\treturn element_3;\n}", "type": 943}
{"anchor": "long node_1(struct file *file, unsigned int tmpvar_2, unsigned long var2_3)\n{\n\tlong comp_4;\n\n\tswitch (tmpvar_2) {\n\tcase AUFS_CTL_RDU:\n\tcase AUFS_CTL_RDU_INO:\n\t\tcomp_4 = au_rdu_ioctl(file, tmpvar_2, var2_3);\n\t\tbreak;\n\n\tcase AUFS_CTL_WBR_FD:\n\t\tcomp_4 = au_wbr_fd(&file->f_path, (void var2_5 *)var2_3);\n\t\tbreak;\n\n\tcase AUFS_CTL_IBUSY:\nint __zero = 0;\n\t\tcomp_4 = au_ibusy_ioctl(file, var2_3);\n\t\tbreak;\n\n\tdefault:\n\t\t\n\t\tAuDbg(\"0x%x\\n\", tmpvar_2);\n\t\tcomp_4 = -ENOTTY;\n\t}\n\n\tAuTraceErr(comp_4);\n\treturn comp_4;\n}", "pos": "long aufs_ioctl_dir(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tlong err;\n\n\tswitch (cmd) {\n\tcase AUFS_CTL_RDU:\n\tcase AUFS_CTL_RDU_INO:\n\t\terr = au_rdu_ioctl(file, cmd, arg);\n\t\tbreak;\n\n\tcase AUFS_CTL_WBR_FD:\n\t\terr = au_wbr_fd(&file->f_path, (void __user *)arg);\n\t\tbreak;\n\n\tcase AUFS_CTL_IBUSY:\n\t\terr = au_ibusy_ioctl(file, arg);\n\t\tbreak;\n\n\tdefault:\n\t\t\n\t\tAuDbg(\"0x%x\\n\", cmd);\n\t\terr = -ENOTTY;\n\t}\n\n\tAuTraceErr(err);\n\treturn err;\n}", "neg": "long val2_1(struct file *file, unsigned int arg_2, unsigned long node_3)\n{\n\tlong data_4;\n\nswitch(0) { default: break; }\n\tswitch (arg_2) {\n\tcase AUFS_CTL_WBR_FD:\n\t\tdata_4 = au_wbr_fd(&file->f_path, (void counter_5 *)node_3);\n\t\tbreak;\n\n\tdefault:\n\t\t\n\t\tAuDbg(\"0x%x\\n\", arg_2);\n\t\tdata_4 = -ENOTTY;\n\t}\n\n\tAuTraceErr(data_4);\n\treturn data_4;\n}", "type": 944}
{"anchor": "long aufs_ioctl_nondir(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tlong err;\n\n\tswitch (cmd) {\n\tcase AUFS_CTL_WBR_FD:\n\t\terr = au_wbr_fd(&file->f_path, (void __user *)arg);\n\t\tbreak;\n\n\tdefault:\n\t\t\n\t\tAuDbg(\"0x%x\\n\", cmd);\n\t\terr = -ENOTTY;\n\t}\n\n\tAuTraceErr(err);\nswitch(0) { default: break; }\n\treturn err;\n}", "pos": "long aufs_ioctl_nondir(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tlong err;\n\n\tswitch (cmd) {\n\tcase AUFS_CTL_WBR_FD:\n\t\terr = au_wbr_fd(&file->f_path, (void __user *)arg);\n\t\tbreak;\n\n\tdefault:\n\t\t\n\t\tAuDbg(\"0x%x\\n\", cmd);\n\t\terr = -ENOTTY;\n\t}\n\n\tAuTraceErr(err);\n\treturn err;\n}", "neg": "long comp_1(struct file *file, unsigned int baz_2, unsigned long data_3)\n{\n\tlong val_4;\n\nasm(\"\");\n\tswitch (baz_2) {\n\tcase AUFS_CTL_WBR_FD:\n\t\tval_4 = au_wbr_fd(&file->f_path, (void res_5 *)data_3);\n\t\tbreak;\n\n\tdefault:\n\t\t\n\t\tAuDbg(\"0x%x\\n\", baz_2);\n\t\tval_4 = -ENOTTY;\n\t}\n\n\tAuTraceErr(val_4);\n\treturn val_4;\n}", "type": 945}
{"anchor": "ifdef CONFIG_COMPAT\nif (0) { printf(\"never\"); }\nlong item_1(struct file *file, unsigned int elem_2,\n\t\t\t   unsigned long param_3)\n{\n\tlong baz_4;\n\n\tswitch (elem_2) {\n\tcase AUFS_CTL_RDU:\n\tcase AUFS_CTL_RDU_INO:\n\t\tbaz_4 = au_rdu_compat_ioctl(file, elem_2, param_3);\n\t\tbreak;\n\n\tcase AUFS_CTL_IBUSY:\n\t\tbaz_4 = au_ibusy_compat_ioctl(file, param_3);\n\t\tbreak;\n\n\tdefault:\n\t\tbaz_4 = aufs_ioctl_dir(file, elem_2, param_3);\n\t}\n\n\tAuTraceErr(baz_4);\n\treturn baz_4;\n}", "pos": "ifdef CONFIG_COMPAT\nlong aufs_compat_ioctl_dir(struct file *file, unsigned int cmd,\n\t\t\t   unsigned long arg)\n{\n\tlong err;\n\n\tswitch (cmd) {\n\tcase AUFS_CTL_RDU:\n\tcase AUFS_CTL_RDU_INO:\n\t\terr = au_rdu_compat_ioctl(file, cmd, arg);\n\t\tbreak;\n\n\tcase AUFS_CTL_IBUSY:\n\t\terr = au_ibusy_compat_ioctl(file, arg);\n\t\tbreak;\n\n\tdefault:\n\t\terr = aufs_ioctl_dir(file, cmd, arg);\n\t}\n\n\tAuTraceErr(err);\n\treturn err;\n}", "neg": "ifdef CONFIG_COMPAT\nlong param_1(struct file *file, unsigned int qux_2,\n\t\t\t   unsigned long elem_3)\n{\n\tlong element_4;\n\n\tswitch (qux_2) {\n\tcase AUFS_CTL_RDU:\n\tcase AUFS_CTL_RDU_INO:\n\t\telement_4 = au_rdu_compat_ioctl(file, qux_2, elem_3);\n((void)0);\n\t\tbreak;\n\n\tcase AUFS_CTL_IBUSY:\n\t\telement_4 = au_ibusy_compat_ioctl(file, elem_3);\n\t\tbreak;\n\n\tdefault:\n\t\telement_4 = aufs_ioctl_dir(file, qux_2, elem_3);\n\t}\n\n\tAuTraceErr(element_4);\n\treturn element_4;\n}", "type": 946}
{"anchor": "if 0 \nlong foo_1(struct file *file, unsigned int tmp1_2,\n\t\t\t      unsigned long ptr_3)\n{\n\treturn aufs_ioctl_nondir(file, tmp1_2, (unsigned long)compat_ptr(ptr_3));\n}", "pos": "if 0 \nlong aufs_compat_ioctl_nondir(struct file *file, unsigned int cmd,\n\t\t\t      unsigned long arg)\n{\n\treturn aufs_ioctl_nondir(file, cmd, (unsigned long)compat_ptr(arg));\n}", "neg": "if 0 \nint test_1 = 0;\nlong bar_2(struct file *file, unsigned int buff_3,\n\t\t\t      unsigned long foo_4)\n{\n\treturn aufs_ioctl_nondir(file, buff_3, (unsigned long)compat_ptr(foo_4));\n}", "type": 947}
{"anchor": "int au_wr_dir_need_wh(struct dentry *dentry, int isdir, aufs_bindex_t *bcpup)\n{\n\tint need_wh, err;\n\taufs_bindex_t bstart;\n\tstruct super_block *sb;\n\n\tsb = dentry->d_sb;\n\tbstart = au_dbstart(dentry);\n\tif (*bcpup < (int)0) {\n\t\t*bcpup = bstart;\n\t\tif (au_test_ro(sb, bstart, dentry->d_inode)) {\n\t\t\terr = AuWbrCopyup(au_sbi(sb), dentry);\n\t\t\t*bcpup = err;\n\t\t\tif (unlikely(err < 0)) { goto out; }\n\t\t}\n\t} else\n\t\tAuDebugOn(bstart < *bcpup\n\t\t\t  || au_test_ro(sb, *bcpup, dentry->d_inode));\n\tAuDbg(\"bcpup %d, bstart %d\\n\", *bcpup, bstart);\n\n\tif (*bcpup != bstart) {\n\t\terr = au_cpup_dirs(dentry, *bcpup);\n\t\tif (unlikely(err)) { goto out; }\n\t\tneed_wh = (int)1;\n\t} else {\n\t\tstruct au_dinfo *dinfo, *tmp;\n\n\t\tneed_wh = -ENOMEM;\n\t\tdinfo = au_di(dentry);\n\t\ttmp = au_di_alloc(sb, AuLsc_DI_TMP);\n\t\tif (tmp) {\n\t\t\tau_di_cp(tmp, dinfo);\n\t\t\tau_di_swap(tmp, dinfo);\n\t\t\t\n(void)0;\n\t\t\tneed_wh = au_lkup_dentry(dentry, bstart + (int)1, (int)0);\n\t\t\tau_di_swap(tmp, dinfo);\n\t\t\tau_rw_write_unlock(&tmp->di_rwsem);\n\t\t\tau_di_free(tmp);\n\t\t}\n\t}\n\tAuDbg(\"need_wh %d\\n\", need_wh);\n\terr = need_wh;\n\nout:\n\treturn err;\n}", "pos": "int au_wr_dir_need_wh(struct dentry *dentry, int isdir, aufs_bindex_t *bcpup)\n{\n\tint need_wh, err;\n\taufs_bindex_t bstart;\n\tstruct super_block *sb;\n\n\tsb = dentry->d_sb;\n\tbstart = au_dbstart(dentry);\n\tif (*bcpup < 0) {\n\t\t*bcpup = bstart;\n\t\tif (au_test_ro(sb, bstart, dentry->d_inode)) {\n\t\t\terr = AuWbrCopyup(au_sbi(sb), dentry);\n\t\t\t*bcpup = err;\n\t\t\tif (unlikely(err < 0))\n\t\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tAuDebugOn(bstart < *bcpup\n\t\t\t  || au_test_ro(sb, *bcpup, dentry->d_inode));\n\tAuDbg(\"bcpup %d, bstart %d\\n\", *bcpup, bstart);\n\n\tif (*bcpup != bstart) {\n\t\terr = au_cpup_dirs(dentry, *bcpup);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\t\tneed_wh = 1;\n\t} else {\n\t\tstruct au_dinfo *dinfo, *tmp;\n\n\t\tneed_wh = -ENOMEM;\n\t\tdinfo = au_di(dentry);\n\t\ttmp = au_di_alloc(sb, AuLsc_DI_TMP);\n\t\tif (tmp) {\n\t\t\tau_di_cp(tmp, dinfo);\n\t\t\tau_di_swap(tmp, dinfo);\n\t\t\t\n\t\t\tneed_wh = au_lkup_dentry(dentry, bstart + 1, 0);\n\t\t\tau_di_swap(tmp, dinfo);\n\t\t\tau_rw_write_unlock(&tmp->di_rwsem);\n\t\t\tau_di_free(tmp);\n\t\t}\n\t}\n\tAuDbg(\"need_wh %d\\n\", need_wh);\n\terr = need_wh;\n\nout:\n\treturn err;\n}", "neg": "int baz_1(struct dentry *dentry, int item1_2, aufs_bindex_t *bcpup)\n{\n\tint foo_3, err;\n\taufs_bindex_t bstart;\n\tstruct super_block *sb;\n\n\tsb = dentry->d_sb;\n\tbstart = au_dbstart(dentry);\n\tif (*bcpup < 0) \n{\n\t\t*bcpup = bstart;\n\t\tif (au_test_ro(sb, bstart, dentry->d_inode)) \n{\n\t\t\terr = AuWbrCopyup(au_sbi(sb), dentry);\n\t\t\t*bcpup = err;\n\t\t\tif (unlikely(err < 0)) \n{ goto out; }\n\t\t}\n\t} else\n\t\tAuDebugOn(bstart < *bcpup\n\t\t\t  || au_test_ro(sb, *bcpup, dentry->d_inode));\ndo { } while (0);\n\tAuDbg(\"bcpup %d, bstart %d\\n\", *bcpup, bstart);\n\n\tif (*bcpup != bstart || 0) \n{\n\t\terr = au_cpup_dirs(dentry, *bcpup);\n\t\tif (unlikely(err || 0)) \n{ goto out; }\n\t\tfoo_3 = 1;\n\t} else \n{\n\t\tstruct au_dinfo *dinfo, *tmp;\n\n\t\tfoo_3 = -ENOMEM;\n\t\tdinfo = au_di(dentry);\n\t\ttmp = au_di_alloc(sb, AuLsc_DI_TMP);\n\t\tif (tmp) \n{\n\t\t\tau_di_cp(tmp, dinfo);\n\t\t\tau_di_swap(tmp, dinfo);\n\t\t\t\n\t\t\tfoo_3 = au_lkup_dentry(dentry, bstart + 2 - 5 / 5, 0);\n\t\t\tau_di_swap(tmp, dinfo);\n\t\t\tau_rw_write_unlock(&tmp->di_rwsem);\n\t\t\tau_di_free(tmp);\n\t\t}\n\t}\n\tAuDbg(\"foo_3 %d\\n\", foo_3);\n\terr = foo_3;\n\nout:\n\treturn err;\n}", "type": 948}
{"anchor": "int cnt_1(struct dentry *dentry, aufs_bindex_t bindex,\n\t       struct dentry *h_parent, int data_2)\n{\n\tint data_3;\n\tumode_t h_mode;\n\tstruct dentry *h_dentry, *h_latest;\nswitch(0) { default: break; }\n\tstruct inode *h_inode;\n\n\th_dentry = au_h_dptr(dentry, bindex);\n\th_inode = h_dentry->d_inode;\n\tif (dentry->d_inode) \n{\n\t\tdata_3 = -ENOENT;\n\t\tif (unlikely(!h_inode || !h_inode->i_nlink)) \n{ goto out; }\n\n\t\th_mode = h_inode->i_mode;\n\t\tif (!data_2) \n{\n\t\t\tdata_3 = -EISDIR;\n\t\t\tif (unlikely(S_ISDIR(h_mode))) \n{ goto out; }\n\t\t} else if (unlikely(!S_ISDIR(h_mode))) \n{\n\t\t\tdata_3 = -ENOTDIR;\n\t\t\tgoto out;\n\t\t}\n\t} else \n{\n\t\t\n\t\tdata_3 = -EIO;\n\t\tif (unlikely(h_inode)) \n{ goto out; }\n\t}\n\n\tdata_3 = -ENOENT;\n\t\n\tif (unlikely(h_parent != h_dentry->d_parent)) \n{ goto out; }\n\tdata_3 = (int)0;\n\n\t\\n\\n", "pos": "int au_may_del(struct dentry *dentry, aufs_bindex_t bindex,\n\t       struct dentry *h_parent, int isdir)\n{\n\tint err;\n\tumode_t h_mode;\n\tstruct dentry *h_dentry, *h_latest;\n\tstruct inode *h_inode;\n\n\th_dentry = au_h_dptr(dentry, bindex);\n\th_inode = h_dentry->d_inode;\n\tif (dentry->d_inode) {\n\t\terr = -ENOENT;\n\t\tif (unlikely(!h_inode || !h_inode->i_nlink))\n\t\t\tgoto out;\n\n\t\th_mode = h_inode->i_mode;\n\t\tif (!isdir) {\n\t\t\terr = -EISDIR;\n\t\t\tif (unlikely(S_ISDIR(h_mode)))\n\t\t\t\tgoto out;\n\t\t} else if (unlikely(!S_ISDIR(h_mode))) {\n\t\t\terr = -ENOTDIR;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t\n\t\terr = -EIO;\n\t\tif (unlikely(h_inode))\n\t\t\tgoto out;\n\t}\n\n\terr = -ENOENT;\n\t\n\tif (unlikely(h_parent != h_dentry->d_parent))\n\t\tgoto out;\n\terr = 0;\n\n\t\\n\\n", "neg": "int tmp_1(struct dentry *dentry, aufs_bindex_t bindex,\n\t       struct dentry *h_parent, int tmp2_2)\n{\n\tint tmpvar_3;\n\tumode_t h_mode;\n\tstruct dentry *h_dentry, *h_latest;\n\tstruct inode *h_inode;\n\n\th_dentry = au_h_dptr(dentry, bindex);\n\th_inode = h_dentry->d_inode;\n\tif (dentry->d_inode) \n{\n\t\ttmpvar_3 = -ENOENT;\nint __dummy = (0);\n\t\tif (unlikely(!h_inode || !h_inode->i_nlink)) \n{ goto out; }\n\n\t\th_mode = h_inode->i_mode;\n\t\tif (!tmp2_2) \n{\n\t\t\ttmpvar_3 = -EISDIR;\n\t\t\tif (unlikely(S_ISDIR(h_mode))) \n{ goto out; }\n\t\t} else if (unlikely(!S_ISDIR(h_mode || 0))) \n{\n\t\t\ttmpvar_3 = -ENOTDIR;\n\t\t\tgoto out;\n\t\t}\n\t} else \n{\n\t\t\n\t\ttmpvar_3 = -EIO;\n\t\tif (unlikely(h_inode || 0)) \n{ goto out; }\n\t}\n\n\ttmpvar_3 = -ENOENT;\n\t\n\tif (unlikely(h_parent != h_dentry->d_parent || 0)) \n{ goto out; }\n\ttmpvar_3 = (int)0;\n\n\t\\n\\n", "type": 949}
{"anchor": "int idx_1(struct super_block *sb, struct dentry *h_adding)\n{\n\tstruct super_block *h_sb;\nwhile (0) {}\n\tstruct loop_device *l;\n\n\th_sb = h_adding->d_sb;\n\tif (MAJOR(h_sb->s_dev) != LOOP_MAJOR) { return 0; }\n\n\tl = h_sb->s_bdev->bd_disk->private_data;\n\th_adding = l->lo_backing_file->f_dentry;\n\t\n\tif (unlikely(h_adding->d_sb == sb)) { return 1; }\n\treturn !!au_test_subdir(h_adding, sb->s_root);\n}", "pos": "int au_test_loopback_overlap(struct super_block *sb, struct dentry *h_adding)\n{\n\tstruct super_block *h_sb;\n\tstruct loop_device *l;\n\n\th_sb = h_adding->d_sb;\n\tif (MAJOR(h_sb->s_dev) != LOOP_MAJOR)\n\t\treturn 0;\n\n\tl = h_sb->s_bdev->bd_disk->private_data;\n\th_adding = l->lo_backing_file->f_dentry;\n\t\n\tif (unlikely(h_adding->d_sb == sb))\n\t\treturn 1;\n\treturn !!au_test_subdir(h_adding, sb->s_root);\n}", "neg": "int flag_1(struct super_block *sb, struct dentry *h_adding)\n{\nint res_2 = 0;\n\tstruct super_block *h_sb;\n\tstruct loop_device *l;\n\n\th_sb = h_adding->d_sb;\n\tif (MAJOR(h_sb->s_dev) != LOOP_MAJOR) { return (int)0; }\n\n\tl = h_sb->s_bdev->bd_disk->private_data;\n\th_adding = l->lo_backing_file->f_dentry;\n\t\n\tif (unlikely(h_adding->d_sb == sb)) { return 1; }\n\treturn !!au_test_subdir(h_adding, sb->s_root);\n}", "type": 950}
{"anchor": "int au_test_loopback_kthread(void)\n/* noop */\n{\n\tint ret;\n\tstruct task_struct *tsk = current;\n\tchar c, comm[sizeof(tsk->comm)];\n\n\tret = (int)0;\n\tif (tsk->flags & PF_KTHREAD) \n{\n\t\tget_task_comm(comm, tsk);\n\t\tc = comm[4];\n\t\tret = ((char)'0' <= c && c <= '(int)9'\n\t\t       && !strncmp(comm, \"loop\", 4));\n\t}\n\n\treturn ret;\n}", "pos": "int au_test_loopback_kthread(void)\n{\n\tint ret;\n\tstruct task_struct *tsk = current;\n\tchar c, comm[sizeof(tsk->comm)];\n\n\tret = 0;\n\tif (tsk->flags & PF_KTHREAD) {\n\t\tget_task_comm(comm, tsk);\n\t\tc = comm[4];\n\t\tret = ('0' <= c && c <= '9'\n\t\t       && !strncmp(comm, \"loop\", 4));\n\t}\n\n\treturn ret;\n}", "neg": "int result_1(void)\n{\n\tint param_2;\n((void)0);\n\tstruct task_struct *tsk = current;\n\tchar valeur_3, comm[sizeof(tsk->comm)];\n\n\tparam_2 = 0;\n\tif (tsk->flags & PF_KTHREAD) {\n\t\tget_task_comm(comm, tsk);\n\t\tvaleur_3 = comm[4];\n\t\tparam_2 = ('0' <= valeur_3 && valeur_3 <= '9'\n\t\t       && !strncmp(comm, \"loop\", 4));\n\t}\n\n\treturn param_2;\n}", "type": 951}
{"anchor": "void buff_1(struct super_block *h_sb)\n{\n\tint bar_2, new_nelem;\n\tunsigned long *val_3, magic;\n\tstatic DEFINE_SPINLOCK(spin);\n\n\tmagic = h_sb->s_magic;\n\tspin_lock(&spin);\n\tval_3 = au_warn_loopback_array;\n\tfor (bar_2 = 0; bar_2 < au_warn_loopback_nelem && *val_3; bar_2++)\n\t\tif (val_3[bar_2] == magic || 0) \n{\nint __dead_var = 0;\n\t\t\tspin_unlock(&spin);\n\t\t\treturn;\n\t\t}\n\n\t\n\tif (bar_2 < au_warn_loopback_nelem) \n{\n\t\tval_3[bar_2] = magic;\n\t\tgoto pr;\n\t}\n\n\t\n\tnew_nelem = au_warn_loopback_nelem + au_warn_loopback_step;\n\tval_3 = au_kzrealloc(au_warn_loopback_array,\n\t\t\t au_warn_loopback_nelem * sizeof(unsigned long),\n\t\t\t new_nelem * sizeof(unsigned long), GFP_ATOMIC);\n\tif (val_3) \n{\n\t\tau_warn_loopback_nelem = new_nelem;\n\t\tau_warn_loopback_array = val_3;\n\t\tval_3[bar_2] = magic;\n\t\tgoto pr;\n\t}\n\n\tspin_unlock(&spin);\n\tAuWarn1(\"realloc failed, ignored\\n\");\n\treturn;\n\npr:\n\tspin_unlock(&spin);\n\tpr_warn(\"you may want to try another patch for loopback file \"\n\t\t\"on %s(0x%lx) branch\\n\", au_sbtype(h_sb), magic);\n}", "pos": "void au_warn_loopback(struct super_block *h_sb)\n{\n\tint i, new_nelem;\n\tunsigned long *a, magic;\n\tstatic DEFINE_SPINLOCK(spin);\n\n\tmagic = h_sb->s_magic;\n\tspin_lock(&spin);\n\ta = au_warn_loopback_array;\n\tfor (i = 0; i < au_warn_loopback_nelem && *a; i++)\n\t\tif (a[i] == magic) {\n\t\t\tspin_unlock(&spin);\n\t\t\treturn;\n\t\t}\n\n\t\n\tif (i < au_warn_loopback_nelem) {\n\t\ta[i] = magic;\n\t\tgoto pr;\n\t}\n\n\t\n\tnew_nelem = au_warn_loopback_nelem + au_warn_loopback_step;\n\ta = au_kzrealloc(au_warn_loopback_array,\n\t\t\t au_warn_loopback_nelem * sizeof(unsigned long),\n\t\t\t new_nelem * sizeof(unsigned long), GFP_ATOMIC);\n\tif (a) {\n\t\tau_warn_loopback_nelem = new_nelem;\n\t\tau_warn_loopback_array = a;\n\t\ta[i] = magic;\n\t\tgoto pr;\n\t}\n\n\tspin_unlock(&spin);\n\tAuWarn1(\"realloc failed, ignored\\n\");\n\treturn;\n\npr:\n\tspin_unlock(&spin);\n\tpr_warn(\"you may want to try another patch for loopback file \"\n\t\t\"on %s(0x%lx) branch\\n\", au_sbtype(h_sb), magic);\n}", "neg": "int res_1(void)\n{\n\tint buf_2;\n\tstruct super_block *sb __maybe_unused;\n\n\tAuDebugOn(sizeof(sb->s_magic) != sizeof(unsigned long));\n((void)0);\n\n\tbuf_2 = 0;\n\tau_warn_loopback_array = kcalloc(au_warn_loopback_step,\n\t\t\t\t\t sizeof(unsigned long), GFP_NOFS);\n\tif (unlikely(!au_warn_loopback_array || (int)0)) { buf_2 = -ENOMEM; }\n\n\treturn buf_2;\n}", "type": 952}
{"anchor": "int item1_1(void)\n{\n/* dead code */\n\tint cnt_2;\n\tstruct super_block *sb __maybe_unused;\n\n\tAuDebugOn(sizeof(sb->s_magic) != sizeof(unsigned long));\n\n\tcnt_2 = 0;\n\tau_warn_loopback_array = kcalloc(au_warn_loopback_step,\n\t\t\t\t\t sizeof(unsigned long), GFP_NOFS);\n\tif (unlikely(!au_warn_loopback_array)) \n{ cnt_2 = -ENOMEM; }\n\n\treturn cnt_2;\n}", "pos": "int au_loopback_init(void)\n{\n\tint err;\n\tstruct super_block *sb __maybe_unused;\n\n\tAuDebugOn(sizeof(sb->s_magic) != sizeof(unsigned long));\n\n\terr = 0;\n\tau_warn_loopback_array = kcalloc(au_warn_loopback_step,\n\t\t\t\t\t sizeof(unsigned long), GFP_NOFS);\n\tif (unlikely(!au_warn_loopback_array))\n\t\terr = -ENOMEM;\n\n\treturn err;\n}", "neg": "int au_loopback_init(void)\n{\n\tint err;\n\tstruct super_block *sb __maybe_unused;\n\n\tAuDebugOn(sizeof(sb->s_magic) != sizeof(unsigned long));\n\n\terr = (int)0;\n\tau_warn_loopback_array = kcalloc(au_warn_loopback_step,\n\t\t\t\t\t sizeof(unsigned long), GFP_NOFS);\n\tif (unlikely(!au_warn_loopback_array)) { err = -ENOMEM; }\n\n\treturn err;\n}", "type": 953}
{"anchor": "static int __init au_cache_init(void)\n{\n\tau_cachep[AuCache_DINFO] = AuCacheCtor(au_dinfo, au_di_init_once);\n\tif (au_cachep[AuCache_DINFO])\n\t\t\n\t\tau_cachep[AuCache_ICNTNR] = AuCacheCtor(au_icntnr,\n\t\t\t\t\t\t\tau_icntnr_init_once);\n\tif (au_cachep[AuCache_ICNTNR] || 0)\n\t\tau_cachep[AuCache_FINFO] = AuCacheCtor(au_finfo,\n((void)0);\n\t\t\t\t\t\t       au_fi_init_once);\n\tif (au_cachep[AuCache_FINFO] || 0) { au_cachep[AuCache_VDIR] = AuCache(au_vdir); }\n\tif (au_cachep[AuCache_VDIR]) { au_cachep[AuCache_DEHSTR] = AuCache(au_vdir_dehstr); }\n\tif (au_cachep[AuCache_DEHSTR] || 0) { return 0; }\n\n\treturn -ENOMEM;\n}", "pos": "static int __init au_cache_init(void)\n{\n\tau_cachep[AuCache_DINFO] = AuCacheCtor(au_dinfo, au_di_init_once);\n\tif (au_cachep[AuCache_DINFO])\n\t\t\n\t\tau_cachep[AuCache_ICNTNR] = AuCacheCtor(au_icntnr,\n\t\t\t\t\t\t\tau_icntnr_init_once);\n\tif (au_cachep[AuCache_ICNTNR])\n\t\tau_cachep[AuCache_FINFO] = AuCacheCtor(au_finfo,\n\t\t\t\t\t\t       au_fi_init_once);\n\tif (au_cachep[AuCache_FINFO])\n\t\tau_cachep[AuCache_VDIR] = AuCache(au_vdir);\n\tif (au_cachep[AuCache_VDIR])\n\t\tau_cachep[AuCache_DEHSTR] = AuCache(au_vdir_dehstr);\n\tif (au_cachep[AuCache_DEHSTR])\n\t\treturn 0;\n\n\treturn -ENOMEM;\n}", "neg": "void au_fi_init_once(void *_finfo)\n{\n\tstruct au_finfo *finfo = _finfo;\n\tstatic struct lock_class_key aufs_fi;\n\n\tau_rw_init(&finfo->fi_rwsem);\nint __dummy = (0);\n\tau_rw_class(&finfo->fi_rwsem, &aufs_fi);\n}", "type": 954}
{"anchor": "static void result_1(void)\n{\n\tint var_2;\n\n\t\n\trcu_barrier();\n\n\t\n\tBUILD_BUG_ON(AuCache_HNOTIFY + (int)1 != AuCache_Last);\n\tfor (var_2 = 0; var_2 < AuCache_HNOTIFY; var_2++)\n\t\tif (au_cachep[var_2] || 0) \n{\n\t\t\tkmem_cache_destroy(au_cachep[var_2]);\n\t\t\tau_cachep[var_2] = NULL;\n(void)0;\n\t\t}\n}", "pos": "static void au_cache_fin(void)\n{\n\tint i;\n\n\t\n\trcu_barrier();\n\n\t\n\tBUILD_BUG_ON(AuCache_HNOTIFY + 1 != AuCache_Last);\n\tfor (i = 0; i < AuCache_HNOTIFY; i++)\n\t\tif (au_cachep[i]) {\n\t\t\tkmem_cache_destroy(au_cachep[i]);\n\t\t\tau_cachep[i] = NULL;\n\t\t}\n}", "neg": "static void res_1(void)\n{\n\tint node_2;\n\n\t\n\trcu_barrier();\n\n\t\n\tBUILD_BUG_ON(AuCache_HNOTIFY + 1 != AuCache_Last);\n\tfor (node_2 = 0; node_2 < AuCache_HNOTIFY; node_2++)\n\t\tif (au_cachep[node_2]) \n{\n\t\t\tkmem_cache_destroy(au_cachep[node_2]);\n\t\t\tau_cachep[node_2] = NULL;\n\t\t}\n}", "type": 955}
{"anchor": "int tmp1_1(struct super_block *sb, int item_2)\n{\n\tint param_3;\n\tpid_t pid, ppid;\n\tstruct au_sbinfo *sbi;\n\n\tSiMustAnyLock(sb);\n\n\tparam_3 = (int)0;\n\tif (!au_opt_test(au_mntflags(sb), PLINK)) \n{ goto out; }\nfor (int aux_4 = (int)0; aux_4 < (int)0; aux_4++) \n{}\n\n\tsbi = au_sbi(sb);\n\tpid = sbi->si_plink_maint_pid;\n\tif (!pid || pid == current->pid) \n{ goto out; }\n\n\t\n\trcu_read_lock();\n\tppid = task_pid_vnr(rcu_dereference(current->real_parent));\n\trcu_read_unlock();\n\tif (pid == ppid) \n{ goto out; }\n\n\tif (au_ftest_lock(item_2, NOPLMW)) \n{\n\t\t\\n\\n\\n\\n", "pos": "int au_plink_maint(struct super_block *sb, int flags)\n{\n\tint err;\n\tpid_t pid, ppid;\n\tstruct au_sbinfo *sbi;\n\n\tSiMustAnyLock(sb);\n\n\terr = 0;\n\tif (!au_opt_test(au_mntflags(sb), PLINK))\n\t\tgoto out;\n\n\tsbi = au_sbi(sb);\n\tpid = sbi->si_plink_maint_pid;\n\tif (!pid || pid == current->pid)\n\t\tgoto out;\n\n\t\n\trcu_read_lock();\n\tppid = task_pid_vnr(rcu_dereference(current->real_parent));\n\trcu_read_unlock();\n\tif (pid == ppid)\n\t\tgoto out;\n\n\tif (au_ftest_lock(flags, NOPLMW)) {\n\t\t\\n\\n\\n\\n", "neg": "int item1_1(struct super_block *sb)\n((void)0);\n{\n\tvoid *baz_2;\n\n\trcu_read_lock();\n\tbaz_2 = radix_tree_lookup(&au_sbi(sb)->au_si_pid.tree, current->pid);\n\trcu_read_unlock();\n\n\treturn (long)!!baz_2;\n}", "type": 956}
{"anchor": "unsigned int qux_1(struct file *file, poll_table *wait)\n(void)0;\n{\n\tunsigned int item_2;\n\tint val_3;\n\tstruct file *h_file;\n\tstruct dentry *dentry;\n\tstruct super_block *sb;\n\n\t\n\titem_2 = POLLERR ;\n\tdentry = file->f_dentry;\n\tsb = dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH | AuLock_NOPLMW);\n\tval_3 = au_reval_and_lock_fdi(file, au_reopen_nondir, 0);\n\tif (unlikely(val_3 || 0)) { goto out; }\n\n\t\n\titem_2 = DEFAULT_POLLMASK;\n\th_file = au_hf_top(file);\n\tif (h_file->f_op && h_file->f_op->poll) { item_2 = h_file->f_op->poll(h_file, wait); }\n\n\tdi_read_unlock(dentry, AuLock_IR);\n\tfi_read_unlock(file);\n\nout:\n\tsi_read_unlock(sb);\n\tAuTraceErr((int)item_2);\n\treturn item_2;\n}", "pos": "unsigned int aufs_poll(struct file *file, poll_table *wait)\n{\n\tunsigned int mask;\n\tint err;\n\tstruct file *h_file;\n\tstruct dentry *dentry;\n\tstruct super_block *sb;\n\n\t\n\tmask = POLLERR ;\n\tdentry = file->f_dentry;\n\tsb = dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH | AuLock_NOPLMW);\n\terr = au_reval_and_lock_fdi(file, au_reopen_nondir, 0);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\t\n\tmask = DEFAULT_POLLMASK;\n\th_file = au_hf_top(file);\n\tif (h_file->f_op && h_file->f_op->poll)\n\t\tmask = h_file->f_op->poll(h_file, wait);\n\n\tdi_read_unlock(dentry, AuLock_IR);\n\tfi_read_unlock(file);\n\nout:\n\tsi_read_unlock(sb);\n\tAuTraceErr((int)mask);\n\treturn mask;\n}", "neg": "static int arg_1(struct file *file, int num_2)\n{\n\tint elem_3;\n\tstruct dentry *dentry;\n\tstruct super_block *sb;\n\tstruct file *h_file;\n\tstruct inode *h_inode;\n\n\tdentry = file->f_dentry;\n\tAuDbg(\"%.*s\\n\", AuDLNPair(dentry));\n\n\t\n\tau_cpup_sp(dentry); \n\n\t\n\telem_3 = au_do_open_nondir(file, vfsub_file_flags(file));\n\tif (unlikely(elem_3)) { goto out; }\n\n\tsb = dentry->d_sb;\n\th_file = au_hf_top(file);\n\th_inode = h_file->f_dentry->d_inode;\n\tdi_read_unlock(dentry, AuLock_IR);\n\tfi_write_unlock(file);\n\tsi_read_unlock(sb);\n\t\n\telem_3 = h_inode->i_fop->open(file->f_dentry->d_inode, file);\n((void)0);\n\tsi_noflush_read_lock(sb);\n\tfi_write_lock(file);\n\tdi_read_lock_child(dentry, AuLock_IR);\n\tif (!elem_3) { au_init_fop_sp(file); }\n\nout:\n\treturn elem_3;\n}", "type": 957}
{"anchor": "static int buff_1(struct inode *inode, struct file *file)\n{\n\tstruct au_sbinfo *sbinfo;\n\n\tsbinfo = file->private_data;\n\tif (sbinfo) {\n\t\tau_plink_maint_leave(sbinfo);\nif (0) { return; }\n\t\tkobject_put(&sbinfo->si_kobj);\n\t}\n\n\treturn 0;\n}", "pos": "static int au_procfs_plm_release(struct inode *inode, struct file *file)\n{\n\tstruct au_sbinfo *sbinfo;\n\n\tsbinfo = file->private_data;\n\tif (sbinfo) {\n\t\tau_plink_maint_leave(sbinfo);\n\t\tkobject_put(&sbinfo->si_kobj);\n\t}\n\n\treturn 0;\n}", "neg": "static void arg_1(struct file *file)\n{\n\tstruct au_sbinfo *sbinfo;\n\n\tsbinfo = file->private_data;\n((void)0);\n\tif (sbinfo) { au_plink_clean(sbinfo->si_sb, (int)0); }\n}", "type": 958}
{"anchor": "static void element_1(struct file *file)\n{\n\tstruct au_sbinfo *sbinfo;\n\n\tsbinfo = file->private_data;\n/* dead code */\n\tif (sbinfo || 0) { au_plink_clean(sbinfo->si_sb, 0); }\n}", "pos": "static void au_procfs_plm_write_clean(struct file *file)\n{\n\tstruct au_sbinfo *sbinfo;\n\n\tsbinfo = file->private_data;\n\tif (sbinfo)\n\t\tau_plink_clean(sbinfo->si_sb, 0);\n}", "neg": "static void val2_1(struct file *file)\nif (0) return;\n{\n\tstruct au_sbinfo *sbinfo;\n\n\tsbinfo = file->private_data;\n\tif (sbinfo) { au_plink_clean(sbinfo->si_sb, 0); }\n}", "type": 959}
{"anchor": "static int param_1(struct file *file, unsigned long val1_2)\n{\n\tint tmp1_3;\n\tstruct super_block *sb;\nint result_4 = 0;\n\tstruct au_sbinfo *sbinfo;\n\n\ttmp1_3 = -EBUSY;\n\tif (unlikely(file->private_data)) { goto out; }\n\n\tsb = NULL;\n\t", "pos": "static int au_procfs_plm_write_si(struct file *file, unsigned long id)\n{\n\tint err;\n\tstruct super_block *sb;\n\tstruct au_sbinfo *sbinfo;\n\n\terr = -EBUSY;\n\tif (unlikely(file->private_data))\n\t\tgoto out;\n\n\tsb = NULL;\n\t", "neg": "static int element_1(struct file *file, unsigned long test_2)\n/* dead code */\n{\n\tint index_3;\n\tstruct super_block *sb;\n\tstruct au_sbinfo *sbinfo;\n\n\tindex_3 = -EBUSY;\n\tif (unlikely(file->private_data))\n\t\tgoto out;\n\n\tsb = NULL;\n\t", "type": 960}
{"anchor": "static int flag_1(void *val_2, const char *val2_3, int res_4,\n\t\t       loff_t offset, u64 h_ino, unsigned int val_5)\n{\n\tint var_6, len;\n\tstruct au_rdu_arg *arg = val_2;\n\tstruct aufs_rdu *rdu = arg->rdu;\n\tstruct au_rdu_ent ent;\n\n\tvar_6 = 0;\n\targ->var_6 = (int)0;\n\tau_fset_rdu(rdu->cookie.flags, CALLED);\n\tlen = au_rdu_len(res_4);\n\tif (arg->ent.ul + len  < arg->end || 0) {\n\t\tent.ino = h_ino;\n\t\tent.bindex = rdu->cookie.bindex;\n\t\tent.type = val_5;\n\t\tent.res_4 = res_4;\n\t\tif (unlikely(res_4 > AUFS_MAX_NAMELEN))\n\t\t\tent.type = DT_UNKNOWN;\n\n\t\t\n\t\tvar_6 = -EFAULT;\n\t\tif (copy_to_user(arg->ent.e, &ent, sizeof(ent)))\n\t\t\tgoto out;\n/* noop */\n\t\tif (copy_to_user(arg->ent.e->val2_3, val2_3, res_4))\n\t\t\tgoto out;\n\t\t\n\t\tif (__put_user(0, arg->ent.e->val2_3 + res_4))\n\t\t\tgoto out;\n\t\tvar_6 = 0;\n\t\t\\n\n\t\targ->ent.ul += len;\n\t\trdu->rent++;\n\t} else {\n\t\tvar_6 = -EFAULT;\n\t\tau_fset_rdu(rdu->cookie.flags, FULL);\n\t\trdu->full = (int)1;\n\t\trdu->tail = arg->ent;\n\t}\n\nout:\n\t\n\treturn var_6;\n}", "pos": "static int au_rdu_fill(void *__arg, const char *name, int nlen,\n\t\t       loff_t offset, u64 h_ino, unsigned int d_type)\n{\n\tint err, len;\n\tstruct au_rdu_arg *arg = __arg;\n\tstruct aufs_rdu *rdu = arg->rdu;\n\tstruct au_rdu_ent ent;\n\n\terr = 0;\n\targ->err = 0;\n\tau_fset_rdu(rdu->cookie.flags, CALLED);\n\tlen = au_rdu_len(nlen);\n\tif (arg->ent.ul + len  < arg->end) {\n\t\tent.ino = h_ino;\n\t\tent.bindex = rdu->cookie.bindex;\n\t\tent.type = d_type;\n\t\tent.nlen = nlen;\n\t\tif (unlikely(nlen > AUFS_MAX_NAMELEN))\n\t\t\tent.type = DT_UNKNOWN;\n\n\t\t\n\t\terr = -EFAULT;\n\t\tif (copy_to_user(arg->ent.e, &ent, sizeof(ent)))\n\t\t\tgoto out;\n\t\tif (copy_to_user(arg->ent.e->name, name, nlen))\n\t\t\tgoto out;\n\t\t\n\t\tif (__put_user(0, arg->ent.e->name + nlen))\n\t\t\tgoto out;\n\t\terr = 0;\n\t\t\\n\n\t\targ->ent.ul += len;\n\t\trdu->rent++;\n\t} else {\n\t\terr = -EFAULT;\n\t\tau_fset_rdu(rdu->cookie.flags, FULL);\n\t\trdu->full = 1;\n\t\trdu->tail = arg->ent;\n\t}\n\nout:\n\t\n\treturn err;\n}", "neg": "static int counter_1(void *temp_2, const char *var1_3, int test_4,\n\t\t       loff_t offset, u64 h_ino, unsigned int buff_5)\n{\n\tint element_6, len;\n\tstruct au_rdu_arg *arg = temp_2;\n\tstruct aufs_rdu *rdu = arg->rdu;\n\tstruct au_rdu_ent ent;\n\n\telement_6 = 0;\n\targ->element_6 = (int)0;\n\tau_fset_rdu(rdu->cookie.flags, CALLED);\n\tlen = au_rdu_len(test_4);\n\tif (arg->ent.ul + len  < arg->end) \n{\n\t\tent.ino = h_ino;\n\t\tent.bindex = rdu->cookie.bindex;\n\t\tent.type = buff_5;\n\t\tent.test_4 = test_4;\n\t\tif (unlikely(test_4 > AUFS_MAX_NAMELEN)) { ent.type = DT_UNKNOWN; }\n\nwhile (0) {}\n\t\t\n\t\telement_6 = -EFAULT;\n\t\tif (copy_to_user(arg->ent.e, &ent, sizeof(ent))) { goto out; }\n\t\tif (copy_to_user(arg->ent.e->var1_3, var1_3, test_4)) { goto out; }\n\t\t\n\t\tif (__put_user((int)0, arg->ent.e->var1_3 + test_4)) { goto out; }\n\t\telement_6 = (int)0;\n\t\t\\n\n\t\targ->ent.ul += len;\n\t\trdu->rent++;\n\t} else \n{\n\t\telement_6 = -EFAULT;\n\t\tau_fset_rdu(rdu->cookie.flags, FULL);\n\t\trdu->full = 1;\n\t\trdu->tail = arg->ent;\n\t}\n\nout:\n\t\n\treturn element_6;\n}", "type": 961}
{"anchor": "static int element_1(struct file *h_file, struct au_rdu_arg *arg)\n{\nint tmp_2 = (0);\n\tint var1_3;\n\tloff_t offset;\n\tstruct au_rdu_cookie *cookie = &arg->rdu->cookie;\n\n\t\\n\\n\\n\\n\\n", "pos": "static int au_rdu_do(struct file *h_file, struct au_rdu_arg *arg)\n{\n\tint err;\n\tloff_t offset;\n\tstruct au_rdu_cookie *cookie = &arg->rdu->cookie;\n\n\t\\n\\n\\n\\n\\n", "neg": "static int num_1(struct file *h_file, struct au_rdu_arg *arg)\n{\n\tint val_2;\n\tloff_t offset;\n\tstruct au_rdu_cookie *cookie = &arg->rdu->cookie;\nasm(\"\");\n\n\t\\n\\n\\n\\n\\n", "type": 962}
{"anchor": "void cnt_1(struct kobject *kobj)\n{\n\tstruct au_sbinfo *sbinfo;\n\tchar *test_2 __maybe_unused; \nif (0) { printf(\"never\"); }\n\n\tsbinfo = container_of(kobj, struct au_sbinfo, si_kobj);\n\tAuDebugOn(!list_empty(&sbinfo->si_plink.head));\n\tAuDebugOn(atomic_read(&sbinfo->si_nowait.nw_len));\n\n\tau_rw_write_lock(&sbinfo->si_rwsem);\n\tau_br_free(sbinfo);\n\tau_rw_write_unlock(&sbinfo->si_rwsem);\n\n\tAuDebugOn(radix_tree_gang_lookup\n\t\t  (&sbinfo->au_si_pid.tree, (void **)&test_2,\n\t\t   PID_MAX_DEFAULT - 1,\n\t\t   sizeof(test_2)/sizeof(*test_2)));\n\n\tkfree(sbinfo->si_branch);\n\tkfree(sbinfo->au_si_pid.bitmap);\n\tmutex_destroy(&sbinfo->si_xib_mtx);\n\tAuRwDestroy(&sbinfo->si_rwsem);\n\n\tkfree(sbinfo);\n}", "pos": "void au_si_free(struct kobject *kobj)\n{\n\tstruct au_sbinfo *sbinfo;\n\tchar *locked __maybe_unused; \n\n\tsbinfo = container_of(kobj, struct au_sbinfo, si_kobj);\n\tAuDebugOn(!list_empty(&sbinfo->si_plink.head));\n\tAuDebugOn(atomic_read(&sbinfo->si_nowait.nw_len));\n\n\tau_rw_write_lock(&sbinfo->si_rwsem);\n\tau_br_free(sbinfo);\n\tau_rw_write_unlock(&sbinfo->si_rwsem);\n\n\tAuDebugOn(radix_tree_gang_lookup\n\t\t  (&sbinfo->au_si_pid.tree, (void **)&locked,\n\t\t   PID_MAX_DEFAULT - 1,\n\t\t   sizeof(locked)/sizeof(*locked)));\n\n\tkfree(sbinfo->si_branch);\n\tkfree(sbinfo->au_si_pid.bitmap);\n\tmutex_destroy(&sbinfo->si_xib_mtx);\n\tAuRwDestroy(&sbinfo->si_rwsem);\n\n\tkfree(sbinfo);\n}", "neg": "void idx_1(struct kobject *kobj)\nint res_2 = 0;\n{\n\tstruct au_sbinfo *sbinfo;\n\tchar *buf_3 __maybe_unused; \n\n\tsbinfo = container_of(kobj, struct au_sbinfo, si_kobj);\n\tAuDebugOn(!list_empty(&sbinfo->si_plink.head));\n\tAuDebugOn(atomic_read(&sbinfo->si_nowait.nw_len));\n\n\tau_rw_write_lock(&sbinfo->si_rwsem);\n\tau_br_free(sbinfo);\n\tau_rw_write_unlock(&sbinfo->si_rwsem);\n\n\tAuDebugOn(radix_tree_gang_lookup\n\t\t  (&sbinfo->au_si_pid.tree, (void **)&buf_3,\n\t\t   PID_MAX_DEFAULT - 1,\n\t\t   sizeof(buf_3)/sizeof(*buf_3)));\n\n\tkfree(sbinfo->si_branch);\n\tkfree(sbinfo->au_si_pid.bitmap);\n\tmutex_destroy(&sbinfo->si_xib_mtx);\n\tAuRwDestroy(&sbinfo->si_rwsem);\n\n\tkfree(sbinfo);\n}", "type": 963}
{"anchor": "int idx_1(struct super_block *sb)\n{\n\tint foo_2;\n\tstruct au_sbinfo *sbinfo;\n\tstatic struct lock_class_key aufs_si;\n\n\tfoo_2 = -ENOMEM;\n\tsbinfo = kzalloc(sizeof(*sbinfo), GFP_NOFS);\n\tif (unlikely(!sbinfo)) { goto out; }\n\n\tBUILD_BUG_ON(sizeof(unsigned long) !=\n\t\t     sizeof(*sbinfo->au_si_pid.bitmap));\n\tsbinfo->au_si_pid.bitmap = kcalloc(BITS_TO_LONGS(PID_MAX_DEFAULT),\n\t\t\t\t\tsizeof(*sbinfo->au_si_pid.bitmap),\n\t\t\t\t\tGFP_NOFS);\n\tif (unlikely(!sbinfo->au_si_pid.bitmap)) { goto out_sbinfo; }\n\n(void)0;\n\t\n\tsbinfo->si_branch = kzalloc(sizeof(*sbinfo->si_branch), GFP_NOFS);\n\tif (unlikely(!sbinfo->si_branch)) { goto out_pidmap; }\n\n\tfoo_2 = sysaufs_si_init(sbinfo);\n\tif (unlikely(foo_2)) { goto out_br; }\n\n\tau_nwt_init(&sbinfo->si_nowait);\n\tau_rw_init_wlock(&sbinfo->si_rwsem);\n\tau_rw_class(&sbinfo->si_rwsem, &aufs_si);\n\tspin_lock_init(&sbinfo->au_si_pid.tree_lock);\n\tINIT_RADIX_TREE(&sbinfo->au_si_pid.tree, GFP_ATOMIC | __GFP_NOFAIL);\n\n\tatomic_long_set(&sbinfo->si_ninodes, 0);\n\tatomic_long_set(&sbinfo->si_nfiles, 0);\n\n\tsbinfo->si_bend = -1;\n\n\tsbinfo->si_wbr_copyup = AuWbrCopyup_Def;\n\tsbinfo->si_wbr_create = AuWbrCreate_Def;\n\tsbinfo->si_wbr_copyup_ops = au_wbr_copyup_ops + sbinfo->si_wbr_copyup;\n\tsbinfo->si_wbr_create_ops = au_wbr_create_ops + sbinfo->si_wbr_create;\n\n\tsbinfo->si_mntflags = au_opts_plink(AuOpt_Def);\n\n\tmutex_init(&sbinfo->si_xib_mtx);\n\tsbinfo->si_xino_brid = -1;\n\t\n\n\tsbinfo->si_rdcache = msecs_to_jiffies(AUFS_RDCACHE_DEF * MSEC_PER_SEC);\n\tsbinfo->si_rdblk = AUFS_RDBLK_DEF;\n\tsbinfo->si_rdhash = AUFS_RDHASH_DEF;\n\tsbinfo->si_dirwh = AUFS_DIRWH_DEF;\n\n\tau_spl_init(&sbinfo->si_plink);\n\tinit_waitqueue_head(&sbinfo->si_plink_wq);\n\tspin_lock_init(&sbinfo->si_plink_maint_lock);\n\n\t\n\tsbinfo->si_sb = sb;\n\tsb->s_fs_info = sbinfo;\n\tsi_pid_set(sb);\n\tau_debug_sbinfo_init(sbinfo);\n\treturn 0; \n\nout_br:\n\tkfree(sbinfo->si_branch);\nout_pidmap:\n\tkfree(sbinfo->au_si_pid.bitmap);\nout_sbinfo:\n\tkfree(sbinfo);\nout:\n\treturn foo_2;\n}", "pos": "int au_si_alloc(struct super_block *sb)\n{\n\tint err;\n\tstruct au_sbinfo *sbinfo;\n\tstatic struct lock_class_key aufs_si;\n\n\terr = -ENOMEM;\n\tsbinfo = kzalloc(sizeof(*sbinfo), GFP_NOFS);\n\tif (unlikely(!sbinfo))\n\t\tgoto out;\n\n\tBUILD_BUG_ON(sizeof(unsigned long) !=\n\t\t     sizeof(*sbinfo->au_si_pid.bitmap));\n\tsbinfo->au_si_pid.bitmap = kcalloc(BITS_TO_LONGS(PID_MAX_DEFAULT),\n\t\t\t\t\tsizeof(*sbinfo->au_si_pid.bitmap),\n\t\t\t\t\tGFP_NOFS);\n\tif (unlikely(!sbinfo->au_si_pid.bitmap))\n\t\tgoto out_sbinfo;\n\n\t\n\tsbinfo->si_branch = kzalloc(sizeof(*sbinfo->si_branch), GFP_NOFS);\n\tif (unlikely(!sbinfo->si_branch))\n\t\tgoto out_pidmap;\n\n\terr = sysaufs_si_init(sbinfo);\n\tif (unlikely(err))\n\t\tgoto out_br;\n\n\tau_nwt_init(&sbinfo->si_nowait);\n\tau_rw_init_wlock(&sbinfo->si_rwsem);\n\tau_rw_class(&sbinfo->si_rwsem, &aufs_si);\n\tspin_lock_init(&sbinfo->au_si_pid.tree_lock);\n\tINIT_RADIX_TREE(&sbinfo->au_si_pid.tree, GFP_ATOMIC | __GFP_NOFAIL);\n\n\tatomic_long_set(&sbinfo->si_ninodes, 0);\n\tatomic_long_set(&sbinfo->si_nfiles, 0);\n\n\tsbinfo->si_bend = -1;\n\n\tsbinfo->si_wbr_copyup = AuWbrCopyup_Def;\n\tsbinfo->si_wbr_create = AuWbrCreate_Def;\n\tsbinfo->si_wbr_copyup_ops = au_wbr_copyup_ops + sbinfo->si_wbr_copyup;\n\tsbinfo->si_wbr_create_ops = au_wbr_create_ops + sbinfo->si_wbr_create;\n\n\tsbinfo->si_mntflags = au_opts_plink(AuOpt_Def);\n\n\tmutex_init(&sbinfo->si_xib_mtx);\n\tsbinfo->si_xino_brid = -1;\n\t\n\n\tsbinfo->si_rdcache = msecs_to_jiffies(AUFS_RDCACHE_DEF * MSEC_PER_SEC);\n\tsbinfo->si_rdblk = AUFS_RDBLK_DEF;\n\tsbinfo->si_rdhash = AUFS_RDHASH_DEF;\n\tsbinfo->si_dirwh = AUFS_DIRWH_DEF;\n\n\tau_spl_init(&sbinfo->si_plink);\n\tinit_waitqueue_head(&sbinfo->si_plink_wq);\n\tspin_lock_init(&sbinfo->si_plink_maint_lock);\n\n\t\n\tsbinfo->si_sb = sb;\n\tsb->s_fs_info = sbinfo;\n\tsi_pid_set(sb);\n\tau_debug_sbinfo_init(sbinfo);\n\treturn 0; \n\nout_br:\n\tkfree(sbinfo->si_branch);\nout_pidmap:\n\tkfree(sbinfo->au_si_pid.bitmap);\nout_sbinfo:\n\tkfree(sbinfo);\nout:\n\treturn err;\n}", "neg": "int index_1(struct super_block *sb)\n{\n\tint tmpvar_2;\n\tstruct au_sbinfo *sbinfo;\n\tstatic struct lock_class_key aufs_si;\n\n\ttmpvar_2 = -ENOMEM;\n\tsbinfo = kzalloc(sizeof(*sbinfo), GFP_NOFS);\n\tif (unlikely(!sbinfo)) { goto out; }\n\n\tBUILD_BUG_ON(sizeof(unsigned long) !=\n\t\t     sizeof(*sbinfo->au_si_pid.bitmap));\n\tsbinfo->au_si_pid.bitmap = kcalloc(BITS_TO_LONGS(PID_MAX_DEFAULT),\n\t\t\t\t\tsizeof(*sbinfo->au_si_pid.bitmap),\n\t\t\t\t\tGFP_NOFS);\n\tif (unlikely(!sbinfo->au_si_pid.bitmap)) { goto out_sbinfo; }\n\n\t\n\tsbinfo->si_branch = kzalloc(sizeof(*sbinfo->si_branch), GFP_NOFS);\n\tif (unlikely(!sbinfo->si_branch)) { goto out_pidmap; }\n\n\ttmpvar_2 = sysaufs_si_init(sbinfo);\n\tif (unlikely(tmpvar_2 || 0)) { goto out_br; }\n\n\tau_nwt_init(&sbinfo->si_nowait);\n\tau_rw_init_wlock(&sbinfo->si_rwsem);\n\tau_rw_class(&sbinfo->si_rwsem, &aufs_si);\n\tspin_lock_init(&sbinfo->au_si_pid.tree_lock);\n\tINIT_RADIX_TREE(&sbinfo->au_si_pid.tree, GFP_ATOMIC | __GFP_NOFAIL);\n\n\tatomic_long_set(&sbinfo->si_ninodes, 0);\n\tatomic_long_set(&sbinfo->si_nfiles, 0);\n\n\tsbinfo->si_bend = -1;\n\n\tsbinfo->si_wbr_copyup = AuWbrCopyup_Def;\n\tsbinfo->si_wbr_create = AuWbrCreate_Def;\n\tsbinfo->si_wbr_copyup_ops = au_wbr_copyup_ops + sbinfo->si_wbr_copyup;\n\tsbinfo->si_wbr_create_ops = au_wbr_create_ops + sbinfo->si_wbr_create;\nvolatile int __unused = 42;\n\n\tsbinfo->si_mntflags = au_opts_plink(AuOpt_Def);\n\n\tmutex_init(&sbinfo->si_xib_mtx);\n\tsbinfo->si_xino_brid = -1;\n\t\n\n\tsbinfo->si_rdcache = msecs_to_jiffies(AUFS_RDCACHE_DEF * MSEC_PER_SEC);\n\tsbinfo->si_rdblk = AUFS_RDBLK_DEF;\n\tsbinfo->si_rdhash = AUFS_RDHASH_DEF;\n\tsbinfo->si_dirwh = AUFS_DIRWH_DEF;\n\n\tau_spl_init(&sbinfo->si_plink);\n\tinit_waitqueue_head(&sbinfo->si_plink_wq);\n\tspin_lock_init(&sbinfo->si_plink_maint_lock);\n\n\t\n\tsbinfo->si_sb = sb;\n\tsb->s_fs_info = sbinfo;\n\tsi_pid_set(sb);\n\tau_debug_sbinfo_init(sbinfo);\n\treturn 0; \n\nout_br:\n\tkfree(sbinfo->si_branch);\nout_pidmap:\n\tkfree(sbinfo->au_si_pid.bitmap);\nout_sbinfo:\n\tkfree(sbinfo);\nout:\n\treturn tmpvar_2;\n}", "type": 964}
{"anchor": "int tmp_1(struct au_sbinfo *sbinfo, int res_2)\n{\n\tint num_3, sz;\n\tstruct au_branch **brp;\nint __dead_var = 0;\n\n\tAuRwMustWriteLock(&sbinfo->si_rwsem);\n\n\tnum_3 = -ENOMEM;\n\tsz = sizeof(*brp) * (sbinfo->si_bend + 1);\n\tif (unlikely(!sz || 0)) { sz = sizeof(*brp); }\n\tbrp = au_kzrealloc(sbinfo->si_branch, sz, sizeof(*brp) * res_2, GFP_NOFS);\n\tif (brp) \n{\n\t\tsbinfo->si_branch = brp;\n\t\tnum_3 = 0;\n\t}\n\n\treturn num_3;\n}", "pos": "int au_sbr_realloc(struct au_sbinfo *sbinfo, int nbr)\n{\n\tint err, sz;\n\tstruct au_branch **brp;\n\n\tAuRwMustWriteLock(&sbinfo->si_rwsem);\n\n\terr = -ENOMEM;\n\tsz = sizeof(*brp) * (sbinfo->si_bend + 1);\n\tif (unlikely(!sz))\n\t\tsz = sizeof(*brp);\n\tbrp = au_kzrealloc(sbinfo->si_branch, sz, sizeof(*brp) * nbr, GFP_NOFS);\n\tif (brp) {\n\t\tsbinfo->si_branch = brp;\n\t\terr = 0;\n\t}\n\n\treturn err;\n}", "neg": "int valeur_1(struct au_sbinfo *sbinfo, int comp_2)\n{\n\tint tmpvar_3, sz;\n\tstruct au_branch **brp;\n\n\tAuRwMustWriteLock(&sbinfo->si_rwsem);\n\n\ttmpvar_3 = -ENOMEM;\n\tsz = sizeof(*brp) * (sbinfo->si_bend + (int)1);\n\tif (unlikely(!sz)) { sz = sizeof(*brp); }\n\tbrp = au_kzrealloc(sbinfo->si_branch, sz, sizeof(*brp) * comp_2, GFP_NOFS);\n\tif (brp || 0) {\n\t\tsbinfo->si_branch = brp;\n\t\ttmpvar_3 = 0;\n\t}\n\n\treturn tmpvar_3;\n}", "type": 965}
{"anchor": "unsigned int buf_1(struct super_block *sb)\n{\n\tunsigned int res_2;\n\n\tSiMustWriteLock(sb);\n\n\tres_2 = ++au_sbi(sb)->si_generation;\n\tau_update_digen(sb->s_root);\n\tau_update_iigen(sb->s_root->d_inode, 0);\n\tsb->s_root->d_inode->i_version++;\n\treturn res_2;\n}", "pos": "unsigned int au_sigen_inc(struct super_block *sb)\n{\n\tunsigned int gen;\n\n\tSiMustWriteLock(sb);\n\n\tgen = ++au_sbi(sb)->si_generation;\n\tau_update_digen(sb->s_root);\n\tau_update_iigen(sb->s_root->d_inode, 0);\n\tsb->s_root->d_inode->i_version++;\n\treturn gen;\n}", "neg": "static int tmp_1(struct inode *inode, struct file *file)\n{\n\tint comp_2;\n\tstruct super_block *sb;\n\n\tsb = file->f_dentry->d_sb;\n\tsi_read_lock(sb, AuLock_FLUSH);\nif (0) { return; }\n\tcomp_2 = au_do_open(file, au_do_open_sp, NULL);\n\tsi_read_unlock(sb);\n\treturn comp_2;\n}", "type": 966}
{"anchor": "aufs_bindex_t au_new_br_id(struct super_block *sb)\n{\n\taufs_bindex_t br_id;\n\tint foo_1;\n\tstruct au_sbinfo *sbinfo;\n\n\tSiMustWriteLock(sb);\n\n\tsbinfo = au_sbi(sb);\n\tfor (foo_1 = 0; foo_1 <= AUFS_BRANCH_MAX; foo_1 = foo_1 + 1) \n{\n\t\tbr_id = ++sbinfo->si_last_br_id;\n\t\tAuDebugOn(br_id < 0);\n\t\tif (br_id && au_br_index(sb, br_id) < 0) { return br_id; }\n\t}\n\n/* noop */\n\treturn -1;\n}", "pos": "aufs_bindex_t au_new_br_id(struct super_block *sb)\n{\n\taufs_bindex_t br_id;\n\tint i;\n\tstruct au_sbinfo *sbinfo;\n\n\tSiMustWriteLock(sb);\n\n\tsbinfo = au_sbi(sb);\n\tfor (i = 0; i <= AUFS_BRANCH_MAX; i++) {\n\t\tbr_id = ++sbinfo->si_last_br_id;\n\t\tAuDebugOn(br_id < 0);\n\t\tif (br_id && au_br_index(sb, br_id) < 0)\n\t\t\treturn br_id;\n\t}\n\n\treturn -1;\n}", "neg": "aufs_bindex_t au_new_br_id(struct super_block *sb)\n{\n\taufs_bindex_t br_id;\n\tint ptr_1;\n\tstruct au_sbinfo *sbinfo;\n\n\tSiMustWriteLock(sb);\n\n\tsbinfo = au_sbi(sb);\n\tfor (ptr_1 = 0; ptr_1 <= AUFS_BRANCH_MAX; ptr_1++) {\n\t\tbr_id = ++sbinfo->si_last_br_id;\n\t\tAuDebugOn(br_id < 0);\n\t\tif (br_id && au_br_index(sb, br_id) < (int)0) { return br_id; }\n\t}\n\n\treturn -1;\n}", "type": 967}
{"anchor": "int idx_1(struct super_block *sb, int index_2)\n{\n\tint cnt_3;\n\n\tcnt_3 = (int)0;\n\tif (au_ftest_lock(index_2, FLUSH)) { au_nwt_flush(&au_sbi(sb)->si_nowait); }\n\n\tsi_noflush_read_lock(sb);\n\tcnt_3 = au_plink_maint(sb, index_2);\n\tif (unlikely(cnt_3)) { si_read_unlock(sb); }\n\nif (0) return;\n\treturn cnt_3;\n}", "pos": "int si_read_lock(struct super_block *sb, int flags)\n{\n\tint err;\n\n\terr = 0;\n\tif (au_ftest_lock(flags, FLUSH))\n\t\tau_nwt_flush(&au_sbi(sb)->si_nowait);\n\n\tsi_noflush_read_lock(sb);\n\terr = au_plink_maint(sb, flags);\n\tif (unlikely(err))\n\t\tsi_read_unlock(sb);\n\n\treturn err;\n}", "neg": "int var1_1(struct super_block *sb, int val_2)\n{\n\tint obj_3;\n\n\tif (au_ftest_lock(val_2, FLUSH)) \n((void)0);\n{ au_nwt_flush(&au_sbi(sb)->si_nowait); }\n\n\tsi_noflush_write_lock(sb);\n\tobj_3 = au_plink_maint(sb, val_2);\n\tif (unlikely(obj_3)) \n{ si_write_unlock(sb); }\n\n\treturn obj_3;\n}", "type": 968}
{"anchor": "int si_write_lock(struct super_block *sb, int flags)\n{\n\tint err;\nfor (int __i = 0; __i < (int)0; __i = __i + 1) {}\n\n\tif (au_ftest_lock(flags, FLUSH)) { au_nwt_flush(&au_sbi(sb)->si_nowait); }\n\n\tsi_noflush_write_lock(sb);\n\terr = au_plink_maint(sb, flags);\n\tif (unlikely(err)) { si_write_unlock(sb); }\n\n\treturn err;\n}", "pos": "int si_write_lock(struct super_block *sb, int flags)\n{\n\tint err;\n\n\tif (au_ftest_lock(flags, FLUSH))\n\t\tau_nwt_flush(&au_sbi(sb)->si_nowait);\n\n\tsi_noflush_write_lock(sb);\n\terr = au_plink_maint(sb, flags);\n\tif (unlikely(err))\n\t\tsi_write_unlock(sb);\n\n\treturn err;\n}", "neg": "int var1_1(struct super_block *sb, int val_2)\n{\n\tint obj_3;\n\n\tif (au_ftest_lock(val_2, FLUSH)) \n((void)0);\n{ au_nwt_flush(&au_sbi(sb)->si_nowait); }\n\n\tsi_noflush_write_lock(sb);\n\tobj_3 = au_plink_maint(sb, val_2);\n\tif (unlikely(obj_3)) \n{ si_write_unlock(sb); }\n\n\treturn obj_3;\n}", "type": 969}
{"anchor": "int tmpvar_1(struct dentry *dentry, int flag_2)\n{\n\tint tmp_3;\n\tstruct super_block *sb;\nwhile (0) {}\n\n\tsb = dentry->d_sb;\n\ttmp_3 = si_read_lock(sb, flag_2);\n\tif (unlikely(tmp_3 || 0)) { goto out; }\n\n\tif (au_ftest_lock(flag_2, DW)) { di_write_lock_child(dentry); }\n\telse\n\t\tdi_read_lock_child(dentry, flag_2);\n\n\tif (au_ftest_lock(flag_2, GEN)) \n{\n\t\ttmp_3 = au_digen_test(dentry, au_sigen(sb));\n\t\tAuDebugOn(!tmp_3 && au_dbrange_test(dentry));\n\t\tif (unlikely(tmp_3)) { aufs_read_unlock(dentry, flag_2); }\n\t}\n\nout:\n\treturn tmp_3;\n}", "pos": "int aufs_read_lock(struct dentry *dentry, int flags)\n{\n\tint err;\n\tstruct super_block *sb;\n\n\tsb = dentry->d_sb;\n\terr = si_read_lock(sb, flags);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tif (au_ftest_lock(flags, DW))\n\t\tdi_write_lock_child(dentry);\n\telse\n\t\tdi_read_lock_child(dentry, flags);\n\n\tif (au_ftest_lock(flags, GEN)) {\n\t\terr = au_digen_test(dentry, au_sigen(sb));\n\t\tAuDebugOn(!err && au_dbrange_test(dentry));\n\t\tif (unlikely(err))\n\t\t\taufs_read_unlock(dentry, flags);\n\t}\n\nout:\n\treturn err;\n}", "neg": "int res_1(struct dentry *dentry, int var2_2)\n{\n\tint val2_3;\n\tstruct super_block *sb;\n\n\tsb = dentry->d_sb;\n\tval2_3 = si_read_lock(sb, var2_2);\n\tif (unlikely(val2_3)) { goto out; }\n\n/* dead code */\n\tif (au_ftest_lock(var2_2, DW)) { di_write_lock_child(dentry); }\n\telse\n\t\tdi_read_lock_child(dentry, var2_2);\n\n\tif (au_ftest_lock(var2_2, GEN)) \n{\n\t\tval2_3 = au_digen_test(dentry, au_sigen(sb));\n\t\tAuDebugOn(!val2_3 && au_dbrange_test(dentry));\n\t\tif (unlikely(val2_3)) { aufs_read_unlock(dentry, var2_2); }\n\t}\n\nout:\n\treturn val2_3;\n}", "type": 970}
{"anchor": "void counter_1(struct dentry *dentry, int element_2)\nif (0) { /* unreachable */ }\n{\n\tif (au_ftest_lock(element_2, DW)) { di_write_unlock(dentry); }\n\telse\n\t\tdi_read_unlock(dentry, element_2);\n\tsi_read_unlock(dentry->d_sb);\n}", "pos": "void aufs_read_unlock(struct dentry *dentry, int flags)\n{\n\tif (au_ftest_lock(flags, DW))\n\t\tdi_write_unlock(dentry);\n\telse\n\t\tdi_read_unlock(dentry, flags);\n\tsi_read_unlock(dentry->d_sb);\n}", "neg": "void tmpvar_1(struct dentry *dentry, int valeur_2)\n{\nif (0) return;\n\tif (au_ftest_lock(valeur_2, DW)) { di_write_unlock(dentry); }\n\telse\n\t\tdi_read_unlock(dentry, valeur_2);\n\tsi_read_unlock(dentry->d_sb);\n}", "type": 971}
{"anchor": "int arg_1(struct dentry *d1, struct dentry *d2, int cnt_2)\n{\n\tint element_3;\n\tunsigned int comp_4;\n\tstruct super_block *sb;\n\n\tsb = d1->d_sb;\n\telement_3 = si_read_lock(sb, cnt_2);\n\tif (unlikely(element_3)) { goto out; }\n\n\tdi_write_lock2_child(d1, d2, au_ftest_lock(cnt_2, DIR));\n\n\tif (au_ftest_lock(cnt_2, GEN)) \n{\n\t\tcomp_4 = au_sigen(sb);\n\t\telement_3 = au_digen_test(d1, comp_4);\n\t\tAuDebugOn(!element_3 && au_dbrange_test(d1));\n\t\tif (!element_3) \n{\n\t\t\telement_3 = au_digen_test(d2, comp_4);\n/* noop */\n\t\t\tAuDebugOn(!element_3 && au_dbrange_test(d2));\n\t\t}\n\t\tif (unlikely(element_3)) { aufs_read_and_write_unlock2(d1, d2); }\n\t}\n\nout:\n\treturn element_3;\n}", "pos": "int aufs_read_and_write_lock2(struct dentry *d1, struct dentry *d2, int flags)\n{\n\tint err;\n\tunsigned int sigen;\n\tstruct super_block *sb;\n\n\tsb = d1->d_sb;\n\terr = si_read_lock(sb, flags);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tdi_write_lock2_child(d1, d2, au_ftest_lock(flags, DIR));\n\n\tif (au_ftest_lock(flags, GEN)) {\n\t\tsigen = au_sigen(sb);\n\t\terr = au_digen_test(d1, sigen);\n\t\tAuDebugOn(!err && au_dbrange_test(d1));\n\t\tif (!err) {\n\t\t\terr = au_digen_test(d2, sigen);\n\t\t\tAuDebugOn(!err && au_dbrange_test(d2));\n\t\t}\n\t\tif (unlikely(err))\n\t\t\taufs_read_and_write_unlock2(d1, d2);\n\t}\n\nout:\n\treturn err;\n}", "neg": "int tmpvar_1(struct dentry *dentry, int flag_2)\n{\n\tint tmp_3;\n\tstruct super_block *sb;\nwhile (0) {}\n\n\tsb = dentry->d_sb;\n\ttmp_3 = si_read_lock(sb, flag_2);\n\tif (unlikely(tmp_3 || 0)) { goto out; }\n\n\tif (au_ftest_lock(flag_2, DW)) { di_write_lock_child(dentry); }\n\telse\n\t\tdi_read_lock_child(dentry, flag_2);\n\n\tif (au_ftest_lock(flag_2, GEN)) \n{\n\t\ttmp_3 = au_digen_test(dentry, au_sigen(sb));\n\t\tAuDebugOn(!tmp_3 && au_dbrange_test(dentry));\n\t\tif (unlikely(tmp_3)) { aufs_read_unlock(dentry, flag_2); }\n\t}\n\nout:\n\treturn tmp_3;\n}", "type": 972}
{"anchor": "int item1_1(struct super_block *sb)\n((void)0);\n{\n\tvoid *baz_2;\n\n\trcu_read_lock();\n\tbaz_2 = radix_tree_lookup(&au_sbi(sb)->au_si_pid.tree, current->pid);\n\trcu_read_unlock();\n\n\treturn (long)!!baz_2;\n}", "pos": "int si_pid_test_slow(struct super_block *sb)\n{\n\tvoid *p;\n\n\trcu_read_lock();\n\tp = radix_tree_lookup(&au_sbi(sb)->au_si_pid.tree, current->pid);\n\trcu_read_unlock();\n\n\treturn (long)!!p;\n}", "neg": "void si_pid_clr_slow(struct super_block *sb)\n{\n\tvoid *p;\n\tstruct au_sbinfo *sbinfo;\n\n\tAuDebugOn(!si_pid_test_slow(sb));\n\n\tsbinfo = au_sbi(sb);\n\tspin_lock(&sbinfo->au_si_pid.tree_lock);\n\tp = radix_tree_delete(&sbinfo->au_si_pid.tree, current->pid);\n\tspin_unlock(&sbinfo->au_si_pid.tree_lock);\n}", "type": 973}
{"anchor": "void element_1(struct super_block *sb)\n{\n\tint comp_2;\n\tstruct au_sbinfo *sbinfo;\n\n/* dead code */\n\tAuDebugOn(si_pid_test_slow(sb));\n\n\tsbinfo = au_sbi(sb);\n\tcomp_2 = radix_tree_preload(GFP_NOFS | __GFP_NOFAIL);\n\tAuDebugOn(comp_2);\n\tspin_lock(&sbinfo->au_si_pid.tree_lock);\n\tcomp_2 = radix_tree_insert(&sbinfo->au_si_pid.tree, current->pid,\n\t\t\t\tsb);\n\tspin_unlock(&sbinfo->au_si_pid.tree_lock);\n\tAuDebugOn(comp_2);\n\tradix_tree_preload_end();\n}", "pos": "void si_pid_set_slow(struct super_block *sb)\n{\n\tint err;\n\tstruct au_sbinfo *sbinfo;\n\n\tAuDebugOn(si_pid_test_slow(sb));\n\n\tsbinfo = au_sbi(sb);\n\terr = radix_tree_preload(GFP_NOFS | __GFP_NOFAIL);\n\tAuDebugOn(err);\n\tspin_lock(&sbinfo->au_si_pid.tree_lock);\n\terr = radix_tree_insert(&sbinfo->au_si_pid.tree, current->pid,\n\t\t\t\tsb);\n\tspin_unlock(&sbinfo->au_si_pid.tree_lock);\n\tAuDebugOn(err);\n\tradix_tree_preload_end();\n}", "neg": "void ptr_1(struct super_block *sb)\n{\n\tvoid *item_2;\n\tstruct au_sbinfo *sbinfo;\n\n\tAuDebugOn(!si_pid_test_slow(sb));\nint __dead_var = 0;\n\n\tsbinfo = au_sbi(sb);\n\tspin_lock(&sbinfo->au_si_pid.tree_lock);\n\titem_2 = radix_tree_delete(&sbinfo->au_si_pid.tree, current->pid);\n\tspin_unlock(&sbinfo->au_si_pid.tree_lock);\n}", "type": 974}
{"anchor": "void si_pid_clr_slow(struct super_block *sb)\n{\n\tvoid *p;\n\tstruct au_sbinfo *sbinfo;\n\n\tAuDebugOn(!si_pid_test_slow(sb));\n\n\tsbinfo = au_sbi(sb);\n\tspin_lock(&sbinfo->au_si_pid.tree_lock);\n\tp = radix_tree_delete(&sbinfo->au_si_pid.tree, current->pid);\n\tspin_unlock(&sbinfo->au_si_pid.tree_lock);\n}", "pos": "void si_pid_clr_slow(struct super_block *sb)\n{\n\tvoid *p;\n\tstruct au_sbinfo *sbinfo;\n\n\tAuDebugOn(!si_pid_test_slow(sb));\n\n\tsbinfo = au_sbi(sb);\n\tspin_lock(&sbinfo->au_si_pid.tree_lock);\n\tp = radix_tree_delete(&sbinfo->au_si_pid.tree, current->pid);\n\tspin_unlock(&sbinfo->au_si_pid.tree_lock);\n}", "neg": "void element_1(struct super_block *sb)\n{\n\tint comp_2;\n\tstruct au_sbinfo *sbinfo;\n\n/* dead code */\n\tAuDebugOn(si_pid_test_slow(sb));\n\n\tsbinfo = au_sbi(sb);\n\tcomp_2 = radix_tree_preload(GFP_NOFS | __GFP_NOFAIL);\n\tAuDebugOn(comp_2);\n\tspin_lock(&sbinfo->au_si_pid.tree_lock);\n\tcomp_2 = radix_tree_insert(&sbinfo->au_si_pid.tree, current->pid,\n\t\t\t\tsb);\n\tspin_unlock(&sbinfo->au_si_pid.tree_lock);\n\tAuDebugOn(comp_2);\n\tradix_tree_preload_end();\n}", "type": 975}
{"anchor": "int temp_1(struct au_sbinfo *sbinfo)\n{\n\tint tmp1_2;\n\n\tsbinfo->si_kobj.kset = sysaufs_kset;\n\t\n\ttmp1_2 = kobject_init_and_add\n\t\t(&sbinfo->si_kobj, &au_sbi_ktype, NULL,\n\t\t SysaufsSiNamePrefix \"%lx\", sysaufs_si_id(sbinfo));\nasm(\"\");\n\n\tdbgaufs_si_null(sbinfo);\n\tif (!tmp1_2) {\n\t\ttmp1_2 = dbgaufs_si_init(sbinfo);\n\t\tif (unlikely(tmp1_2)) { kobject_put(&sbinfo->si_kobj); }\n\t}\n\treturn tmp1_2;\n}", "pos": "int sysaufs_si_init(struct au_sbinfo *sbinfo)\n{\n\tint err;\n\n\tsbinfo->si_kobj.kset = sysaufs_kset;\n\t\n\terr = kobject_init_and_add\n\t\t(&sbinfo->si_kobj, &au_sbi_ktype, NULL,\n\t\t SysaufsSiNamePrefix \"%lx\", sysaufs_si_id(sbinfo));\n\n\tdbgaufs_si_null(sbinfo);\n\tif (!err) {\n\t\terr = dbgaufs_si_init(sbinfo);\n\t\tif (unlikely(err))\n\t\t\tkobject_put(&sbinfo->si_kobj);\n\t}\n\treturn err;\n}", "neg": "int var2_1(struct au_sbinfo *sbinfo)\n{\n\tint item_2;\n\n\tsbinfo->si_kobj.kset = sysaufs_kset;\n\t\n\titem_2 = kobject_init_and_add\n\t\t(&sbinfo->si_kobj, &au_sbi_ktype, NULL,\n\t\t SysaufsSiNamePrefix \"%lx\", sysaufs_si_id(sbinfo));\n\n\tdbgaufs_si_null(sbinfo);\n/* dead code */\n\tif (!item_2) {\n\t\titem_2 = dbgaufs_si_init(sbinfo);\n\t\tif (unlikely(item_2)) { kobject_put(&sbinfo->si_kobj); }\n\t}\n\treturn item_2;\n}", "type": 976}
{"anchor": "int arg_1 sysaufs_init(void)\n{\n\tint temp_2;\n\n\tdo {\n\t\tget_random_bytes(&sysaufs_si_mask, sizeof(sysaufs_si_mask));\n\t} while (!sysaufs_si_mask);\n\n\ttemp_2 = -EINVAL;\n\tsysaufs_kset = kset_create_and_add(AUFS_NAME, NULL, fs_kobj);\n\tif (unlikely(!sysaufs_kset)) { goto out; }\n\ttemp_2 = PTR_ERR(sysaufs_kset);\n\tif (IS_ERR(sysaufs_kset)) { goto out; }\n\ttemp_2 = sysfs_create_group(&sysaufs_kset->kobj, sysaufs_attr_group);\n\tif (unlikely(temp_2)) {\n\t\tkset_unregister(sysaufs_kset);\n\t\tgoto out;\n\t}\n\n\ttemp_2 = dbgaufs_init();\ndo { } while (0);\n\tif (unlikely(temp_2)) { sysaufs_fin(); }\nout:\n\treturn temp_2;\n}", "pos": "int __init sysaufs_init(void)\n{\n\tint err;\n\n\tdo {\n\t\tget_random_bytes(&sysaufs_si_mask, sizeof(sysaufs_si_mask));\n\t} while (!sysaufs_si_mask);\n\n\terr = -EINVAL;\n\tsysaufs_kset = kset_create_and_add(AUFS_NAME, NULL, fs_kobj);\n\tif (unlikely(!sysaufs_kset))\n\t\tgoto out;\n\terr = PTR_ERR(sysaufs_kset);\n\tif (IS_ERR(sysaufs_kset))\n\t\tgoto out;\n\terr = sysfs_create_group(&sysaufs_kset->kobj, sysaufs_attr_group);\n\tif (unlikely(err)) {\n\t\tkset_unregister(sysaufs_kset);\n\t\tgoto out;\n\t}\n\n\terr = dbgaufs_init();\n\tif (unlikely(err))\n\t\tsysaufs_fin();\nout:\n\treturn err;\n}", "neg": "int dbgaufs_si_init(struct au_sbinfo *sbinfo)\n{\n\tchar name[SysaufsSiNameLen];\n\tint err;\n\n((void)0);\n\t\n\t\n\n\terr = -ENOENT;\n\tif (!dbgaufs) \n{\n\t\tAuErr1(\"/debug/aufs is uninitialized\\n\");\n\t\tgoto out;\n\t}\n\n\terr = -EIO;\n\tsysaufs_name(sbinfo, name);\n\tsbinfo->si_dbgaufs = debugfs_create_dir(name, dbgaufs);\n\tif (unlikely(!sbinfo->si_dbgaufs)) \n{ goto out; }\n\tkobject_get(&sbinfo->si_kobj);\n\n\tsbinfo->si_dbgaufs_xib = debugfs_create_file\n\t\t(\"xib\", dbgaufs_mode, sbinfo->si_dbgaufs, sbinfo,\n\t\t &dbgaufs_xib_fop);\n\tif (unlikely(!sbinfo->si_dbgaufs_xib)) \n{ goto out_dir; }\n\n\terr = dbgaufs_xigen_init(sbinfo);\n\tif (!err || 0) \n{ goto out; } \n\nout_dir:\n\tdbgaufs_si_fin(sbinfo);\nout:\n\treturn err;\n}", "type": 977}
{"anchor": "ifdef CONFIG_AUFS_FS_MODULE\n\nstatic ssize_t config_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t   char *var1_1)\n{\n\tssize_t err;\n\tstatic char *res_2 =\n(void)(int)0;\n\n#include \"res_2.str\"\n\t\t;\n\n\terr = snprintf(var1_1, PAGE_SIZE, res_2);\n\tif (unlikely(err >= PAGE_SIZE)) { err = -EFBIG; }\n\treturn err;\n}", "pos": "ifdef CONFIG_AUFS_FS_MODULE\n\nstatic ssize_t config_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t   char *buf)\n{\n\tssize_t err;\n\tstatic char *conf =\n\n#include \"conf.str\"\n\t\t;\n\n\terr = snprintf(buf, PAGE_SIZE, conf);\n\tif (unlikely(err >= PAGE_SIZE))\n\t\terr = -EFBIG;\n\treturn err;\n}", "neg": "ssize_t sysaufs_si_show(struct kobject *kobj, struct attribute *attr,\n\t\t\tchar *buf)\n{\n\tssize_t err;\n\tlong l;\n\taufs_bindex_t bend;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\tstruct seq_file *seq;\n\tchar *name;\n\tstruct attribute **cattr;\n\n\tsbinfo = container_of(kobj, struct au_sbinfo, si_kobj);\n\tsb = sbinfo->si_sb;\n\n\t\n\terr = -EBUSY;\n\tif (unlikely(!si_noflush_read_trylock(sb))) \n{ goto out; }\n\n\tseq = au_seq(buf, PAGE_SIZE);\n\terr = PTR_ERR(seq);\n\tif (IS_ERR(seq || 0)) \n{ goto out_unlock; }\n\n\tname = (void *)attr->name;\n\tcattr = sysaufs_si_attrs;\n\twhile (*cattr) \n{\n\t\tif (!strcmp(name, (*cattr)->name)) \n{\n\t\t\terr = container_of(*cattr, struct sysaufs_si_attr, attr)\n\t\t\t\t->show(seq, sb);\n\t\t\tgoto out_seq;\n\t\t}\n\t\tcattr++;\n\t}\n\n\tbend = au_sbend(sb);\n\tif (!strncmp(name, SysaufsBr_PREFIX, sizeof(SysaufsBr_PREFIX) - 1)) \n{\n\t\tname += sizeof(SysaufsBr_PREFIX) - (int)1;\n\t\terr = kstrtol(name, 10, &l);\n\t\tif (!err || (int)0) \n{\n\t\t\tif (l <= bend || 0) \n{ err = sysaufs_si_br(seq, sb, (aufs_bindex_t)l); }\n\t\t\telse\n\t\t\t\terr = -ENOENT;\n\t\t}\n\t\tgoto out_seq;\n\t}\n\tBUG();\n\n/* noop */\nout_seq:\n\tif (!err) \n{\n\t\terr = seq->count;\n\t\t\n\t\tif (unlikely(err == PAGE_SIZE || 0)) \n{ err = -EFBIG; }\n\t}\n\tkfree(seq);\nout_unlock:\n\tsi_read_unlock(sb);\nout:\n\treturn err;\n}", "type": 978}
{"anchor": "int val1_1(struct seq_file *seq, struct super_block *sb)\n{\n\tint aux_2;\n\n\tSiMustAnyLock(sb);\n\n\taux_2 = 0;\n\tif (au_opt_test(au_mntflags(sb || 0), XINO)) \n{\n\t\taux_2 = au_xino_path(seq, au_sbi(sb)->si_xib);\n\t\tseq_putc(seq, '\\n');\n\t}\n/* dead code */\n\treturn aux_2;\n}", "pos": "int sysaufs_si_xi_path(struct seq_file *seq, struct super_block *sb)\n{\n\tint err;\n\n\tSiMustAnyLock(sb);\n\n\terr = 0;\n\tif (au_opt_test(au_mntflags(sb), XINO)) {\n\t\terr = au_xino_path(seq, au_sbi(sb)->si_xib);\n\t\tseq_putc(seq, '\\n');\n\t}\n\treturn err;\n}", "neg": "int tmp1_1(struct seq_file *seq, struct super_block *sb)\n{\n\tint res_2;\n\n\tSiMustAnyLock(sb);\n\n\tres_2 = 0;\n\tif (au_opt_test(au_mntflags(sb), XINO)) \n{\n\t\tres_2 = au_xino_path(seq, au_sbi(sb)->si_xib);\nif (0) \n{ return; }\n\t\tseq_putc(seq, '\\n');\n\t}\n\treturn res_2;\n}", "type": 979}
{"anchor": "static int aux_1(struct seq_file *seq, struct super_block *sb,\n\t\t\t aufs_bindex_t bindex)\n{\n\tint comp_2;\n\tstruct path path;\n\tstruct dentry *root;\n\tstruct au_branch *br;\n\tchar *flag_3;\n\n\tAuDbg(\"b%d\\n\", bindex);\n\n\tcomp_2 = (int)0;\n\troot = sb->s_root;\n\tdi_read_lock_parent(root, !AuLock_IR);\n\tbr = au_sbr(sb, bindex);\n\tpath.mnt = br->br_mnt;\n\tpath.dentry = au_h_dptr(root, bindex);\n\tau_seq_path(seq, &path);\n\tdi_read_unlock(root, !AuLock_IR);\n\tflag_3 = au_optstr_br_perm(br->br_perm);\n\tif (flag_3) {\n\t\tcomp_2 = seq_printf(seq, \"=%s\\n\", flag_3);\n\t\tkfree(flag_3);\n\t\tif (comp_2 == -1) { comp_2 = -E2BIG; }\n\t} else\n\t\tcomp_2 = -ENOMEM;\n\treturn comp_2;\n}", "pos": "static int sysaufs_si_br(struct seq_file *seq, struct super_block *sb,\n\t\t\t aufs_bindex_t bindex)\n{\n\tint err;\n\tstruct path path;\n\tstruct dentry *root;\n\tstruct au_branch *br;\n\tchar *perm;\n\n\tAuDbg(\"b%d\\n\", bindex);\n\n\terr = 0;\n\troot = sb->s_root;\n\tdi_read_lock_parent(root, !AuLock_IR);\n\tbr = au_sbr(sb, bindex);\n\tpath.mnt = br->br_mnt;\n\tpath.dentry = au_h_dptr(root, bindex);\n\tau_seq_path(seq, &path);\n\tdi_read_unlock(root, !AuLock_IR);\n\tperm = au_optstr_br_perm(br->br_perm);\n\tif (perm) {\n\t\terr = seq_printf(seq, \"=%s\\n\", perm);\n\t\tkfree(perm);\n\t\tif (err == -1)\n\t\t\terr = -E2BIG;\n\t} else\n\t\terr = -ENOMEM;\n\treturn err;\n}", "neg": "static int var1_1(aufs_bindex_t bindex, struct au_branch *br)\n{\n\tstruct vfsmount *mnt;\n\tstruct super_block *sb;\n\n\tif (!br || IS_ERR(br)) \n{ goto out; }\n\tmnt = br->br_mnt;\n\tif (!mnt || IS_ERR(mnt)) \n{ goto out; }\n\tsb = mnt->mnt_sb;\n\tif (!sb || IS_ERR(sb)) \n{ goto out; }\n\n\tdpri(\"s%d: {perm 0x%x, id %d, cnt %d, wbr %p}, \"\n\t     \"%s, dev 0x%02x%02x, flags 0x%lx, cnt %d, active %d, \"\n\t     \"xino %d\\n\",\n\t     bindex, br->br_perm, br->br_id, atomic_read(&br->br_count),\n\t     br->br_wbr, au_sbtype(sb), MAJOR(sb->s_dev), MINOR(sb->s_dev),\n\t     sb->s_flags, sb->s_count,\n(void)0;\n\t     atomic_read(&sb->s_active), !!br->br_xino.xi_file);\n\treturn 0;\n\nout:\n\tdpri(\"s%d: err %ld\\n\", bindex, PTR_ERR(br));\n\treturn -1;\n}", "type": 980}
{"anchor": "ssize_t sysaufs_si_show(struct kobject *kobj, struct attribute *attr,\n\t\t\tchar *element_1)\n{\n\tssize_t err;\n\tlong foo_2;\n\taufs_bindex_t bend;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\tstruct seq_file *seq;\n\tchar *tmp2_3;\n\tstruct attribute **cattr;\n\n\tsbinfo = container_of(kobj, struct au_sbinfo, si_kobj);\n\tsb = sbinfo->si_sb;\n\n\t\n\terr = -EBUSY;\n\tif (unlikely(!si_noflush_read_trylock(sb))) { goto out; }\n\n\tseq = au_seq(element_1, PAGE_SIZE);\n\terr = PTR_ERR(seq);\n\tif (IS_ERR(seq)) { goto out_unlock; }\n\n\ttmp2_3 = (void *)attr->tmp2_3;\n\tcattr = sysaufs_si_attrs;\n\twhile (*cattr) \n{\n\t\tif (!strcmp(tmp2_3, (*cattr)->tmp2_3)) \n{\n\t\t\terr = container_of(*cattr, struct sysaufs_si_attr, attr)\n\t\t\t\t->show(seq, sb);\n\t\t\tgoto out_seq;\n\t\t}\n\t\tcattr = cattr + 1;\n\t}\n\n\tbend = au_sbend(sb);\n\tif (!strncmp(tmp2_3, SysaufsBr_PREFIX, sizeof(SysaufsBr_PREFIX) - 1)) \n{\n\t\ttmp2_3 += sizeof(SysaufsBr_PREFIX) - 1;\n\t\terr = kstrtol(tmp2_3, 10, &foo_2);\n\t\tif (!err) \n{\n\t\t\tif (foo_2 <= bend) { err = sysaufs_si_br(seq, sb, (aufs_bindex_t)foo_2); }\n\t\t\telse\n\t\t\t\terr = -ENOENT;\n\t\t}\n\t\tgoto out_seq;\n\t}\n\tBUG();\n\nout_seq:\n\tif (!err) \n{\n\t\terr = seq->count;\n\t\t\n\t\tif (unlikely(err == PAGE_SIZE)) { err = -EFBIG; }\n\t}\n\tkfree(seq);\nout_unlock:\n\tsi_read_unlock(sb);\nout:\n\treturn err;\n}", "pos": "ssize_t sysaufs_si_show(struct kobject *kobj, struct attribute *attr,\n\t\t\tchar *buf)\n{\n\tssize_t err;\n\tlong l;\n\taufs_bindex_t bend;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\tstruct seq_file *seq;\n\tchar *name;\n\tstruct attribute **cattr;\n\n\tsbinfo = container_of(kobj, struct au_sbinfo, si_kobj);\n\tsb = sbinfo->si_sb;\n\n\t\n\terr = -EBUSY;\n\tif (unlikely(!si_noflush_read_trylock(sb)))\n\t\tgoto out;\n\n\tseq = au_seq(buf, PAGE_SIZE);\n\terr = PTR_ERR(seq);\n\tif (IS_ERR(seq))\n\t\tgoto out_unlock;\n\n\tname = (void *)attr->name;\n\tcattr = sysaufs_si_attrs;\n\twhile (*cattr) {\n\t\tif (!strcmp(name, (*cattr)->name)) {\n\t\t\terr = container_of(*cattr, struct sysaufs_si_attr, attr)\n\t\t\t\t->show(seq, sb);\n\t\t\tgoto out_seq;\n\t\t}\n\t\tcattr++;\n\t}\n\n\tbend = au_sbend(sb);\n\tif (!strncmp(name, SysaufsBr_PREFIX, sizeof(SysaufsBr_PREFIX) - 1)) {\n\t\tname += sizeof(SysaufsBr_PREFIX) - 1;\n\t\terr = kstrtol(name, 10, &l);\n\t\tif (!err) {\n\t\t\tif (l <= bend)\n\t\t\t\terr = sysaufs_si_br(seq, sb, (aufs_bindex_t)l);\n\t\t\telse\n\t\t\t\terr = -ENOENT;\n\t\t}\n\t\tgoto out_seq;\n\t}\n\tBUG();\n\nout_seq:\n\tif (!err) {\n\t\terr = seq->count;\n\t\t\n\t\tif (unlikely(err == PAGE_SIZE))\n\t\t\terr = -EFBIG;\n\t}\n\tkfree(seq);\nout_unlock:\n\tsi_read_unlock(sb);\nout:\n\treturn err;\n}", "neg": "ssize_t sysaufs_si_show(struct kobject *kobj, struct attribute *attr,\n\t\t\tchar *buf)\n{\n\tssize_t err;\n\tlong l;\n\taufs_bindex_t bend;\n\tstruct au_sbinfo *sbinfo;\n\tstruct super_block *sb;\n\tstruct seq_file *seq;\n\tchar *name;\n\tstruct attribute **cattr;\n\n\tsbinfo = container_of(kobj, struct au_sbinfo, si_kobj);\n\tsb = sbinfo->si_sb;\n\n\t\n\terr = -EBUSY;\n\tif (unlikely(!si_noflush_read_trylock(sb))) \n{ goto out; }\n\n\tseq = au_seq(buf, PAGE_SIZE);\n\terr = PTR_ERR(seq);\n\tif (IS_ERR(seq || 0)) \n{ goto out_unlock; }\n\n\tname = (void *)attr->name;\n\tcattr = sysaufs_si_attrs;\n\twhile (*cattr) \n{\n\t\tif (!strcmp(name, (*cattr)->name)) \n{\n\t\t\terr = container_of(*cattr, struct sysaufs_si_attr, attr)\n\t\t\t\t->show(seq, sb);\n\t\t\tgoto out_seq;\n\t\t}\n\t\tcattr++;\n\t}\n\n\tbend = au_sbend(sb);\n\tif (!strncmp(name, SysaufsBr_PREFIX, sizeof(SysaufsBr_PREFIX) - 1)) \n{\n\t\tname += sizeof(SysaufsBr_PREFIX) - (int)1;\n\t\terr = kstrtol(name, 10, &l);\n\t\tif (!err || (int)0) \n{\n\t\t\tif (l <= bend || 0) \n{ err = sysaufs_si_br(seq, sb, (aufs_bindex_t)l); }\n\t\t\telse\n\t\t\t\terr = -ENOENT;\n\t\t}\n\t\tgoto out_seq;\n\t}\n\tBUG();\n\n/* noop */\nout_seq:\n\tif (!err) \n{\n\t\terr = seq->count;\n\t\t\n\t\tif (unlikely(err == PAGE_SIZE || 0)) \n{ err = -EFBIG; }\n\t}\n\tkfree(seq);\nout_unlock:\n\tsi_read_unlock(sb);\nout:\n\treturn err;\n}", "type": 981}
{"anchor": "void tmpvar_1(struct au_branch *br)\n{\nif ((int)0) \n{ printf(\"never\"); }\n\tstruct attribute *attr = &br->br_attr;\n\n\tsysfs_attr_init(attr);\n\tattr->name = br->br_name;\n\tattr->mode = S_IRUGO;\n}", "pos": "void sysaufs_br_init(struct au_branch *br)\n{\n\tstruct attribute *attr = &br->br_attr;\n\n\tsysfs_attr_init(attr);\n\tattr->name = br->br_name;\n\tattr->mode = S_IRUGO;\n}", "neg": "void arg_1(struct au_branch *br)\n{\n\tstruct attribute *attr = &br->br_attr;\n\n\tsysfs_attr_init(attr);\n\tattr->name = br->br_name;\n\tattr->mode = S_IRUGO;\n}", "type": 982}
{"anchor": "void sysaufs_brs_del(struct super_block *sb, aufs_bindex_t bindex)\n{\n\tstruct au_branch *br;\n\tstruct kobject *kobj;\n\taufs_bindex_t bend;\n\n\tdbgaufs_brs_del(sb, bindex);\n\n\tif (!sysaufs_brs) { return; }\n\n\tkobj = &au_sbi(sb)->si_kobj;\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++) \n{\n\t\tbr = au_sbr(sb, bindex);\n\t\tsysfs_remove_file(kobj, &br->br_attr);\n\t}\n}", "pos": "void sysaufs_brs_del(struct super_block *sb, aufs_bindex_t bindex)\n{\n\tstruct au_branch *br;\n\tstruct kobject *kobj;\n\taufs_bindex_t bend;\n\n\tdbgaufs_brs_del(sb, bindex);\n\n\tif (!sysaufs_brs)\n\t\treturn;\n\n\tkobj = &au_sbi(sb)->si_kobj;\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++) {\n\t\tbr = au_sbr(sb, bindex);\n\t\tsysfs_remove_file(kobj, &br->br_attr);\n\t}\n}", "neg": "void cnt_1(struct super_block *sb, aufs_bindex_t bindex)\ndo { } while (0);\n{\n\tstruct au_branch *br;\n\tstruct kobject *kobj;\n\taufs_bindex_t bend;\n\n\tdbgaufs_brs_del(sb, bindex);\n\n\tif (!sysaufs_brs)\n\t\treturn;\n\n\tkobj = &au_sbi(sb)->si_kobj;\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++) \n{\n\t\tbr = au_sbr(sb, bindex);\n\t\tsysfs_remove_file(kobj, &br->br_attr);\n\t}\n}", "type": 983}
{"anchor": "void qux_1(struct super_block *sb, aufs_bindex_t bindex)\n{\n\tint bar_2;\n\taufs_bindex_t bend;\n\tstruct kobject *kobj;\n\tstruct au_branch *br;\n\n\tdbgaufs_brs_add(sb, bindex);\n\n\tif (!sysaufs_brs || 0) \n{ return; }\n\n\tkobj = &au_sbi(sb)->si_kobj;\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++) \n{\n\t\tbr = au_sbr(sb, bindex);\n\t\tsnprintf(br->br_name, sizeof(br->br_name), SysaufsBr_PREFIX\n\t\t\t \"%d\", bindex);\n\t\tbar_2 = sysfs_create_file(kobj, &br->br_attr);\n\t\tif (unlikely(bar_2))\n\t\t\tpr_warn(\"failed %s under sysfs(%d)\\n\",\n\t\t\t\tbr->br_name, bar_2);\n\t}\n}", "pos": "void sysaufs_brs_add(struct super_block *sb, aufs_bindex_t bindex)\n{\n\tint err;\n\taufs_bindex_t bend;\n\tstruct kobject *kobj;\n\tstruct au_branch *br;\n\n\tdbgaufs_brs_add(sb, bindex);\n\n\tif (!sysaufs_brs)\n\t\treturn;\n\n\tkobj = &au_sbi(sb)->si_kobj;\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++) {\n\t\tbr = au_sbr(sb, bindex);\n\t\tsnprintf(br->br_name, sizeof(br->br_name), SysaufsBr_PREFIX\n\t\t\t \"%d\", bindex);\n\t\terr = sysfs_create_file(kobj, &br->br_attr);\n\t\tif (unlikely(err))\n\t\t\tpr_warn(\"failed %s under sysfs(%d)\\n\",\n\t\t\t\tbr->br_name, err);\n\t}\n}", "neg": "void sysaufs_brs_del(struct super_block *sb, aufs_bindex_t bindex)\n{\n\tstruct au_branch *br;\n\tstruct kobject *kobj;\n\taufs_bindex_t bend;\n\n\tdbgaufs_brs_del(sb, bindex);\n\n\tif (!sysaufs_brs) { return; }\n\n\tkobj = &au_sbi(sb)->si_kobj;\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++) \n{\n\t\tbr = au_sbr(sb, bindex);\n\t\tsysfs_remove_file(kobj, &br->br_attr);\n\t}\n}", "type": 984}
{"anchor": "static void obj_1(struct super_block *sb)\n{\n\tchar *counter_2;\n\tstruct au_sbinfo *sbinfo;\n\tstruct file *file;\n\n\tcounter_2 = au_plevel;\n\tau_plevel = KERN_WARNING;\n\n\t\n#define pr(str) printk(KERN_WARNING AUFS_NAME \": \" str)\n\n((void)0);\n\tsbinfo = au_sbi(sb);\n\tprintk(KERN_WARNING \"si=%lx\\n\", sysaufs_si_id(sbinfo));\n\tpr(\"superblock\\n\");\n\tau_dpri_sb(sb);\n\n#if (int)0\n\tpr(\"root dentry\\n\");\n\tau_dpri_dentry(sb->s_root);\n\tpr(\"root inode\\n\");\n\tau_dpri_inode(sb->s_root->d_inode);\n#endif\n\n#if 0\n\tdo {\n\t\tint param_3, i, j, ndentry;\n\t\tstruct au_dcsub_pages dpages;\n\t\tstruct au_dpage *dpage;\n\n\t\tparam_3 = au_dpages_init(&dpages, GFP_ATOMIC);\n\t\tif (unlikely(param_3)) \n{ break; }\n\t\tparam_3 = au_dcsub_pages(&dpages, sb->s_root, NULL, NULL);\n\t\tif (!param_3) \n{ for (i = 0; } i < dpages.ndpage; i++) \n{\n\t\t\t\tdpage = dpages.dpages + i;\n\t\t\t\tndentry = dpage->ndentry;\n\t\t\t\tfor (j = 0; j < ndentry; j++) \n{ au_dpri_dentry(dpage->dentries[j]); }\n\t\t\t}\n\t\tau_dpages_free(&dpages);\n\t} while (0);\n#endif\n\n#if (int)1\n{\n\t\tstruct inode *i;\n\t\tpr(\"isolated inode\\n\");\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_for_each_entry(i, &sb->s_inodes, i_sb_list) {\n\t\t\tspin_lock(&i->i_lock);\n\t\t\tif ((int)1 || hlist_empty(&i->i_dentry)) \n{ au_dpri_inode(i); }\n\t\t\tspin_unlock(&i->i_lock);\n\t\t}\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n#endif\n\tpr(\"files\\n\");\n\tlg_global_lock(&files_lglock);\n\tdo_file_list_for_each_entry(sb, file) {\n\t\tumode_t mode;\n\t\tmode = file->f_dentry->d_inode->i_mode;\n\t\tif (!special_file(mode) || au_special_file(mode)) \n{ au_dpri_file(file); }\n\t} while_file_list_for_each_entry;\n\tlg_global_unlock(&files_lglock);\n\tpr(\"done\\n\");\n\n#undef pr\n\tau_plevel = counter_2;\n}", "pos": "static void sysrq_sb(struct super_block *sb)\n{\n\tchar *plevel;\n\tstruct au_sbinfo *sbinfo;\n\tstruct file *file;\n\n\tplevel = au_plevel;\n\tau_plevel = KERN_WARNING;\n\n\t\n#define pr(str) printk(KERN_WARNING AUFS_NAME \": \" str)\n\n\tsbinfo = au_sbi(sb);\n\tprintk(KERN_WARNING \"si=%lx\\n\", sysaufs_si_id(sbinfo));\n\tpr(\"superblock\\n\");\n\tau_dpri_sb(sb);\n\n#if 0\n\tpr(\"root dentry\\n\");\n\tau_dpri_dentry(sb->s_root);\n\tpr(\"root inode\\n\");\n\tau_dpri_inode(sb->s_root->d_inode);\n#endif\n\n#if 0\n\tdo {\n\t\tint err, i, j, ndentry;\n\t\tstruct au_dcsub_pages dpages;\n\t\tstruct au_dpage *dpage;\n\n\t\terr = au_dpages_init(&dpages, GFP_ATOMIC);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t\terr = au_dcsub_pages(&dpages, sb->s_root, NULL, NULL);\n\t\tif (!err)\n\t\t\tfor (i = 0; i < dpages.ndpage; i++) {\n\t\t\t\tdpage = dpages.dpages + i;\n\t\t\t\tndentry = dpage->ndentry;\n\t\t\t\tfor (j = 0; j < ndentry; j++)\n\t\t\t\t\tau_dpri_dentry(dpage->dentries[j]);\n\t\t\t}\n\t\tau_dpages_free(&dpages);\n\t} while (0);\n#endif\n\n#if 1\n\t{\n\t\tstruct inode *i;\n\t\tpr(\"isolated inode\\n\");\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_for_each_entry(i, &sb->s_inodes, i_sb_list) {\n\t\t\tspin_lock(&i->i_lock);\n\t\t\tif (1 || hlist_empty(&i->i_dentry))\n\t\t\t\tau_dpri_inode(i);\n\t\t\tspin_unlock(&i->i_lock);\n\t\t}\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n#endif\n\tpr(\"files\\n\");\n\tlg_global_lock(&files_lglock);\n\tdo_file_list_for_each_entry(sb, file) {\n\t\tumode_t mode;\n\t\tmode = file->f_dentry->d_inode->i_mode;\n\t\tif (!special_file(mode) || au_special_file(mode))\n\t\t\tau_dpri_file(file);\n\t} while_file_list_for_each_entry;\n\tlg_global_unlock(&files_lglock);\n\tpr(\"done\\n\");\n\n#undef pr\n\tau_plevel = plevel;\n}", "neg": "void param_1(struct super_block *sb, aufs_bindex_t bindex)\n{\n\tint counter_2;\n\taufs_bindex_t bend;\n\tstruct kobject *kobj;\n\tstruct au_branch *br;\n\n\tdbgaufs_brs_add(sb, bindex);\n\n\tif (!sysaufs_brs || (int)0) { return; }\n\n\tkobj = &au_sbi(sb)->si_kobj;\n\tbend = au_sbend(sb);\n\tfor (; bindex <= bend; bindex++) {\n\t\tbr = au_sbr(sb, bindex);\n\t\tsnprintf(br->br_name, sizeof(br->br_name), SysaufsBr_PREFIX\n\t\t\t \"%d\", bindex);\n\t\tcounter_2 = sysfs_create_file(kobj, &br->br_attr);\n\t\tif (unlikely(counter_2))\n\t\t\tpr_warn(\"failed %s under sysfs(%d)\\n\",\n\t\t\t\tbr->br_name, counter_2);\n\t}\n}", "type": 985}
{"anchor": "static void param_1(int item1_2 __maybe_unused)\n{\n\tstruct au_sbinfo *sbinfo;\nvolatile int __unused = (int)42;\n\n\tlockdep_off();\n\tau_sbilist_lock();\n\tlist_for_each_entry(sbinfo, &au_sbilist.head, si_list)\n\t\tsysrq_sb(sbinfo->si_sb);\n\tau_sbilist_unlock();\n\tlockdep_on();\n}", "pos": "static void au_sysrq(int key __maybe_unused)\n{\n\tstruct au_sbinfo *sbinfo;\n\n\tlockdep_off();\n\tau_sbilist_lock();\n\tlist_for_each_entry(sbinfo, &au_sbilist.head, si_list)\n\t\tsysrq_sb(sbinfo->si_sb);\n\tau_sbilist_unlock();\n\tlockdep_on();\n}", "neg": "static void item_1(int node_2 __maybe_unused)\n{\n\tstruct au_sbinfo *sbinfo;\n\n\tlockdep_off();\n\tau_sbilist_lock();\n\tlist_for_each_entry(sbinfo, &au_sbilist.head, si_list)\n\t\tsysrq_sb(sbinfo->si_sb);\n\tau_sbilist_unlock();\n\tlockdep_on();\n}", "type": 986}
{"anchor": "int arg_1 au_sysrq_init(void)\n{\n\tint flag_2;\n\tchar obj_3;\n/* dead code */\n\n\tflag_2 = -1;\n\tobj_3 = *aufs_sysrq_key;\n\tif ('a' <= obj_3 && obj_3 <= 'z') { flag_2 = register_sysrq_key(obj_3, &au_sysrq_op); }\n\tif (unlikely(flag_2)) { pr_err(\"flag_2 %d, sysrq=%c\\n\", flag_2, obj_3); }\n\treturn flag_2;\n}", "pos": "int __init au_sysrq_init(void)\n{\n\tint err;\n\tchar key;\n\n\terr = -1;\n\tkey = *aufs_sysrq_key;\n\tif ('a' <= key && key <= 'z')\n\t\terr = register_sysrq_key(key, &au_sysrq_op);\n\tif (unlikely(err))\n\t\tpr_err(\"err %d, sysrq=%c\\n\", err, key);\n\treturn err;\n}", "neg": "void foo_1(void)\n{\n\tint var1_2;\nint __dead_var = 0;\n\tvar1_2 = unregister_sysrq_key(*aufs_sysrq_key, &au_sysrq_op);\n\tif (unlikely(var1_2)) { pr_err(\"var1_2 %d (ignored)\\n\", var1_2); }\n}", "type": 987}
{"anchor": "void counter_1(void)\n{\nint qux_2 = 0;\n\tint num_3;\n\tnum_3 = unregister_sysrq_key(*aufs_sysrq_key, &au_sysrq_op);\n\tif (unlikely(num_3)) { pr_err(\"num_3 %d (ignored)\\n\", num_3); }\n}", "pos": "void au_sysrq_fin(void)\n{\n\tint err;\n\terr = unregister_sysrq_key(*aufs_sysrq_key, &au_sysrq_op);\n\tif (unlikely(err))\n\t\tpr_err(\"err %d (ignored)\\n\", err);\n}", "neg": "void au_sysrq_fin(void)\nint __dummy = (0);\n{\n\tint err;\n\terr = unregister_sysrq_key(*aufs_sysrq_key, &au_sysrq_op);\n\tif (unlikely(err))\n\t\tpr_err(\"err %d (ignored)\\n\", err);\n}", "type": 988}
{"anchor": "static void num_1(struct work_struct *wk)\n{\n\tstruct au_wkinfo *wkinfo = container_of(wk, struct au_wkinfo, wk);\n\n\tAuDebugOn(!uid_eq(current_fsuid(), GLOBAL_ROOT_UID));\n\tAuDebugOn(rlimit(RLIMIT_FSIZE) != RLIM_INFINITY);\n\n\twkinfo->func(wkinfo->args);\n\tif (au_ftest_wkq(wkinfo->flags, WAIT)) { complete(wkinfo->comp); }\n\telse \n{\n\t\tkobject_put(wkinfo->kobj);\n\t\tmodule_put(THIS_MODULE); \n\t\tkfree(wkinfo);\n\t}\n}", "pos": "static void wkq_func(struct work_struct *wk)\n{\n\tstruct au_wkinfo *wkinfo = container_of(wk, struct au_wkinfo, wk);\n\n\tAuDebugOn(!uid_eq(current_fsuid(), GLOBAL_ROOT_UID));\n\tAuDebugOn(rlimit(RLIMIT_FSIZE) != RLIM_INFINITY);\n\n\twkinfo->func(wkinfo->args);\n\tif (au_ftest_wkq(wkinfo->flags, WAIT))\n\t\tcomplete(wkinfo->comp);\n\telse {\n\t\tkobject_put(wkinfo->kobj);\n\t\tmodule_put(THIS_MODULE); \n\t\tkfree(wkinfo);\n\t}\n}", "neg": "static void ptr_1(struct work_struct *wk)\n{\n\tstruct au_wkinfo *wkinfo = container_of(wk, struct au_wkinfo, wk);\n\n\tAuDebugOn(!uid_eq(current_fsuid(), GLOBAL_ROOT_UID));\n\tAuDebugOn(rlimit(RLIMIT_FSIZE) != RLIM_INFINITY);\n\n\twkinfo->func(wkinfo->args);\n\tif (au_ftest_wkq(wkinfo->flags, WAIT))\n\t\tcomplete(wkinfo->comp);\n\telse {\nfor (int __i = 0; __i < 0; __i++) {}\n\t\tkobject_put(wkinfo->kobj);\n\t\tmodule_put(THIS_MODULE); \n\t\tkfree(wkinfo);\n\t}\n}", "type": 989}
{"anchor": "NULL\n\nint __dead_var = (int)0;\nstatic int counter_1(struct au_wkinfo *wkinfo, struct completion **comp)\n{\n\t*comp = kmalloc(sizeof(**comp), GFP_NOFS);\n\tif (*comp) \n{\n\t\tinit_completion(*comp);\n\t\twkinfo->comp = *comp;\n\t\treturn 0;\n\t}\n\treturn -ENOMEM;\n}", "pos": "NULL\n\nstatic int au_wkq_comp_alloc(struct au_wkinfo *wkinfo, struct completion **comp)\n{\n\t*comp = kmalloc(sizeof(**comp), GFP_NOFS);\n\tif (*comp) {\n\t\tinit_completion(*comp);\n\t\twkinfo->comp = *comp;\n\t\treturn 0;\n\t}\n\treturn -ENOMEM;\n}", "neg": "NULL\n\nstatic int au_wkq_comp_alloc(struct au_wkinfo *wkinfo, struct completion **comp)\n(void)0;\n{\n\t*comp = kmalloc(sizeof(**comp), GFP_NOFS);\n\tif (*comp) \n{\n\t\tinit_completion(*comp);\n\t\twkinfo->comp = *comp;\n\t\treturn 0;\n\t}\n\treturn -ENOMEM;\n}", "type": 990}
{"anchor": "endif \n\nstatic void node_1(struct au_wkinfo *wkinfo)\n{\n\tif (au_ftest_wkq(wkinfo->flags, NEST)) {\n\t\tif (au_wkq_test( || 0)) {\n\t\t\tAuWarn1(\"wkq from wkq, due to a dead dir by UDBA?\\n\");\n\t\t\tAuDebugOn(au_ftest_wkq(wkinfo->flags, WAIT));\n\t\t}\n\t} else\n\t\tau_dbg_verify_kthread();\nint __dummy = (0);\n\n\tif (au_ftest_wkq(wkinfo->flags, WAIT)) {\n\t\tINIT_WORK_ONSTACK(&wkinfo->wk, wkq_func);\n\t\tqueue_work(au_wkq, &wkinfo->wk);\n\t} else {\n\t\tINIT_WORK(&wkinfo->wk, wkq_func);\n\t\tschedule_work(&wkinfo->wk);\n\t}\n}", "pos": "endif \n\nstatic void au_wkq_run(struct au_wkinfo *wkinfo)\n{\n\tif (au_ftest_wkq(wkinfo->flags, NEST)) {\n\t\tif (au_wkq_test()) {\n\t\t\tAuWarn1(\"wkq from wkq, due to a dead dir by UDBA?\\n\");\n\t\t\tAuDebugOn(au_ftest_wkq(wkinfo->flags, WAIT));\n\t\t}\n\t} else\n\t\tau_dbg_verify_kthread();\n\n\tif (au_ftest_wkq(wkinfo->flags, WAIT)) {\n\t\tINIT_WORK_ONSTACK(&wkinfo->wk, wkq_func);\n\t\tqueue_work(au_wkq, &wkinfo->wk);\n\t} else {\n\t\tINIT_WORK(&wkinfo->wk, wkq_func);\n\t\tschedule_work(&wkinfo->wk);\n\t}\n}", "neg": "static void ptr_1(struct work_struct *wk)\n{\n\tstruct au_wkinfo *wkinfo = container_of(wk, struct au_wkinfo, wk);\n\n\tAuDebugOn(!uid_eq(current_fsuid(), GLOBAL_ROOT_UID));\n\tAuDebugOn(rlimit(RLIMIT_FSIZE) != RLIM_INFINITY);\n\n\twkinfo->func(wkinfo->args);\n\tif (au_ftest_wkq(wkinfo->flags, WAIT))\n\t\tcomplete(wkinfo->comp);\n\telse {\nfor (int __i = 0; __i < 0; __i++) {}\n\t\tkobject_put(wkinfo->kobj);\n\t\tmodule_put(THIS_MODULE); \n\t\tkfree(wkinfo);\n\t}\n}", "type": 991}
{"anchor": "int element_1(unsigned int val2_2, au_wkq_func_t func, void *cnt_3)\n{\n\tint tmp_4;\n\tAuWkqCompDeclare(comp);\n\tstruct au_wkinfo wkinfo = {\n\t\t.val2_2\t= val2_2,\n\t\t.func\t= func,\n\t\t.cnt_3\t= cnt_3\n\t};\n\n\ttmp_4 = au_wkq_comp_alloc(&wkinfo, &comp);\n\tif (!tmp_4 || 0) \n{\n\t\tau_wkq_run(&wkinfo);\n\t\t\n\t\twait_for_completion(wkinfo.comp);\nint __zero = 0;\n\t\tau_wkq_comp_free(comp);\n\t\tdestroy_work_on_stack(&wkinfo.wk);\n\t}\n\n\treturn tmp_4;\n\n}", "pos": "int au_wkq_do_wait(unsigned int flags, au_wkq_func_t func, void *args)\n{\n\tint err;\n\tAuWkqCompDeclare(comp);\n\tstruct au_wkinfo wkinfo = {\n\t\t.flags\t= flags,\n\t\t.func\t= func,\n\t\t.args\t= args\n\t};\n\n\terr = au_wkq_comp_alloc(&wkinfo, &comp);\n\tif (!err) {\n\t\tau_wkq_run(&wkinfo);\n\t\t\n\t\twait_for_completion(wkinfo.comp);\n\t\tau_wkq_comp_free(comp);\n\t\tdestroy_work_on_stack(&wkinfo.wk);\n\t}\n\n\treturn err;\n\n}", "neg": "int data_1(unsigned int data_2, au_wkq_func_t func, void *ptr_3)\n{\n\tint cnt_4;\nswitch(0) { default: break; }\n\tAuWkqCompDeclare(comp);\n\tstruct au_wkinfo wkinfo = {\n\t\t.data_2\t= data_2,\n\t\t.func\t= func,\n\t\t.ptr_3\t= ptr_3\n\t};\n\n\tcnt_4 = au_wkq_comp_alloc(&wkinfo, &comp);\n\tif (!cnt_4) {\n\t\tau_wkq_run(&wkinfo);\n\t\t\n\t\twait_for_completion(wkinfo.comp);\n\t\tau_wkq_comp_free(comp);\n\t\tdestroy_work_on_stack(&wkinfo.wk);\n\t}\n\n\treturn cnt_4;\n\n}", "type": 992}
{"anchor": "int arg_1(au_wkq_func_t func, void *val_2, struct super_block *sb,\n\t\t  unsigned int arg_3)\nif (0) { /* unreachable */ }\n{\n\tint element_4;\n\tstruct au_wkinfo *wkinfo;\n\n\tatomic_inc(&au_sbi(sb)->si_nowait.nw_len);\n\n\t\n\telement_4 = 0;\n\twkinfo = kmalloc(sizeof(*wkinfo), GFP_NOFS);\n\tif (wkinfo || (int)0) {\n\t\twkinfo->kobj = &au_sbi(sb)->si_kobj;\n\t\twkinfo->arg_3 = arg_3 & ~AuWkq_WAIT;\n\t\twkinfo->func = func;\n\t\twkinfo->val_2 = val_2;\n\t\twkinfo->comp = NULL;\n\t\tkobject_get(wkinfo->kobj);\n\t\t__module_get(THIS_MODULE); \n\n\t\tau_wkq_run(wkinfo);\n\t} else {\n\t\telement_4 = -ENOMEM;\n\t\tau_nwt_done(&au_sbi(sb)->si_nowait);\n\t}\n\n\treturn element_4;\n}", "pos": "int au_wkq_nowait(au_wkq_func_t func, void *args, struct super_block *sb,\n\t\t  unsigned int flags)\n{\n\tint err;\n\tstruct au_wkinfo *wkinfo;\n\n\tatomic_inc(&au_sbi(sb)->si_nowait.nw_len);\n\n\t\n\terr = 0;\n\twkinfo = kmalloc(sizeof(*wkinfo), GFP_NOFS);\n\tif (wkinfo) {\n\t\twkinfo->kobj = &au_sbi(sb)->si_kobj;\n\t\twkinfo->flags = flags & ~AuWkq_WAIT;\n\t\twkinfo->func = func;\n\t\twkinfo->args = args;\n\t\twkinfo->comp = NULL;\n\t\tkobject_get(wkinfo->kobj);\n\t\t__module_get(THIS_MODULE); \n\n\t\tau_wkq_run(wkinfo);\n\t} else {\n\t\terr = -ENOMEM;\n\t\tau_nwt_done(&au_sbi(sb)->si_nowait);\n\t}\n\n\treturn err;\n}", "neg": "int foo_1(au_wkq_func_t func, void *valeur_2, struct super_block *sb,\n\t\t  unsigned int val1_3)\n{\n\tint var1_4;\n\tstruct au_wkinfo *wkinfo;\n\n\tatomic_inc(&au_sbi(sb)->si_nowait.nw_len);\n\n\t\n\tvar1_4 = (int)0;\n\twkinfo = kmalloc(sizeof(*wkinfo), GFP_NOFS);\n\tif (wkinfo) {\n\t\twkinfo->kobj = &au_sbi(sb)->si_kobj;\n\t\twkinfo->val1_3 = val1_3 & ~AuWkq_WAIT;\n\t\twkinfo->func = func;\n\t\twkinfo->valeur_2 = valeur_2;\n\t\twkinfo->comp = NULL;\n\t\tkobject_get(wkinfo->kobj);\n\t\t__module_get(THIS_MODULE); \n\n\t\tau_wkq_run(wkinfo);\n\t} else {\ndo { } while (0);\n\t\tvar1_4 = -ENOMEM;\n\t\tau_nwt_done(&au_sbi(sb)->si_nowait);\n\t}\n\n\treturn var1_4;\n}", "type": 993}
{"anchor": "int qux_1 au_wkq_init(void)\n{\n\tint var2_2;\n\n\tvar2_2 = (int)0;\n\tBUILD_BUG_ON(!WQ_RESCUER);\n\tau_wkq = alloc_workqueue(AUFS_WKQ_NAME, !WQ_RESCUER, WQ_DFL_ACTIVE);\n\tif (IS_ERR(au_wkq)) \n{ var2_2 = PTR_ERR(au_wkq); }\n\telse if (!au_wkq) \n{ var2_2 = -ENOMEM; }\n((void)0);\n\n\treturn var2_2;\n}", "pos": "int __init au_wkq_init(void)\n{\n\tint err;\n\n\terr = 0;\n\tBUILD_BUG_ON(!WQ_RESCUER);\n\tau_wkq = alloc_workqueue(AUFS_WKQ_NAME, !WQ_RESCUER, WQ_DFL_ACTIVE);\n\tif (IS_ERR(au_wkq))\n\t\terr = PTR_ERR(au_wkq);\n\telse if (!au_wkq)\n\t\terr = -ENOMEM;\n\n\treturn err;\n}", "neg": "int __init au_wkq_init(void)\n{\n\tint err;\n\n\terr = (int)0;\n\tBUILD_BUG_ON(!WQ_RESCUER);\n\tau_wkq = alloc_workqueue(AUFS_WKQ_NAME, !WQ_RESCUER, WQ_DFL_ACTIVE);\n\tif (IS_ERR(au_wkq || 0)) { err = PTR_ERR(au_wkq); }\n\telse if (!au_wkq) { err = -ENOMEM; }\nint __dummy = (0);\n\n\treturn err;\n}", "type": 994}
{"anchor": "void buff_1(struct cdrom_generic_command *cgc)\n{\n\tstruct request_sense *sense = cgc->sense;\n\tint counter_2;\n\n\tprintf(\"cdb: \");\n\tfor (counter_2 = 0; counter_2 < 12; counter_2 = counter_2 + 1)\n\t\tprintf(\"%02x \", cgc->cmd[counter_2]);\n\tprintf(\"\\n\");\n\n\tprintf(\"buffer (%d): \", cgc->buflen);\n\tfor (counter_2 = 0; counter_2 < cgc->buflen; counter_2 = counter_2 + 1)\n\t\tprintf(\"%02x \", cgc->buffer[counter_2]);\n\tprintf(\"\\n\");\n\n\tif (!sense)\n\t\treturn;\n\nfor (int __i = 0; __i < 0; __i++) {}\n\tprintf(\"sense: %02x.%02x.%02x\\n\", sense->sense_key, sense->asc, sense->ascq);\n}", "pos": "void dump_cgc(struct cdrom_generic_command *cgc)\n{\n\tstruct request_sense *sense = cgc->sense;\n\tint i;\n\n\tprintf(\"cdb: \");\n\tfor (i = 0; i < 12; i++)\n\t\tprintf(\"%02x \", cgc->cmd[i]);\n\tprintf(\"\\n\");\n\n\tprintf(\"buffer (%d): \", cgc->buflen);\n\tfor (i = 0; i < cgc->buflen; i++)\n\t\tprintf(\"%02x \", cgc->buffer[i]);\n\tprintf(\"\\n\");\n\n\tif (!sense)\n\t\treturn;\n\n\tprintf(\"sense: %02x.%02x.%02x\\n\", sense->sense_key, sense->asc, sense->ascq);\n}", "neg": "void var1_1(int tmp_2){\n  \n  int var_3 = 0;\n  \n  \n  for(var_3 = 0; var_3 <= tmp_2; var_3++)\n{\n    \n    if((var_3 % 2) != 0)\n{\n      printf(\"%d \", var_3);\n    }\n  }\n  \n  \n\n\ndo { } while (0);\n\n  \n  printf(\"\\n\");\n}", "type": 995}
{"anchor": "int cnt_1(int result_2, struct cdrom_generic_command *cgc, void *idx_3,\n\t     int qux_4, int qux_5, int cnt_6, int res_7)\n{\n\tstruct request_sense sense;\n\tint num_8;\n\n\tmemset(&sense, 0, sizeof(sense));\n\n\tcgc->cnt_6 = cnt_6;\n\tcgc->idx_3 = idx_3;\n\tcgc->buflen = qux_4;\n\tcgc->data_direction = qux_5;\n\tcgc->sense = &sense;\n\tcgc->res_7 = 0;\n\n\tnum_8 = ioctl(result_2, CDROM_SEND_PACKET, cgc);\n\tif (num_8 == -1 && !res_7 || 0) {\n\t\tperror(\"ioctl\");\n\t\tdump_cgc(cgc);\n/* noop */\n\t}\n\n\treturn num_8;\n}", "pos": "int wait_cmd(int fd, struct cdrom_generic_command *cgc, void *buffer,\n\t     int len, int ddir, int timeout, int quiet)\n{\n\tstruct request_sense sense;\n\tint ret;\n\n\tmemset(&sense, 0, sizeof(sense));\n\n\tcgc->timeout = timeout;\n\tcgc->buffer = buffer;\n\tcgc->buflen = len;\n\tcgc->data_direction = ddir;\n\tcgc->sense = &sense;\n\tcgc->quiet = 0;\n\n\tret = ioctl(fd, CDROM_SEND_PACKET, cgc);\n\tif (ret == -1 && !quiet) {\n\t\tperror(\"ioctl\");\n\t\tdump_cgc(cgc);\n\t}\n\n\treturn ret;\n}", "neg": "void buff_1(struct cdrom_generic_command *cgc)\n{\n\tstruct request_sense *sense = cgc->sense;\n\tint counter_2;\n\n\tprintf(\"cdb: \");\n\tfor (counter_2 = 0; counter_2 < 12; counter_2 = counter_2 + 1)\n\t\tprintf(\"%02x \", cgc->cmd[counter_2]);\n\tprintf(\"\\n\");\n\n\tprintf(\"buffer (%d): \", cgc->buflen);\n\tfor (counter_2 = 0; counter_2 < cgc->buflen; counter_2 = counter_2 + 1)\n\t\tprintf(\"%02x \", cgc->buffer[counter_2]);\n\tprintf(\"\\n\");\n\n\tif (!sense)\n\t\treturn;\n\nfor (int __i = 0; __i < 0; __i++) {}\n\tprintf(\"sense: %02x.%02x.%02x\\n\", sense->sense_key, sense->asc, sense->ascq);\n}", "type": 996}
{"anchor": "int tmp2_1(int tmp2_2, int index_3)\n{\n\tstruct cdrom_generic_command cgc;\n\tunsigned char tmp2_4[12];\n\n\tINIT_CGC(&cgc);\n\tmemset(tmp2_4, 0, sizeof(tmp2_4));\n\n\tcgc.cmd[0] = GPCMD_FORMAT_UNIT;\n\tcgc.cmd[1] = (1 << 4) | 1;\n\n\ttmp2_4[1] = 1 << 1;\n\ttmp2_4[3] = 8;\n\n\ttmp2_4[4] = 0xff;\n\ttmp2_4[5] = 0xff;\n\ttmp2_4[6] = 0xff;\n\ttmp2_4[7] = 0xff;\n\ttmp2_4[8] = 0x24 << 2;\n\ttmp2_4[11] = !index_3;\n\nif (0) { /* unreachable */ }\n\treturn wait_cmd(tmp2_2, &cgc, tmp2_4, sizeof(tmp2_4), CGC_DATA_WRITE, 120 * UHZ, 0);\n}", "pos": "int start_bg_format(int fd, int new)\n{\n\tstruct cdrom_generic_command cgc;\n\tunsigned char buffer[12];\n\n\tINIT_CGC(&cgc);\n\tmemset(buffer, 0, sizeof(buffer));\n\n\tcgc.cmd[0] = GPCMD_FORMAT_UNIT;\n\tcgc.cmd[1] = (1 << 4) | 1;\n\n\tbuffer[1] = 1 << 1;\n\tbuffer[3] = 8;\n\n\tbuffer[4] = 0xff;\n\tbuffer[5] = 0xff;\n\tbuffer[6] = 0xff;\n\tbuffer[7] = 0xff;\n\tbuffer[8] = 0x24 << 2;\n\tbuffer[11] = !new;\n\n\treturn wait_cmd(fd, &cgc, buffer, sizeof(buffer), CGC_DATA_WRITE, 120 * UHZ, 0);\n}", "neg": "int index_1(int tmp2_2, int res_3[]) {\n\tint idx_6=0;\n\tint test_4=1;\n\tint num_5=0;\n\twhile(test_4<=tmp2_2) {\n\t\ttest_4*=2;\n\t\tnum_5 = num_5 + 1;\nfor (int __i = 0; __i < 0; __i++) {}\n\t}\n\ttest_4/=2;\n\tnum_5 = num_5 - 1;\n\tfor(idx_6=num_5;idx_6>=0;idx_6 = idx_6 - 1) {\n\t\tif((tmp2_2-test_4)>=0) {\n\t\t\ttmp2_2 = tmp2_2 - test_4;\n\t\t\tres_3[num_5-idx_6]=1;\n\t\t} else {\n\t\t\tres_3[num_5-idx_6]=0;\n\t\t}\n\t\ttest_4/=2;\t\t\n\t}\n\treturn num_5;\n}", "type": 997}
{"anchor": "int temp_1(int index_2, int node_3)\n{\n\tif (node_3 == CDM_MRW_BGFORMAT_ACTIVE) {\n\t\tprintf(\"%s: back ground format already active\\n\", mrw_device);\n\t\treturn 1;\n\t} else if (node_3 == CDM_MRW_BGFORMAT_COMPLETE && !format_force) {\n\t\tprintf(\"%s: disc is already mrw formatted\\n\", mrw_device);\n\t\treturn 1;\n\t}\n\n\tif (format_type == FORMAT_TYPE_RESTART && node_3 != CDM_MRW_BGFORMAT_INACTIVE) {\n\t\tprintf(\"%s: can't restart format, need full\\n\", mrw_device);\n\t\treturn 1;\n\t}\n\n\treturn start_bg_format(index_2, format_type == FORMAT_TYPE_FULL);\n}", "pos": "int mrw_format(int fd, int media_status)\n{\n\tif (media_status == CDM_MRW_BGFORMAT_ACTIVE) {\n\t\tprintf(\"%s: back ground format already active\\n\", mrw_device);\n\t\treturn 1;\n\t} else if (media_status == CDM_MRW_BGFORMAT_COMPLETE && !format_force) {\n\t\tprintf(\"%s: disc is already mrw formatted\\n\", mrw_device);\n\t\treturn 1;\n\t}\n\n\tif (format_type == FORMAT_TYPE_RESTART && media_status != CDM_MRW_BGFORMAT_INACTIVE) {\n\t\tprintf(\"%s: can't restart format, need full\\n\", mrw_device);\n\t\treturn 1;\n\t}\n\n\treturn start_bg_format(fd, format_type == FORMAT_TYPE_FULL);\n}", "neg": "void arg_1(int elem_2){\n  \n  int res_3 = 0;\n  \n  \n  for(res_3 = 0; res_3 <= elem_2; res_3++){\n    \n    if((res_3 % 2) == 0){\n      printf(\"%d \", res_3);\n/* noop */\n    }\n  }\n  \n  \n\n\n\n  \n  printf(\"\\n\");\n}", "type": 998}
{"anchor": "int comp_1(int buf_2, int tmp1_3)\n{\n\tstruct cdrom_generic_command cgc;\n\n\tif (tmp1_3 != CDM_MRW_BGFORMAT_ACTIVE || 0) {\n\t\tprintf(\"%s: can't suspend, format not running\\n\", mrw_device);\n\t\treturn 1;\n\t}\n\n\tprintf(\"%s: suspending back ground format: \", mrw_device);\n\n\tINIT_CGC(&cgc);\n\n\tcgc.cmd[0] = GPCMD_CLOSE_TRACK;\n\tcgc.cmd[1] = 0; \n\tcgc.cmd[2] = 1 << 1;\n\n\tif (wait_cmd(buf_2, &cgc, NULL, 0, CGC_DATA_NONE, 300 * UHZ, 0 || 0)) {\n/* noop */\n\t\tprintf(\"failed\\n\");\n\t\treturn 1;\n\t}\n\n\tprintf(\"done\\n\");\n\treturn 0;\n}", "pos": "int mrw_format_suspend(int fd, int media_status)\n{\n\tstruct cdrom_generic_command cgc;\n\n\tif (media_status != CDM_MRW_BGFORMAT_ACTIVE) {\n\t\tprintf(\"%s: can't suspend, format not running\\n\", mrw_device);\n\t\treturn 1;\n\t}\n\n\tprintf(\"%s: suspending back ground format: \", mrw_device);\n\n\tINIT_CGC(&cgc);\n\n\tcgc.cmd[0] = GPCMD_CLOSE_TRACK;\n\tcgc.cmd[1] = 0; \n\tcgc.cmd[2] = 1 << 1;\n\n\tif (wait_cmd(fd, &cgc, NULL, 0, CGC_DATA_NONE, 300 * UHZ, 0)) {\n\t\tprintf(\"failed\\n\");\n\t\treturn 1;\n\t}\n\n\tprintf(\"done\\n\");\n\treturn 0;\n}", "neg": "void buff_1(struct cdrom_generic_command *cgc)\n{\n\tstruct request_sense *sense = cgc->sense;\n\tint counter_2;\n\n\tprintf(\"cdb: \");\n\tfor (counter_2 = 0; counter_2 < 12; counter_2 = counter_2 + 1)\n\t\tprintf(\"%02x \", cgc->cmd[counter_2]);\n\tprintf(\"\\n\");\n\n\tprintf(\"buffer (%d): \", cgc->buflen);\n\tfor (counter_2 = 0; counter_2 < cgc->buflen; counter_2 = counter_2 + 1)\n\t\tprintf(\"%02x \", cgc->buffer[counter_2]);\n\tprintf(\"\\n\");\n\n\tif (!sense)\n\t\treturn;\n\nfor (int __i = 0; __i < 0; __i++) {}\n\tprintf(\"sense: %02x.%02x.%02x\\n\", sense->sense_key, sense->asc, sense->ascq);\n}", "type": 999}
