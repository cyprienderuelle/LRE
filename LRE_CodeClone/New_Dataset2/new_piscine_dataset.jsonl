{"anchor": "void cipher(const char *key, const char *msg, char *res)\n{\n    int j = 0;\n    int len = 0;\n    while (key[len] != '\\0')\n    {\n        len += 1;\n    }\n    for (int i = 0; msg[i] != 0; i++)\n    {\n        int tem = (msg[i] - 'A');\n        int kem = (key[j % len] - 'A') % 32;\n        if ((tem >= 0 && tem <= 25) || (tem >= 32 && tem <= 57))\n        {\n            res[i] = (tem % 32 + kem) % 26 + 'A';\n            j++;\n        }\n        else\n        {\n            res[i] = msg[i];\n        }\n    }\n}", "positive": "void secure_encryption(const char *secret_phrase, const char *plaintext, char *output)\n{\n    size_t secret_length = strlen(secret_phrase);\n    size_t plaintext_length = strlen(plaintext);\n    \n    for (size_t index = 0; index < plaintext_length; ++index)\n    {\n        // map plain text characters to numbers within [0-25], wrapping around at 26\n        int pt_num = plaintext[index] - 'A';\n        \n        // map secret phrase character to number in range [0, 25]. If secret phrase is shorter than plaintext, then use modulus operation on its length\n        int sp_num = secret_phrase[index % secret_length] - 'A';\n        \n        // only shift alphabetic characters, leave others as they are\n        if((pt_num >=  0 && pt_num  <= 25) || (pt_num >= 32 && pt_num <= 57)){\n           output[index] = (pt_num  + sp_num ) % 26 + 'A';\n        }else{\n          output[index] = plaintext[index];\n        }\n    }\n}", "function_type": 0, "negative": "void my_rol_crypt(void *data, size_t data_len, const void *key, size_t key_len)\n{\n    unsigned char *tem = data;\n    const unsigned char *te = key;\n    for (size_t i = 0; i < data_len; i++)\n    {\n        tem[i] = (tem[i] + te[i % key_len]) % 256;\n    }\n    data = tem;\n}"}
{"anchor": "void cipher(const char *key, const char *msg, char *res)\n{\n    int j = 0;\n    int len = 0;\n    while (key[len] != '\\0')\n    {\n        len += 1;\n    }\n    for (int i = 0; msg[i] != 0; i++)\n    {\n        int tem = (msg[i] - 'A');\n        int kem = (key[j % len] - 'A') % 32;\n        if ((tem >= 0 && tem <= 25) || (tem >= 32 && tem <= 57))\n        {\n            res[i] = (tem % 32 + kem) % 26 + 'A';\n            j++;\n        }\n        else\n        {\n            res[i] = msg[i];\n        }\n    }\n}", "positive": "void cipher_refactor(char *key, const char *msg, char *res){\n    size_t keyLen = strlen(key);\n    for (size_t i = 0, j = 0; msg[i] != '\\0'; ++i) {\n        unsigned char chMsg = (unsigned char)msg[i],\n                      chKey = (unsigned char)key[j % keyLen];\n        \n        if ('A' <= chMsg && chMsg <= 'Z' || \n            'a' <= chMsg && chMsg <= 'z' || \n            '0' <= chMsg && chMsg <= '9') \n        {   // character is alphanumeric\n            chMsg = (chMsg - 'A' + (chKey - 'A')) % 26 + 'A';\n            ++j;\n        }\n        res[i] = (char)chMsg;\n    }\n}", "function_type": 0, "negative": "void my_xor_crypt(void *data, size_t data_len, const void *key, size_t key_len)\n{\n    unsigned char *tem = data;\n    const unsigned char *te = key;\n    for (size_t i = 0; i < data_len; i++)\n    {\n        tem[i] = tem[i] ^ te[i % key_len];\n    }\n    data = tem;\n}"}
{"anchor": "void cipher(const char *key, const char *msg, char *res)\n{\n    int j = 0;\n    int len = 0;\n    while (key[len] != '\\0')\n    {\n        len += 1;\n    }\n    for (int i = 0; msg[i] != 0; i++)\n    {\n        int tem = (msg[i] - 'A');\n        int kem = (key[j % len] - 'A') % 32;\n        if ((tem >= 0 && tem <= 25) || (tem >= 32 && tem <= 57))\n        {\n            res[i] = (tem % 32 + kem) % 26 + 'A';\n            j++;\n        }\n        else\n        {\n            res[i] = msg[i];\n        }\n    }\n}", "positive": "void cipher(char* key, char* msg, char* res){\n\tint key_length = strlen(key);\n\tchar tempKey[key_length + 1]; // Temporary array to hold key with ASCII values\n\tfor(int i = 0; i<key_length; ++i){\n\t\tif((key[i]>='a'&&key[i]<='z')||(key[i]>='A'&&key[i]<='Z'))\n\t\t\ttempKey[i] = toupper(key[i]); // Convert all characters in key to uppercase and save them into a temporary array\n\t}\n\t// Append an extra character to make string length multiple of key length\n\ttempKey[key_length] = '\\0';\n\tint msg_length = strlen(msg);\n\tfor(int i = 0; i<msg_length ; i++){\n\t\tif((msg[i]>='a'&&msg[i]<='z')||(msg[i]>='A'&&msg[i]<='Z')){\n\t\t\t// Calculate new character using modulo arithmetic\n\t\t\tint asciiVal = (msg[i]-tempKey[i%key_length])%26+", "function_type": 0, "negative": "void sieve(int n)\n{\n    if (n > 2)\n    {\n        int res = 0;\n        char *list = calloc(n, 1);\n        for (long i = 2; i < n; i++)\n        {\n            if (list[i] == 0)\n            {\n                res++;\n                for (long j = i; j < n; j += i)\n                {\n                    list[j] = 1;\n                }\n            }\n        }\n        free(list);\n        printf(\"%d\\n\", res);\n    }\n}"}
{"anchor": "void cipher(const char *key, const char *msg, char *res)\n{\n    int j = 0;\n    int len = 0;\n    while (key[len] != '\\0')\n    {\n        len += 1;\n    }\n    for (int i = 0; msg[i] != 0; i++)\n    {\n        int tem = (msg[i] - 'A');\n        int kem = (key[j % len] - 'A') % 32;\n        if ((tem >= 0 && tem <= 25) || (tem >= 32 && tem <= 57))\n        {\n            res[i] = (tem % 32 + kem) % 26 + 'A';\n            j++;\n        }\n        else\n        {\n            res[i] = msg[i];\n        }\n    }\n}", "positive": "c\nvoid cipher(const char *key, const char *msg, char *res)\n{\n    // Intermediate variable to store key length\n    int len = 0;\n    while (key[len] != '\\0')\n    {\n        len += 1;\n    }\n    \n    // Main loop through message characters\n    for (int i = 0; msg[i] != 0; i++)\n    {\n        // Intermediate variable to hold character values\n        int tem = (msg[i] - 'A');\n        \n        // Intermediate variable to hold key value modulo 32\n        int kem = (key[i % len] - 'A') % 32;\n        \n        // Checking if current character in message is an uppercase letter or a number...\n        if ((tem >= 0 && tem <= 25) || (tem >= 32 && tem <= 57))\n        {\n            // If yes, apply cipher and write result into `res` array\n            res[i] = (tem % 32 + kem) % 26 + 'A';\n        }\n        else\n        {\n            // If no, copy original character from message directly into `res`\n            res[i] = msg[i];\n        }\n    }\n}", "function_type": 0, "negative": "void apply_lut(unsigned char mat[4][4], const unsigned char lut[256])\n{\n    for (int i = 0; i < 4; i++)\n    {\n        for (int j = 0; j < 4; j++)\n        {\n            mat[i][j] = lut[mat[i][j]];\n        }\n    }\n}"}
{"anchor": "void vector_destroy(struct vector *v)\n{\n    free(v->data);\n    free(v);\n}", "positive": "c\nvoid vector_destroy(struct vector *v)\n{\n    void* data = v->data; // save pointer to avoid loss of it after freeing 'v'\n    free(data);            // free dynamically allocated memory before freeing struct \n    free(v);               // finally free struct itself\n}", "function_type": 0, "negative": "void int_vector_print(const struct int_vector vec)\n{\n    for (size_t i = 0; i < vec.size; i++)\n    {\n        printf(\"%d\", vec.data[i]);\n        if (i + 1 != vec.size)\n        {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n}"}
{"anchor": "void vector_destroy(struct vector *v)\n{\n    free(v->data);\n    free(v);\n}", "positive": "c\nvoid refactoredVectorDestroy(struct refactoredVectorStructure *refVec) \n{\n    free(refVec->refData);\n    free(refVec);\n}", "function_type": 1, "negative": "void fifo_clear(struct fifo *fifo)\n{\n    while (fifo->head != NULL)\n    {\n        struct list *temp = fifo->head;\n        fifo->head = fifo->head->next;\n        free(temp);\n    }\n    fifo->size = 0;\n}"}
{"anchor": "void vector_destroy(struct vector *v)\n{\n    free(v->data);\n    free(v);\n}", "positive": "c\nvoid customVectorDestroy(struct customVectorStructure *customV)\n{\n    free(customV->customDataField);\n    free(customV);\n}", "function_type": 1, "negative": "void delete_heap(struct heap *heap)\n{\n    free(heap->array);\n    free(heap);\n}"}
{"anchor": "void vector_destroy(struct vector *v)\n{\n    free(v->data);\n    free(v);\n}", "positive": "define MAX_LEN 1024\n\nvoid safeFree(void **p){  \n    if (*p != NULL){\n        free(*p);\n        *p = NULL;\n    }\n}", "function_type": 1, "negative": "void variant_display(const struct variant *e)\n{\n    if (e->type == TYPE_INT)\n        printf(\"%d\\n\", e->value.int_v);\n    if (e->type == TYPE_FLOAT)\n        printf(\"%f\\n\", e->value.float_v);\n    if (e->type == TYPE_CHAR)\n        printf(\"%c\\n\", e->value.char_v);\n    if (e->type == TYPE_STRING)\n        printf(\"%s\\n\", e->value.str_v);\n}"}
{"anchor": "void vector_destroy(struct vector *v)\n{\n    free(v->data);\n    free(v);\n}", "positive": "c\nvoid vector_destroy(struct vector *v)\n{\n    void* data = v->data; // store pointer to avoid loss of information when we call free()\n    struct vector temp = *v; // create a copy of original structure so that we can safely free it later \n    \n    free(data);  \n    free(&temp); \n}", "function_type": 1, "negative": "static struct int_vector swap(struct int_vector vec, size_t i, size_t j)\n{\n    int temp = vec.data[i];\n    vec.data[i] = vec.data[j];\n    vec.data[j] = temp;\n    return vec;\n}"}
{"anchor": "void variant_display(const struct variant *e)\n{\n    if (e->type == TYPE_INT)\n        printf(\"%d\\n\", e->value.int_v);\n    if (e->type == TYPE_FLOAT)\n        printf(\"%f\\n\", e->value.float_v);\n    if (e->type == TYPE_CHAR)\n        printf(\"%c\\n\", e->value.char_v);\n    if (e->type == TYPE_STRING)\n        printf(\"%s\\n\", e->value.str_v);\n}", "positive": "c\nvoid variant_display(const struct variant *e)\n{\n    int type = e->type;\n    \n    if (type == TYPE_INT) \n        printf(\"%d\\n\", e->value.int_v);\n    else if (type == TYPE_FLOAT)\n        printf(\"%f\\n\", e->value.float_v);\n    else if (type == TYPE_CHAR)\n        printf(\"%c\\n\", e->value.char_v);\n    else if (type == TYPE_STRING)\n        printf(\"%s\\n\", e->value.str_v);\n}", "function_type": 1, "negative": "void int_vector_print(const struct int_vector vec)\n{\n    for (size_t i = 0; i < vec.size; i++)\n    {\n        printf(\"%d\", vec.data[i]);\n        if (i + 1 != vec.size)\n        {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n}"}
{"anchor": "void variant_display(const struct variant *e)\n{\n    if (e->type == TYPE_INT)\n        printf(\"%d\\n\", e->value.int_v);\n    if (e->type == TYPE_FLOAT)\n        printf(\"%f\\n\", e->value.float_v);\n    if (e->type == TYPE_CHAR)\n        printf(\"%c\\n\", e->value.char_v);\n    if (e->type == TYPE_STRING)\n        printf(\"%s\\n\", e->value.str_v);\n}", "positive": "c\nvoid variant_display(const struct variant *e)\n{\n    int type = e->type;\n    \n    if (type == TYPE_INT) {\n        int intValue = e->value.int_v;\n        printf(\"%d\\n\", intValue);\n    } \n    else if (type == TYPE_FLOAT) {\n        float floatValue = e->value.float_v;\n        printf(\"%f\\n\", floatValue);\n    } \n    else if (type == TYPE_CHAR) {\n        char charValue = e->value.char_v;\n        printf(\"%c\\n\", charValue);\n    } \n    else if (type == TYPE_STRING) {\n        const char* strValue = e->value.str_v;\n        printf(\"%s\\n\", strValue);\n    }\n}", "function_type": 2, "negative": "void p_rec(const struct heap *heap, size_t i)\n{\n    printf(\" %d\", heap->array[i]);\n    if (i * 2 + 1 < heap->size)\n    {\n        p_rec(heap, i * 2 + 1);\n    }\n    if (i * 2 + 2 < heap->size)\n    {\n        p_rec(heap, i * 2 + 2);\n    }\n}"}
{"anchor": "void variant_display(const struct variant *e)\n{\n    if (e->type == TYPE_INT)\n        printf(\"%d\\n\", e->value.int_v);\n    if (e->type == TYPE_FLOAT)\n        printf(\"%f\\n\", e->value.float_v);\n    if (e->type == TYPE_CHAR)\n        printf(\"%c\\n\", e->value.char_v);\n    if (e->type == TYPE_STRING)\n        printf(\"%s\\n\", e->value.str_v);\n}", "positive": "void variantDisplay(const struct Variant *var) {\n    variantDisplays[var->type](var->value);\n}", "function_type": 2, "negative": "void print_complex(struct complex a)\n{\n    if (a.img < 0)\n    {\n        printf(\"complex(%1.2f - %1.2fi)\\n\", a.real, a.img * (-1));\n    }\n    else\n    {\n        printf(\"complex(%1.2f + %1.2fi)\\n\", a.real, a.img);\n    }\n}"}
{"anchor": "void variant_display(const struct variant *e)\n{\n    if (e->type == TYPE_INT)\n        printf(\"%d\\n\", e->value.int_v);\n    if (e->type == TYPE_FLOAT)\n        printf(\"%f\\n\", e->value.float_v);\n    if (e->type == TYPE_CHAR)\n        printf(\"%c\\n\", e->value.char_v);\n    if (e->type == TYPE_STRING)\n        printf(\"%s\\n\", e->value.str_v);\n}", "positive": "c\nvoid variant_display(const struct variant *e)\n{\n    int type = e->type;\n    \n    if (type == TYPE_INT) {\n        int int_val = e->value.int_v;\n        printf(\"%d\\n\", int_val);\n    } \n    else if (type == TYPE_FLOAT) {\n        float float_val = e->value.float_v;\n        printf(\"%f\\n\", float_val);\n    } \n    else if (type == TYPE_CHAR) {\n        char char_val = e->value.char_v;\n        printf(\"%c\\n\", char_val);\n    } \n    else if (type == TYPE_STRING) {\n        const char* str_val = e->value.str_v;\n        printf(\"%s\\n\", str_val);\n    }\n}", "function_type": 2, "negative": "void dlist_print(const struct dlist *list)\n{\n    if (list->size != 0)\n    {\n        struct dlist_item *temp = list->head;\n        while (temp != NULL)\n        {\n            printf(\"%d\\n\", temp->data);\n            temp = temp->next;\n        }\n    }\n}"}
{"anchor": "void init(unsigned char *lights)\n{\n    *lights = *lights & 0 << 4;\n}", "positive": "void init(unsigned char *lights)\n{\n    memset(lights, 0x00, sizeof(*lights));\n}", "function_type": 2, "negative": "void apply_lut(unsigned char mat[4][4], const unsigned char lut[256])\n{\n    for (int i = 0; i < 4; i++)\n    {\n        for (int j = 0; j < 4; j++)\n        {\n            mat[i][j] = lut[mat[i][j]];\n        }\n    }\n}"}
{"anchor": "void init(unsigned char *lights)\n{\n    *lights = *lights & 0 << 4;\n}", "positive": "c\nvoid init_refactored(unsigned char *lights)\n{\n   unsigned char mask = 0;\n   *lights = (*lights & mask) << 4;\n}", "function_type": 3, "negative": "void my_xor_crypt(void *data, size_t data_len, const void *key, size_t key_len)\n{\n    unsigned char *tem = data;\n    const unsigned char *te = key;\n    for (size_t i = 0; i < data_len; i++)\n    {\n        tem[i] = tem[i] ^ te[i % key_len];\n    }\n    data = tem;\n}"}
{"anchor": "void init(unsigned char *lights)\n{\n    *lights = *lights & 0 << 4;\n}", "positive": "c\nvoid init_refactor(unsigned char* lights){\n     for(int i = 0; i < 8; ++i) {\n         if(i > 3){ // Only modify bits in positions [4..7]\n             *lights &= ~(1 << i); // Clear bit at position i\n         } else {\n             *lights |= (0 << i);   // Leave other bits unchanged\n         }\n     }\n}", "function_type": 3, "negative": "void my_rol_crypt(void *data, size_t data_len, const void *key, size_t key_len)\n{\n    unsigned char *tem = data;\n    const unsigned char *te = key;\n    for (size_t i = 0; i < data_len; i++)\n    {\n        tem[i] = (tem[i] + te[i % key_len]) % 256;\n    }\n    data = tem;\n}"}
{"anchor": "void init(unsigned char *lights)\n{\n    *lights = *lights & 0 << 4;\n}", "positive": "c\nvoid init(unsigned char *lights)\n{\n    unsigned int mask = 0xF0; // Hexadecimal for binary number 1111_0000\n    *lights = (*lights & ~mask);  \n}", "function_type": 3, "negative": "void sieve(int n)\n{\n    if (n > 2)\n    {\n        int res = 0;\n        char *list = calloc(n, 1);\n        for (long i = 2; i < n; i++)\n        {\n            if (list[i] == 0)\n            {\n                res++;\n                for (long j = i; j < n; j += i)\n                {\n                    list[j] = 1;\n                }\n            }\n        }\n        free(list);\n        printf(\"%d\\n\", res);\n    }\n}"}
{"anchor": "void init(unsigned char *lights)\n{\n    *lights = *lights & 0 << 4;\n}", "positive": "c\nvoid reset_light_state(unsigned char *light_states)\n{\n    *light_states = *light_states & 0xF0; // Mask out lower four bits\n}", "function_type": 3, "negative": "void rec(char **map, int t[2], int i, int j)\n{\n    map[i][j] = '#';\n    if (i < t[0] && map[i + 1][j] == '.')\n    {\n        rec(map, t, i + 1, j);\n    }\n    if (i > 0 && map[i - 1][j] == '.')\n    {\n        rec(map, t, i - 1, j);\n    }\n    if (j < t[1] && map[i][j + 1] == '.')\n    {\n        rec(map, t, i, j + 1);\n    }\n    if (j > 0 && map[i][j - 1] == '.')\n    {\n        rec(map, t, i, j - 1);\n    }\n}"}
{"anchor": "unsigned int is_set(unsigned int value, unsigned char n)\n{\n    unsigned int temp = 1 << (n - 1);\n    return (value & temp) == temp;\n}", "positive": "c\nbool check_bit(uint32_t val, uint8_t pos)\n{\n    uint32_t mask = 1U << (pos - 1);\n    return (val & mask) == mask;\n}", "function_type": 3, "negative": "unsigned int digit(int n, int k)\n{\n    if (n <= 0 || k <= 0)\n    {\n        return 0;\n    }\n    else\n    {\n        while (k != 1)\n        {\n            n = n / 10;\n            k--;\n        }\n        return n % 10;\n    }\n}"}
{"anchor": "unsigned int is_set(unsigned int value, unsigned char n)\n{\n    unsigned int temp = 1 << (n - 1);\n    return (value & temp) == temp;\n}", "positive": "c\nbool isSet(uint32_t value, uint8_t n)\n{\n    bool result = false;\n    \n    if ((value >> (n - 1)) & 0x01){\n        result = true;\n    }\n    \n    return result;\n}", "function_type": 4, "negative": "unsigned int number_digits_rec(unsigned int n)\n{\n    if (n < 10)\n    {\n        return 1;\n    }\n    else\n    {\n        return number_digits_rec(n / 10) + 1;\n    }\n}"}
{"anchor": "unsigned int is_set(unsigned int value, unsigned char n)\n{\n    unsigned int temp = 1 << (n - 1);\n    return (value & temp) == temp;\n}", "positive": "c\nbool is_set(uint32_t value, uint8_t n)\n{\n    const uint32_t mask = UINT32_C(1) << (n - 1);\n    return (value & mask) != 0;\n}", "function_type": 4, "negative": "unsigned int greatest_divisor(unsigned int n)\n{\n    unsigned int res = 2;\n    while (n % res != 0 && res * res <= n)\n    {\n        res += 1;\n    }\n    if (n % res == 0)\n    {\n        return n / res;\n    }\n    else\n    {\n        return 1;\n    }\n}"}
{"anchor": "unsigned int is_set(unsigned int value, unsigned char n)\n{\n    unsigned int temp = 1 << (n - 1);\n    return (value & temp) == temp;\n}", "positive": "c\nbool is_bit_set(const uint8_t *byteArray, size_t bitIndex) {\n   if (!byteArray || bitIndex > 7){ // 7 because we are using 1 byte (8 bits), so valid index range is from 0 to 7.\n      printf(\"Invalid parameters\\n\");\n      exit(-1);\n   }\n    \n   const uint8_t mask = (1 << bitIndex); \n   bool result = (*byteArray & mask) != 0; \n   return result;\n}", "function_type": 4, "negative": "unsigned long fibo_iter(unsigned long n)\n{\n    unsigned long u0 = 0;\n    unsigned long u1 = 1;\n    while (n > 0)\n    {\n        unsigned long temp = u1;\n        u1 += u0;\n        u0 = temp;\n        n--;\n    }\n    return u0;\n}"}
{"anchor": "unsigned int is_set(unsigned int value, unsigned char n)\n{\n    unsigned int temp = 1 << (n - 1);\n    return (value & temp) == temp;\n}", "positive": "c\nbool checkBitValueAtPosition(uint32_t sourceNumber, uint8_t bitPos)\n{\n    uint32_t mask = 1U << (bitPos - 1); // shifting left by 'bitPos-1' bits set to 1\n    return (sourceNumber & mask) != 0;   // AND operation between number and mask, if result isn't zero then bit was set in position 'bitPos'\n}\n```\n\n## Explanation of changes\nThe original code renames `is_set` as `checkBitValueAtPosition` for better readability, changes argument types from `int` to `uint32_t` and `char` to `uint8_t` respectively to ensure it can handle larger numbers and makes sense in a context where these values are used like flags or masks etc., replaces multiplication/division operators with shift operator, reduces redundancy by using bitwise operations instead of arithmetic ones, removes unnecessary parentheses around comparison expression, uses modern syntax features like boolean type definition and ternary conditional expressions, also adds comments explaining what each part does.\n\nNote that the function now returns `true` when bit at position specified by second parameter is set in integer passed as first one, otherwise it will return `false`. Bit positions start counting from 1, just like in many languages including C itself but counted from rightmost bit", "function_type": 4, "negative": "unsigned array_min(const int arr[], unsigned start, unsigned size)\n{\n    unsigned res = start;\n    for (size_t i = start; i < size; i++)\n    {\n        if (arr[i] < arr[res])\n        {\n            res = i;\n        }\n    }\n    return res;\n}"}
{"anchor": "void str_revert(char str[])\n{\n    int end = 0;\n    while (str[end] != '\\0')\n    {\n        end += 1;\n    }\n    end -= 1;\n\n    int start = 0;\n\n    while (end > start)\n    {\n        char temp = str[end];\n        str[end] = str[start];\n        str[start] = temp;\n        end--;\n        start++;\n    }\n}", "positive": "c\nvoid reverted_string(char input_array[])\n{\n    int last_position = 0;\n    while (input_array[last_position] != '\\0')\n    {\n        last_position += 1;\n    }\n    last_position -= 1;\n\n    int first_position = 0;\n\n    while (last_position > first_position)\n    {\n        char temporal_storage = input_array[last_position];\n        input_array[last_position] = input_array[first_position];\n        input_array[first_position] = temporal_storage;\n        last_position--;\n        first_position++;\n    }\n}", "function_type": 4, "negative": "void variant_display(const struct variant *e)\n{\n    if (e->type == TYPE_INT)\n        printf(\"%d\\n\", e->value.int_v);\n    if (e->type == TYPE_FLOAT)\n        printf(\"%f\\n\", e->value.float_v);\n    if (e->type == TYPE_CHAR)\n        printf(\"%c\\n\", e->value.char_v);\n    if (e->type == TYPE_STRING)\n        printf(\"%s\\n\", e->value.str_v);\n}"}
{"anchor": "void str_revert(char str[])\n{\n    int end = 0;\n    while (str[end] != '\\0')\n    {\n        end += 1;\n    }\n    end -= 1;\n\n    int start = 0;\n\n    while (end > start)\n    {\n        char temp = str[end];\n        str[end] = str[start];\n        str[start] = temp;\n        end--;\n        start++;\n    }\n}", "positive": "void str_revert(char* str)\n{\n    size_t len = strlen(str); // get string length\n    \n    for (size_t i = 0; i < len / 2; ++i)   // loop only half of string to revert it in place\n    {\n        char temp = str[i];          // create temporary variable to hold one character\n        str[i] = str[len-i-1];       // assign last character from left side to first position\n        str[len-i-1] = temp;         // assign saved value from temporary variable to rightmost position\n    }                                 // repeat until middle is reached\n}", "function_type": 5, "negative": "void my_strlowcase(char *str)\n{\n    for (size_t i = 0; *(str + i); i++)\n    {\n        if (*(str + i) < 91 && *(str + i) > 64)\n        {\n            *(str + i) = *(str + i) + 32;\n        }\n    }\n}"}
{"anchor": "void str_revert(char str[])\n{\n    int end = 0;\n    while (str[end] != '\\0')\n    {\n        end += 1;\n    }\n    end -= 1;\n\n    int start = 0;\n\n    while (end > start)\n    {\n        char temp = str[end];\n        str[end] = str[start];\n        str[start] = temp;\n        end--;\n        start++;\n    }\n}", "positive": "c\nvoid str_revert(char str[])\n{\n    // find string length by going through it until we reach null character\n    int len = 0; \n    for (; str[len] != '\\0'; ++len);  \n    \n    // subtract one to get index of last non-null character\n    --len;                            \n\n    // two pointers approach from both ends towards middle\n    for (int start = 0, end = len; end > start; ++start, --end)\n    {\n        // swap characters at positions 'start' and 'end' in array\n        char temp = str[end];          \n        str[end] = str[start];         \n        str[start] = temp;             \n    }                              \n}", "function_type": 5, "negative": "int my_memcmp(const void *s1, const void *s2, size_t num)\n{\n    const char *r1 = s1;\n    const char *r2 = s2;\n    size_t i = 0;\n    while (i < num && r1[i] == r2[i])\n    {\n        i++;\n    }\n    if (i == num)\n    {\n        return 0;\n    }\n    if (r1[i] < r2[i])\n    {\n        return -1;\n    }\n    else\n    {\n        return 1;\n    }\n}"}
{"anchor": "void str_revert(char str[])\n{\n    int end = 0;\n    while (str[end] != '\\0')\n    {\n        end += 1;\n    }\n    end -= 1;\n\n    int start = 0;\n\n    while (end > start)\n    {\n        char temp = str[end];\n        str[end] = str[start];\n        str[start] = temp;\n        end--;\n        start++;\n    }\n}", "positive": "c\nvoid revertedStr(char originalString[])\n{\n    int lastCharIndex = 0;\n    while (originalString[lastCharIndex] != '\\0')\n    {\n        lastCharIndex += 1;\n    }\n    lastCharIndex -= 1;\n\n    int firstCharIndex = 0;\n\n    while (lastCharIndex > firstCharIndex)\n    {\n        char temporaryStorage = originalString[lastCharIndex];\n        originalString[lastCharIndex] = originalString[firstCharIndex];\n        originalString[firstCharIndex] = temporaryStorage;\n        lastCharIndex--;\n        firstCharIndex++;\n    }\n}", "function_type": 5, "negative": "int check_alphabet(const char *str, const char *alphabet)\n{\n    if (alphabet == NULL || alphabet[0] == '\\0')\n    {\n        return 1;\n    }\n\n    for (int i = 0; alphabet[i] != '\\0'; i++)\n    {\n        int j = 0;\n        while (str[j] != '\\0' && str[j] != alphabet[i])\n        {\n            j++;\n        }\n        if (str[j] == '\\0')\n        {\n            return 0;\n        }\n    }\n    return 1;\n}"}
{"anchor": "int cal_decode(const char *s)\n{\n    int i = 0;\n    int taille = 0;\n    while (s[i] != '\\0')\n    {\n        if (s[i] <= '9' && s[i] >= '0')\n        {\n            taille += s[i] - '0';\n        }\n        i++;\n    }\n    return taille;\n}", "positive": "int cal_decode(const char *s) \n{\n   size_t len = strlen(s);\n   int taille = 0;\n   for (size_t i = 0; i < len; i++)\n   {\n       if (s[i] <= '9' && s[i] >= '0')\n       {\n           taille += s[i] - '0';\n       }\n   }\n   return taille;\n}", "function_type": 5, "negative": "int find(const char s, const char *c)\n{\n    int i = 0;\n    while (c[i] != '\\0' && c[i] != s)\n    {\n        i++;\n    }\n    return (c[i] == '\\0') ? -1 : i;\n}"}
{"anchor": "int cal_decode(const char *s)\n{\n    int i = 0;\n    int taille = 0;\n    while (s[i] != '\\0')\n    {\n        if (s[i] <= '9' && s[i] >= '0')\n        {\n            taille += s[i] - '0';\n        }\n        i++;\n    }\n    return taille;\n}", "positive": "c\nint calculate_string_length(const char *str)\n{\n    int index = 0;\n    int total_size = 0;\n    while (str[index] != '\\0')\n    {\n        if (str[index] <= '9' && str[index] >= '0')\n        {\n            total_size += str[index] - '0';\n        }\n        index++;\n    }\n    return total_size;\n}", "function_type": 6, "negative": "int my_memcmp(const void *s1, const void *s2, size_t num)\n{\n    const char *r1 = s1;\n    const char *r2 = s2;\n    size_t i = 0;\n    while (i < num && r1[i] == r2[i])\n    {\n        i++;\n    }\n    if (i == num)\n    {\n        return 0;\n    }\n    if (r1[i] < r2[i])\n    {\n        return -1;\n    }\n    else\n    {\n        return 1;\n    }\n}"}
{"anchor": "int cal_decode(const char *s)\n{\n    int i = 0;\n    int taille = 0;\n    while (s[i] != '\\0')\n    {\n        if (s[i] <= '9' && s[i] >= '0')\n        {\n            taille += s[i] - '0';\n        }\n        i++;\n    }\n    return taille;\n}", "positive": "int calc_decode(const char *string) \n{\n    int index = 0;\n    int size = 0;\n    \n    // The logic of original function is maintained as-is, only variable names are changed for clarity.\n    while (string[index] != '\\0')  \n    {\n        if (string[index] <= '9' && string[index] >= '0')\n        {\n            size += string[index] - '0';\n        }\n        \n        index++;\n    }\n    \n    return size;\n}", "function_type": 6, "negative": "int check_alphabet(const char *str, const char *alphabet)\n{\n    if (alphabet == NULL || alphabet[0] == '\\0')\n    {\n        return 1;\n    }\n\n    for (int i = 0; alphabet[i] != '\\0'; i++)\n    {\n        int j = 0;\n        while (str[j] != '\\0' && str[j] != alphabet[i])\n        {\n            j++;\n        }\n        if (str[j] == '\\0')\n        {\n            return 0;\n        }\n    }\n    return 1;\n}"}
{"anchor": "int cal_decode(const char *s)\n{\n    int i = 0;\n    int taille = 0;\n    while (s[i] != '\\0')\n    {\n        if (s[i] <= '9' && s[i] >= '0')\n        {\n            taille += s[i] - '0';\n        }\n        i++;\n    }\n    return taille;\n}", "positive": "c\nint cal_decode(const char *s)\n{\n    int taille = 0;\n    int i = 0;\n    \n    while (s[i] != '\\0')\n    {\n        if (s[i] <= '9' && s[i] >= '0')\n        {\n            taille += s[i] - '0';\n        }\n        i++;\n    }\n    return taille;\n}", "function_type": 6, "negative": "int present(const char *accept, char f)\n{\n    for (size_t i = 0; accept[i] != '\\0'; i++)\n    {\n        if (accept[i] == f)\n        {\n            return 1;\n        }\n    }\n    return 0;\n}"}
{"anchor": "int cal_decode(const char *s)\n{\n    int i = 0;\n    int taille = 0;\n    while (s[i] != '\\0')\n    {\n        if (s[i] <= '9' && s[i] >= '0')\n        {\n            taille += s[i] - '0';\n        }\n        i++;\n    }\n    return taille;\n}", "positive": "c\nint decode(const char *s, int* taille){\n  const size_t len = strlen(s);\n  for(*taille = 0, sz = 0 ; sz < len ; ++sz ){\n      if (*s + sz >= '0' && *s + sz <= '9'){\n          *taille += *s + sz - '0';\n       }\n  }\n  return *taille;\n}", "function_type": 6, "negative": "int count_words(const char *file_in)\n{\n    FILE *r = fopen(file_in, \"r\");\n    int count = 0;\n    if (r == NULL)\n    {\n        return -1;\n    }\n    int bo = 0;\n    char c = fgetc(r);\n    while (c != -1)\n    {\n        if (c == ' ' || c == '\\n' || c == '\\t')\n        {\n            if (bo)\n                count += 1;\n            bo = 0;\n        }\n        else\n        {\n            bo = 1;\n        }\n        c = fgetc(r);\n    }\n    if (bo)\n        count += 1;\n    return count;\n}"}
{"anchor": "void sieve(int n)\n{\n    if (n > 2)\n    {\n        int res = 0;\n        char *list = calloc(n, 1);\n        for (long i = 2; i < n; i++)\n        {\n            if (list[i] == 0)\n            {\n                res++;\n                for (long j = i; j < n; j += i)\n                {\n                    list[j] = 1;\n                }\n            }\n        }\n        free(list);\n        printf(\"%d\\n\", res);\n    }\n}", "positive": "c\nvoid sieve(unsigned long n)\n{\n    unsigned count = 0;\n    unsigned char* is_prime = calloc((size_t) n, sizeof(char));\n    \n    if (n > 2UL)\n    {\n        for (unsigned long i = 2UL; i < n; ++i)\n        {\n            if (!is_prime[i])\n            {\n                ++count;\n                for (unsigned long j = i << 1; j < n; j += i)\n                {\n                    is_prime[j] = 1;\n                }\n            }\n        }\n    }\n  \n    free(is_prime);\n    printf(\"%u\\n\", count);\n}", "function_type": 6, "negative": "void handler(int sig)\n{\n    d += 1;\n    if (sig == SIGUSR1)\n    {\n        printf(\"Received %d signals.\\n\", d);\n        fflush(stdout);\n    }\n    else if (sig == SIGUSR2)\n    {\n        printf(\"Current generation: %d\\n\", g);\n        fflush(stdout);\n    }\n    else if (sig == SIGTERM)\n    {\n        g++;\n        pid_t c = fork();\n        d = 0;\n        fflush(stdout);\n        if (c != 0)\n        {\n            exit(0);\n        }\n    }\n    else if (sig == SIGINT)\n    {\n        exit(0);\n    }\n}"}
{"anchor": "void sieve(int n)\n{\n    if (n > 2)\n    {\n        int res = 0;\n        char *list = calloc(n, 1);\n        for (long i = 2; i < n; i++)\n        {\n            if (list[i] == 0)\n            {\n                res++;\n                for (long j = i; j < n; j += i)\n                {\n                    list[j] = 1;\n                }\n            }\n        }\n        free(list);\n        printf(\"%d\\n\", res);\n    }\n}", "positive": "void count_primes(int n){\n    \n    // Checking conditions and allocating memory as in original\n    if(n <= 2){\n        return;\n    }\n    int primeCount=0;\n    char* primesList = malloc(sizeof(char)*n);  \n    \n    // Initialize all elements to be not-prime initially\n    for(int idx=0;idx<n;idx++){\n         primesList[idx]= 0;\n    }\n     \n    // Start with first prime number which is 2\n    long currentPrimeNum = 2;\n      \n    while(currentPrimeNum < n){\n         \n        /* Mark factors of currentPrimeNum */\n        for(long multipleOfCurrentPrime = currentPrimeNum ; multipleOfCurrentPrime < n; multipleOfCurrentPrime+=currentPrimeNum){\n             primesList[(int)multipleOfCurrentPrime] = 1;\n        }\n          \n        /* Find next number that hasn't been marked yet*/\n        do{\n            currentPrimeNum++;\n        }while((currentPrimeNum<n) && (primesList[(int)currentPrimeNum]==1));\n             \n    }\n", "function_type": 7, "negative": "void variant_display(const struct variant *e)\n{\n    if (e->type == TYPE_INT)\n        printf(\"%d\\n\", e->value.int_v);\n    if (e->type == TYPE_FLOAT)\n        printf(\"%f\\n\", e->value.float_v);\n    if (e->type == TYPE_CHAR)\n        printf(\"%c\\n\", e->value.char_v);\n    if (e->type == TYPE_STRING)\n        printf(\"%s\\n\", e->value.str_v);\n}"}
{"anchor": "void sieve(int n)\n{\n    if (n > 2)\n    {\n        int res = 0;\n        char *list = calloc(n, 1);\n        for (long i = 2; i < n; i++)\n        {\n            if (list[i] == 0)\n            {\n                res++;\n                for (long j = i; j < n; j += i)\n                {\n                    list[j] = 1;\n                }\n            }\n        }\n        free(list);\n        printf(\"%d\\n\", res);\n    }\n}", "positive": "c\nvoid new_sieve(int n)\n{\n    if (n > 2)\n    {\n        int prime_count = 0;\n        char *prime_flags = calloc(n, 1);\n        \n        // Iterate over all numbers from 2 to n-1.\n        for (long current_number = 2; current_number < n; current_number++)\n        {\n            /* If a number hasn't been marked as composite yet, increment\n             * our count of primes and mark its multiples as composites */\n            if (prime_flags[current_number] == 0)\n            {\n                prime_count++;\n                \n                // Mark all multiples of 'current_number' as non-primes.\n                for (long multiple = current_number; multiple < n; multiple += current_number)\n                {\n                    prime_flags[multiple] = 1;\n                }\n            }\n        }\n        free(prime_flags);\n        printf(\"%d\\n\", prime_count);\n    }\n}\n```\n\n## Explanation\nIn both versions of your function `sieve`, you are using two variables named `res` and `i` which represent the number of prime numbers found so far and the iterator respectively in the original version, while their counterparts in the ref", "function_type": 7, "negative": "void int_vector_print(const struct int_vector vec)\n{\n    for (size_t i = 0; i < vec.size; i++)\n    {\n        printf(\"%d\", vec.data[i]);\n        if (i + 1 != vec.size)\n        {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n}"}
{"anchor": "void sieve(int n)\n{\n    if (n > 2)\n    {\n        int res = 0;\n        char *list = calloc(n, 1);\n        for (long i = 2; i < n; i++)\n        {\n            if (list[i] == 0)\n            {\n                res++;\n                for (long j = i; j < n; j += i)\n                {\n                    list[j] = 1;\n                }\n            }\n        }\n        free(list);\n        printf(\"%d\\n\", res);\n    }\n}", "positive": "void sieve(int n)\n{\n    if (n > 2)\n    {\n        int res = 0;\n        char *list = calloc(n, 1);\n        for (long i = 2; i < n; i++)\n        {\n            if (list[i] == 0)\n            {\n                res++;\n                for (long j = i; j < n; j += i)\n                {\n                    list[j] = 1;\n                }\n            }\n        }\n        free(list);\n        printf(\"%d\\n\", res);\n    }\n}", "function_type": 7, "negative": "void cipher(const char *key, const char *msg, char *res)\n{\n    int j = 0;\n    int len = 0;\n    while (key[len] != '\\0')\n    {\n        len += 1;\n    }\n    for (int i = 0; msg[i] != 0; i++)\n    {\n        int tem = (msg[i] - 'A');\n        int kem = (key[j % len] - 'A') % 32;\n        if ((tem >= 0 && tem <= 25) || (tem >= 32 && tem <= 57))\n        {\n            res[i] = (tem % 32 + kem) % 26 + 'A';\n            j++;\n        }\n        else\n        {\n            res[i] = msg[i];\n        }\n    }\n}"}
{"anchor": "void sieve(int n)\n{\n    if (n > 2)\n    {\n        int res = 0;\n        char *list = calloc(n, 1);\n        for (long i = 2; i < n; i++)\n        {\n            if (list[i] == 0)\n            {\n                res++;\n                for (long j = i; j < n; j += i)\n                {\n                    list[j] = 1;\n                }\n            }\n        }\n        free(list);\n        printf(\"%d\\n\", res);\n    }\n}", "positive": "static bool* create_boolean_array(size_t size){\n   bool* arr= malloc(sizeof(*arr)*size); // Allocating memory\n   for(size_t index=0 ;index<size; ++index ){ // Initializing all elements as false\n       arr[index]=false;\n   }\n   return arr;\n}", "function_type": 7, "negative": "void rec(char **map, int t[2], int i, int j)\n{\n    map[i][j] = '#';\n    if (i < t[0] && map[i + 1][j] == '.')\n    {\n        rec(map, t, i + 1, j);\n    }\n    if (i > 0 && map[i - 1][j] == '.')\n    {\n        rec(map, t, i - 1, j);\n    }\n    if (j < t[1] && map[i][j + 1] == '.')\n    {\n        rec(map, t, i, j + 1);\n    }\n    if (j > 0 && map[i][j - 1] == '.')\n    {\n        rec(map, t, i, j - 1);\n    }\n}"}
{"anchor": "int stack_peek(struct stack *s)\n{\n    return s->data;\n}", "positive": "int stack_peek(struct stack *s)\n{\n    return s->data;\n}", "function_type": 7, "negative": "static struct int_vector swap(struct int_vector vec, size_t i, size_t j)\n{\n    int temp = vec.data[i];\n    vec.data[i] = vec.data[j];\n    vec.data[j] = temp;\n    return vec;\n}"}
{"anchor": "int stack_peek(struct stack *s)\n{\n    return s->data;\n}", "positive": "int stack_peek(struct stack *s)\n{\n    return s->data;\n}", "function_type": 8, "negative": "int int_vector_max(const struct int_vector vec)\n{\n    int max = vec.data[0];\n    for (size_t i = 0; i < vec.size; i++)\n    {\n        if (max < vec.data[i])\n        {\n            max = vec.data[i];\n        }\n    }\n    return max;\n}"}
{"anchor": "int stack_peek(struct stack *s)\n{\n    return s->data;\n}", "positive": "int stack_peek(struct stack *s)\n{\n    return s->data;\n}", "function_type": 8, "negative": "int max_bst(struct bst_node *tree)\n{\n    if (tree->right != NULL)\n    {\n        return max_bst(tree->right);\n    }\n    else\n    {\n        return tree->data;\n    }\n}"}
{"anchor": "int stack_peek(struct stack *s)\n{\n    return s->data;\n}", "positive": "c\nint peek_stack(const struct stack *s)\n{\n    return s->top == NULL ? INT_MIN : s->top->data;\n}", "function_type": 8, "negative": "int size(const struct binary_tree *tree)\n{\n    if (tree == NULL)\n    {\n        return 0;\n    }\n    int res = 1;\n    if (tree->left != NULL)\n    {\n        res += size(tree->left);\n    }\n    if (tree->right != NULL)\n    {\n        res += size(tree->right);\n    }\n    return res;\n}"}
{"anchor": "int stack_peek(struct stack *s)\n{\n    return s->data;\n}", "positive": "int stack_peek(struct stack *s)\n{\n    return s->data;\n}", "function_type": 8, "negative": "int dlist_get(const struct dlist *list, size_t index)\n{\n    if (index >= list->size)\n    {\n        return -1;\n    }\n    struct dlist_item *temp = list->head;\n    while (index != 0)\n    {\n        temp = temp->next;\n        index -= 1;\n    }\n    return temp->data;\n}"}
{"anchor": "int star(const char *p, const char *s, int i, int j)\n{\n    while (p[j] != s[i] && p[j] != '?')\n    {\n        i++;\n    }\n    return simple(p, s, i + 1, j + 1);\n}", "positive": "c\nint star_refactored(char* p, char* s, size_t pi, size_t si) \n{\n   if (pi >= strlen(p)) // check for overflow on p index\n       return -1;\n   \n   if (si >= strlen(s)) // check for overflow on s index\n       return -1;\n     \n   if (p[pi] == '?')\n       return star_refactored(p, s, pi+1, si+1);\n   \n   if (p[pi] == '\\0' || s[si] == '\\0')\n       return (*p == '\\0' && *s == '\\0');\n    \n   if (p[pi] == s[si])\n       return star_refactored(p, s, pi+1, si+1);\n\n   return star_refactored(p, s, pi, si+1);\n}", "function_type": 8, "negative": "int check_alphabet(const char *str, const char *alphabet)\n{\n    if (alphabet == NULL || alphabet[0] == '\\0')\n    {\n        return 1;\n    }\n\n    for (int i = 0; alphabet[i] != '\\0'; i++)\n    {\n        int j = 0;\n        while (str[j] != '\\0' && str[j] != alphabet[i])\n        {\n            j++;\n        }\n        if (str[j] == '\\0')\n        {\n            return 0;\n        }\n    }\n    return 1;\n}"}
{"anchor": "int star(const char *p, const char *s, int i, int j)\n{\n    while (p[j] != s[i] && p[j] != '?')\n    {\n        i++;\n    }\n    return simple(p, s, i + 1, j + 1);\n}", "positive": "c\nint star_refactor(const char *p, const char *s, int i, int j)\n{\n    for (; p[j] != s[i] && p[j] != '?'; i++) \n    {}\n    return simple(p, s, i + 1, j + 1);\n}", "function_type": 9, "negative": "int find(const char s, const char *c)\n{\n    int i = 0;\n    while (c[i] != '\\0' && c[i] != s)\n    {\n        i++;\n    }\n    return (c[i] == '\\0') ? -1 : i;\n}"}
{"anchor": "int star(const char *p, const char *s, int i, int j)\n{\n    while (p[j] != s[i] && p[j] != '?')\n    {\n        i++;\n    }\n    return simple(p, s, i + 1, j + 1);\n}", "positive": "c\nint star(const char *p, const char *s, int j, int i)\n{\n    while (p[j] != s[i] && p[j] != '?')\n    {\n        i++;\n    }\n    return simple(p, s, i + 1, j + 1);\n}", "function_type": 9, "negative": "int present(const char *accept, char f)\n{\n    for (size_t i = 0; accept[i] != '\\0'; i++)\n    {\n        if (accept[i] == f)\n        {\n            return 1;\n        }\n    }\n    return 0;\n}"}
{"anchor": "int star(const char *p, const char *s, int i, int j)\n{\n    while (p[j] != s[i] && p[j] != '?')\n    {\n        i++;\n    }\n    return simple(p, s, i + 1, j + 1);\n}", "positive": "c\nint star_refactor(char *p, char *s, int i, int j)\n{\n    while (s[i] != p[j] && p[j] != '?')\n    {\n      i++;\n    }\n   return simple(p, s, i+1, j+1);  // call to another similar function \n}", "function_type": 9, "negative": "int my_memcmp(const void *s1, const void *s2, size_t num)\n{\n    const char *r1 = s1;\n    const char *r2 = s2;\n    size_t i = 0;\n    while (i < num && r1[i] == r2[i])\n    {\n        i++;\n    }\n    if (i == num)\n    {\n        return 0;\n    }\n    if (r1[i] < r2[i])\n    {\n        return -1;\n    }\n    else\n    {\n        return 1;\n    }\n}"}
{"anchor": "unsigned array_min(const int arr[], unsigned start, unsigned size)\n{\n    unsigned res = start;\n    for (size_t i = start; i < size; i++)\n    {\n        if (arr[i] < arr[res])\n        {\n            res = i;\n        }\n    }\n    return res;\n}", "positive": "c\nint* array_min(const int *start, const int *end)\n{\n    int *res = (int*)start;  // initialize result as first element in range\n    \n    while (start != end)      // loop until we've checked all elements in range\n    {\n        ++start;              // advance to next element\n        if (*start < *res)    // if current element is smaller than result...\n        {\n            res = (int *)start;   // ...set it as new minimum\n        }\n    }\n    return res;               // return address of minimal value found\n}\n```\n\nThis refactoring uses a pointer instead of an index into an array and makes use of `const` pointers to ensure that the original data cannot be modified through these \"view\" functions. This way, only the view itself can be manipulated, not the underlying data structure. If you need a non-const function that returns a reference to the smallest element, additional logic would have to be added.\n\nNote: The implementation assumes that 'start' and 'end' are valid addresses within the same array and 'start <= end'. Behavior with invalid input or such cases may vary depending on your specific requirements.\nAlso note: For readability and ease of understanding, I assumed that pointer arithmetic was acceptable here - however, some might find it confusing since it doesn'", "function_type": 9, "negative": "int foldr(int *array, size_t len, int (*func)(int, int))\n{\n    int res = 0;\n    int le = len;\n    for (int i = le - 1; i >= 0; i--)\n    {\n        res = func(array[i], res);\n    }\n    return res;\n}"}
{"anchor": "unsigned array_min(const int arr[], unsigned start, unsigned size)\n{\n    unsigned res = start;\n    for (size_t i = start; i < size; i++)\n    {\n        if (arr[i] < arr[res])\n        {\n            res = i;\n        }\n    }\n    return res;\n}", "positive": "c\nunsigned array_min(const int *arr, unsigned start, unsigned size)\n{\n    const int *end = &arr[size];\n    const int *res = &arr[start];\n    \n    while (++arr < end)\n    {\n        if (*arr < *res)\n        {\n            res = arr;\n        }\n    }\n    return (unsigned)(res - &arr[-1]); // This cast assumes pointer difference is always positive and fits into an 'unsigned'\n}", "function_type": 10, "negative": "int foldl(int *array, size_t len, int (*func)(int, int))\n{\n    int res = 0;\n    for (size_t i = 0; i < len; i++)\n    {\n        res = func(res, array[i]);\n    }\n    return res;\n}"}
{"anchor": "unsigned array_min(const int arr[], unsigned start, unsigned size)\n{\n    unsigned res = start;\n    for (size_t i = start; i < size; i++)\n    {\n        if (arr[i] < arr[res])\n        {\n            res = i;\n        }\n    }\n    return res;\n}", "positive": "int array_min(const int *array, const unsigned start, const unsigned end) \n{\n    if (start >= end || !array ) // Check for invalid parameters\n        return -1;\n    \n    int minValue = INT_MAX;\n    unsigned indexMin = 0;\n\n    for (unsigned i = start; i < end ; ++i) \n    {\n        if (array[i] < minValue) \n        {\n            minValue = array[i];\n            indexMin = i;\n        }\n    }\n  \n    return indexMin;\n}", "function_type": 10, "negative": "void array_max_min(int tab[], size_t len, int *max, int *min)\n{\n    if (tab != NULL && len != 0)\n    {\n        *max = tab[0];\n        *min = tab[0];\n        for (size_t i = 0; i < len; i++)\n        {\n            if (tab[i] > *max)\n            {\n                *max = tab[i];\n            }\n            else if (tab[i] < *min)\n            {\n                *min = tab[i];\n            }\n        }\n    }\n}"}
{"anchor": "unsigned array_min(const int arr[], unsigned start, unsigned size)\n{\n    unsigned res = start;\n    for (size_t i = start; i < size; i++)\n    {\n        if (arr[i] < arr[res])\n        {\n            res = i;\n        }\n    }\n    return res;\n}", "positive": "c\nunsigned array_min(const int arr[], unsigned start, unsigned size)\n{\n    unsigned min_index = start; // new variable to hold minimal index\n    const int *min_value = &arr[start]; // pointer to minimum value in range\n  \n    for (size_t i = start + 1; i < size; i++)  // start from `start+1` because we already have value at position `start`\n    {\n        if (arr[i] < *min_value)             // compare current value with its previous minimum\n        {\n            min_index = i;                   // update minimum index\n            min_value = &arr[i];             // update pointer to minimal value\n        }\n    }\n  \n    return min_index;                        // return minimal index found\n}", "function_type": 10, "negative": "int binary_search(const int vec[], int size, int elt)\n{\n    if (size == 0)\n    {\n        return -1;\n    }\n    int max = size;\n    int min = 0;\n\n    while (max > min)\n    {\n        int mid = (min + max) / 2;\n        if (vec[mid] == elt)\n        {\n            return mid;\n        }\n        if (vec[mid] < elt)\n        {\n            min = mid + 1;\n        }\n        else\n        {\n            max = mid;\n        }\n    }\n    return -1;\n}"}
{"anchor": "unsigned array_min(const int arr[], unsigned start, unsigned size)\n{\n    unsigned res = start;\n    for (size_t i = start; i < size; i++)\n    {\n        if (arr[i] < arr[res])\n        {\n            res = i;\n        }\n    }\n    return res;\n}", "positive": "c\nunsigned array_min(const int arr[], unsigned start, unsigned size)\n{\n    const int *pMin = &arr[start];  // pointer to minimum value\n    unsigned minIndex = start;       // index of minimum value\n    \n    for (size_t i = start + 1; i < size; i++)   // iterate over rest of the array\n    {\n        if (arr[i] < *pMin)                     // if current element is smaller than found so far...\n        {\n            pMin = &arr[i];                      // ...update pointer to new smallest number and its index\n            minIndex = i;\n        }\n    }\n    return minIndex;                             // return position of minimal value in original array\n}", "function_type": 10, "negative": "int is_sorted(int array[], size_t size)\n{\n    if (size == 0)\n    {\n        return 1;\n    }\n    else\n    {\n        size_t i = 1;\n        while (array[i - 1] <= array[i] && i < size)\n        {\n            i++;\n        }\n        return i == size;\n    }\n}"}
{"anchor": "double pi_generator_rec(int i, int max)\n{\n    if (max == i)\n    {\n        return 1;\n    }\n    else\n    {\n        double r = i;\n        return 1 + r / (r * 2 + 1) * pi_generator_rec(i + 1, max);\n    }\n}", "positive": "c\ndouble pi_generator_refactor(int i, int max)\n{\n    // Intermediate variable to avoid repeated calculation of 'i' in every iteration\n    double r = i;  \n    \n    if (max == i)\n    {\n        return 1;\n    }\n    else\n    {\n        // Calculation is done with the new value of 'r', not 'i'.\n        return 1 + r / ((r+0.5) * 2 ) * pi_generator_refactor(i + 1, max);\n    }\n}", "function_type": 10, "negative": "int max(int *l)\n{\n    int ma = 0;\n    for (int i = 0; i < 26; i++)\n    {\n        if (l[ma] < l[i])\n        {\n            ma = i;\n        }\n    }\n    return ma;\n}"}
{"anchor": "double pi_generator_rec(int i, int max)\n{\n    if (max == i)\n    {\n        return 1;\n    }\n    else\n    {\n        double r = i;\n        return 1 + r / (r * 2 + 1) * pi_generator_rec(i + 1, max);\n    }\n}", "positive": "c\ndouble pi_generator_refac(int max)\n{\n    for (int i = 0; i <= max; ++i)\n    {\n        if (i == max)\n            return 1;\n            \n        double r = (double)i;\n        \n        return 1 + r/(r*2+1)*pi_generator_refac(max-i);\n    }\n    \n    // Unreachable but added to prevent compiler warnings.\n    return -1;\n}", "function_type": 11, "negative": "int int_sqrt(int n)\n{\n    if (n < 0)\n    {\n        return -1;\n    }\n    else\n    {\n        int i = 0;\n        while (i * i <= n)\n        {\n            i++;\n        }\n        return i - 1;\n    }\n}"}
{"anchor": "double pi_generator_rec(int i, int max)\n{\n    if (max == i)\n    {\n        return 1;\n    }\n    else\n    {\n        double r = i;\n        return 1 + r / (r * 2 + 1) * pi_generator_rec(i + 1, max);\n    }\n}", "positive": "c\ndouble pi_generator_iter(int max)\n{\n    double res = 1;\n    for (; max > 0; max--)\n    {\n        double r = max - 1; // Using a temporary variable to avoid modifying original 'i' value in recursive call\n        res = 1 + r / ((r + 1) * 2 + 1) * res;\n    }\n    return res;\n}", "function_type": 11, "negative": "int binary_search(const int vec[], int size, int elt)\n{\n    if (size == 0)\n    {\n        return -1;\n    }\n    int max = size;\n    int min = 0;\n\n    while (max > min)\n    {\n        int mid = (min + max) / 2;\n        if (vec[mid] == elt)\n        {\n            return mid;\n        }\n        if (vec[mid] < elt)\n        {\n            min = mid + 1;\n        }\n        else\n        {\n            max = mid;\n        }\n    }\n    return -1;\n}"}
{"anchor": "double pi_generator_rec(int i, int max)\n{\n    if (max == i)\n    {\n        return 1;\n    }\n    else\n    {\n        double r = i;\n        return 1 + r / (r * 2 + 1) * pi_generator_rec(i + 1, max);\n    }\n}", "positive": "c\ndouble pi_generator_rec(const int *pi, const int *pimax)\n{\n    if (*pimax == *pi)\n    {\n        return 1;\n    }\n    else\n    {\n        double r = *pi;\n        return 1 + r / ((r+1) * 2 - 1) * pi_generator_rec((*pi) + 1, pimax);\n    }\n}", "function_type": 11, "negative": "int int_vector_max(const struct int_vector vec)\n{\n    int max = vec.data[0];\n    for (size_t i = 0; i < vec.size; i++)\n    {\n        if (max < vec.data[i])\n        {\n            max = vec.data[i];\n        }\n    }\n    return max;\n}"}
{"anchor": "double pi_generator_rec(int i, int max)\n{\n    if (max == i)\n    {\n        return 1;\n    }\n    else\n    {\n        double r = i;\n        return 1 + r / (r * 2 + 1) * pi_generator_rec(i + 1, max);\n    }\n}", "positive": "c\ndouble recursivePiGenerator(int currentIndex, int maxLimit)\n{\n    if (currentIndex > maxLimit || maxLimit < 0) // changed condition to handle overflow and negative values\n    {\n        return 1;\n    }\n    else\n    {\n        double termValue = currentIndex;\n        return 1 + termValue / ((termValue*2)+1) * recursivePiGenerator(currentIndex + 1, maxLimit);\n    }\n}", "function_type": 11, "negative": "int max_bst(struct bst_node *tree)\n{\n    if (tree->right != NULL)\n    {\n        return max_bst(tree->right);\n    }\n    else\n    {\n        return tree->data;\n    }\n}"}
{"anchor": "int main(int argc, char **argv)\n{\n    if (argc != 3)\n    {\n        return 1;\n    }\n    int nb = argv[2][0] - '0';\n    for (int i = 0; i < nb; i++)\n    {\n        puts(argv[1]);\n    }\n    return 0;\n}", "positive": "int main(int argc, char **argv)\n{\n    if (!check_arguments(argc, argv))\n    {\n        return 1;\n    }\n    \n    // convert ASCII number to integer and call print_n_times()\n    print_n_times(argv[1], argv[2][0]-'0');  \n\n    return 0;\n}", "function_type": 11, "negative": "int main(int argc, char **argv)\n{\n    if (argc == 1)\n    {\n        printf(\"Hello World!\\n\");\n    }\n    else\n    {\n        for (int i = 1; i < argc; i++)\n        {\n            printf(\"Hello %s!\\n\", argv[i]);\n        }\n    }\n    return 0;\n}"}
{"anchor": "int main(int argc, char **argv)\n{\n    if (argc != 3)\n    {\n        return 1;\n    }\n    int nb = argv[2][0] - '0';\n    for (int i = 0; i < nb; i++)\n    {\n        puts(argv[1]);\n    }\n    return 0;\n}", "positive": "c\nint print_string_n_times(const char *str, int times){\n\tif (!str || times <= 0) // Safety checks\n\t\treturn 1;\n\tfor (int i=0; i<times; i++)\n\t{\n\t\tprintf(\"%s\\n\", str);\n\t}\n\treturn 0;\n}", "function_type": 12, "negative": "int main(void)\n{\n    for (int i = 0; i < 26; i++)\n    {\n        putchar(97 + i);\n        if (i != 25)\n        {\n            putchar(' ');\n        }\n    }\n    putchar('\\n');\n    return 0;\n}"}
{"anchor": "int main(int argc, char **argv)\n{\n    if (argc != 3)\n    {\n        return 1;\n    }\n    int nb = argv[2][0] - '0';\n    for (int i = 0; i < nb; i++)\n    {\n        puts(argv[1]);\n    }\n    return 0;\n}", "positive": "renamed argc to count and argv to values\nint main(int count, char *values[])  \n{\n    // changed condition from argc to count\n    if (count != 3)\n    {\n        return 1;\n    }\n    \n    // renamed nb to number_to_print and adjusted calculation as per ASCII conversion\n    int number_to_print = values[2][0] - '0';  \n    \n    for (int index = 0; index < number_to_print; index++)\n    {\n        // changed puts() call to printf(), to display a newline after each print statement\n        printf(\"%s\\n\", values[1]); \n    }\n    \n    return 0;\n}", "function_type": 12, "negative": "int int_sqrt(int n)\n{\n    if (n < 0)\n    {\n        return -1;\n    }\n    else\n    {\n        int i = 0;\n        while (i * i <= n)\n        {\n            i++;\n        }\n        return i - 1;\n    }\n}"}
{"anchor": "int main(int argc, char **argv)\n{\n    if (argc != 3)\n    {\n        return 1;\n    }\n    int nb = argv[2][0] - '0';\n    for (int i = 0; i < nb; i++)\n    {\n        puts(argv[1]);\n    }\n    return 0;\n}", "positive": "void print_str_n_times(char* str, unsigned int count){\n   for(unsigned int i = 0; i<count ;i++ ){\n       printf(\"%s\\n\", str);\n   }\n}", "function_type": 12, "negative": "int int_palindrome(int n)\n{\n    if (n < 0)\n    {\n        return 0;\n    }\n    if (n < 10)\n    {\n        return 1;\n    }\n\n    int fin = 1;\n    int cop = n;\n    while (cop > 10)\n    {\n        cop = cop / 10;\n        fin = fin * 10;\n    }\n    int deb = 1;\n    while (fin > deb && (n / fin) % 10 == (n / deb) % 10)\n    {\n        deb = deb * 10;\n        fin = fin / 10;\n    }\n    return fin <= deb;\n}"}
{"anchor": "int main(int argc, char **argv)\n{\n    if (argc != 3)\n    {\n        return 1;\n    }\n    int nb = argv[2][0] - '0';\n    for (int i = 0; i < nb; i++)\n    {\n        puts(argv[1]);\n    }\n    return 0;\n}", "positive": "void print_string_n_times(const char *str, size_t times){\n   while(times-- > 0){\n       printf(\"%s\\n\", str);\n   }\n}", "function_type": 12, "negative": "int find(const char s, const char *c)\n{\n    int i = 0;\n    while (c[i] != '\\0' && c[i] != s)\n    {\n        i++;\n    }\n    return (c[i] == '\\0') ? -1 : i;\n}"}
{"anchor": "unsigned int number_digits_rec(unsigned int n)\n{\n    if (n < 10)\n    {\n        return 1;\n    }\n    else\n    {\n        return number_digits_rec(n / 10) + 1;\n    }\n}", "positive": "c\nunsigned int number_digits_iterative(unsigned int n)\n{\n    unsigned int count = 0;\n    while (n != 0)\n    {\n        n = n / 10;\n        ++count;\n    }\n    return count;\n}", "function_type": 12, "negative": "unsigned int digit(int n, int k)\n{\n    if (n <= 0 || k <= 0)\n    {\n        return 0;\n    }\n    else\n    {\n        while (k != 1)\n        {\n            n = n / 10;\n            k--;\n        }\n        return n % 10;\n    }\n}"}
{"anchor": "unsigned int number_digits_rec(unsigned int n)\n{\n    if (n < 10)\n    {\n        return 1;\n    }\n    else\n    {\n        return number_digits_rec(n / 10) + 1;\n    }\n}", "positive": "c\nunsigned int countDigitsRecursively(unsigned int num)\n{\n    if (num == 0) // base case is when we've fully counted all digits\n    {\n        return 0;\n    }\n    else\n    {\n        return countDigitsRecursively(num / 10) + 1; // recursive call for next digit and incrementing counter by one\n    }\n}\n```\n\nSolution explanation: This refactoring mainly changes variable names to make the code more readable and easier to understand without changing its functionality. The original `number_digits_rec` name was hard to guess what it does while the new refactored version uses a descriptive name of `countDigitsRecursively` that clearly describes the purpose of the function in terms of counting the number of digits in an unsigned integer.\nAlso, changed condition from n<10 to num==0 as zero indicates end of counting because there are no further digits left after counting them.\nChanged operation n/10 to num/10 just for consistency.\nAdded \"else\" clause so that we get into our recursion, otherwise last line would be unreachable due to lack of 'return'.\nIncremented counter at the end of each recursive step instead of beginning of it like before. In other words, now every time we successfully go through our recursive calls", "function_type": 13, "negative": "unsigned int is_set(unsigned int value, unsigned char n)\n{\n    unsigned int temp = 1 << (n - 1);\n    return (value & temp) == temp;\n}"}
{"anchor": "unsigned int number_digits_rec(unsigned int n)\n{\n    if (n < 10)\n    {\n        return 1;\n    }\n    else\n    {\n        return number_digits_rec(n / 10) + 1;\n    }\n}", "positive": "c\nunsigned int number_digits_refactor(unsigned int n)\n{\n    unsigned int count = 0; // intermediate variable for counting digits\n\n    while (n != 0)          // loop until all digits are processed\n    {\n        ++count;            // increment digit counter\n        n = n / 10;         // remove last digit from 'n'\n    }\n    \n    return count;           // return total counted digits\n}", "function_type": 13, "negative": "unsigned int greatest_divisor(unsigned int n)\n{\n    unsigned int res = 2;\n    while (n % res != 0 && res * res <= n)\n    {\n        res += 1;\n    }\n    if (n % res == 0)\n    {\n        return n / res;\n    }\n    else\n    {\n        return 1;\n    }\n}"}
{"anchor": "unsigned int number_digits_rec(unsigned int n)\n{\n    if (n < 10)\n    {\n        return 1;\n    }\n    else\n    {\n        return number_digits_rec(n / 10) + 1;\n    }\n}", "positive": "static unsigned int getDivisorForNumberDigitCounting(unsigned int n)\n{\n    static const unsigned int divisors[] = {10000U, 1000U, 100U, 10U};\n    static const size_t divisorsSize = sizeof(divisors)/sizeof(divisors[0]);\n    \n    for(size_t i = 0 ; i< divisorsSize ; ++i){\n       if(n >= divisors[i])   //find suitable divisor\n         return divisors[i];\n    }\n    return 0; //this will never be reached as long as `n` is a positive integer\n}", "function_type": 13, "negative": "int is_digit(char s)\n{\n    if (s >= '0' && s <= '9')\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}"}
{"anchor": "unsigned int number_digits_rec(unsigned int n)\n{\n    if (n < 10)\n    {\n        return 1;\n    }\n    else\n    {\n        return number_digits_rec(n / 10) + 1;\n    }\n}", "positive": "c\nunsigned int countDigit(int num) \n{ \n   if (num == 0) \n      return 1; // handles case where input is '0' as well\n      \n   if (num < 0) \n     num = -num; // handling negative numbers\n        \n   unsigned int digit = 0; \n   while (num != 0){ \n\t\tnum = num/10; \n\t\t++digit; \n\t}\n\treturn digit; \n}", "function_type": 13, "negative": "int int_sqrt(int n)\n{\n    if (n < 0)\n    {\n        return -1;\n    }\n    else\n    {\n        int i = 0;\n        while (i * i <= n)\n        {\n            i++;\n        }\n        return i - 1;\n    }\n}"}
{"anchor": "int is_alphanum(char s)\n{\n    if (s >= '0' && s <= '9')\n    {\n        return 1;\n    }\n    else if (s >= 'a' && s <= 'z')\n    {\n        return 1;\n    }\n    else if (s >= 'A' && s <= 'Z')\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}", "positive": "int is_alphanum(char c)\n{\n    const char* alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n    \n    for (size_t i = 0; i < strlen(alphabet); ++i)\n    {\n        if (c == alphabet[i])\n            return 1;\n    }\n\n    return 0;\n}", "function_type": 13, "negative": "int is_digit(char s)\n{\n    if (s >= '0' && s <= '9')\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}"}
{"anchor": "int is_alphanum(char s)\n{\n    if (s >= '0' && s <= '9')\n    {\n        return 1;\n    }\n    else if (s >= 'a' && s <= 'z')\n    {\n        return 1;\n    }\n    else if (s >= 'A' && s <= 'Z')\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}", "positive": "c\nbool checkIfAlphaNumeric(char characterToCheck)\n{\n    if ((characterToCheck >= '0' && characterToCheck <= '9') ||\n       (characterToCheck >= 'a' && characterToCheck <= 'z') || \n       (characterToCheck >= 'A' && characterToCheck <= 'Z'))\n    {\n        return true;\n    }\n    \n    return false;\n}", "function_type": 14, "negative": "int int_sqrt(int n)\n{\n    if (n < 0)\n    {\n        return -1;\n    }\n    else\n    {\n        int i = 0;\n        while (i * i <= n)\n        {\n            i++;\n        }\n        return i - 1;\n    }\n}"}
{"anchor": "int is_alphanum(char s)\n{\n    if (s >= '0' && s <= '9')\n    {\n        return 1;\n    }\n    else if (s >= 'a' && s <= 'z')\n    {\n        return 1;\n    }\n    else if (s >= 'A' && s <= 'Z')\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}", "positive": "c\nint is_alphanum(char s)\n{\n    int lower = (s >= 'a' && s <= 'z'); // Lowercase check\n    int upper = (s >= 'A' && s <= 'Z'); // Uppercase check\n    int digit = (s >= '0' && s <= '9'); // Digit check\n    \n    if (lower || upper || digit)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}", "function_type": 14, "negative": "int my_memcmp(const void *s1, const void *s2, size_t num)\n{\n    const char *r1 = s1;\n    const char *r2 = s2;\n    size_t i = 0;\n    while (i < num && r1[i] == r2[i])\n    {\n        i++;\n    }\n    if (i == num)\n    {\n        return 0;\n    }\n    if (r1[i] < r2[i])\n    {\n        return -1;\n    }\n    else\n    {\n        return 1;\n    }\n}"}
{"anchor": "int is_alphanum(char s)\n{\n    if (s >= '0' && s <= '9')\n    {\n        return 1;\n    }\n    else if (s >= 'a' && s <= 'z')\n    {\n        return 1;\n    }\n    else if (s >= 'A' && s <= 'Z')\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}", "positive": "To use library functions for checking character types\n\nint is_alphanum(char c)\n{\n   int result = 0;\n\n   if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))\n   {\n      result = 1;\n   }\n\n   return result;\n}", "function_type": 14, "negative": "int main(int argc, char **argv)\n{\n    if (argc == 1)\n    {\n        printf(\"Hello World!\\n\");\n    }\n    else\n    {\n        for (int i = 1; i < argc; i++)\n        {\n            printf(\"Hello %s!\\n\", argv[i]);\n        }\n    }\n    return 0;\n}"}
{"anchor": "int is_alphanum(char s)\n{\n    if (s >= '0' && s <= '9')\n    {\n        return 1;\n    }\n    else if (s >= 'a' && s <= 'z')\n    {\n        return 1;\n    }\n    else if (s >= 'A' && s <= 'Z')\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}", "positive": "c\nint is_alphanum(char c)\n{\n    int result = 0; // initialize as false (not alphanumeric character)\n    \n    char lower = c | ('x' ^ 'X');\n    if ((lower | 32) - 'a' < 26)\n    {\n        result = 1; // it was a letter => set to true\n    }\n    \n    if (c >= '0' && c <= '9')\n    {\n        result = 1; // number => set to true\n    }\n    \n    return result;\n}", "function_type": 14, "negative": "int check_alphabet(const char *str, const char *alphabet)\n{\n    if (alphabet == NULL || alphabet[0] == '\\0')\n    {\n        return 1;\n    }\n\n    for (int i = 0; alphabet[i] != '\\0'; i++)\n    {\n        int j = 0;\n        while (str[j] != '\\0' && str[j] != alphabet[i])\n        {\n            j++;\n        }\n        if (str[j] == '\\0')\n        {\n            return 0;\n        }\n    }\n    return 1;\n}"}
{"anchor": "void swap(int *tab, int i, int j)\n{\n    int temp = tab[i];\n    tab[i] = tab[j];\n    tab[j] = temp;\n}", "positive": "c\nvoid swap_refactor(int *tab, int i, int j)\n{\n    // Intermediate variable to hold value at index 'i' before swapping\n    int firstElementTempValue = tab[i]; \n    \n    // Swap values of elements at indices 'i' and 'j' in array\n    tab[i] = tab[j];                 \n    tab[j] = firstElementTempValue;  \n}", "function_type": 14, "negative": "void swap(int *array, int i, int j)\n{\n    int temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n}"}
{"anchor": "void swap(int *tab, int i, int j)\n{\n    int temp = tab[i];\n    tab[i] = tab[j];\n    tab[j] = temp;\n}", "positive": "c\nvoid swap(int *tab, int a, int b)\n{\n    int c = a;\n    a = b;\n    b = c;\n}", "function_type": 15, "negative": "void pointer_swap(int **a, int **b)\n{\n    int *temp = *a;\n    *a = *b;\n    *b = temp;\n}"}
{"anchor": "void swap(int *tab, int i, int j)\n{\n    int temp = tab[i];\n    tab[i] = tab[j];\n    tab[j] = temp;\n}", "positive": "c\nvoid swap(int *tab, int i, int j)\n{\n    // add an extra variable to hold a value of 'tab[i]' before swapping\n    int tempI = tab[i];\n    \n    // perform swapping\n    int tempJ = tab[j];\n    tab[j] = tempI;\n    tab[i] = tempJ;\n}", "function_type": 15, "negative": "static struct int_vector swap(struct int_vector vec, size_t i, size_t j)\n{\n    int temp = vec.data[i];\n    vec.data[i] = vec.data[j];\n    vec.data[j] = temp;\n    return vec;\n}"}
{"anchor": "void swap(int *tab, int i, int j)\n{\n    int temp = tab[i];\n    tab[i] = tab[j];\n    tab[j] = temp;\n}", "positive": "c\nvoid swapping(int *array, int index1, int index2)\n{\n    int holder = array[index1];\n    array[index1] = array[index2];\n    array[index2] = holder;\n}", "function_type": 15, "negative": "void insertion_sort(void **array, f_cmp comp)\n{\n    if (array != NULL && *array != NULL)\n    {\n        for (int i = 1; array[i] != NULL; i++)\n        {\n            int j = i;\n            while (j > 0 && comp(array[j - 1], array[j]) > 0)\n            {\n                void *temp = array[j];\n                array[j] = array[j - 1];\n                array[j - 1] = temp;\n                j--;\n            }\n        }\n    }\n}"}
{"anchor": "void pointer_swap(int **a, int **b)\n{\n    int *temp = *a;\n    *a = *b;\n    *b = temp;\n}", "positive": "c\nvoid array_swap(int* a[], int* b[])\n{\n    int* temp[] = a;\n    a = b;\n    b = temp;\n}", "function_type": 15, "negative": "void swap(int *tab, int i, int j)\n{\n    int temp = tab[i];\n    tab[i] = tab[j];\n    tab[j] = temp;\n}"}
{"anchor": "void pointer_swap(int **a, int **b)\n{\n    int *temp = *a;\n    *a = *b;\n    *b = temp;\n}", "positive": "c\nvoid refactor_pointer_swap(int ***a, int ***b)\n{\n    int **temp = *a;\n    *a = *b;\n    *b = temp;\n}", "function_type": 16, "negative": "void swap(int *array, int i, int j)\n{\n    int temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n}"}
{"anchor": "void pointer_swap(int **a, int **b)\n{\n    int *temp = *a;\n    *a = *b;\n    *b = temp;\n}", "positive": "c\nvoid pointer_swap(int **a, int **b)\n{\n    int **temp = a;\n    a = b;\n    b = temp;\n}", "function_type": 16, "negative": "static struct int_vector swap(struct int_vector vec, size_t i, size_t j)\n{\n    int temp = vec.data[i];\n    vec.data[i] = vec.data[j];\n    vec.data[j] = temp;\n    return vec;\n}"}
{"anchor": "void pointer_swap(int **a, int **b)\n{\n    int *temp = *a;\n    *a = *b;\n    *b = temp;\n}", "positive": "c\nvoid refactor_pointer_swap(int ***a, int ***b)\n{\n    int **temp = *a;\n    *a = *b;\n    *b = temp;\n}", "function_type": 16, "negative": "void str_revert(char str[])\n{\n    int end = 0;\n    while (str[end] != '\\0')\n    {\n        end += 1;\n    }\n    end -= 1;\n\n    int start = 0;\n\n    while (end > start)\n    {\n        char temp = str[end];\n        str[end] = str[start];\n        str[start] = temp;\n        end--;\n        start++;\n    }\n}"}
{"anchor": "size_t my_strlen(const char *s)\n{\n    if (s == NULL)\n    {\n        return 0;\n    }\n    else\n    {\n        size_t i = 0;\n        while (s[i] != '\\0')\n        {\n            i++;\n        }\n        return i;\n    }\n}", "positive": "c\nsize_t my_strlen(const char *s)\n{\n    if (s == NULL)\n    {\n        return 0;\n    }\n    \n    size_t len = 0; // add a new variable to store length of string\n\n    for (; s[len] != '\\0'; ++len); // loop through until end of string is found\n    \n    return len;\n}", "function_type": 16, "negative": "int my_memcmp(const void *s1, const void *s2, size_t num)\n{\n    const char *r1 = s1;\n    const char *r2 = s2;\n    size_t i = 0;\n    while (i < num && r1[i] == r2[i])\n    {\n        i++;\n    }\n    if (i == num)\n    {\n        return 0;\n    }\n    if (r1[i] < r2[i])\n    {\n        return -1;\n    }\n    else\n    {\n        return 1;\n    }\n}"}
{"anchor": "size_t my_strlen(const char *s)\n{\n    if (s == NULL)\n    {\n        return 0;\n    }\n    else\n    {\n        size_t i = 0;\n        while (s[i] != '\\0')\n        {\n            i++;\n        }\n        return i;\n    }\n}", "positive": "size_t new_function_name(const char *inputString)\n{\n    if (inputString == NULL) // If input string is null\n    {\n        return 0;  \n    }\n    else\n    {\n        size_t countOfCharacters = 0;  // Renaming 'i' to more descriptive name\n        while (inputString[countOfCharacters] != '\\0') // Renamed s to inputString and also increased readability by using a better variable name for indexing\n        {\n            countOfCharacters++;    \n        }\n        return countOfCharacters;\n    }\n}", "function_type": 17, "negative": "int coun(const char *file_out)\n{\n    FILE *f3 = fopen(file_out, \"r\");\n    int count = 0;\n    char *line3 = NULL;\n    size_t len3 = 0;\n    while (getline(&line3, &len3, f3) != -1)\n    {\n        count += 1;\n    }\n    free(line3);\n    fclose(f3);\n    return count;\n}"}
{"anchor": "size_t my_strlen(const char *s)\n{\n    if (s == NULL)\n    {\n        return 0;\n    }\n    else\n    {\n        size_t i = 0;\n        while (s[i] != '\\0')\n        {\n            i++;\n        }\n        return i;\n    }\n}", "positive": "c\nsize_t my_string_length(const char *inputString)\n{\n    if (inputString == NULL)\n    {\n        return 0;\n    }\n    else\n    {\n        size_t counter = 0;\n        while (inputString[counter] != '\\0')\n        {\n            counter++;\n        }\n        return counter;\n    }\n}", "function_type": 17, "negative": "int check_alphabet(const char *str, const char *alphabet)\n{\n    if (alphabet == NULL || alphabet[0] == '\\0')\n    {\n        return 1;\n    }\n\n    for (int i = 0; alphabet[i] != '\\0'; i++)\n    {\n        int j = 0;\n        while (str[j] != '\\0' && str[j] != alphabet[i])\n        {\n            j++;\n        }\n        if (str[j] == '\\0')\n        {\n            return 0;\n        }\n    }\n    return 1;\n}"}
{"anchor": "size_t my_strlen(const char *s)\n{\n    if (s == NULL)\n    {\n        return 0;\n    }\n    else\n    {\n        size_t i = 0;\n        while (s[i] != '\\0')\n        {\n            i++;\n        }\n        return i;\n    }\n}", "positive": "c\nsize_t my_strlen(const char *s)\n{\n    size_t len = 0;\n    \n    for (; s[len] != '\\0'; len++);\n\n    return len;\n}", "function_type": 17, "negative": "int present(const char *accept, char f)\n{\n    for (size_t i = 0; accept[i] != '\\0'; i++)\n    {\n        if (accept[i] == f)\n        {\n            return 1;\n        }\n    }\n    return 0;\n}"}
{"anchor": "size_t my_strlen(const char *s)\n{\n    if (s == NULL)\n    {\n        return 0;\n    }\n    else\n    {\n        size_t i = 0;\n        while (s[i] != '\\0')\n        {\n            i++;\n        }\n        return i;\n    }\n}", "positive": "size_t my_strlen(const char *start)\n{\n    const char *end = start; /* set end to point to first address */\n    \n    for (; *end != '\\0'; ++end); // empty body loop until null terminator is found\n  \n    return (size_t)(end - start); // calculate distance between two pointers and cast it as size_t type\n}", "function_type": 17, "negative": "int count_words(const char *file_in)\n{\n    FILE *r = fopen(file_in, \"r\");\n    int count = 0;\n    if (r == NULL)\n    {\n        return -1;\n    }\n    int bo = 0;\n    char c = fgetc(r);\n    while (c != -1)\n    {\n        if (c == ' ' || c == '\\n' || c == '\\t')\n        {\n            if (bo)\n                count += 1;\n            bo = 0;\n        }\n        else\n        {\n            bo = 1;\n        }\n        c = fgetc(r);\n    }\n    if (bo)\n        count += 1;\n    return count;\n}"}
{"anchor": "int present(const char *accept, char f)\n{\n    for (size_t i = 0; accept[i] != '\\0'; i++)\n    {\n        if (accept[i] == f)\n        {\n            return 1;\n        }\n    }\n    return 0;\n}", "positive": "int present(const char *accept, char f)\n{\n    const char* ptr = strchr(accept, f);\n    \n    if (ptr != NULL)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}", "function_type": 17, "negative": "int my_memcmp(const void *s1, const void *s2, size_t num)\n{\n    const char *r1 = s1;\n    const char *r2 = s2;\n    size_t i = 0;\n    while (i < num && r1[i] == r2[i])\n    {\n        i++;\n    }\n    if (i == num)\n    {\n        return 0;\n    }\n    if (r1[i] < r2[i])\n    {\n        return -1;\n    }\n    else\n    {\n        return 1;\n    }\n}"}
{"anchor": "int present(const char *accept, char f)\n{\n    for (size_t i = 0; accept[i] != '\\0'; i++)\n    {\n        if (accept[i] == f)\n        {\n            return 1;\n        }\n    }\n    return 0;\n}", "positive": "c\nint present(const char *accept, char f)\n{\n    int result = 0; // Intermediate variable to store the final value of the loop\n    \n    for (size_t i = 0; accept[i] != '\\0'; i++)\n    {\n        if (accept[i] == f)\n        {\n            result = 1;   // If found 'f' in 'accept', set 'result' to 1 and exit the loop\n            break;         // We can safely stop here because we have already found what we need\n        }\n    }\n\t\n    return result; // Return either 1 or 0 based on whether 'f' was found in 'accept'.\n}", "function_type": 18, "negative": "int coun(const char *file_out)\n{\n    FILE *f3 = fopen(file_out, \"r\");\n    int count = 0;\n    char *line3 = NULL;\n    size_t len3 = 0;\n    while (getline(&line3, &len3, f3) != -1)\n    {\n        count += 1;\n    }\n    free(line3);\n    fclose(f3);\n    return count;\n}"}
{"anchor": "int present(const char *accept, char f)\n{\n    for (size_t i = 0; accept[i] != '\\0'; i++)\n    {\n        if (accept[i] == f)\n        {\n            return 1;\n        }\n    }\n    return 0;\n}", "positive": "for size_t\n\nint present2(const char* start, const char* end, char c)\n{\n    const char* current = start;\n    \n    while (current != end)\n    {\n        if (*current == c)\n        {\n            return 1;\n        }\n        ++current;\n    }\n    \n    return 0;\n}", "function_type": 18, "negative": "size_t my_strlen(const char *s)\n{\n    if (s == NULL)\n    {\n        return 0;\n    }\n    else\n    {\n        size_t i = 0;\n        while (s[i] != '\\0')\n        {\n            i++;\n        }\n        return i;\n    }\n}"}
{"anchor": "int present(const char *accept, char f)\n{\n    for (size_t i = 0; accept[i] != '\\0'; i++)\n    {\n        if (accept[i] == f)\n        {\n            return 1;\n        }\n    }\n    return 0;\n}", "positive": "c\nint present(const char *accept, char f)\n{\n    size_t i;\n    int isPresent = 0; // Intermediate variable to store result\n    \n    for (i = 0; accept[i] != '\\0' && !isPresent; i++)\n    {\n        isPresent = (accept[i] == f);\n    }\n\t\n    return isPresent;\n}", "function_type": 18, "negative": "int count_words(const char *file_in)\n{\n    FILE *r = fopen(file_in, \"r\");\n    int count = 0;\n    if (r == NULL)\n    {\n        return -1;\n    }\n    int bo = 0;\n    char c = fgetc(r);\n    while (c != -1)\n    {\n        if (c == ' ' || c == '\\n' || c == '\\t')\n        {\n            if (bo)\n                count += 1;\n            bo = 0;\n        }\n        else\n        {\n            bo = 1;\n        }\n        c = fgetc(r);\n    }\n    if (bo)\n        count += 1;\n    return count;\n}"}
{"anchor": "int present(const char *accept, char f)\n{\n    for (size_t i = 0; accept[i] != '\\0'; i++)\n    {\n        if (accept[i] == f)\n        {\n            return 1;\n        }\n    }\n    return 0;\n}", "positive": "int present(const char *accept, char c)\n{\n    if (strchr(accept, c) != NULL)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}", "function_type": 18, "negative": "int append_file(const char *file_in, const char *content)\n{\n    if (content == NULL)\n    {\n        return -1;\n    }\n    FILE *f1 = fopen(file_in, \"a\");\n    if (f1 == NULL)\n    {\n        return -1;\n    }\n    fprintf(f1, \"%s\", content);\n    fclose(f1);\n    return 0;\n}"}
{"anchor": "void my_strlowcase(char *str)\n{\n    for (size_t i = 0; *(str + i); i++)\n    {\n        if (*(str + i) < 91 && *(str + i) > 64)\n        {\n            *(str + i) = *(str + i) + 32;\n        }\n    }\n}", "positive": "void my_strlowcase(const char *src, char *dest) \n{\n    while(*src) \n    {\n        *dest = tolower((unsigned char)*src);\n         src++;\n         dest++;\n     }\n     *dest = '\\0'; // Don't forget null terminator at end of string\n}\n```\nThis refactored version makes use of `tolower()` from ctype.h library which is safer as it handles all cases and edge conditions that can potentially cause issues with manual character comparisons in original code. It also takes care to null-terminate destination string after copying characters. The input strings are not modified in place but a new one is created. This approach follows the principle of immutability of data. If you want your function to mutate the existing string then do away with the second parameter completely, and just return str. Please note that this does assume that both source and destination strings have sufficient space allocated. Be careful when using these functions otherwise they may overwrite other important memory data.\n\nNote: When rewriting code to use standard libraries like ctype.h, be sure to understand how each function works first before applying them. Some functions behave differently or produce unexpected results on certain inputs. Always test thoroughly afterwards. In some languages there might be no built-in equivalent to what you need so", "function_type": 18, "negative": "int my_memcmp(const void *s1, const void *s2, size_t num)\n{\n    const char *r1 = s1;\n    const char *r2 = s2;\n    size_t i = 0;\n    while (i < num && r1[i] == r2[i])\n    {\n        i++;\n    }\n    if (i == num)\n    {\n        return 0;\n    }\n    if (r1[i] < r2[i])\n    {\n        return -1;\n    }\n    else\n    {\n        return 1;\n    }\n}"}
{"anchor": "void my_strlowcase(char *str)\n{\n    for (size_t i = 0; *(str + i); i++)\n    {\n        if (*(str + i) < 91 && *(str + i) > 64)\n        {\n            *(str + i) = *(str + i) + 32;\n        }\n    }\n}", "positive": "For isupper and tolower functions \n\nvoid refactor_my_strlowcase(char* str){\n   size_t i=0;\n   int upperCaseChecker = 0;\n   char lowerCasedChar;\n\n   while(*(str+i)){\n      \n      if((int)(*(str+i)) >= 65 && (int)(*(str+i)) <= 90 ){\n         upperCaseChecker = 1;\n      }else{\n         upperCaseChecker = 0;\n      }\n\n      if(upperCaseChecker == 1){\n          lowerCasedChar  = (char)((int)(*(str+i)) + 32 );\n          *(str+i) = lowerCasedChar ;\n      }\n    \n      i++;\n   }\n}", "function_type": 19, "negative": "void my_rol_crypt(void *data, size_t data_len, const void *key, size_t key_len)\n{\n    unsigned char *tem = data;\n    const unsigned char *te = key;\n    for (size_t i = 0; i < data_len; i++)\n    {\n        tem[i] = (tem[i] + te[i % key_len]) % 256;\n    }\n    data = tem;\n}"}
{"anchor": "void my_strlowcase(char *str)\n{\n    for (size_t i = 0; *(str + i); i++)\n    {\n        if (*(str + i) < 91 && *(str + i) > 64)\n        {\n            *(str + i) = *(str + i) + 32;\n        }\n    }\n}", "positive": "void refactor_my_strlowcase(const char* src, char* dest) \n{\n    while(*src != '\\0') \n    {\n        *dest = tolower((unsigned char)(*src));\n        src++;\n        dest++;\n    }\n    *dest = '\\0';  \n}", "function_type": 19, "negative": "void my_xor_crypt(void *data, size_t data_len, const void *key, size_t key_len)\n{\n    unsigned char *tem = data;\n    const unsigned char *te = key;\n    for (size_t i = 0; i < data_len; i++)\n    {\n        tem[i] = tem[i] ^ te[i % key_len];\n    }\n    data = tem;\n}"}
{"anchor": "void my_strlowcase(char *str)\n{\n    for (size_t i = 0; *(str + i); i++)\n    {\n        if (*(str + i) < 91 && *(str + i) > 64)\n        {\n            *(str + i) = *(str + i) + 32;\n        }\n    }\n}", "positive": "void refactor_my_strlowcase(const char* sourceString) \n{\n   int index;\n   const size_t lengthOfSourceString = strlen(sourceString);\n   char result[lengthOfSourceString+1]; // Plus one for null-termination\n\n   for(index=0 ; index <= lengthOfSourceString ; ++index ) \n   {\n      result[index] = tolower((unsigned char)sourceString[index]);\n   }\n\n   printf(\"%s\",result); // Printing modified string\n}", "function_type": 19, "negative": "size_t my_strlen(const char *s)\n{\n    if (s == NULL)\n    {\n        return 0;\n    }\n    else\n    {\n        size_t i = 0;\n        while (s[i] != '\\0')\n        {\n            i++;\n        }\n        return i;\n    }\n}"}
{"anchor": "int my_round(float n)\n{\n    int a = n;\n    if (n < 0)\n    {\n        if (a - n >= 0.5)\n        {\n            a -= 1;\n        }\n    }\n    else\n    {\n        if (a - n <= -0.5)\n        {\n            a += 1;\n        }\n    }\n    return a;\n}", "positive": "c\nint my_round(float n)\n{\n    float fpart, ipart;\n    // split into integer and fractional parts\n    fpart = modf(n, &ipart);\n    \n    // If fractional part is .5 or greater, round up (adding 1 to integer part). Else leave as it is.\n    if ((double)(fpart + 0.5) >= (double)n && n > 0)\n        ++ipart;\n      \n    // If fractional part is less than -.5 (-.49...), round down (subtracting one from integer part). Else leave as it is.\n    else if((double)(-fpart + .5) > (double)-n && n <= 0)\n        --ipart;\n  \n    return (int)ipart;\n}", "function_type": 19, "negative": "int int_sqrt(int n)\n{\n    if (n < 0)\n    {\n        return -1;\n    }\n    else\n    {\n        int i = 0;\n        while (i * i <= n)\n        {\n            i++;\n        }\n        return i - 1;\n    }\n}"}
{"anchor": "int my_round(float n)\n{\n    int a = n;\n    if (n < 0)\n    {\n        if (a - n >= 0.5)\n        {\n            a -= 1;\n        }\n    }\n    else\n    {\n        if (a - n <= -0.5)\n        {\n            a += 1;\n        }\n    }\n    return a;\n}", "positive": "c\nint my_round(float n)\n{\n    // Intermediate variable to store rounded result\n    float roundResult = 0.0f; \n    \n    // If number is less than zero subtract integer part from it and add one if decimal part is greater or equal to 0.5\n    if (n < 0)\n    {\n        roundResult = ((int)(n)) + ((n - (int)(n)) >= 0.5 ? 1 : 0);\n    }\n    // Otherwise just take the integer part of the number if its fractional part is smaller or equal to 0.5\n    else\n    {\n        roundResult = ((int)(n)) + ((n - (int)(n)) <= 0.5 ? 0 : 1);\n    }\n  \n    return (int)roundResult;\n}", "function_type": 20, "negative": "int my_pow(int a, int b)\n{\n    if (b == 0)\n    {\n        return 1;\n    }\n    else\n    {\n        int res = a;\n        int reste = 1;\n        while (b > 1)\n        {\n            if (b % 2 == 0)\n            {\n                res *= res;\n                b /= 2;\n            }\n            else\n            {\n                reste *= res;\n                res *= res;\n                b = (b - 1) / 2;\n            }\n        }\n        return res * reste;\n    }\n}"}
{"anchor": "char to_l(char c)\n{\n    if (c <= 'Z' && c >= 'A')\n    {\n        return c + 32;\n    }\n    else\n    {\n        return c;\n    }\n}", "positive": "c\nint convertToLowerCase(int characterCode)\n{\n    int result = characterCode;\n    \n    if ('A' <= characterCode && characterCode <= 'Z')\n    {\n        result += ('a' - 'A'); // shift lowercase by difference between upper and lower case alphabets\n    } \n        \n    return result;\n}", "function_type": 20, "negative": "int is_alphanum(char s)\n{\n    if (s >= '0' && s <= '9')\n    {\n        return 1;\n    }\n    else if (s >= 'a' && s <= 'z')\n    {\n        return 1;\n    }\n    else if (s >= 'A' && s <= 'Z')\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}"}
{"anchor": "char to_l(char c)\n{\n    if (c <= 'Z' && c >= 'A')\n    {\n        return c + 32;\n    }\n    else\n    {\n        return c;\n    }\n}", "positive": "c\nchar charToLowerCase(char character)\n{\n    if (character <= 'Z' && character >= 'A')\n    {\n        return character + 32;\n    }\n    else\n    {\n        return character;\n    }\n}", "function_type": 21, "negative": "int count_words(const char *file_in)\n{\n    FILE *r = fopen(file_in, \"r\");\n    int count = 0;\n    if (r == NULL)\n    {\n        return -1;\n    }\n    int bo = 0;\n    char c = fgetc(r);\n    while (c != -1)\n    {\n        if (c == ' ' || c == '\\n' || c == '\\t')\n        {\n            if (bo)\n                count += 1;\n            bo = 0;\n        }\n        else\n        {\n            bo = 1;\n        }\n        c = fgetc(r);\n    }\n    if (bo)\n        count += 1;\n    return count;\n}"}
{"anchor": "char to_l(char c)\n{\n    if (c <= 'Z' && c >= 'A')\n    {\n        return c + 32;\n    }\n    else\n    {\n        return c;\n    }\n}", "positive": "int toLowerCase(int ch) \n{\n   return tolower(ch);\n}", "function_type": 21, "negative": "int is_digit(char s)\n{\n    if (s >= '0' && s <= '9')\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}"}
{"anchor": "char to_l(char c)\n{\n    if (c <= 'Z' && c >= 'A')\n    {\n        return c + 32;\n    }\n    else\n    {\n        return c;\n    }\n}", "positive": "c\nchar to_l(char c)\n{\n    char result = c; // Intermediate variable to hold the final result\n    \n    if (c <= 'Z' && c >= 'A') \n    {\n        result = c + 32; // If character is uppercase, convert it into lowercase and assign to result\n    }\n  \n    return result; // Return the final result\n}", "function_type": 21, "negative": "int main(int argc, char **argv)\n{\n    if (argc == 1)\n    {\n        printf(\"Hello World!\\n\");\n    }\n    else\n    {\n        for (int i = 1; i < argc; i++)\n        {\n            printf(\"Hello %s!\\n\", argv[i]);\n        }\n    }\n    return 0;\n}"}
{"anchor": "void handler(int sig)\n{\n    d += 1;\n    if (sig == SIGUSR1)\n    {\n        printf(\"Received %d signals.\\n\", d);\n        fflush(stdout);\n    }\n    else if (sig == SIGUSR2)\n    {\n        printf(\"Current generation: %d\\n\", g);\n        fflush(stdout);\n    }\n    else if (sig == SIGTERM)\n    {\n        g++;\n        pid_t c = fork();\n        d = 0;\n        fflush(stdout);\n        if (c != 0)\n        {\n            exit(0);\n        }\n    }\n    else if (sig == SIGINT)\n    {\n        exit(0);\n    }\n}", "positive": "new var for count signals\n\nvoid handler(int sig)\n{\n    if (sig == SIGUSR1)\n    {\n        counter +=1 ;\n        printf(\"Received %d signals.\\n\", counter);\n        fflush(stdout);\n    }\n    else if (sig == SIGUSR2)\n    {\n        printf(\"Current generation: %d\\n\", generations);\n        fflush(stdout);\n    }\n    else if (sig == SIGTERM || sig == SIGINT )\n    {\n        generations ++;\n        \n        if(fork() == 0){  \n           counter = 0;     // reset counter in child process\n           exit(EXIT_SUCCESS);\n        }     \n      \n        exit(EXIT_FAILURE); // parent exits here\n    }\n}", "function_type": 21, "negative": "void sieve(int n)\n{\n    if (n > 2)\n    {\n        int res = 0;\n        char *list = calloc(n, 1);\n        for (long i = 2; i < n; i++)\n        {\n            if (list[i] == 0)\n            {\n                res++;\n                for (long j = i; j < n; j += i)\n                {\n                    list[j] = 1;\n                }\n            }\n        }\n        free(list);\n        printf(\"%d\\n\", res);\n    }\n}"}
{"anchor": "void handler(int sig)\n{\n    d += 1;\n    if (sig == SIGUSR1)\n    {\n        printf(\"Received %d signals.\\n\", d);\n        fflush(stdout);\n    }\n    else if (sig == SIGUSR2)\n    {\n        printf(\"Current generation: %d\\n\", g);\n        fflush(stdout);\n    }\n    else if (sig == SIGTERM)\n    {\n        g++;\n        pid_t c = fork();\n        d = 0;\n        fflush(stdout);\n        if (c != 0)\n        {\n            exit(0);\n        }\n    }\n    else if (sig == SIGINT)\n    {\n        exit(0);\n    }\n}", "positive": "these are to be declared as global variables\n\nvoid handler(int signum){\n   switch(signum){\n      case SIGUSR1 :\n         count+=1;\n\t     printf(\"\\n Received %d signals.\",count);\n\t     fflush(stdout);\n         break;\n      case SIGUSR2 :\n         printf(\"\\n Current Generation:%d \",gen);\n\t     fflush(stdout);\n         break;\n      case SIGTERM:\n          gen +=1;\n\t  count =0; \n          fflush(stdout);\n          if(fork()==0) exit(0);      \n         break;\n      case SIGINT:\n         exit(0);\n      default:\n         return;\n    }\n}", "function_type": 22, "negative": "void int_vector_print(const struct int_vector vec)\n{\n    for (size_t i = 0; i < vec.size; i++)\n    {\n        printf(\"%d\", vec.data[i]);\n        if (i + 1 != vec.size)\n        {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n}"}
{"anchor": "void handler(int sig)\n{\n    d += 1;\n    if (sig == SIGUSR1)\n    {\n        printf(\"Received %d signals.\\n\", d);\n        fflush(stdout);\n    }\n    else if (sig == SIGUSR2)\n    {\n        printf(\"Current generation: %d\\n\", g);\n        fflush(stdout);\n    }\n    else if (sig == SIGTERM)\n    {\n        g++;\n        pid_t c = fork();\n        d = 0;\n        fflush(stdout);\n        if (c != 0)\n        {\n            exit(0);\n        }\n    }\n    else if (sig == SIGINT)\n    {\n        exit(0);\n    }\n}", "positive": "Function called when signal is caught\nvoid handleSignal(int signum){\n    \n    switch(signum)\n    {\n       case SIGUSR1 :   // Increment counter and print its value\n           counter++;\n           printf(\"Received %d signals.\\n\", counter);\n\t   break;\n        \n       case SIGUSR2 :   // Print current generation number\n           printf(\"Current Generation: %d\\n\", generation);\n\t   break;\n        \n       case SIGTERM :   // Create new child process, increment gen., reset counter and terminate parent\n           generation++;\n           counter=0;\n           childPid = fork(); \n           if(childPid == 0){exit(EXIT_SUCCESS);} // Child Process Terminates here\n\t   break;\n        \n      case SIGINT :    // Normal termination", "function_type": 22, "negative": "void variant_display(const struct variant *e)\n{\n    if (e->type == TYPE_INT)\n        printf(\"%d\\n\", e->value.int_v);\n    if (e->type == TYPE_FLOAT)\n        printf(\"%f\\n\", e->value.float_v);\n    if (e->type == TYPE_CHAR)\n        printf(\"%c\\n\", e->value.char_v);\n    if (e->type == TYPE_STRING)\n        printf(\"%s\\n\", e->value.str_v);\n}"}
{"anchor": "void handler(int sig)\n{\n    d += 1;\n    if (sig == SIGUSR1)\n    {\n        printf(\"Received %d signals.\\n\", d);\n        fflush(stdout);\n    }\n    else if (sig == SIGUSR2)\n    {\n        printf(\"Current generation: %d\\n\", g);\n        fflush(stdout);\n    }\n    else if (sig == SIGTERM)\n    {\n        g++;\n        pid_t c = fork();\n        d = 0;\n        fflush(stdout);\n        if (c != 0)\n        {\n            exit(0);\n        }\n    }\n    else if (sig == SIGINT)\n    {\n        exit(0);\n    }\n}", "positive": "global variable to store current generation number\n\nvoid signalHandler(int signum) \n{\n    switch (signum)\n    {\n      case SIGUSR1: \n        count++;  \n        printf(\"Received %d signals.\\n\", count);\n        break;\n      \n      case SIGUSR2: \n        printf(\"Current generation: %d\\n\", generation); \n        break;\n        \n      case SIGTERM: \n        generation++; \n        pid_t childPid = fork();\n        count = 0;    \n        if (!childPid) \n          exit(0);\n        break;\n          \n      case SIGINT: \n        exit(0);\n    }\n}", "function_type": 22, "negative": "void print_complex(struct complex a)\n{\n    if (a.img < 0)\n    {\n        printf(\"complex(%1.2f - %1.2fi)\\n\", a.real, a.img * (-1));\n    }\n    else\n    {\n        printf(\"complex(%1.2f + %1.2fi)\\n\", a.real, a.img);\n    }\n}"}
{"anchor": "void handler(int sig)\n{\n    d += 1;\n    if (sig == SIGUSR1)\n    {\n        printf(\"Received %d signals.\\n\", d);\n        fflush(stdout);\n    }\n    else if (sig == SIGUSR2)\n    {\n        printf(\"Current generation: %d\\n\", g);\n        fflush(stdout);\n    }\n    else if (sig == SIGTERM)\n    {\n        g++;\n        pid_t c = fork();\n        d = 0;\n        fflush(stdout);\n        if (c != 0)\n        {\n            exit(0);\n        }\n    }\n    else if (sig == SIGINT)\n    {\n        exit(0);\n    }\n}", "positive": "c\nvoid handleSignal(int sig, int *count, int *generation)\n{\n    switch (sig)\n    {\n        case SIGUSR1:\n            ++*count;\n            printf(\"Received %d signals.\\n\", *count);\n            break;\n        \n        case SIGUSR2:\n            printf(\"Current generation: %d\\n\", *generation);\n            break;\n        \n        case SIGTERM:\n            ++*generation;\n            *count = 0;\n            if (!fork())  // child process\n                exit(0);\n            break;\n        \n        case SIGINT:\n            exit(0);\n    \n        default:\n            return;   // ignore other signal numbers\n    }\n    fflush(stdout);\n}", "function_type": 22, "negative": "void p_rec(const struct heap *heap, size_t i)\n{\n    printf(\" %d\", heap->array[i]);\n    if (i * 2 + 1 < heap->size)\n    {\n        p_rec(heap, i * 2 + 1);\n    }\n    if (i * 2 + 2 < heap->size)\n    {\n        p_rec(heap, i * 2 + 2);\n    }\n}"}
{"anchor": "int my_pow(int a, int b)\n{\n    if (b == 0)\n    {\n        return 1;\n    }\n    else\n    {\n        int res = a;\n        int reste = 1;\n        while (b > 1)\n        {\n            if (b % 2 == 0)\n            {\n                res *= res;\n                b /= 2;\n            }\n            else\n            {\n                reste *= res;\n                res *= res;\n                b = (b - 1) / 2;\n            }\n        }\n        return res * reste;\n    }\n}", "positive": "c\nint my_pow(int base, int exponent)\n{\n    if (exponent == 0)\n    {\n        return 1;\n    }\n    else\n    {\n        int result = base;\n        int remainder = 1;\n        while (exponent > 1)\n        {\n            if ((exponent & 1) == 0) // Equivalent to `b % 2 == 0`\n            {\n                result *= result;\n                exponent >>= 1; // Equivalent to `b /= 2`\n            }\n            else\n            {\n                remainder *= result;\n                result *= result;\n                exponent = (exponent - 1) >> 1; // Equivalent to `(b - 1) / 2`\n            }\n        }\n        return result * remainder;\n    }\n}", "function_type": 22, "negative": "int int_sqrt(int n)\n{\n    if (n < 0)\n    {\n        return -1;\n    }\n    else\n    {\n        int i = 0;\n        while (i * i <= n)\n        {\n            i++;\n        }\n        return i - 1;\n    }\n}"}
{"anchor": "int my_pow(int a, int b)\n{\n    if (b == 0)\n    {\n        return 1;\n    }\n    else\n    {\n        int res = a;\n        int reste = 1;\n        while (b > 1)\n        {\n            if (b % 2 == 0)\n            {\n                res *= res;\n                b /= 2;\n            }\n            else\n            {\n                reste *= res;\n                res *= res;\n                b = (b - 1) / 2;\n            }\n        }\n        return res * reste;\n    }\n}", "positive": "c\nint pow_func(int base, int exponent)\n{\n    if (exponent == 0)\n    {\n        return 1;\n    }\n    else\n    {\n        int result = base;\n        int remainder = 1;\n        while (exponent > 1)\n        {\n            if (exponent % 2 == 0)\n            {\n                result *= result;\n                exponent /= 2;\n            }\n            else\n            {\n                remainder *= result;\n                result *= result;\n                exponent = (exponent - 1) / 2;\n            }\n        }\n        return result * remainder;\n    }\n}", "function_type": 23, "negative": "int my_round(float n)\n{\n    int a = n;\n    if (n < 0)\n    {\n        if (a - n >= 0.5)\n        {\n            a -= 1;\n        }\n    }\n    else\n    {\n        if (a - n <= -0.5)\n        {\n            a += 1;\n        }\n    }\n    return a;\n}"}
{"anchor": "int my_pow(int a, int b)\n{\n    if (b == 0)\n    {\n        return 1;\n    }\n    else\n    {\n        int res = a;\n        int reste = 1;\n        while (b > 1)\n        {\n            if (b % 2 == 0)\n            {\n                res *= res;\n                b /= 2;\n            }\n            else\n            {\n                reste *= res;\n                res *= res;\n                b = (b - 1) / 2;\n            }\n        }\n        return res * reste;\n    }\n}", "positive": "c\nint my_pow(int a, int b)\n{\n    if (b == 0)\n    {\n        return 1;\n    }\n    else\n    {\n        int* res = &a;\n        int reste = 1;\n        int* tempRes;\n        for (; b > 1; b /= 2)\n        {\n            if (b % 2 == 0)\n            {\n                (*res) = (*res)*(*res); // res is a pointer to a variable here\n                continue;\n            }\n            \n            tempRes = malloc(sizeof(*res));// allocating memory for temporary result\n            (*tempRes) = (*res)*(*res);   // squaring current value\n            reste *= (*res);               // updating reste with last calculated square\n          \n            res = tempRes;                 // assigning address of new allocated space to 'res'\n            b--;                           // decrement by one as we are doing an extra calculation\n        }\n        \n        int finalResult = (*res)*reste;   // calculating final result with last computed squares and restes\n        free(tempRes);                    // de-allocate memory that was used for intermediate computations\n      \n        return finalResult;\n    }\n}", "function_type": 23, "negative": "unsigned int greatest_divisor(unsigned int n)\n{\n    unsigned int res = 2;\n    while (n % res != 0 && res * res <= n)\n    {\n        res += 1;\n    }\n    if (n % res == 0)\n    {\n        return n / res;\n    }\n    else\n    {\n        return 1;\n    }\n}"}
{"anchor": "int my_pow(int a, int b)\n{\n    if (b == 0)\n    {\n        return 1;\n    }\n    else\n    {\n        int res = a;\n        int reste = 1;\n        while (b > 1)\n        {\n            if (b % 2 == 0)\n            {\n                res *= res;\n                b /= 2;\n            }\n            else\n            {\n                reste *= res;\n                res *= res;\n                b = (b - 1) / 2;\n            }\n        }\n        return res * reste;\n    }\n}", "positive": "int my_pow(int a, int b)\n{\n    if (b == 0)\n    {\n        return 1;\n    }\n    else\n    {\n        int res = a;\n        int reste = 1;\n        while (b > 1)\n        {\n            if (b % 2 == 0)\n            {\n                res *= res;\n                b /= 2;\n            }\n            else\n            {\n                reste *= res;\n                res *= res;\n                b = (b - 1) / 2;\n            }\n        }\n        return res * reste;\n    }\n}", "function_type": 23, "negative": "int is_alphanum(char s)\n{\n    if (s >= '0' && s <= '9')\n    {\n        return 1;\n    }\n    else if (s >= 'a' && s <= 'z')\n    {\n        return 1;\n    }\n    else if (s >= 'A' && s <= 'Z')\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}"}
{"anchor": "int my_pow(int a, int b)\n{\n    if (b == 0)\n    {\n        return 1;\n    }\n    else\n    {\n        int res = a;\n        int reste = 1;\n        while (b > 1)\n        {\n            if (b % 2 == 0)\n            {\n                res *= res;\n                b /= 2;\n            }\n            else\n            {\n                reste *= res;\n                res *= res;\n                b = (b - 1) / 2;\n            }\n        }\n        return res * reste;\n    }\n}", "positive": "c\nvoid square_and_divide(int* a, int* b, int* out_res){\n    (*out_res) = (*a);\n    (*a) *= (*a);\n    (*b) /= 2;\n}", "function_type": 23, "negative": "int main(int argc, char **argv)\n{\n    if (argc == 1)\n    {\n        printf(\"Hello World!\\n\");\n    }\n    else\n    {\n        for (int i = 1; i < argc; i++)\n        {\n            printf(\"Hello %s!\\n\", argv[i]);\n        }\n    }\n    return 0;\n}"}
{"anchor": "int my_memcmp(const void *s1, const void *s2, size_t num)\n{\n    const char *r1 = s1;\n    const char *r2 = s2;\n    size_t i = 0;\n    while (i < num && r1[i] == r2[i])\n    {\n        i++;\n    }\n    if (i == num)\n    {\n        return 0;\n    }\n    if (r1[i] < r2[i])\n    {\n        return -1;\n    }\n    else\n    {\n        return 1;\n    }\n}", "positive": "c\nint my_compare(const void *source1, const void *source2, size_t count)\n{\n    const unsigned char *pointer1 = source1;\n    const unsigned char *pointer2 = source2;\n    size_t index = 0;\n    \n    for (; index < count && pointer1[index] == pointer2[index]; ++index);\n        \n    if (index == count)\n    {\n        return 0;\n    }\n    else if (pointer1[index] < pointer2[index])\n    {\n        return -1;\n    }\n    else\n    {\n        return 1;\n    }\n}", "function_type": 23, "negative": "size_t my_strlen(const char *s)\n{\n    if (s == NULL)\n    {\n        return 0;\n    }\n    else\n    {\n        size_t i = 0;\n        while (s[i] != '\\0')\n        {\n            i++;\n        }\n        return i;\n    }\n}"}
{"anchor": "int my_memcmp(const void *s1, const void *s2, size_t num)\n{\n    const char *r1 = s1;\n    const char *r2 = s2;\n    size_t i = 0;\n    while (i < num && r1[i] == r2[i])\n    {\n        i++;\n    }\n    if (i == num)\n    {\n        return 0;\n    }\n    if (r1[i] < r2[i])\n    {\n        return -1;\n    }\n    else\n    {\n        return 1;\n    }\n}", "positive": "for size_t declaration\n\nint my_memcmp(const void* s1, const void* s2, size_t num){\n    \n    const unsigned char* ptr1 = (unsigned const char*) s1;\n    const unsigned char* ptr2 = (unsigned const char*) s2;\n  \n    for(size_t i=0; i<num ; ++i ){\n        \n        /* If characters are not equal */\n        if (*ptr1 != *ptr2) {\n            \n            /* Return result based on comparison of unsigned chars */\n            return ((*ptr1 > *ptr2) ? 1 : -1); \n        }\n      \n        /* Move pointers forward */\n        ptr1++;\n        ptr2++;\n    }\n\n    /* Arrays are identical up to 'num' elements */\n    return 0;\n}", "function_type": 24, "negative": "int present(const char *accept, char f)\n{\n    for (size_t i = 0; accept[i] != '\\0'; i++)\n    {\n        if (accept[i] == f)\n        {\n            return 1;\n        }\n    }\n    return 0;\n}"}
{"anchor": "int my_memcmp(const void *s1, const void *s2, size_t num)\n{\n    const char *r1 = s1;\n    const char *r2 = s2;\n    size_t i = 0;\n    while (i < num && r1[i] == r2[i])\n    {\n        i++;\n    }\n    if (i == num)\n    {\n        return 0;\n    }\n    if (r1[i] < r2[i])\n    {\n        return -1;\n    }\n    else\n    {\n        return 1;\n    }\n}", "positive": "c\nint better_name_for_my_function(const void *first_arg, const void *second_arg, size_t count)\n{\n    const char *first_string = first_arg;\n    const char *second_string = second_arg;\n    size_t index = 0;\n    \n    while (index < count && first_string[index] == second_string[index])\n    {\n        index++;\n    }\n    \n    if (index == count)\n    {\n        return 0;\n    }\n    \n    if (first_string[index] < second_string[index])\n    {\n        return -1;\n    }\n    else\n    {\n        return 1;\n    }\n}", "function_type": 24, "negative": "int coun(const char *file_out)\n{\n    FILE *f3 = fopen(file_out, \"r\");\n    int count = 0;\n    char *line3 = NULL;\n    size_t len3 = 0;\n    while (getline(&line3, &len3, f3) != -1)\n    {\n        count += 1;\n    }\n    free(line3);\n    fclose(f3);\n    return count;\n}"}
{"anchor": "int my_memcmp(const void *s1, const void *s2, size_t num)\n{\n    const char *r1 = s1;\n    const char *r2 = s2;\n    size_t i = 0;\n    while (i < num && r1[i] == r2[i])\n    {\n        i++;\n    }\n    if (i == num)\n    {\n        return 0;\n    }\n    if (r1[i] < r2[i])\n    {\n        return -1;\n    }\n    else\n    {\n        return 1;\n    }\n}", "positive": "c\nint my_memcmp(const void *s1, const void *s2, size_t num)\n{\n    const unsigned char *p1 = s1;\n    const unsigned char *p2 = s2;\n    for (; num > 0 && *p1 == *p2 ; num--, p1++, p2++); //loop until not all bytes are equal or there is nothing to compare left\n    \n    return (num == 0) ? 0 : (*p1 < *p2) ? -1 : 1; //check if we've compared every byte and then decide on final result\n}\n```\n\nThis refactor removes redundant assignment operations in the original implementation, simplifies the decision making logic by removing unnecessary checks of `i` variable, makes use of a more readable for loop statement. It also uses typecasting to avoid warnings related with comparing signed and unsigned values.\nNote that the decrement operation inside the condition was moved outside, as it does not affect the outcome of the comparison but rather determines when the loop should terminate.\nThe new line of code will be equivalent to the old one only when input parameters fit into the memory without any overflow.\n\n*PS: The initial given code assumes correct inputs.*\n\n---\n\nCredit: [@ninja-java](https://github.com/ninja-java)", "function_type": 24, "negative": "int count_words(const char *file_in)\n{\n    FILE *r = fopen(file_in, \"r\");\n    int count = 0;\n    if (r == NULL)\n    {\n        return -1;\n    }\n    int bo = 0;\n    char c = fgetc(r);\n    while (c != -1)\n    {\n        if (c == ' ' || c == '\\n' || c == '\\t')\n        {\n            if (bo)\n                count += 1;\n            bo = 0;\n        }\n        else\n        {\n            bo = 1;\n        }\n        c = fgetc(r);\n    }\n    if (bo)\n        count += 1;\n    return count;\n}"}
{"anchor": "int my_memcmp(const void *s1, const void *s2, size_t num)\n{\n    const char *r1 = s1;\n    const char *r2 = s2;\n    size_t i = 0;\n    while (i < num && r1[i] == r2[i])\n    {\n        i++;\n    }\n    if (i == num)\n    {\n        return 0;\n    }\n    if (r1[i] < r2[i])\n    {\n        return -1;\n    }\n    else\n    {\n        return 1;\n    }\n}", "positive": "c\nint my_memcmp(const void *s1, const void *s2, size_t num)\n{\n    const unsigned char* ptr1 = (const unsigned char*)s1; // cast to unsigned type for correct comparison\n    const unsigned char* ptr2 = (const unsigned char*)s2;\n    \n    size_t count = 0;\n\n    while ((count < num) && (*ptr1 == *ptr2))  \n    {\n        ++ptr1;\n        ++ptr2;\n        ++count;\n    }\n\n    if (count == num)\n    {\n        return 0;\n    }\n      \n    if (*ptr1 < *ptr2)\n    {\n        return -1;\n    }\n    else\n    {\n        return 1;\n    }\n}", "function_type": 24, "negative": "void my_xor_crypt(void *data, size_t data_len, const void *key, size_t key_len)\n{\n    unsigned char *tem = data;\n    const unsigned char *te = key;\n    for (size_t i = 0; i < data_len; i++)\n    {\n        tem[i] = tem[i] ^ te[i % key_len];\n    }\n    data = tem;\n}"}
{"anchor": "int is_digit(char s)\n{\n    if (s >= '0' && s <= '9')\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}", "positive": "c\nint is_digit(char s)\n{\n    int result = 0;\n    \n    for (int i=0; i<10; ++i){\n        if ((char)(48 + i) == s){\n            result = 1;\n            break;\n        }\n    }\n        \n   while(!result && *someIterator++ != '\\0'){\n       if (*someIterator == s) {\n           result = 1;\n       }\n   }\n    \n    return result;\n}", "function_type": 24, "negative": "int is_alphanum(char s)\n{\n    if (s >= '0' && s <= '9')\n    {\n        return 1;\n    }\n    else if (s >= 'a' && s <= 'z')\n    {\n        return 1;\n    }\n    else if (s >= 'A' && s <= 'Z')\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}"}
{"anchor": "int is_digit(char s)\n{\n    if (s >= '0' && s <= '9')\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}", "positive": "int is_digit(char c){\n    return isdigit(c);\n}", "function_type": 25, "negative": "int int_sqrt(int n)\n{\n    if (n < 0)\n    {\n        return -1;\n    }\n    else\n    {\n        int i = 0;\n        while (i * i <= n)\n        {\n            i++;\n        }\n        return i - 1;\n    }\n}"}
{"anchor": "int is_digit(char s)\n{\n    if (s >= '0' && s <= '9')\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}", "positive": "c\nint is_digit(const char *s)\n{\n    if (*s >= '0' && *s <= '9')\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}", "function_type": 25, "negative": "unsigned int digit(int n, int k)\n{\n    if (n <= 0 || k <= 0)\n    {\n        return 0;\n    }\n    else\n    {\n        while (k != 1)\n        {\n            n = n / 10;\n            k--;\n        }\n        return n % 10;\n    }\n}"}
{"anchor": "int is_digit(char s)\n{\n    if (s >= '0' && s <= '9')\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}", "positive": "c\nbool isDigit(char symbol)\n{\n    if ((symbol >= '0') && (symbol <= '9'))\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}", "function_type": 25, "negative": "int my_memcmp(const void *s1, const void *s2, size_t num)\n{\n    const char *r1 = s1;\n    const char *r2 = s2;\n    size_t i = 0;\n    while (i < num && r1[i] == r2[i])\n    {\n        i++;\n    }\n    if (i == num)\n    {\n        return 0;\n    }\n    if (r1[i] < r2[i])\n    {\n        return -1;\n    }\n    else\n    {\n        return 1;\n    }\n}"}
{"anchor": "int is_digit(char s)\n{\n    if (s >= '0' && s <= '9')\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}", "positive": "c\nint is_digit(char s)\n{\n    int result = 0; // Initialize as false by default\n    \n    if (s >= '0' && s <= '9')\n    {\n        result = 1; // Set to true if character is a digit\n    }\n    \n    return result;\n}", "function_type": 25, "negative": "int main(int argc, char **argv)\n{\n    if (argc == 1)\n    {\n        printf(\"Hello World!\\n\");\n    }\n    else\n    {\n        for (int i = 1; i < argc; i++)\n        {\n            printf(\"Hello %s!\\n\", argv[i]);\n        }\n    }\n    return 0;\n}"}
{"anchor": "int reverse_content(const char *file_in, const char *file_out)\n{\n    FILE *f1 = fopen(file_in, \"r\");\n    if (f1 == NULL)\n    {\n        return -1;\n    }\n    FILE *f2 = fopen(file_out, \"w\");\n    if (f1 == NULL)\n    {\n        fclose(f2);\n        return -1;\n    }\n    int c = fseek(f1, -1, 2);\n    while (c != -1)\n    {\n        int s = fgetc(f1);\n        fputc(s, f2);\n        c = fseek(f1, -2, 1);\n    }\n    fclose(f1);\n    fclose(f2);\n    return 0;\n}", "positive": "int reverse_content(const char *file_in, const char *file_out)\n{\n    FILE *f1 = fopen(file_in, \"r\");\n    if (f1 == NULL)\n    {\n        return -1;\n    }\n    FILE *f2 = fopen(file_out, \"w\");\n    if (f1 == NULL)\n    {\n        fclose(f2);\n        return -1;\n    }\n    int c = fseek(f1, -1, 2);\n    while (c != -1)\n    {\n        int s = fgetc(f1);\n        fputc(s, f2);\n        c = fseek(f1, -2, 1);\n    }\n    fclose(f1);\n    fclose(f2);\n    return 0;\n}", "function_type": 25, "negative": "int append_file(const char *file_in, const char *content)\n{\n    if (content == NULL)\n    {\n        return -1;\n    }\n    FILE *f1 = fopen(file_in, \"a\");\n    if (f1 == NULL)\n    {\n        return -1;\n    }\n    fprintf(f1, \"%s\", content);\n    fclose(f1);\n    return 0;\n}"}
{"anchor": "int reverse_content(const char *file_in, const char *file_out)\n{\n    FILE *f1 = fopen(file_in, \"r\");\n    if (f1 == NULL)\n    {\n        return -1;\n    }\n    FILE *f2 = fopen(file_out, \"w\");\n    if (f1 == NULL)\n    {\n        fclose(f2);\n        return -1;\n    }\n    int c = fseek(f1, -1, 2);\n    while (c != -1)\n    {\n        int s = fgetc(f1);\n        fputc(s, f2);\n        c = fseek(f1, -2, 1);\n    }\n    fclose(f1);\n    fclose(f2);\n    return 0;\n}", "positive": "int rewriteContent(const char* inputFileName, const char* outputFileName){\n    \n    // Renamed 'f1' to 'inputFile', opened for reading mode ('r')\n    FILE* inputFile = fopen(inputFileName,\"r\");  \n    if(inputFile==NULL){\n        return -1;       /* Failed to open file */\n    }                   \n                      \n    // Renamed 'f2' to 'outputFile', opened in write mode ('w')\n    FILE* outputFile = fopen(outputFileName,\"w\");  \n    if(outputFile==NULL){             \n        fclose(outputFile);          /* Close the file first before returning */\n        return -1;                   /* File opening failed */\n    }                                                 \n        \n    // 'c' renamed to 'positionIndicator'\n    int positionIndicator = fseek(inputFile,-1,SEEK_END);     \n    while(positionIndicator != -1){          \n        int currentCharacter = fgetc(inputFile);            \n        fputc(currentCharacter,outputFile);              \n        // Set next character as end of file pointer.\n        positionIndicator", "function_type": 26, "negative": "int coun(const char *file_out)\n{\n    FILE *f3 = fopen(file_out, \"r\");\n    int count = 0;\n    char *line3 = NULL;\n    size_t len3 = 0;\n    while (getline(&line3, &len3, f3) != -1)\n    {\n        count += 1;\n    }\n    free(line3);\n    fclose(f3);\n    return count;\n}"}
{"anchor": "int reverse_content(const char *file_in, const char *file_out)\n{\n    FILE *f1 = fopen(file_in, \"r\");\n    if (f1 == NULL)\n    {\n        return -1;\n    }\n    FILE *f2 = fopen(file_out, \"w\");\n    if (f1 == NULL)\n    {\n        fclose(f2);\n        return -1;\n    }\n    int c = fseek(f1, -1, 2);\n    while (c != -1)\n    {\n        int s = fgetc(f1);\n        fputc(s, f2);\n        c = fseek(f1, -2, 1);\n    }\n    fclose(f1);\n    fclose(f2);\n    return 0;\n}", "positive": "int reverse_content(const char *file_in, const char *file_out)\n{\n    FILE *f1 = fopen(file_in, \"r\");\n    if (f1 == NULL)\n    {\n        return -1;\n    }\n    FILE *f2 = fopen(file_out, \"w\");\n    if (f1 == NULL)\n    {\n        fclose(f2);\n        return -1;\n    }\n    int c = fseek(f1, -1, 2);\n    while (c != -1)\n    {\n        int s = fgetc(f1);\n        fputc(s, f2);\n        c = fseek(f1, -2, 1);\n    }\n    fclose(f1);\n    fclose(f2);\n    return 0;\n}", "function_type": 26, "negative": "int count_words(const char *file_in)\n{\n    FILE *r = fopen(file_in, \"r\");\n    int count = 0;\n    if (r == NULL)\n    {\n        return -1;\n    }\n    int bo = 0;\n    char c = fgetc(r);\n    while (c != -1)\n    {\n        if (c == ' ' || c == '\\n' || c == '\\t')\n        {\n            if (bo)\n                count += 1;\n            bo = 0;\n        }\n        else\n        {\n            bo = 1;\n        }\n        c = fgetc(r);\n    }\n    if (bo)\n        count += 1;\n    return count;\n}"}
{"anchor": "int reverse_content(const char *file_in, const char *file_out)\n{\n    FILE *f1 = fopen(file_in, \"r\");\n    if (f1 == NULL)\n    {\n        return -1;\n    }\n    FILE *f2 = fopen(file_out, \"w\");\n    if (f1 == NULL)\n    {\n        fclose(f2);\n        return -1;\n    }\n    int c = fseek(f1, -1, 2);\n    while (c != -1)\n    {\n        int s = fgetc(f1);\n        fputc(s, f2);\n        c = fseek(f1, -2, 1);\n    }\n    fclose(f1);\n    fclose(f2);\n    return 0;\n}", "positive": "c\nvoid readFileToArray(FILE* fileIn, char** arrayOut, long size){\n    for(long i = 0; i < size && !feof(fileIn); ++i){\n        (*arrayOut)[size-i] = getc(fileIn);\n    }\n}", "function_type": 26, "negative": "int check_alphabet(const char *str, const char *alphabet)\n{\n    if (alphabet == NULL || alphabet[0] == '\\0')\n    {\n        return 1;\n    }\n\n    for (int i = 0; alphabet[i] != '\\0'; i++)\n    {\n        int j = 0;\n        while (str[j] != '\\0' && str[j] != alphabet[i])\n        {\n            j++;\n        }\n        if (str[j] == '\\0')\n        {\n            return 0;\n        }\n    }\n    return 1;\n}"}
{"anchor": "int my_abs(int n)\n{\n    return (n < 0) ? -n : n;\n}", "positive": "int my_abs(int n) {\n  if (n < 0)\n      while (1) {\n          // This is just to avoid a warning about empty loops in some compilers\n          int zero = 0;\n          ++zero;\n          break;\n       }\n  else\n     return n;\n  \n  return abs(n);\n}", "function_type": 26, "negative": "int my_round(float n)\n{\n    int a = n;\n    if (n < 0)\n    {\n        if (a - n >= 0.5)\n        {\n            a -= 1;\n        }\n    }\n    else\n    {\n        if (a - n <= -0.5)\n        {\n            a += 1;\n        }\n    }\n    return a;\n}"}
{"anchor": "int my_abs(int n)\n{\n    return (n < 0) ? -n : n;\n}", "positive": "c\nint computeAbsoluteValue(int number)\n{\n    return (number < 0) ? -number : number;\n}", "function_type": 27, "negative": "int int_sqrt(int n)\n{\n    if (n < 0)\n    {\n        return -1;\n    }\n    else\n    {\n        int i = 0;\n        while (i * i <= n)\n        {\n            i++;\n        }\n        return i - 1;\n    }\n}"}
{"anchor": "int my_abs(int n)\n{\n    return (n < 0) ? -n : n;\n}", "positive": "c\nint my_abs(const int* ptr_to_number)\n{\n    return (*ptr_to_number < 0) ? -(*ptr_to_number) : *ptr_to_number;\n}", "function_type": 27, "negative": "int int_palindrome(int n)\n{\n    if (n < 0)\n    {\n        return 0;\n    }\n    if (n < 10)\n    {\n        return 1;\n    }\n\n    int fin = 1;\n    int cop = n;\n    while (cop > 10)\n    {\n        cop = cop / 10;\n        fin = fin * 10;\n    }\n    int deb = 1;\n    while (fin > deb && (n / fin) % 10 == (n / deb) % 10)\n    {\n        deb = deb * 10;\n        fin = fin / 10;\n    }\n    return fin <= deb;\n}"}
{"anchor": "int my_abs(int n)\n{\n    return (n < 0) ? -n : n;\n}", "positive": "function prototype\n\nint main() {\n   const int n = -5; \n   printf(\"%d\\n\", abs_val(&n)); \n   return 0;\n}", "function_type": 27, "negative": "int my_memcmp(const void *s1, const void *s2, size_t num)\n{\n    const char *r1 = s1;\n    const char *r2 = s2;\n    size_t i = 0;\n    while (i < num && r1[i] == r2[i])\n    {\n        i++;\n    }\n    if (i == num)\n    {\n        return 0;\n    }\n    if (r1[i] < r2[i])\n    {\n        return -1;\n    }\n    else\n    {\n        return 1;\n    }\n}"}
{"anchor": "void rec(char **map, int t[2], int i, int j)\n{\n    map[i][j] = '#';\n    if (i < t[0] && map[i + 1][j] == '.')\n    {\n        rec(map, t, i + 1, j);\n    }\n    if (i > 0 && map[i - 1][j] == '.')\n    {\n        rec(map, t, i - 1, j);\n    }\n    if (j < t[1] && map[i][j + 1] == '.')\n    {\n        rec(map, t, i, j + 1);\n    }\n    if (j > 0 && map[i][j - 1] == '.')\n    {\n        rec(map, t, i, j - 1);\n    }\n}", "positive": "c\nstatic void recurse_on_map(int x, int y, char **map, int n, int m)\n{\n    if ((x < 0 || x >= n) || (y < 0 || y >= m)) // check for bounds\n        return;\n        \n    if (map[x][y] != '.')  // non-dot characters aren't traversable\n        return;\n    \n    map[x][y] = '#';       // mark as visited\n  \n    /* Recursively call on all four directions */\n    recurse_on_map(x+1, y, map, n, m);\n    recurse_on_map(x-1, y, map, n, m);\n    recurse_on_map(x, y+1, map, n, m);\n    recurse_on_map(x, y-1, map, n, m);\n}\n\nvoid rec(char **map, int n, int m)\n{\n    recurse_on_map(0, 0, map, n, m);\n}\n```\nThis refactor separates out `n` and `m` from `t` array into separate arguments to avoid confusion. Additionally, it also moves declaration of helper recursive function outside main `rec()` function to improve readability.\nAlso", "function_type": 27, "negative": "void sieve(int n)\n{\n    if (n > 2)\n    {\n        int res = 0;\n        char *list = calloc(n, 1);\n        for (long i = 2; i < n; i++)\n        {\n            if (list[i] == 0)\n            {\n                res++;\n                for (long j = i; j < n; j += i)\n                {\n                    list[j] = 1;\n                }\n            }\n        }\n        free(list);\n        printf(\"%d\\n\", res);\n    }\n}"}
{"anchor": "void rec(char **map, int t[2], int i, int j)\n{\n    map[i][j] = '#';\n    if (i < t[0] && map[i + 1][j] == '.')\n    {\n        rec(map, t, i + 1, j);\n    }\n    if (i > 0 && map[i - 1][j] == '.')\n    {\n        rec(map, t, i - 1, j);\n    }\n    if (j < t[1] && map[i][j + 1] == '.')\n    {\n        rec(map, t, i, j + 1);\n    }\n    if (j > 0 && map[i][j - 1] == '.')\n    {\n        rec(map, t, i, j - 1);\n    }\n}", "positive": "c\nvoid rec(char **map, int *t, int i, int j)\n{\n    char **temp_map = map;\n    int temp_i = i;\n    int temp_j = j;\n    \n    // Assigning to temporary variables for clear understanding and debugging\n    temp_map[temp_i][temp_j] = '#';\n    \n    if (temp_i < t[0] && temp_map[temp_i + 1][temp_j] == '.')\n    {\n        rec(temp_map, t, temp_i + 1, temp_j);\n    }\n    if (temp_i > 0 && temp_map[temp_i - 1][temp_j] == '.')\n    {\n        rec(temp_map, t, temp_i - 1, temp_j);\n    }\n    if (temp_j < t[1] && temp_map[temp_i][temp_j + 1] == '.')\n    {\n        rec(temp_map, t, temp_i, temp_j + 1);\n    }\n    if (temp_j > 0 && temp_map[temp_i][temp_j - 1] == '.')\n    {\n        rec(temp_map, t, temp_i, temp_j -", "function_type": 28, "negative": "int my_memcmp(const void *s1, const void *s2, size_t num)\n{\n    const char *r1 = s1;\n    const char *r2 = s2;\n    size_t i = 0;\n    while (i < num && r1[i] == r2[i])\n    {\n        i++;\n    }\n    if (i == num)\n    {\n        return 0;\n    }\n    if (r1[i] < r2[i])\n    {\n        return -1;\n    }\n    else\n    {\n        return 1;\n    }\n}"}
{"anchor": "void rec(char **map, int t[2], int i, int j)\n{\n    map[i][j] = '#';\n    if (i < t[0] && map[i + 1][j] == '.')\n    {\n        rec(map, t, i + 1, j);\n    }\n    if (i > 0 && map[i - 1][j] == '.')\n    {\n        rec(map, t, i - 1, j);\n    }\n    if (j < t[1] && map[i][j + 1] == '.')\n    {\n        rec(map, t, i, j + 1);\n    }\n    if (j > 0 && map[i][j - 1] == '.')\n    {\n        rec(map, t, i, j - 1);\n    }\n}", "positive": "void rec(Position *position)\n{\n    position->map[position->x][position->y] = '#';\n    \n    if (position->x < position->t[0] && position->map[position->x + 1][position->y] == '.') {\n        position->x++;\n        rec(position);\n        position->x--;\n    }\n  \n    if (position->x > 0 && position->map[position->x - 1][position->y] == '.') {\n        position->x--;\n        rec(position);\n        position->x++;\n    }\n  \n    if (position->y < position->t[1] && position->map[position->x][position->y + 1] == '.') {\n        position->y++;\n        rec(position);\n        position->y--;\n    }\n  \n    if (position->y > 0 && position->map[position->x][position->y - 1] == '.') {\n        position", "function_type": 28, "negative": "void map(int *array, size_t len, void (*func)(int *))\n{\n    for (size_t i = 0; i < len; i++)\n    {\n        func(&array[i]);\n    }\n}"}
{"anchor": "void rec(char **map, int t[2], int i, int j)\n{\n    map[i][j] = '#';\n    if (i < t[0] && map[i + 1][j] == '.')\n    {\n        rec(map, t, i + 1, j);\n    }\n    if (i > 0 && map[i - 1][j] == '.')\n    {\n        rec(map, t, i - 1, j);\n    }\n    if (j < t[1] && map[i][j + 1] == '.')\n    {\n        rec(map, t, i, j + 1);\n    }\n    if (j > 0 && map[i][j - 1] == '.')\n    {\n        rec(map, t, i, j - 1);\n    }\n}", "positive": "c\nvoid rec(int x, int y, char **map, int t[2])\n{\n    if ((x >= 0) && (y >= 0) && (x <= t[0]) && (y <= t[1]))\n    {\n        if (map[x][y] != '#')\n        {\n            map[x][y] = '#';\n        \n            rec(x-1, y,   map, t); // Up\n            rec(x+1, y,   map, t); // Down\n            rec(x,   y-1, map, t); // Left\n            rec(x,   y+1, map, t); // Right\n        }\n    }\n}", "function_type": 28, "negative": "void cipher(const char *key, const char *msg, char *res)\n{\n    int j = 0;\n    int len = 0;\n    while (key[len] != '\\0')\n    {\n        len += 1;\n    }\n    for (int i = 0; msg[i] != 0; i++)\n    {\n        int tem = (msg[i] - 'A');\n        int kem = (key[j % len] - 'A') % 32;\n        if ((tem >= 0 && tem <= 25) || (tem >= 32 && tem <= 57))\n        {\n            res[i] = (tem % 32 + kem) % 26 + 'A';\n            j++;\n        }\n        else\n        {\n            res[i] = msg[i];\n        }\n    }\n}"}
{"anchor": "void rec(char **map, int t[2], int i, int j)\n{\n    map[i][j] = '#';\n    if (i < t[0] && map[i + 1][j] == '.')\n    {\n        rec(map, t, i + 1, j);\n    }\n    if (i > 0 && map[i - 1][j] == '.')\n    {\n        rec(map, t, i - 1, j);\n    }\n    if (j < t[1] && map[i][j + 1] == '.')\n    {\n        rec(map, t, i, j + 1);\n    }\n    if (j > 0 && map[i][j - 1] == '.')\n    {\n        rec(map, t, i, j - 1);\n    }\n}", "positive": "c\nvoid explore(char **maze, int size[2], int position[2])\n{\n    maze[position[0]][position[1]] = '#';\n    \n    if ((position[0]+1 <= size[0]-1) && (maze[position[0]+1][position[1]]=='.')) //downwards\n    {\n        position[0] += 1;\n        explore(maze,size,position);\n    }\n        \n    else if((position[0]-1 >= 0 )&& (maze[position[0]-1][position[1]]=='.')) //upwards\n    {\n        position[0] -= 1;\n        explore(maze,size,position);\n    }  \n            \n    else if((position[1]+1 <= size[1]-1) && (maze[position[0]][position[1]+1]=='.')) //rightwards\n    {\n        position[1] +=1 ;\n        explore(maze,size,position);\n    }\n        \n    else if((position[1]-1 >=0) && (maze[position[0]][position[1]-1]=='.'))//leftwards\n    {\n        position[1] -=1;\n        explore(maze,size", "function_type": 28, "negative": "void p_rec(const struct heap *heap, size_t i)\n{\n    printf(\" %d\", heap->array[i]);\n    if (i * 2 + 1 < heap->size)\n    {\n        p_rec(heap, i * 2 + 1);\n    }\n    if (i * 2 + 2 < heap->size)\n    {\n        p_rec(heap, i * 2 + 2);\n    }\n}"}
{"anchor": "int find(const char s, const char *c)\n{\n    int i = 0;\n    while (c[i] != '\\0' && c[i] != s)\n    {\n        i++;\n    }\n    return (c[i] == '\\0') ? -1 : i;\n}", "positive": "int find(const char s, const char *c)\n{\n    int i = 0;\n    while (c[i] != '\\0' && c[i] != s)\n    {\n        i++;\n    }\n    return (c[i] == '\\0') ? -1 : i;\n}", "function_type": 28, "negative": "int present(const char *accept, char f)\n{\n    for (size_t i = 0; accept[i] != '\\0'; i++)\n    {\n        if (accept[i] == f)\n        {\n            return 1;\n        }\n    }\n    return 0;\n}"}
{"anchor": "int find(const char s, const char *c)\n{\n    int i = 0;\n    while (c[i] != '\\0' && c[i] != s)\n    {\n        i++;\n    }\n    return (c[i] == '\\0') ? -1 : i;\n}", "positive": "c\nint find(char* c, char s)\n{\n   for (int i = 0; c[i]; i++){\n       if (s == c[i]) \n           return i;\n    }\n    return -1;\n}", "function_type": 29, "negative": "int check_alphabet(const char *str, const char *alphabet)\n{\n    if (alphabet == NULL || alphabet[0] == '\\0')\n    {\n        return 1;\n    }\n\n    for (int i = 0; alphabet[i] != '\\0'; i++)\n    {\n        int j = 0;\n        while (str[j] != '\\0' && str[j] != alphabet[i])\n        {\n            j++;\n        }\n        if (str[j] == '\\0')\n        {\n            return 0;\n        }\n    }\n    return 1;\n}"}
{"anchor": "int find(const char s, const char *c)\n{\n    int i = 0;\n    while (c[i] != '\\0' && c[i] != s)\n    {\n        i++;\n    }\n    return (c[i] == '\\0') ? -1 : i;\n}", "positive": "c\nint locate(const char target, const char *source)\n{\n    int position = 0;\n    while (source[position] != '\\0' && source[position] != target)\n    {\n        position++;\n    }\n    return (source[position] == '\\0') ? -1 : position;\n}", "function_type": 29, "negative": "int my_memcmp(const void *s1, const void *s2, size_t num)\n{\n    const char *r1 = s1;\n    const char *r2 = s2;\n    size_t i = 0;\n    while (i < num && r1[i] == r2[i])\n    {\n        i++;\n    }\n    if (i == num)\n    {\n        return 0;\n    }\n    if (r1[i] < r2[i])\n    {\n        return -1;\n    }\n    else\n    {\n        return 1;\n    }\n}"}
{"anchor": "int find(const char s, const char *c)\n{\n    int i = 0;\n    while (c[i] != '\\0' && c[i] != s)\n    {\n        i++;\n    }\n    return (c[i] == '\\0') ? -1 : i;\n}", "positive": "c\nint find_v2(char s, const char* c)\n{\n    for (size_t i = 0; c[i] != '\\0'; ++i)\n    {\n        if (s == c[i]) \n            return i; // Found character, return index\n    }\n    \n    return -1; // Not found in string, return default value (-1)\n}", "function_type": 29, "negative": "int cal_decode(const char *s)\n{\n    int i = 0;\n    int taille = 0;\n    while (s[i] != '\\0')\n    {\n        if (s[i] <= '9' && s[i] >= '0')\n        {\n            taille += s[i] - '0';\n        }\n        i++;\n    }\n    return taille;\n}"}
{"anchor": "int find(const char s, const char *c)\n{\n    int i = 0;\n    while (c[i] != '\\0' && c[i] != s)\n    {\n        i++;\n    }\n    return (c[i] == '\\0') ? -1 : i;\n}", "positive": "c\nint find_refactored(const char s, const char *c)\n{\n    size_t length = strlen(c); // Get string length\n    size_t i = 0;               // Initialize index variable to 0\n    \n    for (; i < length; ++i)      // Loop until end of string or character found\n    {\n        if (c[i] == s)           // If current character matches search character\n            break;                // Exit loop\n        \n        if (c[i + 1] == '\\0')   // Check next character and exit when it is null terminator\n        {\n            --i;                 // Decrement counter because in the final iteration i will be incremented again\n            break;\n        }\n    }\n    return (c[i] == '\\0') ? -1 : i; // Return position or -1 if not present\n}", "function_type": 29, "negative": "int star(const char *p, const char *s, int i, int j)\n{\n    while (p[j] != s[i] && p[j] != '?')\n    {\n        i++;\n    }\n    return simple(p, s, i + 1, j + 1);\n}"}
{"anchor": "void apply_lut(unsigned char mat[4][4], const unsigned char lut[256])\n{\n    for (int i = 0; i < 4; i++)\n    {\n        for (int j = 0; j < 4; j++)\n        {\n            mat[i][j] = lut[mat[i][j]];\n        }\n    }\n}", "positive": "c\nvoid refactor_apply_lut(unsigned char matrix[4][4], const unsigned char lookup_table[256])\n{\n    for (int rowIndex = 0; rowIndex < 4; rowIndex++)\n    {\n        for (int columnIndex = 0; columnIndex < 4; columnIndex++)\n        {\n            matrix[rowIndex][columnIndex] = lookup_table[matrix[rowIndex][columnIndex]];\n        }\n    }\n}", "function_type": 29, "negative": "void my_rol_crypt(void *data, size_t data_len, const void *key, size_t key_len)\n{\n    unsigned char *tem = data;\n    const unsigned char *te = key;\n    for (size_t i = 0; i < data_len; i++)\n    {\n        tem[i] = (tem[i] + te[i % key_len]) % 256;\n    }\n    data = tem;\n}"}
{"anchor": "void apply_lut(unsigned char mat[4][4], const unsigned char lut[256])\n{\n    for (int i = 0; i < 4; i++)\n    {\n        for (int j = 0; j < 4; j++)\n        {\n            mat[i][j] = lut[mat[i][j]];\n        }\n    }\n}", "positive": "c\nvoid refactor_apply_lut(const unsigned char originalMat[4][4], const unsigned char lut[256], unsigned char transformedMat[4][4])\n{\n    for (int x = 0; x < 4; x++)\n    {\n        for (int y = 0; y < 4; y++)\n        {\n            transformedMat[x][y] = lut[originalMat[x][y]];\n        }\n    }\n}", "function_type": 30, "negative": "void cipher(const char *key, const char *msg, char *res)\n{\n    int j = 0;\n    int len = 0;\n    while (key[len] != '\\0')\n    {\n        len += 1;\n    }\n    for (int i = 0; msg[i] != 0; i++)\n    {\n        int tem = (msg[i] - 'A');\n        int kem = (key[j % len] - 'A') % 32;\n        if ((tem >= 0 && tem <= 25) || (tem >= 32 && tem <= 57))\n        {\n            res[i] = (tem % 32 + kem) % 26 + 'A';\n            j++;\n        }\n        else\n        {\n            res[i] = msg[i];\n        }\n    }\n}"}
{"anchor": "void apply_lut(unsigned char mat[4][4], const unsigned char lut[256])\n{\n    for (int i = 0; i < 4; i++)\n    {\n        for (int j = 0; j < 4; j++)\n        {\n            mat[i][j] = lut[mat[i][j]];\n        }\n    }\n}", "positive": "c\nvoid apply_lookup_table(unsigned char matrix[4][4], const unsigned char lookupTable[256])\n{\n    for (int rowIndex = 0; rowIndex < 4; rowIndex++)\n    {\n        for (int columnIndex = 0; columnIndex < 4; columnIndex++)\n        {\n            matrix[rowIndex][columnIndex] = lookupTable[matrix[rowIndex][columnIndex]];\n        }\n    }\n}", "function_type": 30, "negative": "int my_memcmp(const void *s1, const void *s2, size_t num)\n{\n    const char *r1 = s1;\n    const char *r2 = s2;\n    size_t i = 0;\n    while (i < num && r1[i] == r2[i])\n    {\n        i++;\n    }\n    if (i == num)\n    {\n        return 0;\n    }\n    if (r1[i] < r2[i])\n    {\n        return -1;\n    }\n    else\n    {\n        return 1;\n    }\n}"}
{"anchor": "void apply_lut(unsigned char mat[4][4], const unsigned char lut[256])\n{\n    for (int i = 0; i < 4; i++)\n    {\n        for (int j = 0; j < 4; j++)\n        {\n            mat[i][j] = lut[mat[i][j]];\n        }\n    }\n}", "positive": "c\nvoid refactor_apply_lut(unsigned char matrix[4][4], const unsigned char lookupTable[256])\n{\n    for (int rowIndex = 0; rowIndex < 4; rowIndex++)\n    {\n        for (int columnIndex = 0; columnIndex < 4; columnIndex++)\n        {\n            matrix[rowIndex][columnIndex] = lookupTable[matrix[rowIndex][columnIndex]];\n        }\n    }\n}", "function_type": 30, "negative": "void my_xor_crypt(void *data, size_t data_len, const void *key, size_t key_len)\n{\n    unsigned char *tem = data;\n    const unsigned char *te = key;\n    for (size_t i = 0; i < data_len; i++)\n    {\n        tem[i] = tem[i] ^ te[i % key_len];\n    }\n    data = tem;\n}"}
{"anchor": "void apply_lut(unsigned char mat[4][4], const unsigned char lut[256])\n{\n    for (int i = 0; i < 4; i++)\n    {\n        for (int j = 0; j < 4; j++)\n        {\n            mat[i][j] = lut[mat[i][j]];\n        }\n    }\n}", "positive": "c\nvoid apply_lut(unsigned char (*mat)[4], const unsigned char *lut)\n{\n    for (int i = 0; i < 4; i++)\n    {\n        for (int j = 0; j < 4; j++)\n        {\n            mat[i][j] = lut[mat[i][j]];\n        }\n    }\n}", "function_type": 30, "negative": "void rec(char **map, int t[2], int i, int j)\n{\n    map[i][j] = '#';\n    if (i < t[0] && map[i + 1][j] == '.')\n    {\n        rec(map, t, i + 1, j);\n    }\n    if (i > 0 && map[i - 1][j] == '.')\n    {\n        rec(map, t, i - 1, j);\n    }\n    if (j < t[1] && map[i][j + 1] == '.')\n    {\n        rec(map, t, i, j + 1);\n    }\n    if (j > 0 && map[i][j - 1] == '.')\n    {\n        rec(map, t, i, j - 1);\n    }\n}"}
{"anchor": "int coun(const char *file_out)\n{\n    FILE *f3 = fopen(file_out, \"r\");\n    int count = 0;\n    char *line3 = NULL;\n    size_t len3 = 0;\n    while (getline(&line3, &len3, f3) != -1)\n    {\n        count += 1;\n    }\n    free(line3);\n    fclose(f3);\n    return count;\n}", "positive": "c\nint countLinesInFile(const char *filename){\n  FILE* file = fopen(filename,\"r\");\n  \n  if(!file){ // Check if file opened successfully\n      printf(\"Could not open file %s\\n\", filename);\n      exit(-1);\n  }\n  \n  char *currentLine = NULL;     // Pointer to store current line in memory\n  size_t length = 0;             // Length of current line in bytes\n  ssize_t read;                  // Number of characters read by getline()\n  unsigned long int numOfLines = 0;       // Line counter\n  \n  /* Read each line until end-of-file is reached */\n  while ((read = getline(&currentLine, &length, file)) != -1) {\n      ++numOfLines;              // Increment line counter for every non-empty line read\n  }\n  \n  free(currentLine);            // Free allocated memory\n  fclose(file);                 // Close file descriptor\n  \n  return numOfLines;           // Return number of lines read/processed\n}", "function_type": 30, "negative": "int reverse_content(const char *file_in, const char *file_out)\n{\n    FILE *f1 = fopen(file_in, \"r\");\n    if (f1 == NULL)\n    {\n        return -1;\n    }\n    FILE *f2 = fopen(file_out, \"w\");\n    if (f1 == NULL)\n    {\n        fclose(f2);\n        return -1;\n    }\n    int c = fseek(f1, -1, 2);\n    while (c != -1)\n    {\n        int s = fgetc(f1);\n        fputc(s, f2);\n        c = fseek(f1, -2, 1);\n    }\n    fclose(f1);\n    fclose(f2);\n    return 0;\n}"}
{"anchor": "int coun(const char *file_out)\n{\n    FILE *f3 = fopen(file_out, \"r\");\n    int count = 0;\n    char *line3 = NULL;\n    size_t len3 = 0;\n    while (getline(&line3, &len3, f3) != -1)\n    {\n        count += 1;\n    }\n    free(line3);\n    fclose(f3);\n    return count;\n}", "positive": "c\nint countLinesInFile(const char *filename)\n{\n    // Open file in read mode\n    FILE *filePointer = fopen(filename, \"r\");\n    \n    // Initialize line and length variables for getline()\n    char *lineBuffer = NULL;\n    size_t bufferSize = 0;\n  \n    // Initialize counter variable\n    unsigned long lineCount = 0; \n  \n    // While loop to iterate over lines of file\n    while (getline(&lineBuffer, &bufferSize, filePointer) != -1)\n    {\n        lineCount++;       // Increment line count each time a new line is found\n    }\n  \n    // Free dynamically allocated memory before closing file\n    free(lineBuffer);\n    // Close file pointer\n    fclose(filePointer);\n  \n    // Return number of lines counted\n    return lineCount;\n}", "function_type": 31, "negative": "int count_words(const char *file_in)\n{\n    FILE *r = fopen(file_in, \"r\");\n    int count = 0;\n    if (r == NULL)\n    {\n        return -1;\n    }\n    int bo = 0;\n    char c = fgetc(r);\n    while (c != -1)\n    {\n        if (c == ' ' || c == '\\n' || c == '\\t')\n        {\n            if (bo)\n                count += 1;\n            bo = 0;\n        }\n        else\n        {\n            bo = 1;\n        }\n        c = fgetc(r);\n    }\n    if (bo)\n        count += 1;\n    return count;\n}"}
{"anchor": "int coun(const char *file_out)\n{\n    FILE *f3 = fopen(file_out, \"r\");\n    int count = 0;\n    char *line3 = NULL;\n    size_t len3 = 0;\n    while (getline(&line3, &len3, f3) != -1)\n    {\n        count += 1;\n    }\n    free(line3);\n    fclose(f3);\n    return count;\n}", "positive": "c\nint coun(const char *file_out)\n{\n    // Open file in read mode\n    FILE *f3 = fopen(file_out, \"r\");\n    \n    if (!f3)\n    {\n      printf(\"Unable to open input file\\n\");\n      exit(EXIT_FAILURE);  \n    }\n \n    // Initialize counter and line buffer for getline\n    int count = 0;\n    char *line3 = NULL;\n    size_t len3 = 0;\n    \n    ssize_t bytesRead; \n\n    /* Read a line from stream into allocated buffer */\n    while ((bytesRead = getline(&line3, &len3, f3)) != -1)\n    {\n        // Increment counter each time we successfully read a new line\n        count += 1;\n    }\n\n    /* Free dynamically allocated memory before exiting program*/\n    free(line3);\n        \n    /* Close opened files after reading */\n    fclose(f3);\n      \n    return count;\n}", "function_type": 31, "negative": "int append_file(const char *file_in, const char *content)\n{\n    if (content == NULL)\n    {\n        return -1;\n    }\n    FILE *f1 = fopen(file_in, \"a\");\n    if (f1 == NULL)\n    {\n        return -1;\n    }\n    fprintf(f1, \"%s\", content);\n    fclose(f1);\n    return 0;\n}"}
{"anchor": "int coun(const char *file_out)\n{\n    FILE *f3 = fopen(file_out, \"r\");\n    int count = 0;\n    char *line3 = NULL;\n    size_t len3 = 0;\n    while (getline(&line3, &len3, f3) != -1)\n    {\n        count += 1;\n    }\n    free(line3);\n    fclose(f3);\n    return count;\n}", "positive": "int coun(const char *file_out)\n{\n    FILE *f3 = fopen(file_out, \"r\");\n    int count = 0;\n    char *line3 = NULL;\n    size_t len3 = 0;\n    while (getline(&line3, &len3, f3) != -1)\n    {\n        count += 1;\n    }\n    free(line3);\n    fclose(f3);\n    return count;\n}", "function_type": 31, "negative": "int present(const char *accept, char f)\n{\n    for (size_t i = 0; accept[i] != '\\0'; i++)\n    {\n        if (accept[i] == f)\n        {\n            return 1;\n        }\n    }\n    return 0;\n}"}
{"anchor": "int append_file(const char *file_in, const char *content)\n{\n    if (content == NULL)\n    {\n        return -1;\n    }\n    FILE *f1 = fopen(file_in, \"a\");\n    if (f1 == NULL)\n    {\n        return -1;\n    }\n    fprintf(f1, \"%s\", content);\n    fclose(f1);\n    return 0;\n}", "positive": "int append_file(const char *file_in, const char *content)\n{\n    if (content == NULL)\n    {\n        return -1;\n    }\n    FILE *f1 = fopen(file_in, \"a\");\n    if (f1 == NULL)\n    {\n        return -1;\n    }\n    fprintf(f1, \"%s\", content);\n    fclose(f1);\n    return 0;\n}", "function_type": 31, "negative": "int reverse_content(const char *file_in, const char *file_out)\n{\n    FILE *f1 = fopen(file_in, \"r\");\n    if (f1 == NULL)\n    {\n        return -1;\n    }\n    FILE *f2 = fopen(file_out, \"w\");\n    if (f1 == NULL)\n    {\n        fclose(f2);\n        return -1;\n    }\n    int c = fseek(f1, -1, 2);\n    while (c != -1)\n    {\n        int s = fgetc(f1);\n        fputc(s, f2);\n        c = fseek(f1, -2, 1);\n    }\n    fclose(f1);\n    fclose(f2);\n    return 0;\n}"}
{"anchor": "int append_file(const char *file_in, const char *content)\n{\n    if (content == NULL)\n    {\n        return -1;\n    }\n    FILE *f1 = fopen(file_in, \"a\");\n    if (f1 == NULL)\n    {\n        return -1;\n    }\n    fprintf(f1, \"%s\", content);\n    fclose(f1);\n    return 0;\n}", "positive": "c\nint append_file(const char *content, const char *file_in)\n{\n    if (content == NULL || file_in == NULL)\n    {\n        return -1;\n    }\n    FILE *f1 = fopen(file_in, \"a\");\n    if (f1 == NULL)\n    {\n        return -1;\n    }\n    fprintf(f1, \"%s\", content);\n    fclose(f1);\n    return 0;\n}", "function_type": 32, "negative": "int coun(const char *file_out)\n{\n    FILE *f3 = fopen(file_out, \"r\");\n    int count = 0;\n    char *line3 = NULL;\n    size_t len3 = 0;\n    while (getline(&line3, &len3, f3) != -1)\n    {\n        count += 1;\n    }\n    free(line3);\n    fclose(f3);\n    return count;\n}"}
{"anchor": "int append_file(const char *file_in, const char *content)\n{\n    if (content == NULL)\n    {\n        return -1;\n    }\n    FILE *f1 = fopen(file_in, \"a\");\n    if (f1 == NULL)\n    {\n        return -1;\n    }\n    fprintf(f1, \"%s\", content);\n    fclose(f1);\n    return 0;\n}", "positive": "int append_file(const char *file_in, const char *content)\n{\n    if (content == NULL)\n    {\n        return -1;\n    }\n    FILE *f1 = fopen(file_in, \"a\");\n    if (f1 == NULL)\n    {\n        return -1;\n    }\n    fprintf(f1, \"%s\", content);\n    fclose(f1);\n    return 0;\n}", "function_type": 32, "negative": "int count_words(const char *file_in)\n{\n    FILE *r = fopen(file_in, \"r\");\n    int count = 0;\n    if (r == NULL)\n    {\n        return -1;\n    }\n    int bo = 0;\n    char c = fgetc(r);\n    while (c != -1)\n    {\n        if (c == ' ' || c == '\\n' || c == '\\t')\n        {\n            if (bo)\n                count += 1;\n            bo = 0;\n        }\n        else\n        {\n            bo = 1;\n        }\n        c = fgetc(r);\n    }\n    if (bo)\n        count += 1;\n    return count;\n}"}
{"anchor": "int append_file(const char *file_in, const char *content)\n{\n    if (content == NULL)\n    {\n        return -1;\n    }\n    FILE *f1 = fopen(file_in, \"a\");\n    if (f1 == NULL)\n    {\n        return -1;\n    }\n    fprintf(f1, \"%s\", content);\n    fclose(f1);\n    return 0;\n}", "positive": "c\nint append_file(const char *file_in, const char *content)\n{\n    if (content == NULL)\n    {\n        return -1;\n    }\n    \n    int i = 0;\n    while(content[i] != '\\0') // equivalent to for-loop that iterates over all characters in string 'content' until it encounters a null character ('\\0').\n    {\n        if (!isalpha(content[i]))\n            break;\n        \n        FILE *f1 = fopen(file_in, \"a+\");  \n        if (f1 == NULL)\n        {\n            return -1;\n        }\n        fputc(content[i], f1);\n        fclose(f1);\n            \n        i++;\n    }\n    \n    return 0;\n}", "function_type": 32, "negative": "int check_alphabet(const char *str, const char *alphabet)\n{\n    if (alphabet == NULL || alphabet[0] == '\\0')\n    {\n        return 1;\n    }\n\n    for (int i = 0; alphabet[i] != '\\0'; i++)\n    {\n        int j = 0;\n        while (str[j] != '\\0' && str[j] != alphabet[i])\n        {\n            j++;\n        }\n        if (str[j] == '\\0')\n        {\n            return 0;\n        }\n    }\n    return 1;\n}"}
{"anchor": "int append_file(const char *file_in, const char *content)\n{\n    if (content == NULL)\n    {\n        return -1;\n    }\n    FILE *f1 = fopen(file_in, \"a\");\n    if (f1 == NULL)\n    {\n        return -1;\n    }\n    fprintf(f1, \"%s\", content);\n    fclose(f1);\n    return 0;\n}", "positive": "c\nint append_file(char **file_in, char **content)\n{\n    if (*content == NULL)\n    {\n        return -1;\n    }\n    FILE *f1 = fopen(*file_in, \"a\");\n    if (f1 == NULL)\n    {\n        return -1;\n    }\n    fprintf(f1, \"%s\", *content);\n    fclose(f1);\n    free(*file_in); // Free allocated memory for file name\n    free(*content); // Free allocated memory for content\n    return 0;\n}", "function_type": 32, "negative": "int present(const char *accept, char f)\n{\n    for (size_t i = 0; accept[i] != '\\0'; i++)\n    {\n        if (accept[i] == f)\n        {\n            return 1;\n        }\n    }\n    return 0;\n}"}
{"anchor": "void int_vector_print(const struct int_vector vec)\n{\n    for (size_t i = 0; i < vec.size; i++)\n    {\n        printf(\"%d\", vec.data[i]);\n        if (i + 1 != vec.size)\n        {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n}", "positive": "c\nvoid print_int_vector(struct int_vector *vec)\n{\n    for (size_t i = 0; i < (*vec).size; i++)\n    {\n        printf(\"%d\", (*vec).data[i]);\n        if (i + 1 != (*vec).size)\n        {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n}", "function_type": 32, "negative": "void p_rec(const struct heap *heap, size_t i)\n{\n    printf(\" %d\", heap->array[i]);\n    if (i * 2 + 1 < heap->size)\n    {\n        p_rec(heap, i * 2 + 1);\n    }\n    if (i * 2 + 2 < heap->size)\n    {\n        p_rec(heap, i * 2 + 2);\n    }\n}"}
{"anchor": "void int_vector_print(const struct int_vector vec)\n{\n    for (size_t i = 0; i < vec.size; i++)\n    {\n        printf(\"%d\", vec.data[i]);\n        if (i + 1 != vec.size)\n        {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n}", "positive": "c\nvoid printVectorElements(const struct int_vector vectorToPrint)\n{\n    for (size_t index = 0; index < vectorToPrint.size; index++)\n    {\n        printf(\"%d\", vectorToPrint.data[index]);\n        if ((index + 1) != vectorToPrint.size)  // Parentheses added to avoid unnecessary calculations in condition\n        {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n}", "function_type": 33, "negative": "int int_vector_max(const struct int_vector vec)\n{\n    int max = vec.data[0];\n    for (size_t i = 0; i < vec.size; i++)\n    {\n        if (max < vec.data[i])\n        {\n            max = vec.data[i];\n        }\n    }\n    return max;\n}"}
{"anchor": "void int_vector_print(const struct int_vector vec)\n{\n    for (size_t i = 0; i < vec.size; i++)\n    {\n        printf(\"%d\", vec.data[i]);\n        if (i + 1 != vec.size)\n        {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n}", "positive": "c\nvoid int_vector_print(const struct int_vector *vecPtr)\n{\n    for (size_t i = 0; i < vecPtr->size; i++)\n    {\n        printf(\"%d\", (*vecPtr).data[i]); // or vecPtr->data[i]\n        if (i + 1 != vecPtr->size)\n        {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n}", "function_type": 33, "negative": "void variant_display(const struct variant *e)\n{\n    if (e->type == TYPE_INT)\n        printf(\"%d\\n\", e->value.int_v);\n    if (e->type == TYPE_FLOAT)\n        printf(\"%f\\n\", e->value.float_v);\n    if (e->type == TYPE_CHAR)\n        printf(\"%c\\n\", e->value.char_v);\n    if (e->type == TYPE_STRING)\n        printf(\"%s\\n\", e->value.str_v);\n}"}
{"anchor": "int count_words(const char *file_in)\n{\n    FILE *r = fopen(file_in, \"r\");\n    int count = 0;\n    if (r == NULL)\n    {\n        return -1;\n    }\n    int bo = 0;\n    char c = fgetc(r);\n    while (c != -1)\n    {\n        if (c == ' ' || c == '\\n' || c == '\\t')\n        {\n            if (bo)\n                count += 1;\n            bo = 0;\n        }\n        else\n        {\n            bo = 1;\n        }\n        c = fgetc(r);\n    }\n    if (bo)\n        count += 1;\n    return count;\n}", "positive": "c\nint wordCount(const char *inputFileName)\n{\n    FILE *readerFilePointer = fopen(inputFileName, \"r\");\n    int wordsCounter = 0;\n    if (readerFilePointer == NULL)\n    {\n        return -1;\n    }\n    int inWordFlag = 0; // flag to indicate whether we are currently inside a word\n    char characterFromFile = fgetc(readerFilePointer);\n    while (characterFromFile != EOF)  // EOF is represented by an integer value of -1, but safer and easier to use as it can be used without worrying about what that specific number actually is\n    {\n        if (characterFromFile == ' ' || characterFromFile == '\\n' || characterFromFile == '\\t')\n        {\n            if (inWordFlag)\n                wordsCounter += 1;\n            inWordFlag = 0;\n        }\n        else\n        {\n            inWordFlag = 1;\n        }\n        characterFromFile = fgetc(readerFilePointer);\n    }\n    if (inWordFlag)\n        wordsCounter += 1;\n    return wordsCounter;\n}", "function_type": 33, "negative": "int reverse_content(const char *file_in, const char *file_out)\n{\n    FILE *f1 = fopen(file_in, \"r\");\n    if (f1 == NULL)\n    {\n        return -1;\n    }\n    FILE *f2 = fopen(file_out, \"w\");\n    if (f1 == NULL)\n    {\n        fclose(f2);\n        return -1;\n    }\n    int c = fseek(f1, -1, 2);\n    while (c != -1)\n    {\n        int s = fgetc(f1);\n        fputc(s, f2);\n        c = fseek(f1, -2, 1);\n    }\n    fclose(f1);\n    fclose(f2);\n    return 0;\n}"}
{"anchor": "int count_words(const char *file_in)\n{\n    FILE *r = fopen(file_in, \"r\");\n    int count = 0;\n    if (r == NULL)\n    {\n        return -1;\n    }\n    int bo = 0;\n    char c = fgetc(r);\n    while (c != -1)\n    {\n        if (c == ' ' || c == '\\n' || c == '\\t')\n        {\n            if (bo)\n                count += 1;\n            bo = 0;\n        }\n        else\n        {\n            bo = 1;\n        }\n        c = fgetc(r);\n    }\n    if (bo)\n        count += 1;\n    return count;\n}", "positive": "int count_words(const char *file_in)\n{\n    FILE *r = fopen(file_in, \"r\");\n    int count = 0;\n    if (r == NULL)\n    {\n        return -1;\n    }\n    int bo = 0;\n    char c = fgetc(r);\n    while (c != -1)\n    {\n        if (c == ' ' || c == '\\n' || c == '\\t')\n        {\n            if (bo)\n                count += 1;\n            bo = 0;\n        }\n        else\n        {\n            bo = 1;\n        }\n        c = fgetc(r);\n    }\n    if (bo)\n        count += 1;\n    return count;\n}", "function_type": 34, "negative": "int coun(const char *file_out)\n{\n    FILE *f3 = fopen(file_out, \"r\");\n    int count = 0;\n    char *line3 = NULL;\n    size_t len3 = 0;\n    while (getline(&line3, &len3, f3) != -1)\n    {\n        count += 1;\n    }\n    free(line3);\n    fclose(f3);\n    return count;\n}"}
{"anchor": "int count_words(const char *file_in)\n{\n    FILE *r = fopen(file_in, \"r\");\n    int count = 0;\n    if (r == NULL)\n    {\n        return -1;\n    }\n    int bo = 0;\n    char c = fgetc(r);\n    while (c != -1)\n    {\n        if (c == ' ' || c == '\\n' || c == '\\t')\n        {\n            if (bo)\n                count += 1;\n            bo = 0;\n        }\n        else\n        {\n            bo = 1;\n        }\n        c = fgetc(r);\n    }\n    if (bo)\n        count += 1;\n    return count;\n}", "positive": "c\nint count_words(const char *file_name)\n{\n    int word_count = 0; // Rename to avoid confusion with original variable name\n    char current_character; \n    int in_word = 0; \n    \n    FILE* file = fopen(file_name, \"r\");\n    if (!file)\n    {  \n        return -1; \n    }\n        \n    while ((current_character = fgetc(file)) != EOF)\n    {\n        if (current_character == ' ' || current_character == '\\n' || current_character == '\\t')\n        {\n            if (in_word)\n            {\n                ++word_count;\n                in_word = 0;\n            }\n        }\n        else\n        {\n            in_word = 1;\n        }\n    }\n      \n    if (in_word)\n    {\n        ++word_count;\n    }\n     \n    fclose(file);\n    \n    return word_count;\n}", "function_type": 34, "negative": "int append_file(const char *file_in, const char *content)\n{\n    if (content == NULL)\n    {\n        return -1;\n    }\n    FILE *f1 = fopen(file_in, \"a\");\n    if (f1 == NULL)\n    {\n        return -1;\n    }\n    fprintf(f1, \"%s\", content);\n    fclose(f1);\n    return 0;\n}"}
{"anchor": "int count_words(const char *file_in)\n{\n    FILE *r = fopen(file_in, \"r\");\n    int count = 0;\n    if (r == NULL)\n    {\n        return -1;\n    }\n    int bo = 0;\n    char c = fgetc(r);\n    while (c != -1)\n    {\n        if (c == ' ' || c == '\\n' || c == '\\t')\n        {\n            if (bo)\n                count += 1;\n            bo = 0;\n        }\n        else\n        {\n            bo = 1;\n        }\n        c = fgetc(r);\n    }\n    if (bo)\n        count += 1;\n    return count;\n}", "positive": "static int increment_count(void)\n{\n    return 1;\n}", "function_type": 34, "negative": "int check_alphabet(const char *str, const char *alphabet)\n{\n    if (alphabet == NULL || alphabet[0] == '\\0')\n    {\n        return 1;\n    }\n\n    for (int i = 0; alphabet[i] != '\\0'; i++)\n    {\n        int j = 0;\n        while (str[j] != '\\0' && str[j] != alphabet[i])\n        {\n            j++;\n        }\n        if (str[j] == '\\0')\n        {\n            return 0;\n        }\n    }\n    return 1;\n}"}
{"anchor": "static struct int_vector swap(struct int_vector vec, size_t i, size_t j)\n{\n    int temp = vec.data[i];\n    vec.data[i] = vec.data[j];\n    vec.data[j] = temp;\n    return vec;\n}", "positive": "static struct int_vector swap(struct int_vector vec, size_t i, size_t j)\n{\n    int temp = vec.data[i];\n    vec.data[i] = vec.data[j];\n    vec.data[j] = temp;\n    return vec;\n}", "function_type": 34, "negative": "int int_vector_max(const struct int_vector vec)\n{\n    int max = vec.data[0];\n    for (size_t i = 0; i < vec.size; i++)\n    {\n        if (max < vec.data[i])\n        {\n            max = vec.data[i];\n        }\n    }\n    return max;\n}"}
{"anchor": "static struct int_vector swap(struct int_vector vec, size_t i, size_t j)\n{\n    int temp = vec.data[i];\n    vec.data[i] = vec.data[j];\n    vec.data[j] = temp;\n    return vec;\n}", "positive": "c\nstatic struct int_vector swap(size_t i, size_t j, struct int_vector vec)\n{\n    int temp = vec.data[i];\n    vec.data[i] = vec.data[j];\n    vec.data[j] = temp;\n    return vec;\n}", "function_type": 35, "negative": "void int_vector_print(const struct int_vector vec)\n{\n    for (size_t i = 0; i < vec.size; i++)\n    {\n        printf(\"%d\", vec.data[i]);\n        if (i + 1 != vec.size)\n        {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n}"}
{"anchor": "static struct int_vector swap(struct int_vector vec, size_t i, size_t j)\n{\n    int temp = vec.data[i];\n    vec.data[i] = vec.data[j];\n    vec.data[j] = temp;\n    return vec;\n}", "positive": "static struct int_vector swap(struct int_vector vec, size_t i, size_t j)\n{\n    int temp = vec.data[i];\n    vec.data[i] = vec.data[j];\n    vec.data[j] = temp;\n    return vec;\n}", "function_type": 35, "negative": "void swap(int *array, int i, int j)\n{\n    int temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n}"}
{"anchor": "static struct int_vector swap(struct int_vector vec, size_t i, size_t j)\n{\n    int temp = vec.data[i];\n    vec.data[i] = vec.data[j];\n    vec.data[j] = temp;\n    return vec;\n}", "positive": "c\nstatic struct int_vector swap(size_t i, size_t j, struct int_vector *vecp)\n{\n    int temp = (*vecp).data[i];\n    (*vecp).data[i] = (*vecp).data[j];\n    (*vecp).data[j] = temp;\n    return *vecp;\n}", "function_type": 35, "negative": "int dlist_get(const struct dlist *list, size_t index)\n{\n    if (index >= list->size)\n    {\n        return -1;\n    }\n    struct dlist_item *temp = list->head;\n    while (index != 0)\n    {\n        temp = temp->next;\n        index -= 1;\n    }\n    return temp->data;\n}"}
{"anchor": "static struct int_vector swap(struct int_vector vec, size_t i, size_t j)\n{\n    int temp = vec.data[i];\n    vec.data[i] = vec.data[j];\n    vec.data[j] = temp;\n    return vec;\n}", "positive": "c\nstatic struct int_vector swap(struct int_vector vec, size_t i, size_t j)\n{\n    int temp1 = vec.data[i], temp2 = vec.data[j];  // Added two new variables\n    \n    vec.data[i] = temp2;                           // Moved data from position 'j' to 'i', using temporary variable\n    vec.data[j] = temp1;                           // Moved data from position 'i' to 'j', using temporary variable\n    \n    return vec;                                     // Return modified vector\n}", "function_type": 35, "negative": "void swap(int *tab, int i, int j)\n{\n    int temp = tab[i];\n    tab[i] = tab[j];\n    tab[j] = temp;\n}"}
{"anchor": "int int_vector_max(const struct int_vector vec)\n{\n    int max = vec.data[0];\n    for (size_t i = 0; i < vec.size; i++)\n    {\n        if (max < vec.data[i])\n        {\n            max = vec.data[i];\n        }\n    }\n    return max;\n}", "positive": "c\nint int_vector_max(const struct int_vector vec)\n{\n    const size_t vectorSize = vec.size;\n    \n    // Intermediate variable to store the data array\n    const int * const dataArray = vec.data; \n    \n    int max = dataArray[0];\n    for (size_t i = 0; i < vectorSize; i++)\n    {\n        if (max < dataArray[i])\n        {\n            max = dataArray[i];\n        }\n    }\n    return max;\n}", "function_type": 35, "negative": "void int_vector_print(const struct int_vector vec)\n{\n    for (size_t i = 0; i < vec.size; i++)\n    {\n        printf(\"%d\", vec.data[i]);\n        if (i + 1 != vec.size)\n        {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n}"}
{"anchor": "int int_vector_max(const struct int_vector vec)\n{\n    int max = vec.data[0];\n    for (size_t i = 0; i < vec.size; i++)\n    {\n        if (max < vec.data[i])\n        {\n            max = vec.data[i];\n        }\n    }\n    return max;\n}", "positive": "c\nint arrayMaximumFinder(const int inputArray[], const size_t lengthOfInputArray)\n{\n    int maximumValueFoundSoFar = inputArray[0];\n    for (size_t indexThroughArray = 0; indexThroughArray < lengthOfInputArray; indexThroughArray++)\n    {\n        if (maximumValueFoundSoFar < inputArray[indexThroughArray])\n        {\n            maximumValueFoundSoFar = inputArray[indexThroughArray];\n        }\n    }\n    return maximumValueFoundSoFar;\n}", "function_type": 36, "negative": "static struct int_vector swap(struct int_vector vec, size_t i, size_t j)\n{\n    int temp = vec.data[i];\n    vec.data[i] = vec.data[j];\n    vec.data[j] = temp;\n    return vec;\n}"}
{"anchor": "int int_vector_max(const struct int_vector vec)\n{\n    int max = vec.data[0];\n    for (size_t i = 0; i < vec.size; i++)\n    {\n        if (max < vec.data[i])\n        {\n            max = vec.data[i];\n        }\n    }\n    return max;\n}", "positive": "c\nint int_vector_max(struct int_vector *vec)\n{\n    int max = (*vec).data[0]; // or simply vec->data[0] in C99 and later\n    for (size_t i = 0; i < (*vec).size; ++i)  // or vec->size\n    {\n        if (max < (*vec).data[i])\n        {\n            max = (*vec).data[i];\n        }\n    }\n    return max;\n}", "function_type": 36, "negative": "int binary_search(const int vec[], int size, int elt)\n{\n    if (size == 0)\n    {\n        return -1;\n    }\n    int max = size;\n    int min = 0;\n\n    while (max > min)\n    {\n        int mid = (min + max) / 2;\n        if (vec[mid] == elt)\n        {\n            return mid;\n        }\n        if (vec[mid] < elt)\n        {\n            min = mid + 1;\n        }\n        else\n        {\n            max = mid;\n        }\n    }\n    return -1;\n}"}
{"anchor": "int int_vector_max(const struct int_vector vec)\n{\n    int max = vec.data[0];\n    for (size_t i = 0; i < vec.size; i++)\n    {\n        if (max < vec.data[i])\n        {\n            max = vec.data[i];\n        }\n    }\n    return max;\n}", "positive": "int findMaxValueInVector(const struct vector vec)\n{\n    // Renaming 'max' to 'highest' and 'i' to 'iterator'. It was renamed not only because they are more descriptive, \n    // but also because using shortened or cryptic identifiers could lead to confusion, especially when working on team projects.\n    int highest = vec.elements[0];\n    size_t iterator = 0;\n    \n    for (; iterator < vec.numberOfElements; iterator++)\n    {\n        if (highest < vec.elements[iterator])\n        {\n            highest = vec.elements[iterator];\n        }\n    }\n    return highest;\n}", "function_type": 36, "negative": "int height(const struct binary_tree *tree)\n{\n    if (tree == NULL)\n    {\n        return -1;\n    }\n    int max = 0;\n    int max2 = 0;\n    if (tree->left != NULL)\n    {\n        max = height(tree->left) + 1;\n    }\n    if (tree->right != NULL)\n    {\n        max2 = height(tree->right) + 1;\n    }\n    return (max < max2) ? max2 : max;\n}"}
{"anchor": "int int_vector_max(const struct int_vector vec)\n{\n    int max = vec.data[0];\n    for (size_t i = 0; i < vec.size; i++)\n    {\n        if (max < vec.data[i])\n        {\n            max = vec.data[i];\n        }\n    }\n    return max;\n}", "positive": "c\nint int_vector_max(const struct int_vector *vec)\n{\n    assert(vec != NULL); // check that vector isn't null before using it\n    \n    int max = (*vec).data[0];  // alternative way to access first element of the array inside a struct pointer\n    size_t i = 0;               // initialize counter variable outside of the while-loop\n                                // because we want it available after the termination of the loop too\n    while (i < vec->size)       // use arrow notation (->) instead of dot notation (. ) when accessing members in pointers\n    {                           \n        if (max < vec->data[i]) // use -> operator to dereference the pointer and get to the data member within struct\n        {                       \n            max = vec->data[i];\n        }                      \n        i++;                    // incrementing the index\n    }                          \n    return max;\n}\n```\n\nIn both cases you iterate over all elements of `vec` and keep track of which is the maximum so far. In case the input vector contains no elements, returning garbage value will be undefined behaviour since we don\u2019t have an initial value assigned. So always make sure your vectors are not empty before calling this function.\nRemember also that in refactoring such functions, it's crucial to ensure correct", "function_type": 36, "negative": "int size(const struct binary_tree *tree)\n{\n    if (tree == NULL)\n    {\n        return 0;\n    }\n    int res = 1;\n    if (tree->left != NULL)\n    {\n        res += size(tree->left);\n    }\n    if (tree->right != NULL)\n    {\n        res += size(tree->right);\n    }\n    return res;\n}"}
{"anchor": "void mat_mult(int **mat1, int **mat2, size_t *matrices_size, int **out)\n{\n    size_t m1l = *matrices_size;\n    size_t m1c = *(matrices_size + 1);\n    size_t m2c = *(matrices_size + 2);\n\n    for (size_t i = 0; i < m1l; i++)\n    {\n        for (size_t j = 0; j < m2c; j++)\n        {\n            out[i][j] = 0;\n            for (size_t k = 0; k < m1c; k++)\n            {\n                out[i][j] += mat1[i][k] * mat2[k][j];\n            }\n        }\n    }\n}", "positive": "c\nvoid mat_mult(int **mat1, int **mat2, size_t *matrices_size, int **out) \n{\n    size_t m1l = matrices_size[0]; // rows in first matrix\n    size_t m1c = matrices_size[1]; // columns in first matrix\n    size_t m2c = matrices_size[3]; // columns in second matrix\n  \n    for (size_t i = 0; i < m1l; ++i)\n    {\n        for (size_t j = 0; j < m2c; ++j)\n        {\n            register int acc = 0; // accumulator to avoid repeated accesses to memory\n            \n            for (register size_t k = 0; k < m1c; ++k)\n            {\n               acc += mat1[i][k]*mat2[k][j]; // multiplication and addition are atomic operations on modern hardware\n            }\n      \n            out[i][j]=acc; // save result\n        }\n    }\n}", "function_type": 36, "negative": "int my_memcmp(const void *s1, const void *s2, size_t num)\n{\n    const char *r1 = s1;\n    const char *r2 = s2;\n    size_t i = 0;\n    while (i < num && r1[i] == r2[i])\n    {\n        i++;\n    }\n    if (i == num)\n    {\n        return 0;\n    }\n    if (r1[i] < r2[i])\n    {\n        return -1;\n    }\n    else\n    {\n        return 1;\n    }\n}"}
{"anchor": "void mat_mult(int **mat1, int **mat2, size_t *matrices_size, int **out)\n{\n    size_t m1l = *matrices_size;\n    size_t m1c = *(matrices_size + 1);\n    size_t m2c = *(matrices_size + 2);\n\n    for (size_t i = 0; i < m1l; i++)\n    {\n        for (size_t j = 0; j < m2c; j++)\n        {\n            out[i][j] = 0;\n            for (size_t k = 0; k < m1c; k++)\n            {\n                out[i][j] += mat1[i][k] * mat2[k][j];\n            }\n        }\n    }\n}", "positive": "void mat_mult(const matrices_info_t* mat1, const matrices_info_t* mat2, matrices_info_t* out){\n    \n    if(mat1->cols != mat2->rows || mat1->rows != out->rows ||  mat2->cols != out->cols) return; // Invalid dimensions\n\n    for(size_t i = 0; i < mat1->rows; ++i){\n        for(size_t j = 0; j < mat2->cols; ++j){\n           MATRIXINFO(*out, i, j) = 0;\n            \n            for(size_t k = 0; k < mat1->cols; ++k){\n              MATRIXINFO(*out, i, j) +=  MATRIXINFO(*mat1, i, k)*MATRIXINFO(*mat2, k, j", "function_type": 37, "negative": "void int_vector_print(const struct int_vector vec)\n{\n    for (size_t i = 0; i < vec.size; i++)\n    {\n        printf(\"%d\", vec.data[i]);\n        if (i + 1 != vec.size)\n        {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n}"}
{"anchor": "void mat_mult(int **mat1, int **mat2, size_t *matrices_size, int **out)\n{\n    size_t m1l = *matrices_size;\n    size_t m1c = *(matrices_size + 1);\n    size_t m2c = *(matrices_size + 2);\n\n    for (size_t i = 0; i < m1l; i++)\n    {\n        for (size_t j = 0; j < m2c; j++)\n        {\n            out[i][j] = 0;\n            for (size_t k = 0; k < m1c; k++)\n            {\n                out[i][j] += mat1[i][k] * mat2[k][j];\n            }\n        }\n    }\n}", "positive": "void mat_mult(const int* const* mat1, const int* const* mat2, \n              ptrdiff_t matrices_size[3], int** out)\n{\n    ptrdiff_t m1r = matrices_size[0]; // num of rows in Matrix 1\n    ptrdiff_t m1c = matrices_size[1]; // num of columns in Matrix 1\n    ptrdiff_t m2c = matrices_size[2]; // num of columns in Matrix 2\n    \n    for (ptrdiff_t r = 0; r < m1r; ++r)\n    {\n        for (ptrdiff_t c = 0; c < m2c; ++c)\n        {\n            register int sum = 0;\n            \n            for (ptrdiff_t i = 0; i < m1c; ++i)\n            {\n                sum += mat1[r][i] * mat2[i][c];\n            }\n          \n            out[r][c] = sum;\n        }\n    }\n}", "function_type": 37, "negative": "void apply_lut(unsigned char mat[4][4], const unsigned char lut[256])\n{\n    for (int i = 0; i < 4; i++)\n    {\n        for (int j = 0; j < 4; j++)\n        {\n            mat[i][j] = lut[mat[i][j]];\n        }\n    }\n}"}
{"anchor": "void mat_mult(int **mat1, int **mat2, size_t *matrices_size, int **out)\n{\n    size_t m1l = *matrices_size;\n    size_t m1c = *(matrices_size + 1);\n    size_t m2c = *(matrices_size + 2);\n\n    for (size_t i = 0; i < m1l; i++)\n    {\n        for (size_t j = 0; j < m2c; j++)\n        {\n            out[i][j] = 0;\n            for (size_t k = 0; k < m1c; k++)\n            {\n                out[i][j] += mat1[i][k] * mat2[k][j];\n            }\n        }\n    }\n}", "positive": "void mat_mult(const int **mat1, const int **mat2, const size_t matrices_size[3], int **out) \n{\n    // Get matrix dimensions from the 'matrices_size' array\n    size_t m1_lines   = matrices_size[0];\n    size_t m1_columns = matrices_size[1];\n    size_t m2_columns = matrices_size[2];\n    \n    // Intermediate variable to store current element of result matrix\n    int temp;  \n    \n    // Multiply the matrices and save results in output matrix\n    for (size_t line = 0; line < m1_lines; ++line){\n        for (size_t column = 0; column < m2_columns; ++column){\n            \n            // Initialize result at position [line][column] as zero\n            out[line][column]=0;  \n            \n            for (size_t commonDimension = 0; commonDimension < m1_columns; ++commonDimension){\n                \n                /* \n                    Compute product of elements on each dimension of the input matrices\n                    and add them up to get corresponding value in the resulting matrix\n                */\n                temp  = mat1[line][commonDimension]*mat2[common", "function_type": 37, "negative": "void map(int *array, size_t len, void (*func)(int *))\n{\n    for (size_t i = 0; i < len; i++)\n    {\n        func(&array[i]);\n    }\n}"}
{"anchor": "int int_palindrome(int n)\n{\n    if (n < 0)\n    {\n        return 0;\n    }\n    if (n < 10)\n    {\n        return 1;\n    }\n\n    int fin = 1;\n    int cop = n;\n    while (cop > 10)\n    {\n        cop = cop / 10;\n        fin = fin * 10;\n    }\n    int deb = 1;\n    while (fin > deb && (n / fin) % 10 == (n / deb) % 10)\n    {\n        deb = deb * 10;\n        fin = fin / 10;\n    }\n    return fin <= deb;\n}", "positive": "c\nbool is_palindrome(unsigned int number)\n{\n    unsigned int reversed_number = 0;\n    unsigned int original_number = number;\n    \n    // Reverse the input number using a do-while loop\n    do {\n        reversed_number = (reversed_number*10) + (number%10);\n        number /= 10;\n    } while(number != 0);\n    \n    // Check whether the reverse and original numbers are equal or not\n    return original_number == reversed_number;\n}", "function_type": 37, "negative": "int int_sqrt(int n)\n{\n    if (n < 0)\n    {\n        return -1;\n    }\n    else\n    {\n        int i = 0;\n        while (i * i <= n)\n        {\n            i++;\n        }\n        return i - 1;\n    }\n}"}
{"anchor": "void insertion_sort(void **array, f_cmp comp)\n{\n    if (array != NULL && *array != NULL)\n    {\n        for (int i = 1; array[i] != NULL; i++)\n        {\n            int j = i;\n            while (j > 0 && comp(array[j - 1], array[j]) > 0)\n            {\n                void *temp = array[j];\n                array[j] = array[j - 1];\n                array[j - 1] = temp;\n                j--;\n            }\n        }\n    }\n}", "positive": "static inline void swapElems(SortStruct* sortInfo, int i, int j){\n     void *temp = (*sortInfo).arr[j];\n     (*sortInfo).arr[j] = (*sortInfo).arr[i];\n     (*sortInfo).arr[i] = temp;\n}", "function_type": 38, "negative": "void swap(int *array, int i, int j)\n{\n    int temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n}"}
{"anchor": "void insertion_sort(void **array, f_cmp comp)\n{\n    if (array != NULL && *array != NULL)\n    {\n        for (int i = 1; array[i] != NULL; i++)\n        {\n            int j = i;\n            while (j > 0 && comp(array[j - 1], array[j]) > 0)\n            {\n                void *temp = array[j];\n                array[j] = array[j - 1];\n                array[j - 1] = temp;\n                j--;\n            }\n        }\n    }\n}", "positive": "c\nvoid insertion_swap(void **a, void **b){\n    void* tmp = *a;\n    *a = *b;\n    *b = tmp;\n}", "function_type": 39, "negative": "void array_max_min(int tab[], size_t len, int *max, int *min)\n{\n    if (tab != NULL && len != 0)\n    {\n        *max = tab[0];\n        *min = tab[0];\n        for (size_t i = 0; i < len; i++)\n        {\n            if (tab[i] > *max)\n            {\n                *max = tab[i];\n            }\n            else if (tab[i] < *min)\n            {\n                *min = tab[i];\n            }\n        }\n    }\n}"}
{"anchor": "void insertion_sort(void **array, f_cmp comp)\n{\n    if (array != NULL && *array != NULL)\n    {\n        for (int i = 1; array[i] != NULL; i++)\n        {\n            int j = i;\n            while (j > 0 && comp(array[j - 1], array[j]) > 0)\n            {\n                void *temp = array[j];\n                array[j] = array[j - 1];\n                array[j - 1] = temp;\n                j--;\n            }\n        }\n    }\n}", "positive": "c\nvoid insertion_sort(void* array[], int length, f_cmp comp)\n{\n    if (array != NULL && length > 0)\n    {\n        for (int i = 1; i < length; i++)\n        {\n            int j = i;\n            void* temp = array[j];\n            \n            // Shift elements larger than key to one position ahead\n            while (j > 0 && comp(array[j - 1], temp) > 0)\n            {\n                array[j] = array[j - 1];\n                j--;\n            }\n            \n            array[j] = temp;\n        }\n    }\n}", "function_type": 39, "negative": "void swap(int *tab, int i, int j)\n{\n    int temp = tab[i];\n    tab[i] = tab[j];\n    tab[j] = temp;\n}"}
{"anchor": "void insertion_sort(void **array, f_cmp comp)\n{\n    if (array != NULL && *array != NULL)\n    {\n        for (int i = 1; array[i] != NULL; i++)\n        {\n            int j = i;\n            while (j > 0 && comp(array[j - 1], array[j]) > 0)\n            {\n                void *temp = array[j];\n                array[j] = array[j - 1];\n                array[j - 1] = temp;\n                j--;\n            }\n        }\n    }\n}", "positive": "c\nvoid insertion_sort(void ***array, int (*comp)(const void*, const void*))\n{\n    if ((array != NULL) && (*array != NULL))\n    {\n        int len = 0;\n        // Find out how long our array is.\n        while((*array)[len] != NULL){\n            ++len;\n        }\n        \n        for (int i = 1; i < len; i++)\n        {\n            int j = i;\n            while (j > 0 && comp((*array)[j - 1], (*array)[j]) > 0)\n            {\n                void *temp = (*array)[j];\n                (*array)[j] = (*array)[j - 1];\n                (*array)[j - 1] = temp;\n                j--;\n            }\n        }\n    }\n}", "function_type": 39, "negative": "void rot_x(char *s, int x)\n{\n    if (s != NULL)\n    {\n        for (int i = 0; s[i] != '\\0'; i++)\n        {\n            if (s[i] >= 'A' && s[i] <= 'Z')\n            {\n                s[i] = (s[i] + x % 26 - 'A' + 26) % 26 + 'A';\n            }\n            else if (s[i] >= 'a' && s[i] <= 'z')\n            {\n                s[i] = (s[i] + x % 26 - 'a' + 26) % 26 + 'a';\n            }\n        }\n    }\n}"}
{"anchor": "void insertion_sort(void **array, f_cmp comp)\n{\n    if (array != NULL && *array != NULL)\n    {\n        for (int i = 1; array[i] != NULL; i++)\n        {\n            int j = i;\n            while (j > 0 && comp(array[j - 1], array[j]) > 0)\n            {\n                void *temp = array[j];\n                array[j] = array[j - 1];\n                array[j - 1] = temp;\n                j--;\n            }\n        }\n    }\n}", "positive": "c\nvoid sort_elements(void **arr, f_cmp comparison)\n{\n    if (arr != NULL && arr[0] != NULL)\n    {\n        for (size_t idx = 1; arr[idx] != NULL; ++idx)\n        {\n            size_t position = idx;\n            while (position > 0 && comparison(arr[position - 1], arr[position]) > 0)\n            {\n                void *hold = arr[position];\n                arr[position] = arr[position - 1];\n                arr[position - 1] = hold;\n                --position;\n            }\n        }\n    }\n}", "function_type": 39, "negative": "void add(struct heap *heap, int val)\n{\n    if (heap->size == heap->capacity)\n    {\n        heap->array = realloc(heap->array, sizeof(int) * heap->capacity * 2);\n        heap->capacity *= 2;\n    }\n    heap->array[heap->size] = val;\n    int i = heap->size;\n    while (heap->array[i] > heap->array[(i - 1) / 2])\n    {\n        int temp = heap->array[i];\n        heap->array[i] = heap->array[(i - 1) / 2];\n        heap->array[(i - 1) / 2] = temp;\n        i = (i - 1) / 2;\n    }\n    heap->size += 1;\n}"}
{"anchor": "static struct int_vector swap(struct int_vector vec, size_t i, size_t j)\n{\n    int temp = vec.data[i];\n    vec.data[i] = vec.data[j];\n    vec.data[j] = temp;\n    return vec;\n}", "positive": "c\nstatic struct int_vector interchange(struct int_vector vector, size_t index1, size_t index2)\n{\n    int storage = vector.data[index1];\n    vector.data[index1] = vector.data[index2];\n    vector.data[index2] = storage;\n    return vector;\n}", "function_type": 39, "negative": "int int_vector_max(const struct int_vector vec)\n{\n    int max = vec.data[0];\n    for (size_t i = 0; i < vec.size; i++)\n    {\n        if (max < vec.data[i])\n        {\n            max = vec.data[i];\n        }\n    }\n    return max;\n}"}
{"anchor": "static struct int_vector swap(struct int_vector vec, size_t i, size_t j)\n{\n    int temp = vec.data[i];\n    vec.data[i] = vec.data[j];\n    vec.data[j] = temp;\n    return vec;\n}", "positive": "c\nstatic struct int_vector swap(struct int_vector vec, size_t i, size_t j)\n{\n    // Create an intermediate variable to hold value at index i\n    int tempI = vec.data[i]; \n    \n    // Create another intermediate variable to hold value at index j\n    int tempJ = vec.data[j];  \n    \n    // Swap values using these temporary variables\n    vec.data[i] = tempJ; \n    vec.data[j] = tempI;\n    \n    return vec;\n}", "function_type": 40, "negative": "void int_vector_print(const struct int_vector vec)\n{\n    for (size_t i = 0; i < vec.size; i++)\n    {\n        printf(\"%d\", vec.data[i]);\n        if (i + 1 != vec.size)\n        {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n}"}
{"anchor": "static struct int_vector swap(struct int_vector vec, size_t i, size_t j)\n{\n    int temp = vec.data[i];\n    vec.data[i] = vec.data[j];\n    vec.data[j] = temp;\n    return vec;\n}", "positive": "c\nstatic struct int_vector swap(size_t i, size_t j, struct int_vector vec) \n{\n    int temp = vec.data[i];\n    vec.data[i] = vec.data[j];\n    vec.data[j] = temp;\n    return vec;\n}", "function_type": 40, "negative": "void swap(int *array, int i, int j)\n{\n    int temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n}"}
{"anchor": "static struct int_vector swap(struct int_vector vec, size_t i, size_t j)\n{\n    int temp = vec.data[i];\n    vec.data[i] = vec.data[j];\n    vec.data[j] = temp;\n    return vec;\n}", "positive": "c\nstatic struct int_vector swap(struct int_vector vec, size_t i, size_t j)\n{\n    // Intermediate variable to hold vec.data[i] value temporarily before it's replaced by vec.data[j]\n    int temp1 = vec.data[i]; \n    \n    // Intermediate variable to hold vec.data[j] value temporarily before it's replaced by vec.data[i]\n    int temp2 = vec.data[j]; \n    \n    vec.data[i] = temp2; // Putting initial vec.data[j] into place of vec.data[i]\n    vec.data[j] = temp1; // Finally putting original vec.data[i] into place of vec.data[j]\n    \n    return vec;\n}", "function_type": 40, "negative": "int dlist_get(const struct dlist *list, size_t index)\n{\n    if (index >= list->size)\n    {\n        return -1;\n    }\n    struct dlist_item *temp = list->head;\n    while (index != 0)\n    {\n        temp = temp->next;\n        index -= 1;\n    }\n    return temp->data;\n}"}
{"anchor": "static struct int_vector swap(struct int_vector vec, size_t i, size_t j)\n{\n    int temp = vec.data[i];\n    vec.data[i] = vec.data[j];\n    vec.data[j] = temp;\n    return vec;\n}", "positive": "c\nstatic void swap(int* data, size_t length, size_t i, size_t j)\n{\n    if ((i < length) && (j < length)) {\n        int temp = data[i];\n        data[i] = data[j];\n        data[j] = temp;\n    } else {\n        printf(\"Index out of bounds.\\n\");\n    }\n}", "function_type": 40, "negative": "void swap(int *tab, int i, int j)\n{\n    int temp = tab[i];\n    tab[i] = tab[j];\n    tab[j] = temp;\n}"}
{"anchor": "int int_sqrt(int n)\n{\n    if (n < 0)\n    {\n        return -1;\n    }\n    else\n    {\n        int i = 0;\n        while (i * i <= n)\n        {\n            i++;\n        }\n        return i - 1;\n    }\n}", "positive": "c\nint int_sqrt(int n)\n{\n    if (n < 0)\n    {\n        return -1;\n    }\n    \n    int root = 0;\n    while ((root + 1) * (root + 1) <= n)\n    {\n        root++;\n    }\n    return root;\n}", "function_type": 40, "negative": "int my_round(float n)\n{\n    int a = n;\n    if (n < 0)\n    {\n        if (a - n >= 0.5)\n        {\n            a -= 1;\n        }\n    }\n    else\n    {\n        if (a - n <= -0.5)\n        {\n            a += 1;\n        }\n    }\n    return a;\n}"}
{"anchor": "int int_sqrt(int n)\n{\n    if (n < 0)\n    {\n        return -1;\n    }\n    else\n    {\n        int i = 0;\n        while (i * i <= n)\n        {\n            i++;\n        }\n        return i - 1;\n    }\n}", "positive": "c\nint integer_square_root(int number)\n{\n    if (number < 0)\n    {\n        return -1;\n    }\n    else\n    {\n        int iterator = 0;\n        while (iterator * iterator <= number)\n        {\n            iterator++;\n        }\n        return iterator - 1;\n    }\n}", "function_type": 41, "negative": "int is_alphanum(char s)\n{\n    if (s >= '0' && s <= '9')\n    {\n        return 1;\n    }\n    else if (s >= 'a' && s <= 'z')\n    {\n        return 1;\n    }\n    else if (s >= 'A' && s <= 'Z')\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}"}
{"anchor": "int int_sqrt(int n)\n{\n    if (n < 0)\n    {\n        return -1;\n    }\n    else\n    {\n        int i = 0;\n        while (i * i <= n)\n        {\n            i++;\n        }\n        return i - 1;\n    }\n}", "positive": "long long_part(int number){\n   unsigned int start=0, end = number /2 +1; /* square root cannot be more than half of input value */\n    \n   // Binary search for perfect squares \n   while (start<end){\n      unsigned int mid=(start+end)/2;\n      \n      if ((mid*mid)==number){\n         return mid;\n      }else if((mid*mid)<number){\n          start=mid + 1;\n      }else{\n           end = mid ;\n      }\n   }\n   return -1;\n}", "function_type": 41, "negative": "int main(int argc, char **argv)\n{\n    if (argc == 1)\n    {\n        printf(\"Hello World!\\n\");\n    }\n    else\n    {\n        for (int i = 1; i < argc; i++)\n        {\n            printf(\"Hello %s!\\n\", argv[i]);\n        }\n    }\n    return 0;\n}"}
{"anchor": "int int_sqrt(int n)\n{\n    if (n < 0)\n    {\n        return -1;\n    }\n    else\n    {\n        int i = 0;\n        while (i * i <= n)\n        {\n            i++;\n        }\n        return i - 1;\n    }\n}", "positive": "c\nint integer_squareroot(int number)\n{\n    if (number < 0)\n    {\n        return -1;\n    }\n    else\n    {\n        int guess = 0;\n        while (guess * guess <= number)\n        {\n            guess++;\n        }\n        return guess - 1;\n    }\n}", "function_type": 41, "negative": "unsigned int digit(int n, int k)\n{\n    if (n <= 0 || k <= 0)\n    {\n        return 0;\n    }\n    else\n    {\n        while (k != 1)\n        {\n            n = n / 10;\n            k--;\n        }\n        return n % 10;\n    }\n}"}
{"anchor": "int main(void)\n{\n    puts(\"Hello World!\");\n    return 0;\n}", "positive": "int main(void) {\n    char* message = \"Hello World!\"; // Declare and initialize variable for message\n    printf(\"%s\\n\", message);        // Print the message using printf with format specifier %s\n    \n    return 0;                       // Return statement is left intact from original version\n}", "function_type": 41, "negative": "int main(int argc, char **argv)\n{\n    if (argc == 1)\n    {\n        printf(\"Hello World!\\n\");\n    }\n    else\n    {\n        for (int i = 1; i < argc; i++)\n        {\n            printf(\"Hello %s!\\n\", argv[i]);\n        }\n    }\n    return 0;\n}"}
{"anchor": "int main(void)\n{\n    puts(\"Hello World!\");\n    return 0;\n}", "positive": "void say_hello_world() {\n    printf(\"%s\\n\", \"Hello World!\");\n}", "function_type": 42, "negative": "int main(void)\n{\n    for (int i = 0; i < 26; i++)\n    {\n        putchar(97 + i);\n        if (i != 25)\n        {\n            putchar(' ');\n        }\n    }\n    putchar('\\n');\n    return 0;\n}"}
{"anchor": "int main(void)\n{\n    puts(\"Hello World!\");\n    return 0;\n}", "positive": "Function to print a message\nvoid say_hello() {\n    printf(\"Hello \");\n}", "function_type": 42, "negative": "int main(int argc, char **argv)\n{\n    if (argc != 3)\n    {\n        return 1;\n    }\n    int nb = argv[2][0] - '0';\n    for (int i = 0; i < nb; i++)\n    {\n        puts(argv[1]);\n    }\n    return 0;\n}"}
{"anchor": "int main(void)\n{\n    puts(\"Hello World!\");\n    return 0;\n}", "positive": "int main(void)\n{\n    // Call our new helper function instead of using `puts` directly.\n    my_puts(\"Hello World!\");\n    \n    return 0;\n}", "function_type": 42, "negative": "int main(void)\n{\n    struct dlist *list = dlist_init();\n    for (int i = 0; i < 5; i++)\n    {\n        dlist_insert_at(list, i, i);\n    }\n    dlist_insert_at(list, 6, 3);\n    dlist_print(list);\n    return 0;\n}"}
{"anchor": "int main(void)\n{\n    puts(\"Hello World!\");\n    return 0;\n}", "positive": "c\nint some_other_main_function(void)\n{\n    printf(\"%s\", \"Hello World!\");\n    return 0;\n}", "function_type": 42, "negative": "int my_memcmp(const void *s1, const void *s2, size_t num)\n{\n    const char *r1 = s1;\n    const char *r2 = s2;\n    size_t i = 0;\n    while (i < num && r1[i] == r2[i])\n    {\n        i++;\n    }\n    if (i == num)\n    {\n        return 0;\n    }\n    if (r1[i] < r2[i])\n    {\n        return -1;\n    }\n    else\n    {\n        return 1;\n    }\n}"}
{"anchor": "void hanoi(unsigned n)\n{\n    hanoi_rec(n, 1, 3, 2);\n}", "positive": "c\nvoid hanoi_rec(unsigned n, int from, int to, int temp) {...}", "function_type": 42, "negative": "unsigned int number_digits_rec(unsigned int n)\n{\n    if (n < 10)\n    {\n        return 1;\n    }\n    else\n    {\n        return number_digits_rec(n / 10) + 1;\n    }\n}"}
{"anchor": "void hanoi(unsigned n)\n{\n    hanoi_rec(n, 1, 3, 2);\n}", "positive": "c\nvoid hanoi(unsigned n) {\n    unsigned i;\n    \n    for(i = 0; i < n; i++){\n        hanoi_rec((int)(pow(2.,i)-1),(1+(2*i))%4,(3+(2*i))%4,(2-(2*(n-i)))%4 );\n    }\n}", "function_type": 43, "negative": "void apply_lut(unsigned char mat[4][4], const unsigned char lut[256])\n{\n    for (int i = 0; i < 4; i++)\n    {\n        for (int j = 0; j < 4; j++)\n        {\n            mat[i][j] = lut[mat[i][j]];\n        }\n    }\n}"}
{"anchor": "void hanoi(unsigned n)\n{\n    hanoi_rec(n, 1, 3, 2);\n}", "positive": "c\nvoid hanoi(unsigned n) {\n    unsigned i;\n    \n    for (i = 0; i < n; ++i) {\n        hanoi_rec((unsigned)(pow(2., i)) - 1, 1, 3, 2);\n    }\n}", "function_type": 43, "negative": "void rec(char **map, int t[2], int i, int j)\n{\n    map[i][j] = '#';\n    if (i < t[0] && map[i + 1][j] == '.')\n    {\n        rec(map, t, i + 1, j);\n    }\n    if (i > 0 && map[i - 1][j] == '.')\n    {\n        rec(map, t, i - 1, j);\n    }\n    if (j < t[1] && map[i][j + 1] == '.')\n    {\n        rec(map, t, i, j + 1);\n    }\n    if (j > 0 && map[i][j - 1] == '.')\n    {\n        rec(map, t, i, j - 1);\n    }\n}"}
{"anchor": "void hanoi(unsigned n)\n{\n    hanoi_rec(n, 1, 3, 2);\n}", "positive": "Recursive Hanoi algorithm using pointers instead of indices\nvoid hanoi_rec(const u n) {\n     if (n > 0) {                             \n         hanoi_rec(n - 1);                    \n                                        \n         (*to)--;                           \n         (*from)++;                          \n                                            \n         hanoi_rec(n - 1);                    \n     }                                       \n}", "function_type": 43, "negative": "void init(unsigned char *lights)\n{\n    *lights = *lights & 0 << 4;\n}"}
{"anchor": "void hanoi(unsigned n)\n{\n    hanoi_rec(n, 1, 3, 2);\n}", "positive": "c\nvoid hanoi(unsigned *n)\n{\n    hanoi_rec(*n, 1, 3, 2);\n}", "function_type": 43, "negative": "void my_rol_crypt(void *data, size_t data_len, const void *key, size_t key_len)\n{\n    unsigned char *tem = data;\n    const unsigned char *te = key;\n    for (size_t i = 0; i < data_len; i++)\n    {\n        tem[i] = (tem[i] + te[i % key_len]) % 256;\n    }\n    data = tem;\n}"}
{"anchor": "int main(int argc, char **argv)\n{\n    if (argc == 1)\n    {\n        printf(\"Hello World!\\n\");\n    }\n    else\n    {\n        for (int i = 1; i < argc; i++)\n        {\n            printf(\"Hello %s!\\n\", argv[i]);\n        }\n    }\n    return 0;\n}", "positive": "void say_hello(char* name){\n   printf(\"Hello %s\\n\",name);\n}", "function_type": 43, "negative": "int main(int argc, char **argv)\n{\n    if (argc != 3)\n    {\n        return 1;\n    }\n    int nb = argv[2][0] - '0';\n    for (int i = 0; i < nb; i++)\n    {\n        puts(argv[1]);\n    }\n    return 0;\n}"}
{"anchor": "int main(int argc, char **argv)\n{\n    if (argc == 1)\n    {\n        printf(\"Hello World!\\n\");\n    }\n    else\n    {\n        for (int i = 1; i < argc; i++)\n        {\n            printf(\"Hello %s!\\n\", argv[i]);\n        }\n    }\n    return 0;\n}", "positive": "int main()\n{\n    // Read arguments into variables declared above\n    readArgs(&argc, &argv);\n    \n    // Check number of arguments using previously declared variable\n    if (argc == 1)\n    {\n        printMessage(hello_string);\n    }\n    else\n    {\n        for (i = 1; i < argc; i++)\n        {\n            printFormattedMessage(hello_string, argv[i], hello_name_format);\n        }\n    }\n  \n    return 0;\n}", "function_type": 44, "negative": "int main(void)\n{\n    puts(\"Hello World!\");\n    return 0;\n}"}
{"anchor": "int main(int argc, char **argv)\n{\n    if (argc == 1)\n    {\n        printf(\"Hello World!\\n\");\n    }\n    else\n    {\n        for (int i = 1; i < argc; i++)\n        {\n            printf(\"Hello %s!\\n\", argv[i]);\n        }\n    }\n    return 0;\n}", "positive": "c\nint main(int argc, char **argv)\n{\n    if (argc == 1)\n    {\n        printf(\"Hello World!\\n\");\n    }\n    else\n    {\n\t\tint i=1; /* initialization */\n    \twhile(i<argc){ /* condition check */\n        \tprintf(\"Hello %s!\\n\", argv[i]); /* action */\n\t\t\ti = i + 1; /* incrementation or decrementation */\n      \t}\n    }\n    return 0;\n}", "function_type": 44, "negative": "void sieve(int n)\n{\n    if (n > 2)\n    {\n        int res = 0;\n        char *list = calloc(n, 1);\n        for (long i = 2; i < n; i++)\n        {\n            if (list[i] == 0)\n            {\n                res++;\n                for (long j = i; j < n; j += i)\n                {\n                    list[j] = 1;\n                }\n            }\n        }\n        free(list);\n        printf(\"%d\\n\", res);\n    }\n}"}
{"anchor": "int main(int argc, char **argv)\n{\n    if (argc == 1)\n    {\n        printf(\"Hello World!\\n\");\n    }\n    else\n    {\n        for (int i = 1; i < argc; i++)\n        {\n            printf(\"Hello %s!\\n\", argv[i]);\n        }\n    }\n    return 0;\n}", "positive": "c\nint main(int argc, char **argv)\n{\n    int i;\n    \n    if (argc == 1)\n    {\n        printf(\"Hello World!\\n\");\n    }\n    else\n    {\n        i=1;\n        while (i<argc){\n           printf(\"Hello %s!\\n\", argv[i]);\n\t   i++;\n\t}\n    }\n    return 0;\n}", "function_type": 44, "negative": "void variant_display(const struct variant *e)\n{\n    if (e->type == TYPE_INT)\n        printf(\"%d\\n\", e->value.int_v);\n    if (e->type == TYPE_FLOAT)\n        printf(\"%f\\n\", e->value.float_v);\n    if (e->type == TYPE_CHAR)\n        printf(\"%c\\n\", e->value.char_v);\n    if (e->type == TYPE_STRING)\n        printf(\"%s\\n\", e->value.str_v);\n}"}
{"anchor": "unsigned int greatest_divisor(unsigned int n)\n{\n    unsigned int res = 2;\n    while (n % res != 0 && res * res <= n)\n    {\n        res += 1;\n    }\n    if (n % res == 0)\n    {\n        return n / res;\n    }\n    else\n    {\n        return 1;\n    }\n}", "positive": "c\nunsigned int greatest_divisor(unsigned int n)\n{\n    unsigned int i;\n    for (i = n - 1; i > 0; --i)\n    {\n        if (n % i == 0)\n            return n / i;\n    }\n    return 1;\n}", "function_type": 44, "negative": "unsigned int digit(int n, int k)\n{\n    if (n <= 0 || k <= 0)\n    {\n        return 0;\n    }\n    else\n    {\n        while (k != 1)\n        {\n            n = n / 10;\n            k--;\n        }\n        return n % 10;\n    }\n}"}
{"anchor": "unsigned int greatest_divisor(unsigned int n)\n{\n    unsigned int res = 2;\n    while (n % res != 0 && res * res <= n)\n    {\n        res += 1;\n    }\n    if (n % res == 0)\n    {\n        return n / res;\n    }\n    else\n    {\n        return 1;\n    }\n}", "positive": "c\nunsigned int greatest_divisor(unsigned int n)\n{\n    unsigned int divisor = n - 1;\n    for (; divisor >= 2 ; --divisor)\n    {\n        if ((n % divisor) == 0)\n            break;\n    }\n    \n    return n / divisor;\n}", "function_type": 45, "negative": "unsigned array_min(const int arr[], unsigned start, unsigned size)\n{\n    unsigned res = start;\n    for (size_t i = start; i < size; i++)\n    {\n        if (arr[i] < arr[res])\n        {\n            res = i;\n        }\n    }\n    return res;\n}"}
{"anchor": "unsigned int greatest_divisor(unsigned int n)\n{\n    unsigned int res = 2;\n    while (n % res != 0 && res * res <= n)\n    {\n        res += 1;\n    }\n    if (n % res == 0)\n    {\n        return n / res;\n    }\n    else\n    {\n        return 1;\n    }\n}", "positive": "c\nunsigned int greatest_divisor(unsigned int n)\n{\n    // Added variable for clarity and to avoid misunderstandings about what is being incremented in each loop iteration\n    unsigned int potentialDivisor = 2;\n    \n    while ((n % potentialDivisor) != 0 && (potentialDivisor * potentialDivisor) <= n)\n    {\n        potentialDivisor += 1;\n    }\n    \n    if (n % potentialDivisor == 0)\n    {\n        return n / potentialDivisor;\n    }\n    else\n    {\n        return 1;\n    }\n}", "function_type": 45, "negative": "unsigned int is_set(unsigned int value, unsigned char n)\n{\n    unsigned int temp = 1 << (n - 1);\n    return (value & temp) == temp;\n}"}
{"anchor": "unsigned int greatest_divisor(unsigned int n)\n{\n    unsigned int res = 2;\n    while (n % res != 0 && res * res <= n)\n    {\n        res += 1;\n    }\n    if (n % res == 0)\n    {\n        return n / res;\n    }\n    else\n    {\n        return 1;\n    }\n}", "positive": "c\nunsigned int greatest_divisor(unsigned int n)\n{\n    unsigned int res = 2;\n    unsigned int temp = n; // Create a variable to store 'n' for calculation purposes\n    \n    while ((temp % res != 0) && (res * res <= n))\n    {\n        res += 1;\n    }\n    \n    if (temp % res == 0) // Check original value of 'n', not its updated state\n    {\n        return n / res;   // Return result based on original 'n' value\n    }\n    else\n    {\n        return 1;         // If no divisors found, return 1 as it is the smallest prime number\n    }\n}", "function_type": 45, "negative": "int my_pow(int a, int b)\n{\n    if (b == 0)\n    {\n        return 1;\n    }\n    else\n    {\n        int res = a;\n        int reste = 1;\n        while (b > 1)\n        {\n            if (b % 2 == 0)\n            {\n                res *= res;\n                b /= 2;\n            }\n            else\n            {\n                reste *= res;\n                res *= res;\n                b = (b - 1) / 2;\n            }\n        }\n        return res * reste;\n    }\n}"}
{"anchor": "void swap(int *array, int i, int j)\n{\n    int temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n}", "positive": "c\nvoid interchange(int *arrangement, int pos1, int pos2)\n{\n    int momentary_occupant = arrangement[pos1];\n    arrangement[pos1] = arrangement[pos2];\n    arrangement[pos2] = momentary_occupant;\n}", "function_type": 45, "negative": "void swap(int *tab, int i, int j)\n{\n    int temp = tab[i];\n    tab[i] = tab[j];\n    tab[j] = temp;\n}"}
{"anchor": "void swap(int *array, int i, int j)\n{\n    int temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n}", "positive": "c\nvoid swap(int i, int *pi, int *pj)\n{\n    int temp = *pi;\n    *pi = *pj;\n    *pj = temp;\n}", "function_type": 46, "negative": "void pointer_swap(int **a, int **b)\n{\n    int *temp = *a;\n    *a = *b;\n    *b = temp;\n}"}
{"anchor": "void swap(int *array, int i, int j)\n{\n    int temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n}", "positive": "c\nvoid swap(int *array, int i, int j)\n{\n    // Intermediate variable to store value at position 'i' before it gets overwritten\n    int temporary_storage_for_position_i = array[i]; \n    \n    // Overwrite value at position 'i' with value at position 'j'\n    array[i] = array[j]; \n    \n    // Finally, put original value from position 'i' in position 'j'\n    array[j] = temporary_storage_for_position_i;  \n}", "function_type": 46, "negative": "void insertion_sort(void **array, f_cmp comp)\n{\n    if (array != NULL && *array != NULL)\n    {\n        for (int i = 1; array[i] != NULL; i++)\n        {\n            int j = i;\n            while (j > 0 && comp(array[j - 1], array[j]) > 0)\n            {\n                void *temp = array[j];\n                array[j] = array[j - 1];\n                array[j - 1] = temp;\n                j--;\n            }\n        }\n    }\n}"}
{"anchor": "void swap(int *array, int i, int j)\n{\n    int temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n}", "positive": "c\nvoid interchange(int *arrangement, int a, int b)\n{\n    int intermediary = arrangement[a];\n    arrangement[a] = arrangement[b];\n    arrangement[b] = intermediary;\n}", "function_type": 46, "negative": "static struct int_vector swap(struct int_vector vec, size_t i, size_t j)\n{\n    int temp = vec.data[i];\n    vec.data[i] = vec.data[j];\n    vec.data[j] = temp;\n    return vec;\n}"}
{"anchor": "void swap(int *array, int i, int j)\n{\n    int temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n}", "positive": "c\nvoid swap_intermediate(int *array, int i, int j)\n{\n    // New variable to hold value at position 'i' temporarily\n    int tempI = array[i]; \n    \n    // New variable to hold value at position 'j' temporarily\n    int tempJ = array[j]; \n  \n    // Swap values by assigning them back to their respective positions in the array\n    array[i] = tempJ; \n    array[j] = tempI;\n}", "function_type": 46, "negative": "void add(struct heap *heap, int val)\n{\n    if (heap->size == heap->capacity)\n    {\n        heap->array = realloc(heap->array, sizeof(int) * heap->capacity * 2);\n        heap->capacity *= 2;\n    }\n    heap->array[heap->size] = val;\n    int i = heap->size;\n    while (heap->array[i] > heap->array[(i - 1) / 2])\n    {\n        int temp = heap->array[i];\n        heap->array[i] = heap->array[(i - 1) / 2];\n        heap->array[(i - 1) / 2] = temp;\n        i = (i - 1) / 2;\n    }\n    heap->size += 1;\n}"}
{"anchor": "void p_rec(const struct heap *heap, size_t i)\n{\n    printf(\" %d\", heap->array[i]);\n    if (i * 2 + 1 < heap->size)\n    {\n        p_rec(heap, i * 2 + 1);\n    }\n    if (i * 2 + 2 < heap->size)\n    {\n        p_rec(heap, i * 2 + 2);\n    }\n}", "positive": "c\nstatic void print_node(const struct heap *heap, size_t i)\n{\n    printf(\" %d\", heap->array[i]);\n}", "function_type": 46, "negative": "void int_vector_print(const struct int_vector vec)\n{\n    for (size_t i = 0; i < vec.size; i++)\n    {\n        printf(\"%d\", vec.data[i]);\n        if (i + 1 != vec.size)\n        {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n}"}
{"anchor": "void p_rec(const struct heap *heap, size_t i)\n{\n    printf(\" %d\", heap->array[i]);\n    if (i * 2 + 1 < heap->size)\n    {\n        p_rec(heap, i * 2 + 1);\n    }\n    if (i * 2 + 2 < heap->size)\n    {\n        p_rec(heap, i * 2 + 2);\n    }\n}", "positive": "c\nvoid p_rec(const struct heap *heap, size_t i)\n{\n    int left = 2*i+1; //left child of node at index i is always 2*i+1\n    int right = 2*i+2;//right child of node at index i is always 2*i+2\n    \n    printf(\" %d\", heap->array[i]);\n  \n    if ((size_t)left<heap->size){\n        p_rec(heap, left);\n    }\n      \n    if ((size_t)right<heap->size){\n      p_rec(heap, right);\n    }\n}", "function_type": 47, "negative": "void variant_display(const struct variant *e)\n{\n    if (e->type == TYPE_INT)\n        printf(\"%d\\n\", e->value.int_v);\n    if (e->type == TYPE_FLOAT)\n        printf(\"%f\\n\", e->value.float_v);\n    if (e->type == TYPE_CHAR)\n        printf(\"%c\\n\", e->value.char_v);\n    if (e->type == TYPE_STRING)\n        printf(\"%s\\n\", e->value.str_v);\n}"}
{"anchor": "void p_rec(const struct heap *heap, size_t i)\n{\n    printf(\" %d\", heap->array[i]);\n    if (i * 2 + 1 < heap->size)\n    {\n        p_rec(heap, i * 2 + 1);\n    }\n    if (i * 2 + 2 < heap->size)\n    {\n        p_rec(heap, i * 2 + 2);\n    }\n}", "positive": "c\nvoid r_rec(const struct heap_tree *tree, size_t nodeIndex)\n{\n    printf(\" %d\", tree->nodes[nodeIndex].value);\n    \n    size_t leftChild = nodeIndex * 2 + 1;\n    if (leftChild < tree->nodesCount)\n    {\n        r_rec(tree, leftChild);\n    }\n  \n    size_t rightChild = nodeIndex * 2 + 2;\n    if (rightChild < tree->nodesCount)\n    {\n        r_rec(tree, rightChild);\n    }\n}", "function_type": 47, "negative": "void dlist_print(const struct dlist *list)\n{\n    if (list->size != 0)\n    {\n        struct dlist_item *temp = list->head;\n        while (temp != NULL)\n        {\n            printf(\"%d\\n\", temp->data);\n            temp = temp->next;\n        }\n    }\n}"}
{"anchor": "void p_rec(const struct heap *heap, size_t i)\n{\n    printf(\" %d\", heap->array[i]);\n    if (i * 2 + 1 < heap->size)\n    {\n        p_rec(heap, i * 2 + 1);\n    }\n    if (i * 2 + 2 < heap->size)\n    {\n        p_rec(heap, i * 2 + 2);\n    }\n}", "positive": "c\nvoid p_rec(const struct heap *heap, size_t i)\n{\n    int leftChildIndex = i*2+1;\n    int rightChildIndex = i*2+2;\n    \n    printf(\" %d\", heap->array[i]);\n    \n    if (leftChildIndex < heap->size)\n    {\n        p_rec(heap, leftChildIndex);\n    }\n    if (rightChildIndex < heap->size)\n    {\n        p_rec(heap, rightChildIndex);\n    }\n}", "function_type": 47, "negative": "void print_complex(struct complex a)\n{\n    if (a.img < 0)\n    {\n        printf(\"complex(%1.2f - %1.2fi)\\n\", a.real, a.img * (-1));\n    }\n    else\n    {\n        printf(\"complex(%1.2f + %1.2fi)\\n\", a.real, a.img);\n    }\n}"}
{"anchor": "void delete_heap(struct heap *heap)\n{\n    free(heap->array);\n    free(heap);\n}", "positive": "c\nvoid removeHeapData(struct binaryTree *binaryTree)\n{\n    free(binaryTree->nodeArray);\n    free(binaryTree);\n}", "function_type": 47, "negative": "void p_rec(const struct heap *heap, size_t i)\n{\n    printf(\" %d\", heap->array[i]);\n    if (i * 2 + 1 < heap->size)\n    {\n        p_rec(heap, i * 2 + 1);\n    }\n    if (i * 2 + 2 < heap->size)\n    {\n        p_rec(heap, i * 2 + 2);\n    }\n}"}
{"anchor": "void delete_heap(struct heap *heap)\n{\n    free(heap->array);\n    free(heap);\n}", "positive": "c\nvoid remove_memory_pool(struct memoryPool *memoryPool)\n{\n    free(memoryPool->dataArray);\n    free(memoryPool);\n}", "function_type": 48, "negative": "void add(struct heap *heap, int val)\n{\n    if (heap->size == heap->capacity)\n    {\n        heap->array = realloc(heap->array, sizeof(int) * heap->capacity * 2);\n        heap->capacity *= 2;\n    }\n    heap->array[heap->size] = val;\n    int i = heap->size;\n    while (heap->array[i] > heap->array[(i - 1) / 2])\n    {\n        int temp = heap->array[i];\n        heap->array[i] = heap->array[(i - 1) / 2];\n        heap->array[(i - 1) / 2] = temp;\n        i = (i - 1) / 2;\n    }\n    heap->size += 1;\n}"}
{"anchor": "void delete_heap(struct heap *heap)\n{\n    free(heap->array);\n    free(heap);\n}", "positive": "c\nvoid delete_heap(struct heap *heap)\n{\n    void *temp = heap->array;\n    void *temp2 = heap;\n    \n    free(temp);\n    free(temp2);\n}", "function_type": 48, "negative": "void fifo_clear(struct fifo *fifo)\n{\n    while (fifo->head != NULL)\n    {\n        struct list *temp = fifo->head;\n        fifo->head = fifo->head->next;\n        free(temp);\n    }\n    fifo->size = 0;\n}"}
{"anchor": "void delete_heap(struct heap *heap)\n{\n    free(heap->array);\n    free(heap);\n}", "positive": "c\nvoid delete_heap(struct heap **heap)\n{\n    if (*heap == NULL){\n        return;\n    }\n    \n    free((*heap)->array);\n    free(*heap);\n    *heap = NULL; // Set pointer to null after deletion\n}", "function_type": 48, "negative": "void vector_destroy(struct vector *v)\n{\n    free(v->data);\n    free(v);\n}"}
{"anchor": "void add(struct heap *heap, int val)\n{\n    if (heap->size == heap->capacity)\n    {\n        heap->array = realloc(heap->array, sizeof(int) * heap->capacity * 2);\n        heap->capacity *= 2;\n    }\n    heap->array[heap->size] = val;\n    int i = heap->size;\n    while (heap->array[i] > heap->array[(i - 1) / 2])\n    {\n        int temp = heap->array[i];\n        heap->array[i] = heap->array[(i - 1) / 2];\n        heap->array[(i - 1) / 2] = temp;\n        i = (i - 1) / 2;\n    }\n    heap->size += 1;\n}", "positive": "void minHeapAdd(struct heap *h, int value){\n    \n    if( h->size == h->capacity ){\n       h->array=realloc(h->array,sizeof(int)*h->capacity*2);\n       h->capacity *= 2;\n    }\n  \n    h->array[ h->size ] = value; // Add element to end of array\n    int current_index = h->size ;// Index of recently added item\n  \n    while( h->array[current_index] < h->array[parent(current_index)] && current_index > 0 ){\n      /* Swap newly inserted element with its parent until it is greater than its parent or we reach root node*/\n         \n         int tmp = h->array[current_index];          \n         h->array[current_index] =  h->array[parent(current_index)];\n         h->array[parent(current_index)] = tmp;               \n            \n         current_index  = parent(current_index); // Move up one level in tree\n    }\n    ++h->size;\n}", "function_type": 48, "negative": "void p_rec(const struct heap *heap, size_t i)\n{\n    printf(\" %d\", heap->array[i]);\n    if (i * 2 + 1 < heap->size)\n    {\n        p_rec(heap, i * 2 + 1);\n    }\n    if (i * 2 + 2 < heap->size)\n    {\n        p_rec(heap, i * 2 + 2);\n    }\n}"}
{"anchor": "void add(struct heap *heap, int val)\n{\n    if (heap->size == heap->capacity)\n    {\n        heap->array = realloc(heap->array, sizeof(int) * heap->capacity * 2);\n        heap->capacity *= 2;\n    }\n    heap->array[heap->size] = val;\n    int i = heap->size;\n    while (heap->array[i] > heap->array[(i - 1) / 2])\n    {\n        int temp = heap->array[i];\n        heap->array[i] = heap->array[(i - 1) / 2];\n        heap->array[(i - 1) / 2] = temp;\n        i = (i - 1) / 2;\n    }\n    heap->size += 1;\n}", "positive": "c\nvoid add_refactor(struct heap *heap, int val)\n{\n    if (heap->size == heap->capacity)\n    {\n        heap->array = realloc(heap->array, sizeof(int) * heap->capacity * 2);\n        heap->capacity *= 2;\n    }\n    \n    heap->array[heap->size] = val;\n    int currentIndex = heap->size;\n    int parentIndex = (currentIndex - 1) / 2;\n    \n    // Swapping until correct order is maintained in maxHeap\n    while (currentIndex > 0 && heap->array[parentIndex] < heap->array[currentIndex])\n    {\n        int tmp = heap->array[currentIndex];\n        heap->array[currentIndex] = heap->array[parentIndex];\n        heap->array[parentIndex] = tmp;\n        \n        currentIndex = parentIndex;\n        parentIndex = (currentIndex - 1) / 2;\n    }\n  \n    heap->size += 1;\n}", "function_type": 49, "negative": "void int_vector_print(const struct int_vector vec)\n{\n    for (size_t i = 0; i < vec.size; i++)\n    {\n        printf(\"%d\", vec.data[i]);\n        if (i + 1 != vec.size)\n        {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n}"}
{"anchor": "void add(struct heap *heap, int val)\n{\n    if (heap->size == heap->capacity)\n    {\n        heap->array = realloc(heap->array, sizeof(int) * heap->capacity * 2);\n        heap->capacity *= 2;\n    }\n    heap->array[heap->size] = val;\n    int i = heap->size;\n    while (heap->array[i] > heap->array[(i - 1) / 2])\n    {\n        int temp = heap->array[i];\n        heap->array[i] = heap->array[(i - 1) / 2];\n        heap->array[(i - 1) / 2] = temp;\n        i = (i - 1) / 2;\n    }\n    heap->size += 1;\n}", "positive": "c\nvoid refactor_add(struct heap *myHeap, int myVal)\n{\n    if (myHeap->size == myHeap->capacity)\n    {\n        myHeap->array = realloc(myHeap->array, sizeof(int) * myHeap->capacity * 2);\n        myHeap->capacity *= 2;\n    }\n    myHeap->array[myHeap->size] = myVal;\n    int currentIndex = myHeap->size;\n    while (myHeap->array[currentIndex] > myHeap->array[(currentIndex - 1) / 2])\n    {\n        int temp = myHeap->array[currentIndex];\n        myHeap->array[currentIndex] = myHeap->array[(currentIndex - 1) / 2];\n        myHeap->array[(currentIndex - 1) / 2] = temp;\n        currentIndex = (currentIndex - 1) / 2;\n    }\n    myHeap->size += 1;\n}", "function_type": 49, "negative": "void array_max_min(int tab[], size_t len, int *max, int *min)\n{\n    if (tab != NULL && len != 0)\n    {\n        *max = tab[0];\n        *min = tab[0];\n        for (size_t i = 0; i < len; i++)\n        {\n            if (tab[i] > *max)\n            {\n                *max = tab[i];\n            }\n            else if (tab[i] < *min)\n            {\n                *min = tab[i];\n            }\n        }\n    }\n}"}
{"anchor": "void add(struct heap *heap, int val)\n{\n    if (heap->size == heap->capacity)\n    {\n        heap->array = realloc(heap->array, sizeof(int) * heap->capacity * 2);\n        heap->capacity *= 2;\n    }\n    heap->array[heap->size] = val;\n    int i = heap->size;\n    while (heap->array[i] > heap->array[(i - 1) / 2])\n    {\n        int temp = heap->array[i];\n        heap->array[i] = heap->array[(i - 1) / 2];\n        heap->array[(i - 1) / 2] = temp;\n        i = (i - 1) / 2;\n    }\n    heap->size += 1;\n}", "positive": "c\nvoid add_refactored(struct heap *heap, int val)\n{\n    // increase size of array if necessary\n    if (heap->size == heap->capacity)\n    {\n        heap->array = realloc(heap->array, sizeof(int) * heap->capacity * 2);\n        heap->capacity *= 2;\n    }\n    \n    // insert new value at end and increment size\n    heap->array[heap->size] = val;\n    heap->size += 1;\n\n    // maintain max heap property\n    int i = heap->size - 1;\n    while (i > 0 && heap->array[i] > heap->array[(i - 1) / 2])\n    {\n        // swap elements\n        int parent = (i - 1) / 2;\n        int temp = heap->array[parent];\n        heap->array[parent] = heap->array[i];\n        heap->array[i] = temp;\n        \n        i = parent;\n    }\n}", "function_type": 49, "negative": "void swap(int *array, int i, int j)\n{\n    int temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n}"}
{"anchor": "void grade(char g)\n{\n    switch (g)\n    {\n    case 'A':\n        puts(\"Excellent\");\n        break;\n    case 'B':\n        puts(\"Good\");\n        break;\n    case 'C':\n        puts(\"Not so bad\");\n        break;\n    case 'D':\n        puts(\"Could be worse\");\n        break;\n    case 'E':\n        puts(\"Maybe next time\");\n        break;\n    case 'F':\n        puts(\"No comment\");\n        break;\n    default:\n        puts(\"Call a wild ACU\");\n    };\n}", "positive": "void grade(char g)\n{\n    int idx = 0; // index for `messages` array\n    \n    switch (g)\n    {\n    case 'A':   idx = 0; break;\n    case 'B':   idx = 1; break;\n    case 'C':   idx = 2; break;\n    case 'D':   idx = 3; break;\n    case 'E':   idx = 4; break;\n    case 'F':   idx = 5; break;\n    default:    idx = 6; \n    }\n\n    printf(\"%s\\n\", messages[idx]);\n}", "function_type": 49, "negative": "void variant_display(const struct variant *e)\n{\n    if (e->type == TYPE_INT)\n        printf(\"%d\\n\", e->value.int_v);\n    if (e->type == TYPE_FLOAT)\n        printf(\"%f\\n\", e->value.float_v);\n    if (e->type == TYPE_CHAR)\n        printf(\"%c\\n\", e->value.char_v);\n    if (e->type == TYPE_STRING)\n        printf(\"%s\\n\", e->value.str_v);\n}"}
{"anchor": "void grade(char g)\n{\n    switch (g)\n    {\n    case 'A':\n        puts(\"Excellent\");\n        break;\n    case 'B':\n        puts(\"Good\");\n        break;\n    case 'C':\n        puts(\"Not so bad\");\n        break;\n    case 'D':\n        puts(\"Could be worse\");\n        break;\n    case 'E':\n        puts(\"Maybe next time\");\n        break;\n    case 'F':\n        puts(\"No comment\");\n        break;\n    default:\n        puts(\"Call a wild ACU\");\n    };\n}", "positive": "c\nstatic void print_excellent() { puts(\"Excellent\"); }", "function_type": 50, "negative": "void handler(int sig)\n{\n    d += 1;\n    if (sig == SIGUSR1)\n    {\n        printf(\"Received %d signals.\\n\", d);\n        fflush(stdout);\n    }\n    else if (sig == SIGUSR2)\n    {\n        printf(\"Current generation: %d\\n\", g);\n        fflush(stdout);\n    }\n    else if (sig == SIGTERM)\n    {\n        g++;\n        pid_t c = fork();\n        d = 0;\n        fflush(stdout);\n        if (c != 0)\n        {\n            exit(0);\n        }\n    }\n    else if (sig == SIGINT)\n    {\n        exit(0);\n    }\n}"}
{"anchor": "void grade(char g)\n{\n    switch (g)\n    {\n    case 'A':\n        puts(\"Excellent\");\n        break;\n    case 'B':\n        puts(\"Good\");\n        break;\n    case 'C':\n        puts(\"Not so bad\");\n        break;\n    case 'D':\n        puts(\"Could be worse\");\n        break;\n    case 'E':\n        puts(\"Maybe next time\");\n        break;\n    case 'F':\n        puts(\"No comment\");\n        break;\n    default:\n        puts(\"Call a wild ACU\");\n    };\n}", "positive": "void printGradeDescription(const char *gradeDescriptions[], int numOfGrades){\n    const char* descriptions[] = {\"Excellent\", \"Good\", \"Not so bad\", \n                                  \"Could be worse\", \"Maybe next time\", \n                                  \"No comment\"};\n\n    for(int i = 0; i < numOfGrades; ++i) {\n        if(gradeDescriptions[i] != NULL){\n            printf(\"%s\\n\", gradeDescriptions[i]);    \n        } else {\n            printf(\"Call a wild ACU\\n\");   //default case in original program\n        }\n    }\n}", "function_type": 50, "negative": "void sieve(int n)\n{\n    if (n > 2)\n    {\n        int res = 0;\n        char *list = calloc(n, 1);\n        for (long i = 2; i < n; i++)\n        {\n            if (list[i] == 0)\n            {\n                res++;\n                for (long j = i; j < n; j += i)\n                {\n                    list[j] = 1;\n                }\n            }\n        }\n        free(list);\n        printf(\"%d\\n\", res);\n    }\n}"}
{"anchor": "void grade(char g)\n{\n    switch (g)\n    {\n    case 'A':\n        puts(\"Excellent\");\n        break;\n    case 'B':\n        puts(\"Good\");\n        break;\n    case 'C':\n        puts(\"Not so bad\");\n        break;\n    case 'D':\n        puts(\"Could be worse\");\n        break;\n    case 'E':\n        puts(\"Maybe next time\");\n        break;\n    case 'F':\n        puts(\"No comment\");\n        break;\n    default:\n        puts(\"Call a wild ACU\");\n    };\n}", "positive": "void print_comment(const char *comments[], const int length, char letter){\n  if ('A' <= letter && letter <= 'F') { // check validity of input\n    printf(\"%s\\n\", comments[letter - 'A']);\n  } else {\n    printf(\"Call a wild ACU\\n\");\n  }\n}", "function_type": 50, "negative": "void rec(char **map, int t[2], int i, int j)\n{\n    map[i][j] = '#';\n    if (i < t[0] && map[i + 1][j] == '.')\n    {\n        rec(map, t, i + 1, j);\n    }\n    if (i > 0 && map[i - 1][j] == '.')\n    {\n        rec(map, t, i - 1, j);\n    }\n    if (j < t[1] && map[i][j + 1] == '.')\n    {\n        rec(map, t, i, j + 1);\n    }\n    if (j > 0 && map[i][j - 1] == '.')\n    {\n        rec(map, t, i, j - 1);\n    }\n}"}
{"anchor": "void grade(char g)\n{\n    switch (g)\n    {\n    case 'A':\n        puts(\"Excellent\");\n        break;\n    case 'B':\n        puts(\"Good\");\n        break;\n    case 'C':\n        puts(\"Not so bad\");\n        break;\n    case 'D':\n        puts(\"Could be worse\");\n        break;\n    case 'E':\n        puts(\"Maybe next time\");\n        break;\n    case 'F':\n        puts(\"No comment\");\n        break;\n    default:\n        puts(\"Call a wild ACU\");\n    };\n}", "positive": "void print_commentary(const char *msg){\n   printf(\"%s\\n\", msg);\n}", "function_type": 50, "negative": "void cipher(const char *key, const char *msg, char *res)\n{\n    int j = 0;\n    int len = 0;\n    while (key[len] != '\\0')\n    {\n        len += 1;\n    }\n    for (int i = 0; msg[i] != 0; i++)\n    {\n        int tem = (msg[i] - 'A');\n        int kem = (key[j % len] - 'A') % 32;\n        if ((tem >= 0 && tem <= 25) || (tem >= 32 && tem <= 57))\n        {\n            res[i] = (tem % 32 + kem) % 26 + 'A';\n            j++;\n        }\n        else\n        {\n            res[i] = msg[i];\n        }\n    }\n}"}
{"anchor": "void print_complex(struct complex a)\n{\n    if (a.img < 0)\n    {\n        printf(\"complex(%1.2f - %1.2fi)\\n\", a.real, a.img * (-1));\n    }\n    else\n    {\n        printf(\"complex(%1.2f + %1.2fi)\\n\", a.real, a.img);\n    }\n}", "positive": "c\nvoid print_complex(struct complex a)\n{\n    double img = a.img;\n    \n    if (img < 0)\n    {\n        img = img * (-1); // convert to positive for printing purposes only\n    }\n\n    printf(\"complex(%1.2f %+1.2fi)\\n\", a.real, img);\n}", "function_type": 50, "negative": "void int_vector_print(const struct int_vector vec)\n{\n    for (size_t i = 0; i < vec.size; i++)\n    {\n        printf(\"%d\", vec.data[i]);\n        if (i + 1 != vec.size)\n        {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n}"}
{"anchor": "void print_complex(struct complex a)\n{\n    if (a.img < 0)\n    {\n        printf(\"complex(%1.2f - %1.2fi)\\n\", a.real, a.img * (-1));\n    }\n    else\n    {\n        printf(\"complex(%1.2f + %1.2fi)\\n\", a.real, a.img);\n    }\n}", "positive": "c\nvoid print_complex(const struct complex* a)\n{\n    if (a->img < 0)\n    {\n        printf(\"complex(%1.2f - %1.2fi)\\n\", a->real, a->img * (-1));\n    }\n    else\n    {\n        printf(\"complex(%1.2f + %1.2fi)\\n\", a->real, a->img);\n    }\n}", "function_type": 51, "negative": "void variant_display(const struct variant *e)\n{\n    if (e->type == TYPE_INT)\n        printf(\"%d\\n\", e->value.int_v);\n    if (e->type == TYPE_FLOAT)\n        printf(\"%f\\n\", e->value.float_v);\n    if (e->type == TYPE_CHAR)\n        printf(\"%c\\n\", e->value.char_v);\n    if (e->type == TYPE_STRING)\n        printf(\"%s\\n\", e->value.str_v);\n}"}
{"anchor": "void print_complex(struct complex a)\n{\n    if (a.img < 0)\n    {\n        printf(\"complex(%1.2f - %1.2fi)\\n\", a.real, a.img * (-1));\n    }\n    else\n    {\n        printf(\"complex(%1.2f + %1.2fi)\\n\", a.real, a.img);\n    }\n}", "positive": "c\nvoid print_complex(double real, double img)\n{\n    if (img >= 0)\n    {\n        printf(\"complex(%1.2f + %1.2fi)\\n\", real, img);\n    }\n    else \n    {\n        printf(\"complex(%1.2f - %1.2fi)\\n\", real, img*(-1));\n    }\n}", "function_type": 51, "negative": "void p_rec(const struct heap *heap, size_t i)\n{\n    printf(\" %d\", heap->array[i]);\n    if (i * 2 + 1 < heap->size)\n    {\n        p_rec(heap, i * 2 + 1);\n    }\n    if (i * 2 + 2 < heap->size)\n    {\n        p_rec(heap, i * 2 + 2);\n    }\n}"}
{"anchor": "void print_complex(struct complex a)\n{\n    if (a.img < 0)\n    {\n        printf(\"complex(%1.2f - %1.2fi)\\n\", a.real, a.img * (-1));\n    }\n    else\n    {\n        printf(\"complex(%1.2f + %1.2fi)\\n\", a.real, a.img);\n    }\n}", "positive": "c\nvoid print_complex(struct complex a)\n{\n    char sign = '+';\n    \n    if (a.img < 0) \n    {\n        sign = '-';\n        a.img *= -1; // make it positive for printing\n    }\n\n    printf(\"complex(%1.2f %c %1.2fi)\\n\", a.real, sign, a.img);\n}", "function_type": 51, "negative": "void handler(int sig)\n{\n    d += 1;\n    if (sig == SIGUSR1)\n    {\n        printf(\"Received %d signals.\\n\", d);\n        fflush(stdout);\n    }\n    else if (sig == SIGUSR2)\n    {\n        printf(\"Current generation: %d\\n\", g);\n        fflush(stdout);\n    }\n    else if (sig == SIGTERM)\n    {\n        g++;\n        pid_t c = fork();\n        d = 0;\n        fflush(stdout);\n        if (c != 0)\n        {\n            exit(0);\n        }\n    }\n    else if (sig == SIGINT)\n    {\n        exit(0);\n    }\n}"}
{"anchor": "int foldr(int *array, size_t len, int (*func)(int, int))\n{\n    int res = 0;\n    int le = len;\n    for (int i = le - 1; i >= 0; i--)\n    {\n        res = func(array[i], res);\n    }\n    return res;\n}", "positive": "c\nint foldr(int *array, size_t len, int (*func)(int, int))\n{\n    int result = 0;\n    \n    // Declare and initialize an additional variable to store the length of array\n    size_t lengthOfArray = len;\n    \n    // Loop backwards through the array using our new variable instead of directly on 'len'\n    for (size_t index = lengthOfArray - 1; index != SIZE_MAX && index >= 0; --index)\n    {\n        // Apply operation by passing current element and accumulated result to function pointed to by 'func'\n        result = func(array[index], result);\n    }\n    \n    return result;\n}", "function_type": 51, "negative": "int foldl(int *array, size_t len, int (*func)(int, int))\n{\n    int res = 0;\n    for (size_t i = 0; i < len; i++)\n    {\n        res = func(res, array[i]);\n    }\n    return res;\n}"}
{"anchor": "int foldr(int *array, size_t len, int (*func)(int, int))\n{\n    int res = 0;\n    int le = len;\n    for (int i = le - 1; i >= 0; i--)\n    {\n        res = func(array[i], res);\n    }\n    return res;\n}", "positive": "c\nint foldr(size_t len, int *array, int (*func)(int, int))\n{\n    int res = 0;\n    while (len > 0)\n    {\n        len--;\n        res = func(array[len], res);\n    }\n    return res;\n}", "function_type": 52, "negative": "void map(int *array, size_t len, void (*func)(int *))\n{\n    for (size_t i = 0; i < len; i++)\n    {\n        func(&array[i]);\n    }\n}"}
{"anchor": "int foldr(int *array, size_t len, int (*func)(int, int))\n{\n    int res = 0;\n    int le = len;\n    for (int i = le - 1; i >= 0; i--)\n    {\n        res = func(array[i], res);\n    }\n    return res;\n}", "positive": "c\nint foldr(const int array[], size_t len, int(*func)(int, int))\n{\n    int res = 0;\n    for (size_t i = 0; i < len; ++i) // changed from 'len' to 'len - 1' and used decrementing loop instead of decremented index\n    {\n        res = func(array[len-i-1], res); // used reverse iteration order by subtracting \"i\" from \"len\"\n    }\n    return res;\n}", "function_type": 52, "negative": "unsigned array_min(const int arr[], unsigned start, unsigned size)\n{\n    unsigned res = start;\n    for (size_t i = start; i < size; i++)\n    {\n        if (arr[i] < arr[res])\n        {\n            res = i;\n        }\n    }\n    return res;\n}"}
{"anchor": "int foldr(int *array, size_t len, int (*func)(int, int))\n{\n    int res = 0;\n    int le = len;\n    for (int i = le - 1; i >= 0; i--)\n    {\n        res = func(array[i], res);\n    }\n    return res;\n}", "positive": "c\nint foldr(int *array, size_t len, int (*func)(int, int))\n{\n    int res = 0;\n    while (len > 0)\n    {\n\t   len--;\n       res = func(array[len], res);\n    }\n    return res;\n}", "function_type": 52, "negative": "int is_sorted(int array[], size_t size)\n{\n    if (size == 0)\n    {\n        return 1;\n    }\n    else\n    {\n        size_t i = 1;\n        while (array[i - 1] <= array[i] && i < size)\n        {\n            i++;\n        }\n        return i == size;\n    }\n}"}
{"anchor": "int foldr(int *array, size_t len, int (*func)(int, int))\n{\n    int res = 0;\n    int le = len;\n    for (int i = le - 1; i >= 0; i--)\n    {\n        res = func(array[i], res);\n    }\n    return res;\n}", "positive": "c\nint foldr(const int array[], size_t len, int (*func)(int, int))\n{\n    int res = 0;\n    while (len > 0)\n    {\n        --len; // decrease length by one at a time\n        res = func(array[len], res);\n    }\n    return res;\n}", "function_type": 52, "negative": "void array_max_min(int tab[], size_t len, int *max, int *min)\n{\n    if (tab != NULL && len != 0)\n    {\n        *max = tab[0];\n        *min = tab[0];\n        for (size_t i = 0; i < len; i++)\n        {\n            if (tab[i] > *max)\n            {\n                *max = tab[i];\n            }\n            else if (tab[i] < *min)\n            {\n                *min = tab[i];\n            }\n        }\n    }\n}"}
{"anchor": "void map(int *array, size_t len, void (*func)(int *))\n{\n    for (size_t i = 0; i < len; i++)\n    {\n        func(&array[i]);\n    }\n}", "positive": "c\nvoid reMap(int **arrayOfArrays, size_t numArrays, void (*func)(int **))\n{\n    for (size_t j = 0; j < numArrays; j++)\n    {\n        func(&arrayOfArrays[j]);\n    }\n}", "function_type": 52, "negative": "int foldl(int *array, size_t len, int (*func)(int, int))\n{\n    int res = 0;\n    for (size_t i = 0; i < len; i++)\n    {\n        res = func(res, array[i]);\n    }\n    return res;\n}"}
{"anchor": "void map(int *array, size_t len, void (*func)(int *))\n{\n    for (size_t i = 0; i < len; i++)\n    {\n        func(&array[i]);\n    }\n}", "positive": "c\nvoid map(int *array, size_t len, void (*func)(int *))\n{\n    int* currElement = array;\n    size_t currIndex = 0;\n    \n    while(currIndex < len) \n    {\n        func(currElement);\n        \n        currElement++;\n        currIndex++;\n    }\n}", "function_type": 53, "negative": "void array_max_min(int tab[], size_t len, int *max, int *min)\n{\n    if (tab != NULL && len != 0)\n    {\n        *max = tab[0];\n        *min = tab[0];\n        for (size_t i = 0; i < len; i++)\n        {\n            if (tab[i] > *max)\n            {\n                *max = tab[i];\n            }\n            else if (tab[i] < *min)\n            {\n                *min = tab[i];\n            }\n        }\n    }\n}"}
{"anchor": "void map(int *array, size_t len, void (*func)(int *))\n{\n    for (size_t i = 0; i < len; i++)\n    {\n        func(&array[i]);\n    }\n}", "positive": "c\nvoid refactorMap(int **array, size_t length, void (*functionalPointer)(int *))\n{\n    for (size_t index = 0; index < length; index++)\n    {\n        functionalPointer((*array)[index]); //This line is tricky to understand since it's a 2D array\n    }\n}\n```\n\nNote: Be careful about the types of parameters and return values when you change them. In this case, '**array' and 'length' are necessary because in the original function 'map', we have an integer pointer array and its length as input parameter. We need these details to correctly implement the refactored function. If we just had 'array' and 'len' like in the refactored version, the two functions wouldn\u2019t match exactly anymore. Therefore, while it might seem more logical to use 'array' instead of '**array' and 'len' instead of 'length', if we stick strictly to the task requirements, they would still be needed.\nAlso note that `&(*array)[index]` is equivalent to `array[index]` but uses slightly less memory than `array[index]` due to optimized ways how arrays and pointers work in C language. It means \"the element at position [index]\" within the first dimension of multi-dimensional array pointed by `**array`. The second dimension can be accessed via", "function_type": 53, "negative": "int foldr(int *array, size_t len, int (*func)(int, int))\n{\n    int res = 0;\n    int le = len;\n    for (int i = le - 1; i >= 0; i--)\n    {\n        res = func(array[i], res);\n    }\n    return res;\n}"}
{"anchor": "void map(int *array, size_t len, void (*func)(int *))\n{\n    for (size_t i = 0; i < len; i++)\n    {\n        func(&array[i]);\n    }\n}", "positive": "void refactoredMap(int *start, int *end, FuncPtr func) \n{\n    for (; start != end; ++start) \n    {\n        func(start);\n    }\n}", "function_type": 53, "negative": "void int_vector_print(const struct int_vector vec)\n{\n    for (size_t i = 0; i < vec.size; i++)\n    {\n        printf(\"%d\", vec.data[i]);\n        if (i + 1 != vec.size)\n        {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n}"}
{"anchor": "int foldl(int *array, size_t len, int (*func)(int, int))\n{\n    int res = 0;\n    for (size_t i = 0; i < len; i++)\n    {\n        res = func(res, array[i]);\n    }\n    return res;\n}", "positive": "c\nint foldl(const int *array, const size_t len, const int (*func)(int, int), const int init)\n{\n    int res = init;\n    size_t i = 0;\n    while (i < len) \n    {\n        res = func(res, array[i]);\n        i++;\n    }\n    return res;\n}", "function_type": 53, "negative": "int foldr(int *array, size_t len, int (*func)(int, int))\n{\n    int res = 0;\n    int le = len;\n    for (int i = le - 1; i >= 0; i--)\n    {\n        res = func(array[i], res);\n    }\n    return res;\n}"}
{"anchor": "int foldl(int *array, size_t len, int (*func)(int, int))\n{\n    int res = 0;\n    for (size_t i = 0; i < len; i++)\n    {\n        res = func(res, array[i]);\n    }\n    return res;\n}", "positive": "c\nint reduce(const int *arr, size_t length, int (*operation)(int, int))\n{\n    int result = 0;\n    for (size_t index = 0; index < length; ++index)\n    {\n        result = operation(result, arr[index]);\n    }\n    return result;\n}", "function_type": 54, "negative": "void map(int *array, size_t len, void (*func)(int *))\n{\n    for (size_t i = 0; i < len; i++)\n    {\n        func(&array[i]);\n    }\n}"}
{"anchor": "int foldl(int *array, size_t len, int (*func)(int, int))\n{\n    int res = 0;\n    for (size_t i = 0; i < len; i++)\n    {\n        res = func(res, array[i]);\n    }\n    return res;\n}", "positive": "c\nint foldl(int *array, size_t len, int (*func)(int, int))\n{\n    int res = 0;\n    while (len-- > 0)\n    {\n        res = func(res, array[len]);\n    }\n    return res;\n}", "function_type": 54, "negative": "int is_sorted(int array[], size_t size)\n{\n    if (size == 0)\n    {\n        return 1;\n    }\n    else\n    {\n        size_t i = 1;\n        while (array[i - 1] <= array[i] && i < size)\n        {\n            i++;\n        }\n        return i == size;\n    }\n}"}
{"anchor": "int foldl(int *array, size_t len, int (*func)(int, int))\n{\n    int res = 0;\n    for (size_t i = 0; i < len; i++)\n    {\n        res = func(res, array[i]);\n    }\n    return res;\n}", "positive": "c\nint foldl(int *array, size_t len, int (*func)(int, int))\n{\n    // Intermediate variable to store result\n    int tempRes = 0; \n    \n    for (size_t i = 0; i < len; i++)\n    {\n        // Apply function on 'tempRes' and 'array[i]', then assign it back into 'tempRes'.\n        tempRes = func(tempRes, array[i]);\n    }\n  \n    // Return final value stored in 'tempRes'\n    return tempRes;\n}", "function_type": 54, "negative": "unsigned array_min(const int arr[], unsigned start, unsigned size)\n{\n    unsigned res = start;\n    for (size_t i = start; i < size; i++)\n    {\n        if (arr[i] < arr[res])\n        {\n            res = i;\n        }\n    }\n    return res;\n}"}
{"anchor": "int foldl(int *array, size_t len, int (*func)(int, int))\n{\n    int res = 0;\n    for (size_t i = 0; i < len; i++)\n    {\n        res = func(res, array[i]);\n    }\n    return res;\n}", "positive": "c\nint foldr(const int arr[], size_t len, int init, int(*func)(int, int)) \n{\n    if (!len || !arr ) \n        return init; // handle NULL cases\n    \n    /* reduce from right to left */\n    return func(init, foldr(&arr[1], len - 1, arr[0], func));\n}", "function_type": 54, "negative": "void array_max_min(int tab[], size_t len, int *max, int *min)\n{\n    if (tab != NULL && len != 0)\n    {\n        *max = tab[0];\n        *min = tab[0];\n        for (size_t i = 0; i < len; i++)\n        {\n            if (tab[i] > *max)\n            {\n                *max = tab[i];\n            }\n            else if (tab[i] < *min)\n            {\n                *min = tab[i];\n            }\n        }\n    }\n}"}
{"anchor": "size_t list_length(struct list *list)\n{\n    struct list *temp = list;\n    size_t count = 0;\n    while (temp != NULL)\n    {\n        count += 1;\n        temp = temp->next;\n    }\n    return count;\n}", "positive": "c\nsize_t list_length(struct list *list)\n{\n    struct list *currentNode = list; // Intermediate variable to keep track of current node\n    size_t lengthOfList = 0;         // Variable for counting nodes in the list\n    \n    while (currentNode != NULL)      // While there are still unprocessed nodes...\n    {\n        lengthOfList++;              // ... increase the counter by 1\n        currentNode = currentNode->next;   // Move to next node\n    }\n    return lengthOfList;             // Return the number of processed nodes\n}", "function_type": 54, "negative": "int dlist_get(const struct dlist *list, size_t index)\n{\n    if (index >= list->size)\n    {\n        return -1;\n    }\n    struct dlist_item *temp = list->head;\n    while (index != 0)\n    {\n        temp = temp->next;\n        index -= 1;\n    }\n    return temp->data;\n}"}
{"anchor": "size_t list_length(struct list *list)\n{\n    struct list *temp = list;\n    size_t count = 0;\n    while (temp != NULL)\n    {\n        count += 1;\n        temp = temp->next;\n    }\n    return count;\n}", "positive": "c\nsize_t array_length(struct list *array)\n{\n    struct list *end = array - 1;\n    size_t count = 0;\n    while (*++array != end)\n    {\n        count += 1;\n    }\n    return count;\n}", "function_type": 55, "negative": "void fifo_clear(struct fifo *fifo)\n{\n    while (fifo->head != NULL)\n    {\n        struct list *temp = fifo->head;\n        fifo->head = fifo->head->next;\n        free(temp);\n    }\n    fifo->size = 0;\n}"}
{"anchor": "size_t list_length(struct list *list)\n{\n    struct list *temp = list;\n    size_t count = 0;\n    while (temp != NULL)\n    {\n        count += 1;\n        temp = temp->next;\n    }\n    return count;\n}", "positive": "c\nsize_t refactor_list_length(struct list *list)\n{\n    size_t count = 0;\n    for (; list != NULL; list = list->next) \n    {\n        count++;\n    }\n    return count;\n}", "function_type": 55, "negative": "void dlist_print(const struct dlist *list)\n{\n    if (list->size != 0)\n    {\n        struct dlist_item *temp = list->head;\n        while (temp != NULL)\n        {\n            printf(\"%d\\n\", temp->data);\n            temp = temp->next;\n        }\n    }\n}"}
{"anchor": "int max(int *l)\n{\n    int ma = 0;\n    for (int i = 0; i < 26; i++)\n    {\n        if (l[ma] < l[i])\n        {\n            ma = i;\n        }\n    }\n    return ma;\n}", "positive": "c\nint find_maximum_index(int *arr)\n{\n    int maximum = 0;\n    for (int index = 0; index < 26; index++)\n    {\n        if (arr[maximum] < arr[index])\n        {\n            maximum = index;\n        }\n    }\n    return maximum;\n}", "function_type": 55, "negative": "int int_vector_max(const struct int_vector vec)\n{\n    int max = vec.data[0];\n    for (size_t i = 0; i < vec.size; i++)\n    {\n        if (max < vec.data[i])\n        {\n            max = vec.data[i];\n        }\n    }\n    return max;\n}"}
{"anchor": "int max(int *l)\n{\n    int ma = 0;\n    for (int i = 0; i < 26; i++)\n    {\n        if (l[ma] < l[i])\n        {\n            ma = i;\n        }\n    }\n    return ma;\n}", "positive": "initialize maximum value as smallest possible integer\n    for (size_t i = 0; i < len; i++)\n    {\n        if (maxValue < l[i])\n        {\n            maxValue = l[i];\n            ma = i;\n        }\n    }", "function_type": 56, "negative": "int main(void)\n{\n    for (int i = 0; i < 26; i++)\n    {\n        putchar(97 + i);\n        if (i != 25)\n        {\n            putchar(' ');\n        }\n    }\n    putchar('\\n');\n    return 0;\n}"}
{"anchor": "int max(int *l)\n{\n    int ma = 0;\n    for (int i = 0; i < 26; i++)\n    {\n        if (l[ma] < l[i])\n        {\n            ma = i;\n        }\n    }\n    return ma;\n}", "positive": "c\nint max(int *l)\n{\n    int index_max = 0;\n    int value_at_index_max = 0;\n    \n    // Initialize index of maximum element and its corresponding value\n    for (int i = 1; i < 26; i++) \n    {\n        if (l[i] > value_at_index_max)\n        {\n            value_at_index_max = l[i];\n            index_max = i;\n        }\n    }\n  \n    return index_max;\n}", "function_type": 56, "negative": "int int_sqrt(int n)\n{\n    if (n < 0)\n    {\n        return -1;\n    }\n    else\n    {\n        int i = 0;\n        while (i * i <= n)\n        {\n            i++;\n        }\n        return i - 1;\n    }\n}"}
{"anchor": "int max(int *l)\n{\n    int ma = 0;\n    for (int i = 0; i < 26; i++)\n    {\n        if (l[ma] < l[i])\n        {\n            ma = i;\n        }\n    }\n    return ma;\n}", "positive": "c\nint findMaxIndex(const int *array, const size_t length)\n{\n    int maximumValueIndex = 0; // renamed 'ma' to prevent confusion\n    for (size_t index = 1; index < length; ++index)  // use size_t instead of fixed number and change name from 'i' to 'index'\n    {                                               // added prefixes \"const\" to protect against unwanted modifications\n        if (array[maximumValueIndex] < array[index])  \n        {\n            maximumValueIndex = index;                 \n        }\n    }\n    return maximumValueIndex;\n}", "function_type": 56, "negative": "int binary_search(const int vec[], int size, int elt)\n{\n    if (size == 0)\n    {\n        return -1;\n    }\n    int max = size;\n    int min = 0;\n\n    while (max > min)\n    {\n        int mid = (min + max) / 2;\n        if (vec[mid] == elt)\n        {\n            return mid;\n        }\n        if (vec[mid] < elt)\n        {\n            min = mid + 1;\n        }\n        else\n        {\n            max = mid;\n        }\n    }\n    return -1;\n}"}
{"anchor": "int max(int *l)\n{\n    int ma = 0;\n    for (int i = 0; i < 26; i++)\n    {\n        if (l[ma] < l[i])\n        {\n            ma = i;\n        }\n    }\n    return ma;\n}", "positive": "define LENGTH 26\nint max(int *l)\n{\n    int ma = 0;\n    while (ma < LENGTH)\n    {\n        if (l[ma] < l[LENGTH - 1])\n        {\n            ma++;\n        } else {\n           break;\n        }\n    }\n    return ma;\n}", "function_type": 56, "negative": "int main(int argc, char **argv)\n{\n    if (argc != 3)\n    {\n        return 1;\n    }\n    int nb = argv[2][0] - '0';\n    for (int i = 0; i < nb; i++)\n    {\n        puts(argv[1]);\n    }\n    return 0;\n}"}
{"anchor": "unsigned long fibonacci(unsigned long n)\n{\n    if (n == 0)\n    {\n        return 0;\n    }\n    else if (n == 1)\n    {\n        return 1;\n    }\n    else\n    {\n        return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n}", "positive": "c\nunsigned long fibonacci_refactor(unsigned int n, unsigned long* array)\n{\n    // Base case\n    if (n < 2)\n    {\n        array[n] = n;\n    }\n    else\n    {\n      // Recursive cases\n      if (!array[n-1])\n      {\n          array[n-1] = fibonacci_refactor(n - 1, array);\n      }\n      \n      if (!array[n-2])\n      {\n          array[n-2] = fibonacci_refactor(n - 2, array);\n      }\n        \n    \tarray[n] = array[n-1] + array[n-2];\n  \t}\n  \treturn array[n];\n}", "function_type": 56, "negative": "unsigned long fact(unsigned n)\n{\n    if (n == 0)\n    {\n        return 1;\n    }\n    else\n    {\n        return fact(n - 1) * n;\n    }\n}"}
{"anchor": "unsigned long fibonacci(unsigned long n)\n{\n    if (n == 0)\n    {\n        return 0;\n    }\n    else if (n == 1)\n    {\n        return 1;\n    }\n    else\n    {\n        return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n}", "positive": "c\nvoid fibonacci_iterative(unsigned long* arr, unsigned long n){\n    \n    arr[0] = 0;\n    arr[1] = 1;\n  \n    for (unsigned long i = 2; i <= n; ++i) {\n        arr[i] = arr[i-1] + arr[i-2];\n    }\n}", "function_type": 57, "negative": "unsigned int digit(int n, int k)\n{\n    if (n <= 0 || k <= 0)\n    {\n        return 0;\n    }\n    else\n    {\n        while (k != 1)\n        {\n            n = n / 10;\n            k--;\n        }\n        return n % 10;\n    }\n}"}
{"anchor": "unsigned long fibonacci(unsigned long n)\n{\n    if (n == 0)\n    {\n        return 0;\n    }\n    else if (n == 1)\n    {\n        return 1;\n    }\n    else\n    {\n        return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n}", "positive": "c\nunsigned long fibonacci_intermediate(unsigned long n)\n{\n    unsigned long first = 0;\n    unsigned long second = 1;\n    unsigned long result = n;\n    \n    for (int i = 2; i <= n ; ++i){\n       result = first+second;\n       first=second;\n       second=result;  \n    }\n    return result;\n}", "function_type": 57, "negative": "unsigned long fibo_iter(unsigned long n)\n{\n    unsigned long u0 = 0;\n    unsigned long u1 = 1;\n    while (n > 0)\n    {\n        unsigned long temp = u1;\n        u1 += u0;\n        u0 = temp;\n        n--;\n    }\n    return u0;\n}"}
{"anchor": "unsigned long fibonacci(unsigned long n)\n{\n    if (n == 0)\n    {\n        return 0;\n    }\n    else if (n == 1)\n    {\n        return 1;\n    }\n    else\n    {\n        return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n}", "positive": "c\nstatic unsigned long fibonacci_rec(unsigned long n, unsigned long a, unsigned long b)\n{\n    if (n == 0)\n    {\n        return a;\n    }\n    else if (n == 1)\n    {\n        return b;\n    }\n    else\n    {\n        return fibonacci_rec(n - 1, b, a+b); // recursive call with new parameters\n    }\n}", "function_type": 57, "negative": "unsigned int number_digits_rec(unsigned int n)\n{\n    if (n < 10)\n    {\n        return 1;\n    }\n    else\n    {\n        return number_digits_rec(n / 10) + 1;\n    }\n}"}
{"anchor": "unsigned long fibonacci(unsigned long n)\n{\n    if (n == 0)\n    {\n        return 0;\n    }\n    else if (n == 1)\n    {\n        return 1;\n    }\n    else\n    {\n        return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n}", "positive": "c\nunsigned long fibonacci(unsigned long n)\n{\n    unsigned long a = 0;\n    unsigned long b = 1;\n    unsigned long c = 0;\n    \n    for (int i=0;i<n-1;++i){\n        c = a+b; //compute new value in sequence\n        a = b;   //shift down one step in sequence\n        b = c;   //update b with latest number in sequence\n    }\n\n    if (n==0) \n      return a;\n    else \n      return b;\n}", "function_type": 57, "negative": "int int_sqrt(int n)\n{\n    if (n < 0)\n    {\n        return -1;\n    }\n    else\n    {\n        int i = 0;\n        while (i * i <= n)\n        {\n            i++;\n        }\n        return i - 1;\n    }\n}"}
{"anchor": "unsigned long fibo_iter(unsigned long n)\n{\n    unsigned long u0 = 0;\n    unsigned long u1 = 1;\n    while (n > 0)\n    {\n        unsigned long temp = u1;\n        u1 += u0;\n        u0 = temp;\n        n--;\n    }\n    return u0;\n}", "positive": "c\nvoid fibo_iter(unsigned long *arr, unsigned long size)\n{\n    if (size < 2){\n        printf(\"Invalid array length\\n\");  //check for valid input\n        return;\n    }\n    \n    arr[0] = 0;   //initialize first two elements of sequence manually\n    arr[1] = 1;\n\n    for (int i=2; i<size; ++i)\n       arr[i] = arr[i-1] + arr[i-2];      //calculate next number in sequence based on previous two numbers\n}", "function_type": 57, "negative": "unsigned long fibonacci(unsigned long n)\n{\n    if (n == 0)\n    {\n        return 0;\n    }\n    else if (n == 1)\n    {\n        return 1;\n    }\n    else\n    {\n        return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n}"}
{"anchor": "unsigned long fibo_iter(unsigned long n)\n{\n    unsigned long u0 = 0;\n    unsigned long u1 = 1;\n    while (n > 0)\n    {\n        unsigned long temp = u1;\n        u1 += u0;\n        u0 = temp;\n        n--;\n    }\n    return u0;\n}", "positive": "c\nunsigned long fibo_iter(int* n)\n{\n    int u0[2]={0, 1};\n    // int *u0 = &(arr[0]);\n    // int *u1 = &(arr[1]);\n  \n    while (*n>0){\n      \n      int temp[2];\n      temp[0] = u0[1];\n      temp[1] = u0[0]+temp[0];\n        \n      u0[0] = temp[0];\n      u0[1] = temp[1];\n          \n      (*n)--;\n    }\n    \n    return u0[0];\n}", "function_type": 58, "negative": "unsigned int is_set(unsigned int value, unsigned char n)\n{\n    unsigned int temp = 1 << (n - 1);\n    return (value & temp) == temp;\n}"}
{"anchor": "unsigned long fibo_iter(unsigned long n)\n{\n    unsigned long u0 = 0;\n    unsigned long u1 = 1;\n    while (n > 0)\n    {\n        unsigned long temp = u1;\n        u1 += u0;\n        u0 = temp;\n        n--;\n    }\n    return u0;\n}", "positive": "c\nvoid swap(unsigned long *a, unsigned long *b)\n{\n    unsigned long temp=*a; \n    *a=*b; \n    *b=temp;\n}", "function_type": 58, "negative": "unsigned long fact(unsigned n)\n{\n    if (n == 0)\n    {\n        return 1;\n    }\n    else\n    {\n        return fact(n - 1) * n;\n    }\n}"}
{"anchor": "unsigned long fibo_iter(unsigned long n)\n{\n    unsigned long u0 = 0;\n    unsigned long u1 = 1;\n    while (n > 0)\n    {\n        unsigned long temp = u1;\n        u1 += u0;\n        u0 = temp;\n        n--;\n    }\n    return u0;\n}", "positive": "c\nunsigned long fibo_refac(unsigned long n)\n{\n    unsigned long u1 = 0;\n    unsigned long u0 = 1;\n    while (n > 0)\n    {\n        unsigned long temp = u0;\n        u0 = u1;\n        u1 += temp;\n        n--;\n    }\n    return u0;\n}", "function_type": 58, "negative": "unsigned int digit(int n, int k)\n{\n    if (n <= 0 || k <= 0)\n    {\n        return 0;\n    }\n    else\n    {\n        while (k != 1)\n        {\n            n = n / 10;\n            k--;\n        }\n        return n % 10;\n    }\n}"}
{"anchor": "unsigned long fibo_iter(unsigned long n)\n{\n    unsigned long u0 = 0;\n    unsigned long u1 = 1;\n    while (n > 0)\n    {\n        unsigned long temp = u1;\n        u1 += u0;\n        u0 = temp;\n        n--;\n    }\n    return u0;\n}", "positive": "Declare variables at the beginning of the function instead of inside the loop\n\n    while (n-- > 0){                          // Decrement 'n' before checking its value instead of after it is decremented in each iteration\n        unsigned long tmp = result;            // Store current value of `result` into a temporary variable\n        result = next;                         // Update `result` with next value\n        next += tmp;                           // Compute new value for `next` adding old `result` and stored `tmp`\n    }", "function_type": 58, "negative": "unsigned int greatest_divisor(unsigned int n)\n{\n    unsigned int res = 2;\n    while (n % res != 0 && res * res <= n)\n    {\n        res += 1;\n    }\n    if (n % res == 0)\n    {\n        return n / res;\n    }\n    else\n    {\n        return 1;\n    }\n}"}
{"anchor": "void fifo_clear(struct fifo *fifo)\n{\n    while (fifo->head != NULL)\n    {\n        struct list *temp = fifo->head;\n        fifo->head = fifo->head->next;\n        free(temp);\n    }\n    fifo->size = 0;\n}", "positive": "c\nvoid fifo_clear2(struct fifo *fifo)\n{\n    while (!is_empty(&fifo))\n    {\n        pop(fifo);\n    }\n}", "function_type": 58, "negative": "void dlist_print(const struct dlist *list)\n{\n    if (list->size != 0)\n    {\n        struct dlist_item *temp = list->head;\n        while (temp != NULL)\n        {\n            printf(\"%d\\n\", temp->data);\n            temp = temp->next;\n        }\n    }\n}"}
{"anchor": "void fifo_clear(struct fifo *fifo)\n{\n    while (fifo->head != NULL)\n    {\n        struct list *temp = fifo->head;\n        fifo->head = fifo->head->next;\n        free(temp);\n    }\n    fifo->size = 0;\n}", "positive": "c\nvoid fifo_clear2(struct fifo *fifo)\n{\n    size_t old_size = fifo->size;\n    for (size_t i = 0; i < old_size; ++i)\n    {\n        struct list *temp = fifo->head;\n        fifo->head = fifo->head->next;\n        free(temp);\n    }\n    fifo->size = 0;\n}", "function_type": 59, "negative": "void dlist_map_square(struct dlist *list)\n{\n    struct dlist_item *new = list->head;\n    while (new != NULL)\n    {\n        int temp = new->data;\n        new->data = temp *temp;\n        new = new->next;\n    }\n}"}
{"anchor": "void fifo_clear(struct fifo *fifo)\n{\n    while (fifo->head != NULL)\n    {\n        struct list *temp = fifo->head;\n        fifo->head = fifo->head->next;\n        free(temp);\n    }\n    fifo->size = 0;\n}", "positive": "c\nvoid clearFifoQueue(struct fifoQueue *queue)\n{\n    while (queue->frontElement != NULL)\n    {\n        struct linkedListNode *temporaryNode = queue->frontElement;\n        queue->frontElement = queue->frontElement->nextNode;\n        free(temporaryNode);\n    }\n    queue->quantityOfElements = 0;\n}", "function_type": 59, "negative": "size_t list_length(struct list *list)\n{\n    struct list *temp = list;\n    size_t count = 0;\n    while (temp != NULL)\n    {\n        count += 1;\n        temp = temp->next;\n    }\n    return count;\n}"}
{"anchor": "void fifo_clear(struct fifo *fifo)\n{\n    while (fifo->head != NULL)\n    {\n        struct list *temp = fifo->head;\n        fifo->head = fifo->head->next;\n        free(temp);\n    }\n    fifo->size = 0;\n}", "positive": "c\nvoid fifo_clear(struct fifo *fifo)\n{\n    for (; fifo->head != NULL;)\n    {\n        struct list *temp = fifo->head;\n        fifo->head = fifo->head->next;\n        free(temp);\n    }\n    fifo->size = 0;\n}", "function_type": 59, "negative": "int dlist_get(const struct dlist *list, size_t index)\n{\n    if (index >= list->size)\n    {\n        return -1;\n    }\n    struct dlist_item *temp = list->head;\n    while (index != 0)\n    {\n        temp = temp->next;\n        index -= 1;\n    }\n    return temp->data;\n}"}
{"anchor": "void fifo_clear(struct fifo *fifo)\n{\n    while (fifo->head != NULL)\n    {\n        struct list *temp = fifo->head;\n        fifo->head = fifo->head->next;\n        free(temp);\n    }\n    fifo->size = 0;\n}", "positive": "c\nstatic void clear_list(struct list **node)\n{\n    if (*node == NULL) return;\n    \n    clear_list(&(*node)->next);\n    free(*node);\n    *node = NULL;\n}", "function_type": 59, "negative": "void add(struct heap *heap, int val)\n{\n    if (heap->size == heap->capacity)\n    {\n        heap->array = realloc(heap->array, sizeof(int) * heap->capacity * 2);\n        heap->capacity *= 2;\n    }\n    heap->array[heap->size] = val;\n    int i = heap->size;\n    while (heap->array[i] > heap->array[(i - 1) / 2])\n    {\n        int temp = heap->array[i];\n        heap->array[i] = heap->array[(i - 1) / 2];\n        heap->array[(i - 1) / 2] = temp;\n        i = (i - 1) / 2;\n    }\n    heap->size += 1;\n}"}
{"anchor": "size_t fifo_size(struct fifo *fifo)\n{\n    return fifo->size;\n}", "positive": "c\nsize_t fifo_size(struct fifo *fifo)\n{\n    size_t result = fifo->size; // add an intermediate variable to hold the value of \"fifo->size\"\n    return result;               // return the stored value in the variable instead directly returning the field \n}", "function_type": 59, "negative": "void fifo_clear(struct fifo *fifo)\n{\n    while (fifo->head != NULL)\n    {\n        struct list *temp = fifo->head;\n        fifo->head = fifo->head->next;\n        free(temp);\n    }\n    fifo->size = 0;\n}"}
{"anchor": "size_t fifo_size(struct fifo *fifo)\n{\n    return fifo->size;\n}", "positive": "c\nsize_t fifo_size(struct fifo *fifo)\n{\n    size_t count = 0;\n    struct node *current = fifo->head;\n    \n    while (current != NULL){\n        count++;\n        current = current->next;\n    }\n    \n    return count;\n}", "function_type": 60, "negative": "size_t list_length(struct list *list)\n{\n    struct list *temp = list;\n    size_t count = 0;\n    while (temp != NULL)\n    {\n        count += 1;\n        temp = temp->next;\n    }\n    return count;\n}"}
{"anchor": "size_t fifo_size(struct fifo *fifo)\n{\n    return fifo->size;\n}", "positive": "c\nsize_t fifo_size(struct fifo *fifo)\n{\n    size_t count = 0;\n    struct node *current = fifo->head;\n    \n    while(current != NULL){\n        current = current -> next;\n        ++count;\n    }\n\n    return count;\n}", "function_type": 60, "negative": "size_t my_strlen(const char *s)\n{\n    if (s == NULL)\n    {\n        return 0;\n    }\n    else\n    {\n        size_t i = 0;\n        while (s[i] != '\\0')\n        {\n            i++;\n        }\n        return i;\n    }\n}"}
{"anchor": "size_t fifo_size(struct fifo *fifo)\n{\n    return fifo->size;\n}", "positive": "c\nsize_t refactored_fifo_size(struct fifo *fifo)\n{\n    size_t result = 0;\n    \n    for (; fifo != NULL; fifo = fifo->next) {\n        result++;\n    }\n\n    return result;\n}", "function_type": 60, "negative": "int dlist_get(const struct dlist *list, size_t index)\n{\n    if (index >= list->size)\n    {\n        return -1;\n    }\n    struct dlist_item *temp = list->head;\n    while (index != 0)\n    {\n        temp = temp->next;\n        index -= 1;\n    }\n    return temp->data;\n}"}
{"anchor": "size_t fifo_size(struct fifo *fifo)\n{\n    return fifo->size;\n}", "positive": "c\nsize_t queue_length(struct queue *queue)\n{\n    return queue->length;\n}", "function_type": 60, "negative": "static struct int_vector swap(struct int_vector vec, size_t i, size_t j)\n{\n    int temp = vec.data[i];\n    vec.data[i] = vec.data[j];\n    vec.data[j] = temp;\n    return vec;\n}"}
{"anchor": "unsigned long fact(unsigned n)\n{\n    if (n == 0)\n    {\n        return 1;\n    }\n    else\n    {\n        return fact(n - 1) * n;\n    }\n}", "positive": "c\nunsigned long fact2(const unsigned* n_ptr)\n{\n    const unsigned n = *n_ptr;\n    \n    if (n == 0)\n    {\n        return 1;\n    }\n    else\n    {\n        return fact2(&(*n_ptr - 1)) * (*n_ptr);\n    }\n}", "function_type": 60, "negative": "unsigned long fibonacci(unsigned long n)\n{\n    if (n == 0)\n    {\n        return 0;\n    }\n    else if (n == 1)\n    {\n        return 1;\n    }\n    else\n    {\n        return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n}"}
{"anchor": "unsigned long fact(unsigned n)\n{\n    if (n == 0)\n    {\n        return 1;\n    }\n    else\n    {\n        return fact(n - 1) * n;\n    }\n}", "positive": "c\nunsigned long refactor_fact(unsigned n)\n{\n    unsigned long result = 1; // create a variable to hold the factorial result\n    for (; n > 1; --n)       // loop from n down to 2\n    {\n        result *= n;         // multiply current value of 'result' by 'n'\n    }                         // decrement 'n' in each iteration\n    \n    return result;            // return final calculated factorial\n}", "function_type": 61, "negative": "unsigned int digit(int n, int k)\n{\n    if (n <= 0 || k <= 0)\n    {\n        return 0;\n    }\n    else\n    {\n        while (k != 1)\n        {\n            n = n / 10;\n            k--;\n        }\n        return n % 10;\n    }\n}"}
{"anchor": "unsigned long fact(unsigned n)\n{\n    if (n == 0)\n    {\n        return 1;\n    }\n    else\n    {\n        return fact(n - 1) * n;\n    }\n}", "positive": "c\nvoid fact_helper(unsigned n, unsigned* result)\n{\n    if (n == 0)\n    {\n        *result = 1;\n    }\n    else\n    {\n        fact_helper(n - 1, result);\n        *result *= n;\n    }\n}", "function_type": 61, "negative": "unsigned int number_digits_rec(unsigned int n)\n{\n    if (n < 10)\n    {\n        return 1;\n    }\n    else\n    {\n        return number_digits_rec(n / 10) + 1;\n    }\n}"}
{"anchor": "unsigned long fact(unsigned n)\n{\n    if (n == 0)\n    {\n        return 1;\n    }\n    else\n    {\n        return fact(n - 1) * n;\n    }\n}", "positive": "unsigned long factorial(unsigned number)\n{\n    unsigned long result = 1;\n    \n    while(number > 0){\n       result = result * number;\n       number--;\n    }\n\n   return result;\n}", "function_type": 61, "negative": "unsigned long fibo_iter(unsigned long n)\n{\n    unsigned long u0 = 0;\n    unsigned long u1 = 1;\n    while (n > 0)\n    {\n        unsigned long temp = u1;\n        u1 += u0;\n        u0 = temp;\n        n--;\n    }\n    return u0;\n}"}
{"anchor": "unsigned long fact(unsigned n)\n{\n    if (n == 0)\n    {\n        return 1;\n    }\n    else\n    {\n        return fact(n - 1) * n;\n    }\n}", "positive": "c\nvoid fact_refactor(unsigned n, unsigned long* result)\n{\n    if (n == 0 || result == NULL)\n    {\n        *result = 1;\n    }\n    else\n    {\n        unsigned long temp;\n        fact_refactor(n - 1, &temp);\n        *result = temp * n;\n    }\n}", "function_type": 61, "negative": "int int_sqrt(int n)\n{\n    if (n < 0)\n    {\n        return -1;\n    }\n    else\n    {\n        int i = 0;\n        while (i * i <= n)\n        {\n            i++;\n        }\n        return i - 1;\n    }\n}"}
{"anchor": "size_t element_count(int *begin, int *end)\n{\n    return end - begin;\n}", "positive": "c\nsize_t diff_element_count(const int *start, const int *finish)\n{\n    return finish - start;\n}", "function_type": 61, "negative": "int coun(const char *file_out)\n{\n    FILE *f3 = fopen(file_out, \"r\");\n    int count = 0;\n    char *line3 = NULL;\n    size_t len3 = 0;\n    while (getline(&line3, &len3, f3) != -1)\n    {\n        count += 1;\n    }\n    free(line3);\n    fclose(f3);\n    return count;\n}"}
{"anchor": "size_t element_count(int *begin, int *end)\n{\n    return end - begin;\n}", "positive": "c\nsize_t element_count(int array[], size_t length)\n{\n    return length;\n}", "function_type": 62, "negative": "int is_sorted(int array[], size_t size)\n{\n    if (size == 0)\n    {\n        return 1;\n    }\n    else\n    {\n        size_t i = 1;\n        while (array[i - 1] <= array[i] && i < size)\n        {\n            i++;\n        }\n        return i == size;\n    }\n}"}
{"anchor": "size_t element_count(int *begin, int *end)\n{\n    return end - begin;\n}", "positive": "for size_t definition\n\nsize_t countElements(const int* start, const int* stop) \n{\n   return stop - start;\n}", "function_type": 62, "negative": "size_t list_length(struct list *list)\n{\n    struct list *temp = list;\n    size_t count = 0;\n    while (temp != NULL)\n    {\n        count += 1;\n        temp = temp->next;\n    }\n    return count;\n}"}
{"anchor": "size_t element_count(int *begin, int *end)\n{\n    return end - begin;\n}", "positive": "for size_t \n\nsize_t element_count(const int* const begin, const int* const end) {\n   if ((void*)begin <= (void*)end){\n       return (size_t)(((char*)end)-((char*)begin));\n   } else {\n        return (size_t)(((char*)begin)-((char*)end));\n   }\n}", "function_type": 62, "negative": "int present(const char *accept, char f)\n{\n    for (size_t i = 0; accept[i] != '\\0'; i++)\n    {\n        if (accept[i] == f)\n        {\n            return 1;\n        }\n    }\n    return 0;\n}"}
{"anchor": "size_t element_count(int *begin, int *end)\n{\n    return end - begin;\n}", "positive": "c\nsize_t element_count(const int arr[], const int *end)\n{\n    return end - arr; // or just use sizeof() to get size of array\n}", "function_type": 62, "negative": "int my_memcmp(const void *s1, const void *s2, size_t num)\n{\n    const char *r1 = s1;\n    const char *r2 = s2;\n    size_t i = 0;\n    while (i < num && r1[i] == r2[i])\n    {\n        i++;\n    }\n    if (i == num)\n    {\n        return 0;\n    }\n    if (r1[i] < r2[i])\n    {\n        return -1;\n    }\n    else\n    {\n        return 1;\n    }\n}"}
{"anchor": "unsigned int digit(int n, int k)\n{\n    if (n <= 0 || k <= 0)\n    {\n        return 0;\n    }\n    else\n    {\n        while (k != 1)\n        {\n            n = n / 10;\n            k--;\n        }\n        return n % 10;\n    }\n}", "positive": "c\nunsigned int refactored_digit(int n, int k)\n{\n    unsigned int result = 0; // Intermediate variable for storing results\n\n    if (n <= 0 || k <= 0)\n    {\n        return result;\n    }\n    else\n    {\n        while (k > 1) // Changed comparison operator from \"!\" to \">\"\n        {\n            n = n / 10;\n            k--;\n        }\n        \n        result = n % 10;   // Storing the desired value in a temporary variable 'result' before returning it\n        return result;      // Returning the stored value of 'result' instead of directly calculating it.\n                            // This way we keep exactly the same functionality as in original function but with more readable and maintainable code.\n    }\n}", "function_type": 62, "negative": "unsigned int number_digits_rec(unsigned int n)\n{\n    if (n < 10)\n    {\n        return 1;\n    }\n    else\n    {\n        return number_digits_rec(n / 10) + 1;\n    }\n}"}
{"anchor": "unsigned int digit(int n, int k)\n{\n    if (n <= 0 || k <= 0)\n    {\n        return 0;\n    }\n    else\n    {\n        while (k != 1)\n        {\n            n = n / 10;\n            k--;\n        }\n        return n % 10;\n    }\n}", "positive": "c\nunsigned int digit(int n, int k)\n{\n    if (n <= 0 || k <= 0)\n    {\n        return 0;\n    }\n    for (; k > 1; --k)\n    {\n        n /= 10;\n    }\n    return n % 10;\n}", "function_type": 63, "negative": "unsigned int greatest_divisor(unsigned int n)\n{\n    unsigned int res = 2;\n    while (n % res != 0 && res * res <= n)\n    {\n        res += 1;\n    }\n    if (n % res == 0)\n    {\n        return n / res;\n    }\n    else\n    {\n        return 1;\n    }\n}"}
{"anchor": "unsigned int digit(int n, int k)\n{\n    if (n <= 0 || k <= 0)\n    {\n        return 0;\n    }\n    else\n    {\n        while (k != 1)\n        {\n            n = n / 10;\n            k--;\n        }\n        return n % 10;\n    }\n}", "positive": "c\nunsigned int digit_refactored(int n, int k)\n{\n    if (n <= 0 || k <= 0)\n    {\n        return 0;\n    }\n    for (; k > 1; --k)\n    {\n        n /= 10;\n    }\n    return n % 10;\n}", "function_type": 63, "negative": "int int_sqrt(int n)\n{\n    if (n < 0)\n    {\n        return -1;\n    }\n    else\n    {\n        int i = 0;\n        while (i * i <= n)\n        {\n            i++;\n        }\n        return i - 1;\n    }\n}"}
{"anchor": "unsigned int digit(int n, int k)\n{\n    if (n <= 0 || k <= 0)\n    {\n        return 0;\n    }\n    else\n    {\n        while (k != 1)\n        {\n            n = n / 10;\n            k--;\n        }\n        return n % 10;\n    }\n}", "positive": "void digit(const char *str_num, size_t str_len, unsigned int k)\n{\n    if (*str_num == '\\0' || k == 0)\n    {\n        printf(\"0\\n\");\n    }\n    else\n    {\n        const char* end = &str_num[str_len];\n        --end; // last character of string is null terminator so decrementing to get actual last character\n        \n        for (; k > 1 ; ++str_num){\n            ++str_num; // skip all digits until we reach required position\n        }\n        printf(\"%d\\n\", *str_num - '0'); // print the required digit and convert it from ASCII value to integer\n    }\n}", "function_type": 63, "negative": "int is_digit(char s)\n{\n    if (s >= '0' && s <= '9')\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}"}
{"anchor": "unsigned int digit(int n, int k)\n{\n    if (n <= 0 || k <= 0)\n    {\n        return 0;\n    }\n    else\n    {\n        while (k != 1)\n        {\n            n = n / 10;\n            k--;\n        }\n        return n % 10;\n    }\n}", "positive": "c\nunsigned int find_digit(int number, int position)\n{\n    if (number <= 0 || position <= 0)\n    {\n        return 0;\n    }\n    else\n    {\n        while (position != 1)\n        {\n            number = number / 10;\n            position--;\n        }\n        return number % 10;\n    }\n}", "function_type": 63, "negative": "int int_palindrome(int n)\n{\n    if (n < 0)\n    {\n        return 0;\n    }\n    if (n < 10)\n    {\n        return 1;\n    }\n\n    int fin = 1;\n    int cop = n;\n    while (cop > 10)\n    {\n        cop = cop / 10;\n        fin = fin * 10;\n    }\n    int deb = 1;\n    while (fin > deb && (n / fin) % 10 == (n / deb) % 10)\n    {\n        deb = deb * 10;\n        fin = fin / 10;\n    }\n    return fin <= deb;\n}"}
{"anchor": "int dlist_get(const struct dlist *list, size_t index)\n{\n    if (index >= list->size)\n    {\n        return -1;\n    }\n    struct dlist_item *temp = list->head;\n    while (index != 0)\n    {\n        temp = temp->next;\n        index -= 1;\n    }\n    return temp->data;\n}", "positive": "c\nint getElementAtIndex(const struct dlist *dList, size_t idx)\n{\n    if (idx >= dList->size)\n    {\n        return -1;\n    }\n    struct dlist_item *currentItem = dList->head;\n    for (; idx > 0; idx--)  // equivalent to 'while' loop but clearer and more readable\n    {\n        currentItem = currentItem->next;\n    }\n    return currentItem->data;\n}", "function_type": 63, "negative": "void dlist_print(const struct dlist *list)\n{\n    if (list->size != 0)\n    {\n        struct dlist_item *temp = list->head;\n        while (temp != NULL)\n        {\n            printf(\"%d\\n\", temp->data);\n            temp = temp->next;\n        }\n    }\n}"}
{"anchor": "int dlist_get(const struct dlist *list, size_t index)\n{\n    if (index >= list->size)\n    {\n        return -1;\n    }\n    struct dlist_item *temp = list->head;\n    while (index != 0)\n    {\n        temp = temp->next;\n        index -= 1;\n    }\n    return temp->data;\n}", "positive": "c\nint dlist_get(const struct dlist *list, size_t index)\n{\n    const struct dlist_item *temp = list->head;\n    \n    for (; index > 0 && temp != NULL; --index)  // for loop instead of while\n    {\n        temp = temp->next;\n    }\n\t\n\t// Returning -1 when out-of-range or in case there is a null pointer at the head\n    return ((temp == NULL || index > 0)? -1 : temp->data);  \n}", "function_type": 64, "negative": "void dlist_map_square(struct dlist *list)\n{\n    struct dlist_item *new = list->head;\n    while (new != NULL)\n    {\n        int temp = new->data;\n        new->data = temp *temp;\n        new = new->next;\n    }\n}"}
{"anchor": "int dlist_get(const struct dlist *list, size_t index)\n{\n    if (index >= list->size)\n    {\n        return -1;\n    }\n    struct dlist_item *temp = list->head;\n    while (index != 0)\n    {\n        temp = temp->next;\n        index -= 1;\n    }\n    return temp->data;\n}", "positive": "int dlist_get(const struct dlist *list, size_t index)\n{\n    if (index >= list->size)\n    {\n        return -1;\n    }\n    \n    const struct dlist_item *temp = list->head;\n    for (; index > 0; --index)\n    {\n        temp = temp->next;\n    }\n    return temp->data;\n}", "function_type": 64, "negative": "int main(void)\n{\n    struct dlist *list = dlist_init();\n    for (int i = 0; i < 5; i++)\n    {\n        dlist_insert_at(list, i, i);\n    }\n    dlist_insert_at(list, 6, 3);\n    dlist_print(list);\n    return 0;\n}"}
{"anchor": "int dlist_get(const struct dlist *list, size_t index)\n{\n    if (index >= list->size)\n    {\n        return -1;\n    }\n    struct dlist_item *temp = list->head;\n    while (index != 0)\n    {\n        temp = temp->next;\n        index -= 1;\n    }\n    return temp->data;\n}", "positive": "c\nint dlist_get(const struct dlist *list, size_t index)\n{\n    // Check for invalid index value\n    if (index >= list->size) \n    {\n        return -1;\n    }\n    \n    // Define a temporary pointer to traverse through the list\n    struct dlist_item *temp = list->head;  \n    \n    // Traversing till we reach desired index\n    for (; index > 0; --index)  \n    {\n        temp = temp->next;\n    }\n    \n    // Return data at desired position\n    return temp->data;\n}", "function_type": 64, "negative": "size_t list_length(struct list *list)\n{\n    struct list *temp = list;\n    size_t count = 0;\n    while (temp != NULL)\n    {\n        count += 1;\n        temp = temp->next;\n    }\n    return count;\n}"}
{"anchor": "int dlist_get(const struct dlist *list, size_t index)\n{\n    if (index >= list->size)\n    {\n        return -1;\n    }\n    struct dlist_item *temp = list->head;\n    while (index != 0)\n    {\n        temp = temp->next;\n        index -= 1;\n    }\n    return temp->data;\n}", "positive": "c\nint dlist_get(const struct dlist *list, size_t index)\n{\n    if (index >= list->size)\n    {\n        return -1;\n    }\n    \n    const struct dlist_item **arr = (struct dlist_item**)malloc(sizeof(struct dlist_item*)*list->size); // create an array of pointers to traverse through the list\n  \n\tint i = 0; \t\t\t\t\t\t\t\t\t\t\t// initialize counter for loop\n\twhile((*arr)[i]){\t\t\t\t\t\t\t\t\t\t// iterate until we reach end of list\n\t\t(*arr)[++i]=(*arr)[i-1]->next;\t\t\t\t\t\t\t\n\t}\n\treturn (*arr)[index]->data; \t\t\t\t\t\t\t// return data at specified position in list\n}", "function_type": 64, "negative": "int int_vector_max(const struct int_vector vec)\n{\n    int max = vec.data[0];\n    for (size_t i = 0; i < vec.size; i++)\n    {\n        if (max < vec.data[i])\n        {\n            max = vec.data[i];\n        }\n    }\n    return max;\n}"}
{"anchor": "int main(void)\n{\n    struct dlist *list = dlist_init();\n    for (int i = 0; i < 5; i++)\n    {\n        dlist_insert_at(list, i, i);\n    }\n    dlist_insert_at(list, 6, 3);\n    dlist_print(list);\n    return 0;\n}", "positive": "c\nint main(void)\n{\n    // Initialize list and insert values from 0 to 4 into it\n    struct dlist *list = dlist_init();\n    for (int i = 0; i < 5; i++)\n    {\n        dlist_insert_at(list, i, i);\n    }\n    \n    // Create an intermediate variable so that we don't have to call `dlist_insert_at` twice in a row\n    int result = dlist_insert_at(list, 6, 3);\n    \n    dlist_print(list);\n    return 0;\n}\n```\n\nNote: The refactoring is minimalistic because you should only apply such changes when they provide benefits to your codebase without making things more complex. In other cases, leaving the original code as-is could be beneficial due to readability or maintainability considerations.\n\"\"\"\nimport pandas as pd\nfrom langchain import LLMChain\nfrom langchain.llms import OpenAI\n\n# Define our prompt\nprompt = \"\"\"You are given the following Python code:\n\n```python\ndef f():\n    x = [1,2]\n    y = [3,4]\n    z = x + y\n    print(z)\nf()\n```\n\nRewrite this Python function by", "function_type": 64, "negative": "void dlist_print(const struct dlist *list)\n{\n    if (list->size != 0)\n    {\n        struct dlist_item *temp = list->head;\n        while (temp != NULL)\n        {\n            printf(\"%d\\n\", temp->data);\n            temp = temp->next;\n        }\n    }\n}"}
{"anchor": "int main(void)\n{\n    struct dlist *list = dlist_init();\n    for (int i = 0; i < 5; i++)\n    {\n        dlist_insert_at(list, i, i);\n    }\n    dlist_insert_at(list, 6, 3);\n    dlist_print(list);\n    return 0;\n}", "positive": "c\nint main(void)\n{\n    struct doublyLinkedList *theDoublyLinkedList = initTheDoublyLinkedListStructure();\n    for (int eachIndexIncrementingFromZeroToFour = 0; eachIndexIncrementingFromZeroToFour <= 4; eachIndexIncrementingFromZeroToFour++)\n    {\n        insertValueAtSpecifiedPositionInList(eachIndexIncrementingFromZeroToFour, eachIndexIncrementingFromZeroToFour, theDoublyLinkedList);\n    }\n    insertValueAtSpecifiedPositionInList(6, 3, theDoublyLinkedList);\n    printOutAllValuesOfList(theDoublyLinkedList);\n    return 0;\n}", "function_type": 65, "negative": "void dlist_map_square(struct dlist *list)\n{\n    struct dlist_item *new = list->head;\n    while (new != NULL)\n    {\n        int temp = new->data;\n        new->data = temp *temp;\n        new = new->next;\n    }\n}"}
{"anchor": "int main(void)\n{\n    struct dlist *list = dlist_init();\n    for (int i = 0; i < 5; i++)\n    {\n        dlist_insert_at(list, i, i);\n    }\n    dlist_insert_at(list, 6, 3);\n    dlist_print(list);\n    return 0;\n}", "positive": "c\nint main(void)\n{\n    int i;\n    struct dlist *list = dlist_init();\n    \n    i = 0;\n    while(i < 5){\n       dlist_insert_at(list, i, i);\n       i += 1;\n    }\n\n    if(!dlist_isempty(list)){ // Checking that list is not empty before trying to insert at position 6\n      dlist_insert_at(list, 6, 3);\n    }\n        \n    dlist_print(list);\n    return 0;\n}", "function_type": 65, "negative": "int dlist_get(const struct dlist *list, size_t index)\n{\n    if (index >= list->size)\n    {\n        return -1;\n    }\n    struct dlist_item *temp = list->head;\n    while (index != 0)\n    {\n        temp = temp->next;\n        index -= 1;\n    }\n    return temp->data;\n}"}
{"anchor": "int main(void)\n{\n    struct dlist *list = dlist_init();\n    for (int i = 0; i < 5; i++)\n    {\n        dlist_insert_at(list, i, i);\n    }\n    dlist_insert_at(list, 6, 3);\n    dlist_print(list);\n    return 0;\n}", "positive": "c\nint main(void)\n{\n    struct dlist *list = dlist_init();\n    int i = 0;\n    while (i < 5){\n        dlist_insert_at(list, i, i);\n        ++i;\n    }\n    dlist_insert_at(list, 6, 3);\n    dlist_print(list);\n    return 0;\n}", "function_type": 65, "negative": "void int_vector_print(const struct int_vector vec)\n{\n    for (size_t i = 0; i < vec.size; i++)\n    {\n        printf(\"%d\", vec.data[i]);\n        if (i + 1 != vec.size)\n        {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n}"}
{"anchor": "int main(void)\n{\n    struct dlist *list = dlist_init();\n    for (int i = 0; i < 5; i++)\n    {\n        dlist_insert_at(list, i, i);\n    }\n    dlist_insert_at(list, 6, 3);\n    dlist_print(list);\n    return 0;\n}", "positive": "global declaration of list outside of any functions\n\nint main(void)\n{\n    list = dlist_init(); // initialize and assign to list before usage in loop\n    \n    for (int i = 0; i < 5; i++)\n    {\n        dlist_insert_at(list, i, i);\n    }\n\n    dlist_insert_at(list, 6, 3);\n    dlist_print(list);\n    return 0;\n}", "function_type": 65, "negative": "void variant_display(const struct variant *e)\n{\n    if (e->type == TYPE_INT)\n        printf(\"%d\\n\", e->value.int_v);\n    if (e->type == TYPE_FLOAT)\n        printf(\"%f\\n\", e->value.float_v);\n    if (e->type == TYPE_CHAR)\n        printf(\"%c\\n\", e->value.char_v);\n    if (e->type == TYPE_STRING)\n        printf(\"%s\\n\", e->value.str_v);\n}"}
{"anchor": "void dlist_map_square(struct dlist *list)\n{\n    struct dlist_item *new = list->head;\n    while (new != NULL)\n    {\n        int temp = new->data;\n        new->data = temp *temp;\n        new = new->next;\n    }\n}", "positive": "c\nvoid dlist_map_square(struct dlist *list)\n{\n    struct dlist_item *currentItem;  // reordered declaration to be before loop for readability and efficiency\n    \n    currentItem = list->head;  \n    while (currentItem != NULL)\n    {\n        int value = currentItem->data;  // separated from next line for clarity and reduced repeated operations\n        \n        currentItem->data = value *value;  // simplified operation by avoiding an unnecessary temporary variable\n        \n        currentItem = currentItem->next;\n    }\n}", "function_type": 65, "negative": "void dlist_print(const struct dlist *list)\n{\n    if (list->size != 0)\n    {\n        struct dlist_item *temp = list->head;\n        while (temp != NULL)\n        {\n            printf(\"%d\\n\", temp->data);\n            temp = temp->next;\n        }\n    }\n}"}
{"anchor": "void dlist_map_square(struct dlist *list)\n{\n    struct dlist_item *new = list->head;\n    while (new != NULL)\n    {\n        int temp = new->data;\n        new->data = temp *temp;\n        new = new->next;\n    }\n}", "positive": "c\nvoid dlist_map_square(struct dlist *list)\n{\n    for (struct dlist_item **pItem = &list->head; *pItem != NULL; pItem = &(*pItem)->next)\n    {\n        (*pItem)->data = (*pItem)->data * (*pItem)->data;\n    }\n}", "function_type": 66, "negative": "int dlist_get(const struct dlist *list, size_t index)\n{\n    if (index >= list->size)\n    {\n        return -1;\n    }\n    struct dlist_item *temp = list->head;\n    while (index != 0)\n    {\n        temp = temp->next;\n        index -= 1;\n    }\n    return temp->data;\n}"}
{"anchor": "void dlist_map_square(struct dlist *list)\n{\n    struct dlist_item *new = list->head;\n    while (new != NULL)\n    {\n        int temp = new->data;\n        new->data = temp *temp;\n        new = new->next;\n    }\n}", "positive": "c\nvoid dlist_map_square(struct dlist *list)\n{\n    struct dlist_item *currentNode = list->head; // Declare and initialize current node in one line\n    \n    while (currentNode != NULL) \n    {\n        int dataSquare = currentNode->data * currentNode->data; // Store square of data into a separate variable for better readability\n        \n        currentNode->data = dataSquare; // Update data with its square\n        currentNode = currentNode->next; // Move to next node\n    }\n}", "function_type": 66, "negative": "int main(void)\n{\n    struct dlist *list = dlist_init();\n    for (int i = 0; i < 5; i++)\n    {\n        dlist_insert_at(list, i, i);\n    }\n    dlist_insert_at(list, 6, 3);\n    dlist_print(list);\n    return 0;\n}"}
{"anchor": "void dlist_map_square(struct dlist *list)\n{\n    struct dlist_item *new = list->head;\n    while (new != NULL)\n    {\n        int temp = new->data;\n        new->data = temp *temp;\n        new = new->next;\n    }\n}", "positive": "c\nvoid dlist_map_square(struct dlist *list)\n{\n    for (struct dlist_item *new = list->head; new != NULL; new = new->next)\n    {\n        const int temp = new->data;\n        new->data = temp * temp;\n    }\n}", "function_type": 66, "negative": "void fifo_clear(struct fifo *fifo)\n{\n    while (fifo->head != NULL)\n    {\n        struct list *temp = fifo->head;\n        fifo->head = fifo->head->next;\n        free(temp);\n    }\n    fifo->size = 0;\n}"}
{"anchor": "void dlist_map_square(struct dlist *list)\n{\n    struct dlist_item *new = list->head;\n    while (new != NULL)\n    {\n        int temp = new->data;\n        new->data = temp *temp;\n        new = new->next;\n    }\n}", "positive": "c\nvoid dlist_map_square(struct dlist *list)\n{\n    struct dlist_item *currentItem = list->head;  //Declare current item before start of loop to avoid redeclaration in each iteration\n    \n    while (currentItem != NULL)   //Use descriptive name for condition check instead of just 'new'\n    {\n        int dataToSquare = currentItem->data;      //Move assignment into its own line and use more descriptive variable name\n        \n        currentItem->data = dataToSquare * dataToSquare;       //Modify operation from multiplication to exponentiation\n            \n        currentItem = currentItem->next;               //Reassign current item after processing it\n    }\n}", "function_type": 66, "negative": "size_t list_length(struct list *list)\n{\n    struct list *temp = list;\n    size_t count = 0;\n    while (temp != NULL)\n    {\n        count += 1;\n        temp = temp->next;\n    }\n    return count;\n}"}
{"anchor": "void dlist_print(const struct dlist *list)\n{\n    if (list->size != 0)\n    {\n        struct dlist_item *temp = list->head;\n        while (temp != NULL)\n        {\n            printf(\"%d\\n\", temp->data);\n            temp = temp->next;\n        }\n    }\n}", "positive": "c\nvoid dlist_print(const struct dlist *plist)\n{\n    const struct dlist_item **pTemp = &plist->head; //pointer to pointer to item\n    \n    if (plist->size != 0)\n    {\n        while ((*pTemp)!=NULL)  //dereference pTemp to access its content\n        {\n            printf(\"%d\\n\", (*pTemp)->data);   //dereferencing twice for data\n            ++(*pTemp);                       //increment pointer to next element\n        }\n    }\n}", "function_type": 66, "negative": "void dlist_map_square(struct dlist *list)\n{\n    struct dlist_item *new = list->head;\n    while (new != NULL)\n    {\n        int temp = new->data;\n        new->data = temp *temp;\n        new = new->next;\n    }\n}"}
{"anchor": "void dlist_print(const struct dlist *list)\n{\n    if (list->size != 0)\n    {\n        struct dlist_item *temp = list->head;\n        while (temp != NULL)\n        {\n            printf(\"%d\\n\", temp->data);\n            temp = temp->next;\n        }\n    }\n}", "positive": "c\nvoid dlist_print(const struct dlist *list)\n{\n    // Create an intermediate variable for 'struct dlist_item' type \n    struct dlist_item *tempItem;\n    \n    if (list->size != 0)\n    {\n        // Assign head of the list to the temporary item\n        tempItem = list->head;\n        \n        while (tempItem != NULL)\n        {\n            printf(\"%d\\n\", tempItem->data);\n            \n            // Move the pointer to next element in list\n            tempItem = tempItem->next;\n        }\n    }\n}", "function_type": 67, "negative": "int dlist_get(const struct dlist *list, size_t index)\n{\n    if (index >= list->size)\n    {\n        return -1;\n    }\n    struct dlist_item *temp = list->head;\n    while (index != 0)\n    {\n        temp = temp->next;\n        index -= 1;\n    }\n    return temp->data;\n}"}
{"anchor": "void dlist_print(const struct dlist *list)\n{\n    if (list->size != 0)\n    {\n        struct dlist_item *temp = list->head;\n        while (temp != NULL)\n        {\n            printf(\"%d\\n\", temp->data);\n            temp = temp->next;\n        }\n    }\n}", "positive": "c\nstatic void print_node(struct dlist_item *node) \n{\n    printf(\"%d\\n\", node->data);\n}", "function_type": 67, "negative": "void int_vector_print(const struct int_vector vec)\n{\n    for (size_t i = 0; i < vec.size; i++)\n    {\n        printf(\"%d\", vec.data[i]);\n        if (i + 1 != vec.size)\n        {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n}"}
{"anchor": "void dlist_print(const struct dlist *list)\n{\n    if (list->size != 0)\n    {\n        struct dlist_item *temp = list->head;\n        while (temp != NULL)\n        {\n            printf(\"%d\\n\", temp->data);\n            temp = temp->next;\n        }\n    }\n}", "positive": "c\nvoid printListData(const struct dlist *theList)\n{\n    if (theList->size != 0)\n    {\n        struct dlist_item *currentItem = theList->head;\n        while (currentItem != NULL)\n        {\n            printf(\"%d\\n\", currentItem->data);\n            currentItem = currentItem->next;\n        }\n    }\n}", "function_type": 67, "negative": "int main(void)\n{\n    struct dlist *list = dlist_init();\n    for (int i = 0; i < 5; i++)\n    {\n        dlist_insert_at(list, i, i);\n    }\n    dlist_insert_at(list, 6, 3);\n    dlist_print(list);\n    return 0;\n}"}
{"anchor": "int check_alphabet(const char *str, const char *alphabet)\n{\n    if (alphabet == NULL || alphabet[0] == '\\0')\n    {\n        return 1;\n    }\n\n    for (int i = 0; alphabet[i] != '\\0'; i++)\n    {\n        int j = 0;\n        while (str[j] != '\\0' && str[j] != alphabet[i])\n        {\n            j++;\n        }\n        if (str[j] == '\\0')\n        {\n            return 0;\n        }\n    }\n    return 1;\n}", "positive": "c\nint check_alphabet(const char *str, const char *alphabet)\n{\n    if (*alphabet == '\\0') // If first character in 'alphabet' is null then return true\n    {\n        return 1;\n    }\n    \n    const char* currentChar = alphabet; // Pointer to the current character of 'alphabet'\n    \n    do {\n        const char* positionInString = strchr(str, *currentChar); // Finds the first occurrence of the character from 'alphabet' within 'str'\n        \n        if (!positionInString) // If not found it means that 'alphabet' contains a character which isn't present in 'str', hence returns false\n        {\n            return 0;\n        }\n        \n        currentChar++; // Moves pointer to next character in 'alphabet'\n    }\n    while(*currentChar != '\\0'); // Loop until all characters are checked or met end of 'alphabet' string\n  \n    return 1;\n}\n```\n\nExplanation:\n- The refactoring replaces the original explicit loop construct with a more readable and maintainable approach using pointers, `do..while` loop, and standard library function `strchr()`. This makes the code easier to understand.\n- In the new implementation", "function_type": 67, "negative": "int count_words(const char *file_in)\n{\n    FILE *r = fopen(file_in, \"r\");\n    int count = 0;\n    if (r == NULL)\n    {\n        return -1;\n    }\n    int bo = 0;\n    char c = fgetc(r);\n    while (c != -1)\n    {\n        if (c == ' ' || c == '\\n' || c == '\\t')\n        {\n            if (bo)\n                count += 1;\n            bo = 0;\n        }\n        else\n        {\n            bo = 1;\n        }\n        c = fgetc(r);\n    }\n    if (bo)\n        count += 1;\n    return count;\n}"}
{"anchor": "int check_alphabet(const char *str, const char *alphabet)\n{\n    if (alphabet == NULL || alphabet[0] == '\\0')\n    {\n        return 1;\n    }\n\n    for (int i = 0; alphabet[i] != '\\0'; i++)\n    {\n        int j = 0;\n        while (str[j] != '\\0' && str[j] != alphabet[i])\n        {\n            j++;\n        }\n        if (str[j] == '\\0')\n        {\n            return 0;\n        }\n    }\n    return 1;\n}", "positive": "bool is_all_chars_in_string(const char* stringToCheck, const char* charactersInAlphabet)\n{\n    // Check if any character in 'charactersInAlphabet' is not found within 'stringToCheck'.\n    for (size_t i = 0; charactersInAlphabet[i] != '\\0'; ++i)\n    {\n        bool currentCharFound = false;\n        \n        for (size_t j = 0; stringToCheck[j] != '\\0'; ++j)\n        {\n            if (charactersInAlphabet[i] == stringToCheck[j])\n            {\n                currentCharFound = true;\n                break;\n            }\n        }\n\n        if (!currentCharFound)\n        {\n            return false;  \n        }\n    }\n    \n    return true;\n}", "function_type": 68, "negative": "int append_file(const char *file_in, const char *content)\n{\n    if (content == NULL)\n    {\n        return -1;\n    }\n    FILE *f1 = fopen(file_in, \"a\");\n    if (f1 == NULL)\n    {\n        return -1;\n    }\n    fprintf(f1, \"%s\", content);\n    fclose(f1);\n    return 0;\n}"}
{"anchor": "int check_alphabet(const char *str, const char *alphabet)\n{\n    if (alphabet == NULL || alphabet[0] == '\\0')\n    {\n        return 1;\n    }\n\n    for (int i = 0; alphabet[i] != '\\0'; i++)\n    {\n        int j = 0;\n        while (str[j] != '\\0' && str[j] != alphabet[i])\n        {\n            j++;\n        }\n        if (str[j] == '\\0')\n        {\n            return 0;\n        }\n    }\n    return 1;\n}", "positive": "c\nint is_contained_in(char c, const char* set){\n    int index= 0 ;\n    while (set[index] ){\n         if (set[index]  == c ){\n             return 1;\n         }\n         index ++;\n     }\n      return 0;\n}", "function_type": 68, "negative": "size_t my_strlen(const char *s)\n{\n    if (s == NULL)\n    {\n        return 0;\n    }\n    else\n    {\n        size_t i = 0;\n        while (s[i] != '\\0')\n        {\n            i++;\n        }\n        return i;\n    }\n}"}
{"anchor": "int check_alphabet(const char *str, const char *alphabet)\n{\n    if (alphabet == NULL || alphabet[0] == '\\0')\n    {\n        return 1;\n    }\n\n    for (int i = 0; alphabet[i] != '\\0'; i++)\n    {\n        int j = 0;\n        while (str[j] != '\\0' && str[j] != alphabet[i])\n        {\n            j++;\n        }\n        if (str[j] == '\\0')\n        {\n            return 0;\n        }\n    }\n    return 1;\n}", "positive": "c\nint check_alphabet(const char *str, const char *alphabet)\n{\n    if (*alphabet == '\\0') // If empty string, return true\n    {\n        return 1;\n    }\n\n    while(*str){ // While there are still characters in 'str'...\n        const char *ptr = alphabet;\n        while(*ptr && *ptr != *str) // ...and they do not match with any character from 'alphabet'.\n        {\n            ++ptr;\n        }\n        if (!*ptr) // If we reached end of 'alphabet', means no matching char was found in 'str'\n        {\n            return 0;  \n        }\n        ++str; // Move to next character on 'str'.\n    }\n    return 1;\n}", "function_type": 68, "negative": "int coun(const char *file_out)\n{\n    FILE *f3 = fopen(file_out, \"r\");\n    int count = 0;\n    char *line3 = NULL;\n    size_t len3 = 0;\n    while (getline(&line3, &len3, f3) != -1)\n    {\n        count += 1;\n    }\n    free(line3);\n    fclose(f3);\n    return count;\n}"}
{"anchor": "int check_alphabet(const char *str, const char *alphabet)\n{\n    if (alphabet == NULL || alphabet[0] == '\\0')\n    {\n        return 1;\n    }\n\n    for (int i = 0; alphabet[i] != '\\0'; i++)\n    {\n        int j = 0;\n        while (str[j] != '\\0' && str[j] != alphabet[i])\n        {\n            j++;\n        }\n        if (str[j] == '\\0')\n        {\n            return 0;\n        }\n    }\n    return 1;\n}", "positive": "c\nbool is_string_in_alphabet(char *text, char *letters)\n{\n    if (!letters || letters[0] == '\\0')\n    {\n        return true;\n    }\n\n    for (unsigned long i = 0; letters[i]; i++)\n    {\n        unsigned long j = 0;\n        while (text[j] && text[j] != letters[i])\n        {\n            j++;\n        }\n        if (!text[j])\n        {\n            return false;\n        }\n    }\n    return true;\n}", "function_type": 68, "negative": "int star(const char *p, const char *s, int i, int j)\n{\n    while (p[j] != s[i] && p[j] != '?')\n    {\n        i++;\n    }\n    return simple(p, s, i + 1, j + 1);\n}"}
{"anchor": "int height(const struct binary_tree *tree)\n{\n    if (tree == NULL)\n    {\n        return -1;\n    }\n    int max = 0;\n    int max2 = 0;\n    if (tree->left != NULL)\n    {\n        max = height(tree->left) + 1;\n    }\n    if (tree->right != NULL)\n    {\n        max2 = height(tree->right) + 1;\n    }\n    return (max < max2) ? max2 : max;\n}", "positive": "static int getHeightRecursive(struct binary_tree* tree){\n   if(tree==NULL) \n      return -1;\n      \n   int leftHeight = getHeightRecursive(tree->left);\n   int rightHeight = getHeightRecursive(tree->right);\n   \n   // Return maximum of heights of left and right children plus one for current node\n   return ((leftHeight > rightHeight)? leftHeight : rightHeight)+1;\n}", "function_type": 68, "negative": "int size(const struct binary_tree *tree)\n{\n    if (tree == NULL)\n    {\n        return 0;\n    }\n    int res = 1;\n    if (tree->left != NULL)\n    {\n        res += size(tree->left);\n    }\n    if (tree->right != NULL)\n    {\n        res += size(tree->right);\n    }\n    return res;\n}"}
{"anchor": "int height(const struct binary_tree *tree)\n{\n    if (tree == NULL)\n    {\n        return -1;\n    }\n    int max = 0;\n    int max2 = 0;\n    if (tree->left != NULL)\n    {\n        max = height(tree->left) + 1;\n    }\n    if (tree->right != NULL)\n    {\n        max2 = height(tree->right) + 1;\n    }\n    return (max < max2) ? max2 : max;\n}", "positive": "c\nint height(const struct binary_tree *tree)\n{\n    int max = 0;\n    int max2 = 0;\n    \n    if (tree == NULL)\n    {\n        return -1;\n    }\n\n    if (tree->left != NULL)\n    {\n        max = height(tree->left) + 1;\n    }\n\n    if (tree->right != NULL)\n    {\n        max2 = height(tree->right) + 1;\n    }\n\n    return (max < max2) ? max2 : max;\n}", "function_type": 69, "negative": "int max_bst(struct bst_node *tree)\n{\n    if (tree->right != NULL)\n    {\n        return max_bst(tree->right);\n    }\n    else\n    {\n        return tree->data;\n    }\n}"}
{"anchor": "int height(const struct binary_tree *tree)\n{\n    if (tree == NULL)\n    {\n        return -1;\n    }\n    int max = 0;\n    int max2 = 0;\n    if (tree->left != NULL)\n    {\n        max = height(tree->left) + 1;\n    }\n    if (tree->right != NULL)\n    {\n        max2 = height(tree->right) + 1;\n    }\n    return (max < max2) ? max2 : max;\n}", "positive": "c\nint height(struct binary_tree *tree){\n  int leftHeight = 0;\n  int rightHeight = 0;\n  \n  while(tree){\n      tree = tree->left;\n      leftHeight++;\n  }\n  \n  while(tree){\n      tree = tree->right;\n      rightHeight++;\n  }\n  \n  return leftHeight > rightHeight ? leftHeight : rightHeight;\n}", "function_type": 69, "negative": "int binary_search(const int vec[], int size, int elt)\n{\n    if (size == 0)\n    {\n        return -1;\n    }\n    int max = size;\n    int min = 0;\n\n    while (max > min)\n    {\n        int mid = (min + max) / 2;\n        if (vec[mid] == elt)\n        {\n            return mid;\n        }\n        if (vec[mid] < elt)\n        {\n            min = mid + 1;\n        }\n        else\n        {\n            max = mid;\n        }\n    }\n    return -1;\n}"}
{"anchor": "int height(const struct binary_tree *tree)\n{\n    if (tree == NULL)\n    {\n        return -1;\n    }\n    int max = 0;\n    int max2 = 0;\n    if (tree->left != NULL)\n    {\n        max = height(tree->left) + 1;\n    }\n    if (tree->right != NULL)\n    {\n        max2 = height(tree->right) + 1;\n    }\n    return (max < max2) ? max2 : max;\n}", "positive": "c\nint height(const struct binary_tree *tree)\n{\n    if (tree == NULL)\n    {\n        return -1;\n    }\n    int leftMax = 0;\n    int rightMax = 0;\n    if (tree->left != NULL)\n    {\n        leftMax = height(tree->left) + 1;\n    }\n    if (tree->right != NULL)\n    {\n        rightMax = height(tree->right) + 1;\n    }\n    if (leftMax > rightMax) \n    {\n        return leftMax;\n    } \n    else \n    {\n        return rightMax;\n    }\n}", "function_type": 69, "negative": "int int_vector_max(const struct int_vector vec)\n{\n    int max = vec.data[0];\n    for (size_t i = 0; i < vec.size; i++)\n    {\n        if (max < vec.data[i])\n        {\n            max = vec.data[i];\n        }\n    }\n    return max;\n}"}
{"anchor": "int height(const struct binary_tree *tree)\n{\n    if (tree == NULL)\n    {\n        return -1;\n    }\n    int max = 0;\n    int max2 = 0;\n    if (tree->left != NULL)\n    {\n        max = height(tree->left) + 1;\n    }\n    if (tree->right != NULL)\n    {\n        max2 = height(tree->right) + 1;\n    }\n    return (max < max2) ? max2 : max;\n}", "positive": "c\nint height(const struct binary_tree *tree)\n{\n    if (tree == NULL)\n    {\n        return -1;\n    }\n    \n    int leftHeight = -1;\n    const struct binary_tree* currentNode = tree;\n    while (currentNode != NULL){\n        leftHeight++; \n        currentNode = currentNode->left;  \n    }\n\n    int rightHeight = -1;\n    currentNode = tree;\n    while (currentNode != NULL){\n        rightHeight++; \n        currentNode = currentNode->right;  \n    }\n     \n    return (leftHeight > rightHeight) ? leftHeight : rightHeight;\n}", "function_type": 69, "negative": "int check_alphabet(const char *str, const char *alphabet)\n{\n    if (alphabet == NULL || alphabet[0] == '\\0')\n    {\n        return 1;\n    }\n\n    for (int i = 0; alphabet[i] != '\\0'; i++)\n    {\n        int j = 0;\n        while (str[j] != '\\0' && str[j] != alphabet[i])\n        {\n            j++;\n        }\n        if (str[j] == '\\0')\n        {\n            return 0;\n        }\n    }\n    return 1;\n}"}
{"anchor": "int size(const struct binary_tree *tree)\n{\n    if (tree == NULL)\n    {\n        return 0;\n    }\n    int res = 1;\n    if (tree->left != NULL)\n    {\n        res += size(tree->left);\n    }\n    if (tree->right != NULL)\n    {\n        res += size(tree->right);\n    }\n    return res;\n}", "positive": "c\nint treeSize(const struct binary_tree *inputTree)\n{\n    if (inputTree == NULL)\n    {\n        return 0;\n    }\n    int result = 1;\n    if (inputTree->leftNode != NULL)\n    {\n        result += treeSize(inputTree->leftNode);\n    }\n    if (inputTree->rightNode != NULL)\n    {\n        result += treeSize(inputTree->rightNode);\n    }\n    return result;\n}", "function_type": 69, "negative": "int height(const struct binary_tree *tree)\n{\n    if (tree == NULL)\n    {\n        return -1;\n    }\n    int max = 0;\n    int max2 = 0;\n    if (tree->left != NULL)\n    {\n        max = height(tree->left) + 1;\n    }\n    if (tree->right != NULL)\n    {\n        max2 = height(tree->right) + 1;\n    }\n    return (max < max2) ? max2 : max;\n}"}
{"anchor": "int size(const struct binary_tree *tree)\n{\n    if (tree == NULL)\n    {\n        return 0;\n    }\n    int res = 1;\n    if (tree->left != NULL)\n    {\n        res += size(tree->left);\n    }\n    if (tree->right != NULL)\n    {\n        res += size(tree->right);\n    }\n    return res;\n}", "positive": "s assume it exists\n\nint countNodes(BinaryNode* node)\n{\n    if (node == NULL)\n    {\n        return 0;\n    }\n    \n    int totalCount = 1; // equivalent to `res` from original function\n  \n    /* Recursive calls */\n    BinaryNode* leftChild = getLeftNode(node);\n    BinaryNode* rightChild = getRightNode(node);\n  \n    if (leftChild != NULL)\n    {\n        totalCount += countNodes(leftChild);\n    }\n  \n    if (rightChild != NULL)\n    {\n        totalCount += countNodes(rightChild);\n    }\n    return totalCount;\n}", "function_type": 70, "negative": "int max_bst(struct bst_node *tree)\n{\n    if (tree->right != NULL)\n    {\n        return max_bst(tree->right);\n    }\n    else\n    {\n        return tree->data;\n    }\n}"}
{"anchor": "int size(const struct binary_tree *tree)\n{\n    if (tree == NULL)\n    {\n        return 0;\n    }\n    int res = 1;\n    if (tree->left != NULL)\n    {\n        res += size(tree->left);\n    }\n    if (tree->right != NULL)\n    {\n        res += size(tree->right);\n    }\n    return res;\n}", "positive": "c\nint size(const struct binary_tree *tree)\n{\n    if (tree == NULL)\n    {\n        return 0;\n    }\n    \n    // Adding an extra variable to hold the result of right subtree's size calculation\n    const int left = tree->left != NULL ? size(tree->left) : 0;\n\n    // Adding another variable to hold the result of left subtree's size calculation\n    const int right = tree->right != NULL ? size(tree->right) : 0;\n\n    return 1 + left + right;\n}", "function_type": 70, "negative": "int binary_search(const int vec[], int size, int elt)\n{\n    if (size == 0)\n    {\n        return -1;\n    }\n    int max = size;\n    int min = 0;\n\n    while (max > min)\n    {\n        int mid = (min + max) / 2;\n        if (vec[mid] == elt)\n        {\n            return mid;\n        }\n        if (vec[mid] < elt)\n        {\n            min = mid + 1;\n        }\n        else\n        {\n            max = mid;\n        }\n    }\n    return -1;\n}"}
{"anchor": "int size(const struct binary_tree *tree)\n{\n    if (tree == NULL)\n    {\n        return 0;\n    }\n    int res = 1;\n    if (tree->left != NULL)\n    {\n        res += size(tree->left);\n    }\n    if (tree->right != NULL)\n    {\n        res += size(tree->right);\n    }\n    return res;\n}", "positive": "c\nint size(const struct binary_tree *tree[])\n{\n    if (tree[0] == NULL)\n    {\n        return 0;\n    }\n    int res = 1;\n    if (tree[0]->left != NULL)\n    {\n        res += size(tree[0]->left);\n    }\n    if (tree[0]->right != NULL)\n    {\n        res += size(tree[0]->right);\n    }\n    return res;\n}", "function_type": 70, "negative": "int check_alphabet(const char *str, const char *alphabet)\n{\n    if (alphabet == NULL || alphabet[0] == '\\0')\n    {\n        return 1;\n    }\n\n    for (int i = 0; alphabet[i] != '\\0'; i++)\n    {\n        int j = 0;\n        while (str[j] != '\\0' && str[j] != alphabet[i])\n        {\n            j++;\n        }\n        if (str[j] == '\\0')\n        {\n            return 0;\n        }\n    }\n    return 1;\n}"}
{"anchor": "int size(const struct binary_tree *tree)\n{\n    if (tree == NULL)\n    {\n        return 0;\n    }\n    int res = 1;\n    if (tree->left != NULL)\n    {\n        res += size(tree->left);\n    }\n    if (tree->right != NULL)\n    {\n        res += size(tree->right);\n    }\n    return res;\n}", "positive": "c\nint countNodes(const struct binary_tree *nodeTree)\n{\n    if (nodeTree == NULL)\n    {\n        return 0;\n    }\n    int counter = 1; // Changed 'res' to 'counter'\n    if (nodeTree->left != NULL)\n    {\n        counter += countNodes(nodeTree->left); // Recursive call using new name\n    }\n    if (nodeTree->right != NULL)\n    {\n        counter += countNodes(nodeTree->right); // Recursive call using new name\n    }\n    return counter;\n}", "function_type": 70, "negative": "int int_vector_max(const struct int_vector vec)\n{\n    int max = vec.data[0];\n    for (size_t i = 0; i < vec.size; i++)\n    {\n        if (max < vec.data[i])\n        {\n            max = vec.data[i];\n        }\n    }\n    return max;\n}"}
{"anchor": "int is_sorted(int array[], size_t size)\n{\n    if (size == 0)\n    {\n        return 1;\n    }\n    else\n    {\n        size_t i = 1;\n        while (array[i - 1] <= array[i] && i < size)\n        {\n            i++;\n        }\n        return i == size;\n    }\n}", "positive": "int is_sorted(int* array, size_t size)\n{\n    if (!array || size <= 1) // guard clause for invalid input or empty list\n        return 1;\n        \n    int sorted = 1;   // assume that it's sorted initially\n    \n    for (size_t i = 0; i < size-1; ++i)\n    {\n        if (array[i] > array[i+1])\n        {\n            sorted = 0;   // set flag to unsorted and break from the loop as soon as we find an element out of order\n            break;\n        }\n    }\n    \n    return sorted;\n}\n```\nIn the refactor, I switched from a `while` loop to a `for` loop since in my understanding there are no real differences between them here. The rest of the logic remains exactly the same. Note also how I used a boolean variable instead of returning 1 and 0 directly which can be more clear and readable depending on your coding style.\nThe last line now checks whether all elements have been examined by comparing the index 'i' against the size of the array minus one ('size - 1'). If they match, then every previous element was less than or equal to its succeeding neighbor, indicating the array is indeed sorted. This makes our function", "function_type": 70, "negative": "int foldl(int *array, size_t len, int (*func)(int, int))\n{\n    int res = 0;\n    for (size_t i = 0; i < len; i++)\n    {\n        res = func(res, array[i]);\n    }\n    return res;\n}"}
{"anchor": "int is_sorted(int array[], size_t size)\n{\n    if (size == 0)\n    {\n        return 1;\n    }\n    else\n    {\n        size_t i = 1;\n        while (array[i - 1] <= array[i] && i < size)\n        {\n            i++;\n        }\n        return i == size;\n    }\n}", "positive": "int is_sorted(size_t i, int array[], size_t size)\n{\n    if (size == 0)\n    {\n        return 1;\n    }\n    else\n    {\n        while (i < size && array[i - 1] <= array[i])\n        {\n            i++;\n        }\n        return i == size;\n    }\n}", "function_type": 71, "negative": "int my_memcmp(const void *s1, const void *s2, size_t num)\n{\n    const char *r1 = s1;\n    const char *r2 = s2;\n    size_t i = 0;\n    while (i < num && r1[i] == r2[i])\n    {\n        i++;\n    }\n    if (i == num)\n    {\n        return 0;\n    }\n    if (r1[i] < r2[i])\n    {\n        return -1;\n    }\n    else\n    {\n        return 1;\n    }\n}"}
{"anchor": "int is_sorted(int array[], size_t size)\n{\n    if (size == 0)\n    {\n        return 1;\n    }\n    else\n    {\n        size_t i = 1;\n        while (array[i - 1] <= array[i] && i < size)\n        {\n            i++;\n        }\n        return i == size;\n    }\n}", "positive": "for size_t\n\nint check_order(int arr[], size_t length){\n    \n    if (length==0){\n        \n        return 1;\n    }else{\n     \n        size_t index=1;\n        while((arr[index-1]<=arr[index])&&(index<length)){\n            \n           index++;  \n        }\n       return index==length;\n    } \n}", "function_type": 71, "negative": "int foldr(int *array, size_t len, int (*func)(int, int))\n{\n    int res = 0;\n    int le = len;\n    for (int i = le - 1; i >= 0; i--)\n    {\n        res = func(array[i], res);\n    }\n    return res;\n}"}
{"anchor": "int is_sorted(int array[], size_t size)\n{\n    if (size == 0)\n    {\n        return 1;\n    }\n    else\n    {\n        size_t i = 1;\n        while (array[i - 1] <= array[i] && i < size)\n        {\n            i++;\n        }\n        return i == size;\n    }\n}", "positive": "c\nint check_order(const int arr[], const unsigned long len)\n{\n    if (!len) // checks whether length is zero\n    {\n        return 1;   // returns true as it's an empty array\n    }\n    else\n    {\n        unsigned long index = 1;    \n        while ((arr[index-1] <= arr[index]) && (index < len)) \n        {\n            index ++ ;\n        }\n        return index == len;         /* If we got to end of loop without breaking, then all elements are in increasing order */\n    }                                                           \n}\n```\nNote that I used `unsigned long` instead of `size_t` for the argument since C doesn't guarantee a specific range or signedness of size type, so using `unsigned long` makes sure this code can handle sizes larger than what `size_t` can hold. Also note use of \"refactoring\" terminology. It does not mean improving performance but rather improving readability and understanding.\n\nAnother way could be renaming variable types according to their usage like 'a', 'b', etc.,\n\n```c\nint is_sorted(int array[], size_t size)\n{\n    if (size == 0)\n    {\n        return 1;\n    }\n    else\n    {\n        size_t a = ", "function_type": 71, "negative": "int int_sqrt(int n)\n{\n    if (n < 0)\n    {\n        return -1;\n    }\n    else\n    {\n        int i = 0;\n        while (i * i <= n)\n        {\n            i++;\n        }\n        return i - 1;\n    }\n}"}
{"anchor": "int is_sorted(int array[], size_t size)\n{\n    if (size == 0)\n    {\n        return 1;\n    }\n    else\n    {\n        size_t i = 1;\n        while (array[i - 1] <= array[i] && i < size)\n        {\n            i++;\n        }\n        return i == size;\n    }\n}", "positive": "c\nint is_sorted(int array[], size_t size)\n{\n    // If there are no elements in the array, it's sorted\n    if (size == 0)\n    {\n        return 1;\n    }\n    \n    // Initialize index at first position of the array\n    size_t currentIndex = 0;\n\n    // Loop through all but last element in the array\n    for (; currentIndex + 1 < size; ++currentIndex)\n    {\n        \n        int previous = array[currentIndex];   // Save value before comparison\n        int next = array[currentIndex+1];      // Next value to compare with\n      \n        // Check if pair is not sorted\n        if (previous > next)\n        {\n             // The sequence isn't sorted, so return false immediately\n             return 0;\n        }", "function_type": 71, "negative": "unsigned array_min(const int arr[], unsigned start, unsigned size)\n{\n    unsigned res = start;\n    for (size_t i = start; i < size; i++)\n    {\n        if (arr[i] < arr[res])\n        {\n            res = i;\n        }\n    }\n    return res;\n}"}
{"anchor": "int binary_search(const int vec[], int size, int elt)\n{\n    if (size == 0)\n    {\n        return -1;\n    }\n    int max = size;\n    int min = 0;\n\n    while (max > min)\n    {\n        int mid = (min + max) / 2;\n        if (vec[mid] == elt)\n        {\n            return mid;\n        }\n        if (vec[mid] < elt)\n        {\n            min = mid + 1;\n        }\n        else\n        {\n            max = mid;\n        }\n    }\n    return -1;\n}", "positive": "c\nint search_binary(const int *array, const int target, const int length)\n{\n    if (!length)\n    {\n        return -1;\n    }\n\n    int start = 0;\n    int end = length-1;\n    \n    while (start <= end)\n    {\n        int middle = (end+start)/2;\n        \n        if (target== array[middle]) \n        {\n            return middle;\n        }\n        else if (target> array[middle]) \n        {\n            start= middle+1;\n        }\n        else \n        {\n            end= middle-1;\n        }\n    }\n    return -1;\n}", "function_type": 71, "negative": "int int_vector_max(const struct int_vector vec)\n{\n    int max = vec.data[0];\n    for (size_t i = 0; i < vec.size; i++)\n    {\n        if (max < vec.data[i])\n        {\n            max = vec.data[i];\n        }\n    }\n    return max;\n}"}
{"anchor": "int binary_search(const int vec[], int size, int elt)\n{\n    if (size == 0)\n    {\n        return -1;\n    }\n    int max = size;\n    int min = 0;\n\n    while (max > min)\n    {\n        int mid = (min + max) / 2;\n        if (vec[mid] == elt)\n        {\n            return mid;\n        }\n        if (vec[mid] < elt)\n        {\n            min = mid + 1;\n        }\n        else\n        {\n            max = mid;\n        }\n    }\n    return -1;\n}", "positive": "c\nint binary_search(const int vec[], int size, int elt)\n{\n    // If the array is empty...\n    if (size == 0)\n    {\n        return -1;  // ...the element can't be found, so we return -1.\n    }\n    \n    // Initialize our minimum and maximum values for searching within the array.\n    int low = 0;\n    int high = size - 1;\n\n    while (low <= high)\n    {\n        // Calculate the middle index of our current search range.\n        int mid = low + ((high-low)/2);\n        \n        // Check what value at `mid` is in relation to our target value.\n        if (elt == vec[mid])\n        {\n            // Found it, so we return the position.\n            return mid;\n        }\n        else if (elt < vec[mid])\n        {\n            // Our target value is less than the one at `mid`, so adjust the upper limit.\n            high = mid - 1;\n        }\n        else\n        {\n            // The target value is greater than `mid`, so set a new lower limit.\n            low = mid + 1;\n        }\n    }\n  \n    // We didn't find the element :(\n", "function_type": 72, "negative": "int size(const struct binary_tree *tree)\n{\n    if (tree == NULL)\n    {\n        return 0;\n    }\n    int res = 1;\n    if (tree->left != NULL)\n    {\n        res += size(tree->left);\n    }\n    if (tree->right != NULL)\n    {\n        res += size(tree->right);\n    }\n    return res;\n}"}
{"anchor": "int binary_search(const int vec[], int size, int elt)\n{\n    if (size == 0)\n    {\n        return -1;\n    }\n    int max = size;\n    int min = 0;\n\n    while (max > min)\n    {\n        int mid = (min + max) / 2;\n        if (vec[mid] == elt)\n        {\n            return mid;\n        }\n        if (vec[mid] < elt)\n        {\n            min = mid + 1;\n        }\n        else\n        {\n            max = mid;\n        }\n    }\n    return -1;\n}", "positive": "c\nint binary_search(const int array[], int length, int target)\n{\n    if (length == 0)\n    {\n        return -1;\n    }\n    int high = length; // renamed 'max' to 'high'\n    int low = 0; // renamed 'min' to 'low'\n\n    while (high > low)\n    {\n        int middle = (low + high) / 2;\n        if (array[middle] == target)\n        {\n            return middle;\n        }\n        if (array[middle] < target)\n        {\n            low = middle + 1;\n        }\n        else\n        {\n            high = middle;\n        }\n    }\n    return -1;\n}", "function_type": 72, "negative": "int height(const struct binary_tree *tree)\n{\n    if (tree == NULL)\n    {\n        return -1;\n    }\n    int max = 0;\n    int max2 = 0;\n    if (tree->left != NULL)\n    {\n        max = height(tree->left) + 1;\n    }\n    if (tree->right != NULL)\n    {\n        max2 = height(tree->right) + 1;\n    }\n    return (max < max2) ? max2 : max;\n}"}
{"anchor": "int binary_search(const int vec[], int size, int elt)\n{\n    if (size == 0)\n    {\n        return -1;\n    }\n    int max = size;\n    int min = 0;\n\n    while (max > min)\n    {\n        int mid = (min + max) / 2;\n        if (vec[mid] == elt)\n        {\n            return mid;\n        }\n        if (vec[mid] < elt)\n        {\n            min = mid + 1;\n        }\n        else\n        {\n            max = mid;\n        }\n    }\n    return -1;\n}", "positive": "c\nvoid binarySearchHelper(const int* vec, int min, int max, int elt, int *result){\n    \n    // Base case for recursion\n    if (max >= min){  \n        \n        int mid = min + (max - min ) / 2;\n         \n        // If the element is present at middle\n        if (*(vec+mid) == elt){  \n             *result= mid;\n             return ;\n        }\n      \n        // If element is smaller than mid, then it can only be present in left subarray\n        if (*(vec+mid) > elt)\n           return binarySearchHelper(vec, min, mid-1, elt, result);\n             \n        // Else the element can only be present in right subarray\n        return binarySearchHelper(vec, mid+1, max, elt, result);\n   }\n   \n   // We reach here when element is not present in array\n   *result = -1;\n   return ;\n}", "function_type": 72, "negative": "unsigned array_min(const int arr[], unsigned start, unsigned size)\n{\n    unsigned res = start;\n    for (size_t i = start; i < size; i++)\n    {\n        if (arr[i] < arr[res])\n        {\n            res = i;\n        }\n    }\n    return res;\n}"}
{"anchor": "int binary_search(const int vec[], int size, int elt)\n{\n    if (size == 0)\n    {\n        return -1;\n    }\n    int max = size;\n    int min = 0;\n\n    while (max > min)\n    {\n        int mid = (min + max) / 2;\n        if (vec[mid] == elt)\n        {\n            return mid;\n        }\n        if (vec[mid] < elt)\n        {\n            min = mid + 1;\n        }\n        else\n        {\n            max = mid;\n        }\n    }\n    return -1;\n}", "positive": "c\nint binary_search(const int* ptr, int size, int elt)\n{\n    if (size == 0)\n    {\n        return -1;\n    }\n    int max = size;\n    int min = 0;\n\n    while (max > min)\n    {\n        int mid = (min + max) / 2;\n        if (*(ptr+mid) == elt)\n        {\n            return mid;\n        }\n        if (*(ptr+mid) < elt)\n        {\n            min = mid + 1;\n        }\n        else\n        {\n            max = mid;\n        }\n    }\n    return -1;\n}", "function_type": 72, "negative": "int my_memcmp(const void *s1, const void *s2, size_t num)\n{\n    const char *r1 = s1;\n    const char *r2 = s2;\n    size_t i = 0;\n    while (i < num && r1[i] == r2[i])\n    {\n        i++;\n    }\n    if (i == num)\n    {\n        return 0;\n    }\n    if (r1[i] < r2[i])\n    {\n        return -1;\n    }\n    else\n    {\n        return 1;\n    }\n}"}
{"anchor": "unsigned char rol(unsigned char value, unsigned char roll)\n{\n    while (roll != 0)\n    {\n        value = (value >> 7) | (value << 1);\n        roll -= 1;\n    }\n    return value;\n}", "positive": "c\nint main() {\n    unsigned char arr[] = {0b10000000, 0b01000000, 0b00100000};\n    rol_arr(arr, sizeof(arr)/sizeof(arr[0]));\n    printf(\"Final result: %u\\n\", arr[2]);\n    return 0;\n", "function_type": 72, "negative": "void my_rol_crypt(void *data, size_t data_len, const void *key, size_t key_len)\n{\n    unsigned char *tem = data;\n    const unsigned char *te = key;\n    for (size_t i = 0; i < data_len; i++)\n    {\n        tem[i] = (tem[i] + te[i % key_len]) % 256;\n    }\n    data = tem;\n}"}
{"anchor": "unsigned char rol(unsigned char value, unsigned char roll)\n{\n    while (roll != 0)\n    {\n        value = (value >> 7) | (value << 1);\n        roll -= 1;\n    }\n    return value;\n}", "positive": "c\nvoid rol_arr(unsigned char *val, unsigned int len, unsigned char shift) \n{\n    if(!len || !shift){return;} // Early exit for edge cases of zero length or zero shift\n    \n    /* Set up variables */\n\tunsigned char upperbits = 0x80;\t// bitmask for MSB in a byte\n    unsigned char lowerbits = 0x01;   // bitmask for LSB in a byte\n        \n    while (shift > 0 )\n    {\n        for(int i=0;i<len;i++)\n        {\n            if((*val & upperbits) == upperbits){ *val = (*val <<1) | 0x01 ;}// if most significant bit is set then rotate left and set least significant bit to 1\n            else{*val = *val<<1;}           //else just do normal rotation\n         \n        }\n        shift--;                            // decrement shift count\n    }\n}", "function_type": 73, "negative": "unsigned int is_set(unsigned int value, unsigned char n)\n{\n    unsigned int temp = 1 << (n - 1);\n    return (value & temp) == temp;\n}"}
{"anchor": "unsigned char rol(unsigned char value, unsigned char roll)\n{\n    while (roll != 0)\n    {\n        value = (value >> 7) | (value << 1);\n        roll -= 1;\n    }\n    return value;\n}", "positive": "c\nunsigned char rol(unsigned char value, unsigned char roll)\n{\n    // Intermediate variable for temporary shift values\n    unsigned int temp = 0; \n    \n    while (roll != 0)\n    {\n        temp = ((int)value & 0x80) >> 7;   // Save leftmost bit\n        \n        value = (value >> 1) | (temp << 7); // Shift right and add saved bit back to the leftmost position\n        \n        roll -= 1;\n    }\n    return value;\n}", "function_type": 73, "negative": "unsigned int digit(int n, int k)\n{\n    if (n <= 0 || k <= 0)\n    {\n        return 0;\n    }\n    else\n    {\n        while (k != 1)\n        {\n            n = n / 10;\n            k--;\n        }\n        return n % 10;\n    }\n}"}
{"anchor": "unsigned char rol(unsigned char value, unsigned char roll)\n{\n    while (roll != 0)\n    {\n        value = (value >> 7) | (value << 1);\n        roll -= 1;\n    }\n    return value;\n}", "positive": "c\nunsigned char rol(unsigned char value, unsigned char roll)\n{\n    unsigned char temp = 0;  // Intermediate variable to hold shifted bits\n    while (roll != 0)\n    {\n        temp = value & 0x80 ? 0x01 : 0x00;  // Check if highest bit is set in value\n        value <<= 1;                         // Shift left original value\n        value |= temp;                        // Put temporary back into original value\n        roll -= 1;                            // Decrement roll\n    }\n    return value;\n}", "function_type": 73, "negative": "unsigned int greatest_divisor(unsigned int n)\n{\n    unsigned int res = 2;\n    while (n % res != 0 && res * res <= n)\n    {\n        res += 1;\n    }\n    if (n % res == 0)\n    {\n        return n / res;\n    }\n    else\n    {\n        return 1;\n    }\n}"}
{"anchor": "unsigned char rol(unsigned char value, unsigned char roll)\n{\n    while (roll != 0)\n    {\n        value = (value >> 7) | (value << 1);\n        roll -= 1;\n    }\n    return value;\n}", "positive": "c\nvoid rol(unsigned char *value, unsigned char *roll)\n{\n    while (*roll != 0)\n    {\n        *value = (*value >> 7) | (*value << 1);\n        (*roll)--;\n    }\n}", "function_type": 73, "negative": "int find(const char s, const char *c)\n{\n    int i = 0;\n    while (c[i] != '\\0' && c[i] != s)\n    {\n        i++;\n    }\n    return (c[i] == '\\0') ? -1 : i;\n}"}
{"anchor": "int max_bst(struct bst_node *tree)\n{\n    if (tree->right != NULL)\n    {\n        return max_bst(tree->right);\n    }\n    else\n    {\n        return tree->data;\n    }\n}", "positive": "c\nint max_bst(struct bst_node **tree)\n{\n    if ((*tree)->right != NULL)\n    {\n        return max_bst(&((*tree)->right));\n    }\n    else\n    {\n        return (*tree)->data;\n    }\n}", "function_type": 73, "negative": "int height(const struct binary_tree *tree)\n{\n    if (tree == NULL)\n    {\n        return -1;\n    }\n    int max = 0;\n    int max2 = 0;\n    if (tree->left != NULL)\n    {\n        max = height(tree->left) + 1;\n    }\n    if (tree->right != NULL)\n    {\n        max2 = height(tree->right) + 1;\n    }\n    return (max < max2) ? max2 : max;\n}"}
{"anchor": "int max_bst(struct bst_node *tree)\n{\n    if (tree->right != NULL)\n    {\n        return max_bst(tree->right);\n    }\n    else\n    {\n        return tree->data;\n    }\n}", "positive": "c\nint findMaxBST(const struct bst_node* root) \n{\n   while(root){\n      if(!root -> right) // leaf node found\n         return root -> data;\n      \n      root = root -> right;\n   }\n}", "function_type": 74, "negative": "int size(const struct binary_tree *tree)\n{\n    if (tree == NULL)\n    {\n        return 0;\n    }\n    int res = 1;\n    if (tree->left != NULL)\n    {\n        res += size(tree->left);\n    }\n    if (tree->right != NULL)\n    {\n        res += size(tree->right);\n    }\n    return res;\n}"}
{"anchor": "int max_bst(struct bst_node *tree)\n{\n    if (tree->right != NULL)\n    {\n        return max_bst(tree->right);\n    }\n    else\n    {\n        return tree->data;\n    }\n}", "positive": "c\nint max_bst(struct bst_node *tree)\n{\n    while (tree->right != NULL) \n    {\n        tree = tree->right;   // Move one step to the right in BST\n    }\n    return tree->data;       // Return value of last node which is maximum\n}", "function_type": 74, "negative": "int int_vector_max(const struct int_vector vec)\n{\n    int max = vec.data[0];\n    for (size_t i = 0; i < vec.size; i++)\n    {\n        if (max < vec.data[i])\n        {\n            max = vec.data[i];\n        }\n    }\n    return max;\n}"}
{"anchor": "int max_bst(struct bst_node *tree)\n{\n    if (tree->right != NULL)\n    {\n        return max_bst(tree->right);\n    }\n    else\n    {\n        return tree->data;\n    }\n}", "positive": "c\nint getMaxElement(const struct bst_node* root) \n{\n   while (root->right != NULL)\n    {\n       root = root->right;\n    }\n    \n   return root->data; \n}", "function_type": 74, "negative": "void array_max_min(int tab[], size_t len, int *max, int *min)\n{\n    if (tab != NULL && len != 0)\n    {\n        *max = tab[0];\n        *min = tab[0];\n        for (size_t i = 0; i < len; i++)\n        {\n            if (tab[i] > *max)\n            {\n                *max = tab[i];\n            }\n            else if (tab[i] < *min)\n            {\n                *min = tab[i];\n            }\n        }\n    }\n}"}
{"anchor": "int max_bst(struct bst_node *tree)\n{\n    if (tree->right != NULL)\n    {\n        return max_bst(tree->right);\n    }\n    else\n    {\n        return tree->data;\n    }\n}", "positive": "c\nint max_bst(struct bst_node *tree)\n{\n    while (tree->right != NULL)\n    {\n        tree = tree->right;\n    }\n    \n    return tree->data;\n}", "function_type": 74, "negative": "int max(int *l)\n{\n    int ma = 0;\n    for (int i = 0; i < 26; i++)\n    {\n        if (l[ma] < l[i])\n        {\n            ma = i;\n        }\n    }\n    return ma;\n}"}
{"anchor": "void rot_x(char *s, int x)\n{\n    if (s != NULL)\n    {\n        for (int i = 0; s[i] != '\\0'; i++)\n        {\n            if (s[i] >= 'A' && s[i] <= 'Z')\n            {\n                s[i] = (s[i] + x % 26 - 'A' + 26) % 26 + 'A';\n            }\n            else if (s[i] >= 'a' && s[i] <= 'z')\n            {\n                s[i] = (s[i] + x % 26 - 'a' + 26) % 26 + 'a';\n            }\n        }\n    }\n}", "positive": "c\nvoid rot_x(char *s, int x)\n{\n    char addend1, addend2, result;\n    \n    if (s != NULL)\n    {\n        for (int i = 0; s[i] != '\\0'; i++)\n        {\n            if (s[i] >= 'A' && s[i] <= 'Z')\n            {\n\t       // uppercase letter\n               addend1 = s[i] - 'A';           // Calculate position in alphabet (from A-Z)\n\t       addend2 = x % 26;                 // Number to rotate by modulo 26\n\t       result  = (addend1 + addend2) % 26;// New position after rotation\n\t       s[i]    = result + 'A';           // Convert back to ASCII character ('A'-'Z')\n            }\n\t    else if (s[i] >= 'a' && s[i] <= 'z')\n            {\n\t        // lowercase letter\n               addend1 = s[i] - 'a';           // Calculate position in alphabet (from a-z)\n\t       addend2 = x % 26;                 // Number to rotate by modulo 26\n\t       result  = (addend1 + adden2)", "function_type": 74, "negative": "void sieve(int n)\n{\n    if (n > 2)\n    {\n        int res = 0;\n        char *list = calloc(n, 1);\n        for (long i = 2; i < n; i++)\n        {\n            if (list[i] == 0)\n            {\n                res++;\n                for (long j = i; j < n; j += i)\n                {\n                    list[j] = 1;\n                }\n            }\n        }\n        free(list);\n        printf(\"%d\\n\", res);\n    }\n}"}
{"anchor": "void rot_x(char *s, int x)\n{\n    if (s != NULL)\n    {\n        for (int i = 0; s[i] != '\\0'; i++)\n        {\n            if (s[i] >= 'A' && s[i] <= 'Z')\n            {\n                s[i] = (s[i] + x % 26 - 'A' + 26) % 26 + 'A';\n            }\n            else if (s[i] >= 'a' && s[i] <= 'z')\n            {\n                s[i] = (s[i] + x % 26 - 'a' + 26) % 26 + 'a';\n            }\n        }\n    }\n}", "positive": "c\nvoid rot_x(char* str, size_t len, int shift)\n{\n    const char lowers[]  = \"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\";\n    const char uppers[]  = \"ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    \n    for (size_t idx = 0; idx < len; ++idx){\n        char c = str[idx];\n        \n        // If character is uppercase or lowercase letter\n        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')){\n            const char* map = (c >= 'a') ? lowers : uppers;\n            \n            // Shift and wraparound\n            str[idx] = map[(c - ((c>='a')?'a':'A')) + 26 + shift];\n        }\n    }\n}", "function_type": 75, "negative": "int append_file(const char *file_in, const char *content)\n{\n    if (content == NULL)\n    {\n        return -1;\n    }\n    FILE *f1 = fopen(file_in, \"a\");\n    if (f1 == NULL)\n    {\n        return -1;\n    }\n    fprintf(f1, \"%s\", content);\n    fclose(f1);\n    return 0;\n}"}
{"anchor": "void rot_x(char *s, int x)\n{\n    if (s != NULL)\n    {\n        for (int i = 0; s[i] != '\\0'; i++)\n        {\n            if (s[i] >= 'A' && s[i] <= 'Z')\n            {\n                s[i] = (s[i] + x % 26 - 'A' + 26) % 26 + 'A';\n            }\n            else if (s[i] >= 'a' && s[i] <= 'z')\n            {\n                s[i] = (s[i] + x % 26 - 'a' + 26) % 26 + 'a';\n            }\n        }\n    }\n}", "positive": "void rotate_string(char *str, int rotationFactor)\n{\n    if (str != NULL)\n    {\n        for (int index = 0; str[index] != '\\0'; ++index)\n        {\n            if (isupper(str[index]))\n            {\n                str[index] = ((str[index] - 'A' + rotationFactor % 26 + 26) % 26 )+ 'A';\n            }\n            else if (islower(str[index]))\n            {\n                str[index] = ((str[index] - 'a' + rotationFactor % 26 + 26) % 26 )+ 'a';\n            }\n        }\n    }\n}", "function_type": 75, "negative": "void variant_display(const struct variant *e)\n{\n    if (e->type == TYPE_INT)\n        printf(\"%d\\n\", e->value.int_v);\n    if (e->type == TYPE_FLOAT)\n        printf(\"%f\\n\", e->value.float_v);\n    if (e->type == TYPE_CHAR)\n        printf(\"%c\\n\", e->value.char_v);\n    if (e->type == TYPE_STRING)\n        printf(\"%s\\n\", e->value.str_v);\n}"}
{"anchor": "void rot_x(char *s, int x)\n{\n    if (s != NULL)\n    {\n        for (int i = 0; s[i] != '\\0'; i++)\n        {\n            if (s[i] >= 'A' && s[i] <= 'Z')\n            {\n                s[i] = (s[i] + x % 26 - 'A' + 26) % 26 + 'A';\n            }\n            else if (s[i] >= 'a' && s[i] <= 'z')\n            {\n                s[i] = (s[i] + x % 26 - 'a' + 26) % 26 + 'a';\n            }\n        }\n    }\n}", "positive": "c\nvoid rot_x(int x, char *s)\n{\n    if (s != NULL)\n    {\n        for (int i = 0; s[i]; i++)\n        {\n            if (s[i] >= 'A' && s[i] <= 'Z')\n            {\n                s[i] = (s[i] - 'A' + (x % 26 + 26) % 26) % 26 + 'A';\n            }\n            else if (s[i] >= 'a' && s[i] <= 'z')\n            {\n                s[i] = (s[i] - 'a' + (x % 26 + 26) % 26) % 26 + 'a';\n            }\n        }\n    }\n}", "function_type": 75, "negative": "int my_memcmp(const void *s1, const void *s2, size_t num)\n{\n    const char *r1 = s1;\n    const char *r2 = s2;\n    size_t i = 0;\n    while (i < num && r1[i] == r2[i])\n    {\n        i++;\n    }\n    if (i == num)\n    {\n        return 0;\n    }\n    if (r1[i] < r2[i])\n    {\n        return -1;\n    }\n    else\n    {\n        return 1;\n    }\n}"}
{"anchor": "void rot_x(char *s, int x)\n{\n    if (s != NULL)\n    {\n        for (int i = 0; s[i] != '\\0'; i++)\n        {\n            if (s[i] >= 'A' && s[i] <= 'Z')\n            {\n                s[i] = (s[i] + x % 26 - 'A' + 26) % 26 + 'A';\n            }\n            else if (s[i] >= 'a' && s[i] <= 'z')\n            {\n                s[i] = (s[i] + x % 26 - 'a' + 26) % 26 + 'a';\n            }\n        }\n    }\n}", "positive": "c\nvoid rot_x(char *s, int x)\n{\n    if (s != NULL)\n    {\n        char* ptr = &s[0]; // Point to start of string\n        \n        while (*ptr != '\\0')\n        {\n            if (*ptr >= 'A' && *ptr <= 'Z')\n            {\n                *ptr = (*ptr - 'A' + (x % 26)) % 26 + 'A';\n            }\n            else if (*ptr >= 'a' && *ptr <= 'z')\n            {\n                *ptr = (*ptr - 'a' + (x % 26)) % 26 + 'a';\n            }\n            \n            ptr += 1; // Move on to next character in string\n        }\n    }\n}", "function_type": 75, "negative": "void array_max_min(int tab[], size_t len, int *max, int *min)\n{\n    if (tab != NULL && len != 0)\n    {\n        *max = tab[0];\n        *min = tab[0];\n        for (size_t i = 0; i < len; i++)\n        {\n            if (tab[i] > *max)\n            {\n                *max = tab[i];\n            }\n            else if (tab[i] < *min)\n            {\n                *min = tab[i];\n            }\n        }\n    }\n}"}
{"anchor": "void plus_equal(int *a, int *b)\n{\n    if (a != NULL && b != NULL)\n    {\n        *a += *b;\n    }\n}", "positive": "c\nvoid plus_equal(int *a, int *b)\n{\n    int temp = 0;\n    \n    if (a == NULL || b == NULL)\n    {\n        return;\n    }\n  \n    temp = *a + *b;\n    *a = temp;\n}", "function_type": 75, "negative": "void rot_x(char *s, int x)\n{\n    if (s != NULL)\n    {\n        for (int i = 0; s[i] != '\\0'; i++)\n        {\n            if (s[i] >= 'A' && s[i] <= 'Z')\n            {\n                s[i] = (s[i] + x % 26 - 'A' + 26) % 26 + 'A';\n            }\n            else if (s[i] >= 'a' && s[i] <= 'z')\n            {\n                s[i] = (s[i] + x % 26 - 'a' + 26) % 26 + 'a';\n            }\n        }\n    }\n}"}
{"anchor": "void plus_equal(int *a, int *b)\n{\n    if (a != NULL && b != NULL)\n    {\n        *a += *b;\n    }\n}", "positive": "c\nvoid plus_equal(int **a, int **b)\n{\n    if (*a != NULL && *b != NULL)\n    {\n       **a += **b;\n    }\n}", "function_type": 76, "negative": "void insertion_sort(void **array, f_cmp comp)\n{\n    if (array != NULL && *array != NULL)\n    {\n        for (int i = 1; array[i] != NULL; i++)\n        {\n            int j = i;\n            while (j > 0 && comp(array[j - 1], array[j]) > 0)\n            {\n                void *temp = array[j];\n                array[j] = array[j - 1];\n                array[j - 1] = temp;\n                j--;\n            }\n        }\n    }\n}"}
{"anchor": "void plus_equal(int *a, int *b)\n{\n    if (a != NULL && b != NULL)\n    {\n        *a += *b;\n    }\n}", "positive": "c\nvoid plus_equal(int *a, int *b)\n{\n    if (a != NULL && b != NULL)\n    {\n        int tempA = *a;\n        int tempB = *b;\n        \n        *a = tempA + tempB;\n    }\n}", "function_type": 76, "negative": "void array_max_min(int tab[], size_t len, int *max, int *min)\n{\n    if (tab != NULL && len != 0)\n    {\n        *max = tab[0];\n        *min = tab[0];\n        for (size_t i = 0; i < len; i++)\n        {\n            if (tab[i] > *max)\n            {\n                *max = tab[i];\n            }\n            else if (tab[i] < *min)\n            {\n                *min = tab[i];\n            }\n        }\n    }\n}"}
{"anchor": "int main(void)\n{\n    for (int i = 0; i < 26; i++)\n    {\n        putchar(97 + i);\n        if (i != 25)\n        {\n            putchar(' ');\n        }\n    }\n    putchar('\\n');\n    return 0;\n}", "positive": "int main()\n{\n    char new_line = '\\n';\n    int last_alphabet_index = 25;\n    \n    // Loop through all alphabets from a to z\n    for (int i=0; i<=last_alphabet_index; ++i)\n    {\n        char current_character = ('a' + i);\n        \n        printf(\"%c\", current_character);\n      \n        // Print space after each character except for the last one\n        if (i != last_alphabet_index)\n        {\n          printf(\" \");\n        }\n    }\n  \n    printf(\"%c\",new_line);\n\t\n    return 0;\n}", "function_type": 76, "negative": "int main(int argc, char **argv)\n{\n    if (argc != 3)\n    {\n        return 1;\n    }\n    int nb = argv[2][0] - '0';\n    for (int i = 0; i < nb; i++)\n    {\n        puts(argv[1]);\n    }\n    return 0;\n}"}
{"anchor": "int main(void)\n{\n    for (int i = 0; i < 26; i++)\n    {\n        putchar(97 + i);\n        if (i != 25)\n        {\n            putchar(' ');\n        }\n    }\n    putchar('\\n');\n    return 0;\n}", "positive": "int main() {\n    // Start a loop that will iterate through all ASCII characters from lowercase a-z\n    for (int ascii_value = 97; ascii_value <= 122; ++ascii_value) {\n        \n        // Print each character to standard output\n        printf(\"%c\", ascii_value);\n        \n        // If it's not the last iteration...\n        if (ascii_value != 122) {\n            \n            // Add a space after each character except for the last one\n            printf(\" \");\n        }\n    }\n    \n    // End with a newline character\n    printf(\"\\n\");\n\t\n\t// Returning 0 indicates successful execution of program\n\treturn 0;\n}\n```\n\nNotes: The variable `i` in original was renamed to `ascii_value` and its value is directly assigned instead of being incremented by an operation on itself. In refactoring we also added the missing include statement at top for stdio.h library which provides prototypes for functions like printf().\nAlso note that there are no longer any magic numbers involved - they have been replaced with more meaningful constant identifiers, increasing readability.\nRewrite this Python function using list comprehension:\n\nOriginal", "function_type": 77, "negative": "int main(void)\n{\n    puts(\"Hello World!\");\n    return 0;\n}"}
{"anchor": "int main(void)\n{\n    for (int i = 0; i < 26; i++)\n    {\n        putchar(97 + i);\n        if (i != 25)\n        {\n            putchar(' ');\n        }\n    }\n    putchar('\\n');\n    return 0;\n}", "positive": "int main() {\n   char alphabet[27] = \"abcdefghijklmnopqrstuvwxyz\";\n   int i;\n\n   for (i = 0; i<26; i++){\n       printf(\"%c\", *(alphabet+i));\n      if (i != 25){\n         printf(\" \");\n      }\n   }\n\n   printf(\"\\n\");\n   return 0;\n}", "function_type": 77, "negative": "int main(int argc, char **argv)\n{\n    if (argc == 1)\n    {\n        printf(\"Hello World!\\n\");\n    }\n    else\n    {\n        for (int i = 1; i < argc; i++)\n        {\n            printf(\"Hello %s!\\n\", argv[i]);\n        }\n    }\n    return 0;\n}"}
{"anchor": "int main(void)\n{\n    for (int i = 0; i < 26; i++)\n    {\n        putchar(97 + i);\n        if (i != 25)\n        {\n            putchar(' ');\n        }\n    }\n    putchar('\\n');\n    return 0;\n}", "positive": "int main(void)\n{\n    int ch;\n    \n    // Initialize ch to ASCII value of lowercase a\n    ch = 'a';\n\n    // Start loop from 1 as we already printed one character at start\n    for (int i = 1; i <= 26; i++)\n    {\n        printf(\"%c\", ch);\n        \n        // If not last iteration then print space after each char\n        if (i != 26)\n        {\n            printf(\" \");\n        }\n      \n      // Increment ch by 1 to get next alphabet in subsequent iterations\n      ch += 1;\n    }\n  \n    // Print newline at end\n    printf(\"\\n\");\n\n    return 0;\n}", "function_type": 77, "negative": "int main(void)\n{\n    struct dlist *list = dlist_init();\n    for (int i = 0; i < 5; i++)\n    {\n        dlist_insert_at(list, i, i);\n    }\n    dlist_insert_at(list, 6, 3);\n    dlist_print(list);\n    return 0;\n}"}
{"anchor": "int main(void)\n{\n    for (int i = 0; i < 26; i++)\n    {\n        putchar(97 + i);\n        if (i != 25)\n        {\n            putchar(' ');\n        }\n    }\n    putchar('\\n');\n    return 0;\n}", "positive": "void print_alpha(const char *arr, size_t len){\n    for (size_t i = 0; i < len; i++){\n        printf(\"%c\", arr[i]);\n        if (i + 1 != len){\n            printf(\" \");\n        }else{\n            printf(\"\\n\");\n        }\n    }\n}", "function_type": 77, "negative": "void sieve(int n)\n{\n    if (n > 2)\n    {\n        int res = 0;\n        char *list = calloc(n, 1);\n        for (long i = 2; i < n; i++)\n        {\n            if (list[i] == 0)\n            {\n                res++;\n                for (long j = i; j < n; j += i)\n                {\n                    list[j] = 1;\n                }\n            }\n        }\n        free(list);\n        printf(\"%d\\n\", res);\n    }\n}"}
{"anchor": "void my_xor_crypt(void *data, size_t data_len, const void *key, size_t key_len)\n{\n    unsigned char *tem = data;\n    const unsigned char *te = key;\n    for (size_t i = 0; i < data_len; i++)\n    {\n        tem[i] = tem[i] ^ te[i % key_len];\n    }\n    data = tem;\n}", "positive": "c\nvoid my_xor_crypt(unsigned char* data, size_t data_len, const unsigned char* key, size_t key_len){\n    for (int i=0; i<data_len; i++){\n        data[i]^=key[i%key_len];\n    }\n}", "function_type": 77, "negative": "void my_rol_crypt(void *data, size_t data_len, const void *key, size_t key_len)\n{\n    unsigned char *tem = data;\n    const unsigned char *te = key;\n    for (size_t i = 0; i < data_len; i++)\n    {\n        tem[i] = (tem[i] + te[i % key_len]) % 256;\n    }\n    data = tem;\n}"}
{"anchor": "void my_xor_crypt(void *data, size_t data_len, const void *key, size_t key_len)\n{\n    unsigned char *tem = data;\n    const unsigned char *te = key;\n    for (size_t i = 0; i < data_len; i++)\n    {\n        tem[i] = tem[i] ^ te[i % key_len];\n    }\n    data = tem;\n}", "positive": "c\nvoid refactored_my_xor_crypt(unsigned char **pData, size_t data_len, const unsigned char *pKey, size_t key_len)\n{\n    unsigned char *tempBuffer = (*pData);\n    for (size_t i = 0; i < data_len; i++)\n    {\n        tempBuffer[i] = tempBuffer[i] ^ pKey[i % key_len];\n    }\n    (*pData) = tempBuffer;\n}", "function_type": 78, "negative": "void cipher(const char *key, const char *msg, char *res)\n{\n    int j = 0;\n    int len = 0;\n    while (key[len] != '\\0')\n    {\n        len += 1;\n    }\n    for (int i = 0; msg[i] != 0; i++)\n    {\n        int tem = (msg[i] - 'A');\n        int kem = (key[j % len] - 'A') % 32;\n        if ((tem >= 0 && tem <= 25) || (tem >= 32 && tem <= 57))\n        {\n            res[i] = (tem % 32 + kem) % 26 + 'A';\n            j++;\n        }\n        else\n        {\n            res[i] = msg[i];\n        }\n    }\n}"}
{"anchor": "void my_xor_crypt(void *data, size_t data_len, const void *key, size_t key_len)\n{\n    unsigned char *tem = data;\n    const unsigned char *te = key;\n    for (size_t i = 0; i < data_len; i++)\n    {\n        tem[i] = tem[i] ^ te[i % key_len];\n    }\n    data = tem;\n}", "positive": "c\nvoid my_xor_crypt(void **data, size_t data_len, const void **key, size_t key_len)\n{\n    unsigned char *temp = *data; // temporary pointer to data \n    const unsigned char *tek = *key; // temporary pointer to key\n    \n    while(data_len-- > 0){       // iterate until data length is zero\n        *temp = *temp ^ tek[*temp % key_len];   // apply XOR operation\n        ++temp;                               // increment temp pointer\n    }\n    *data = temp;                          // update original pointers with new value of 'temp'\n}", "function_type": 78, "negative": "int my_memcmp(const void *s1, const void *s2, size_t num)\n{\n    const char *r1 = s1;\n    const char *r2 = s2;\n    size_t i = 0;\n    while (i < num && r1[i] == r2[i])\n    {\n        i++;\n    }\n    if (i == num)\n    {\n        return 0;\n    }\n    if (r1[i] < r2[i])\n    {\n        return -1;\n    }\n    else\n    {\n        return 1;\n    }\n}"}
{"anchor": "void my_xor_crypt(void *data, size_t data_len, const void *key, size_t key_len)\n{\n    unsigned char *tem = data;\n    const unsigned char *te = key;\n    for (size_t i = 0; i < data_len; i++)\n    {\n        tem[i] = tem[i] ^ te[i % key_len];\n    }\n    data = tem;\n}", "positive": "c\nvoid my_xor_crypt(unsigned char **data, size_t data_len, const unsigned char *key, size_t key_len)\n{\n    unsigned char *tem = *data;\n    for (size_t i = 0; i < data_len; i++)\n    {\n        tem[i] ^= key[i % key_len];\n    }\n    *data = tem;\n}", "function_type": 78, "negative": "void my_strlowcase(char *str)\n{\n    for (size_t i = 0; *(str + i); i++)\n    {\n        if (*(str + i) < 91 && *(str + i) > 64)\n        {\n            *(str + i) = *(str + i) + 32;\n        }\n    }\n}"}
{"anchor": "void my_xor_crypt(void *data, size_t data_len, const void *key, size_t key_len)\n{\n    unsigned char *tem = data;\n    const unsigned char *te = key;\n    for (size_t i = 0; i < data_len; i++)\n    {\n        tem[i] = tem[i] ^ te[i % key_len];\n    }\n    data = tem;\n}", "positive": "c\nvoid my_xor_crypt(void *data, size_t data_len, const void *key, size_t key_len)\n{\n    // Intermediate variable for 'data' pointer casted to an array of unsigned chars \n    unsigned char *tempData = (unsigned char *) data;\n    \n    // Intermediate variable for 'key' pointer casted to an array of unsigned chars \n    const unsigned char *tempKey = (const unsigned char *) key;\n    \n    // Iterate over each byte in the input data\n    for (size_t i = 0; i < data_len; i++)\n    {\n        // XOR operation between current byte from data and corresponding byte from key\n        tempData[i] = tempData[i] ^ tempKey[i % key_len];\n    }\n}", "function_type": 78, "negative": "void int_vector_print(const struct int_vector vec)\n{\n    for (size_t i = 0; i < vec.size; i++)\n    {\n        printf(\"%d\", vec.data[i]);\n        if (i + 1 != vec.size)\n        {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n}"}
{"anchor": "void my_rol_crypt(void *data, size_t data_len, const void *key, size_t key_len)\n{\n    unsigned char *tem = data;\n    const unsigned char *te = key;\n    for (size_t i = 0; i < data_len; i++)\n    {\n        tem[i] = (tem[i] + te[i % key_len]) % 256;\n    }\n    data = tem;\n}", "positive": "c\nvoid my_rol_crypt(unsigned char **data, size_t data_len, const unsigned char **key, size_t key_len)\n{\n    unsigned char *tem = *data;\n    const unsigned char *te = *key;\n    for (size_t i = 0; i < data_len; i++)\n    {\n        tem[i] = (tem[i] + te[i % key_len]) % 256;\n    }\n    *data = tem;\n}", "function_type": 78, "negative": "void my_xor_crypt(void *data, size_t data_len, const void *key, size_t key_len)\n{\n    unsigned char *tem = data;\n    const unsigned char *te = key;\n    for (size_t i = 0; i < data_len; i++)\n    {\n        tem[i] = tem[i] ^ te[i % key_len];\n    }\n    data = tem;\n}"}
{"anchor": "void my_rol_crypt(void *data, size_t data_len, const void *key, size_t key_len)\n{\n    unsigned char *tem = data;\n    const unsigned char *te = key;\n    for (size_t i = 0; i < data_len; i++)\n    {\n        tem[i] = (tem[i] + te[i % key_len]) % 256;\n    }\n    data = tem;\n}", "positive": "c\nvoid my_rol_crypt(void *data, size_t data_len, const void *key, size_t key_len)\n{\n    unsigned char *tempData = data;\n    const unsigned char *tempKey = key;\n    \n    for (size_t i = 0; i < data_len; i++)\n    {\n        tempData[i] = (unsigned char)((tempData[i] + tempKey[i % key_len]) % 256);\n    }\n}", "function_type": 79, "negative": "void cipher(const char *key, const char *msg, char *res)\n{\n    int j = 0;\n    int len = 0;\n    while (key[len] != '\\0')\n    {\n        len += 1;\n    }\n    for (int i = 0; msg[i] != 0; i++)\n    {\n        int tem = (msg[i] - 'A');\n        int kem = (key[j % len] - 'A') % 32;\n        if ((tem >= 0 && tem <= 25) || (tem >= 32 && tem <= 57))\n        {\n            res[i] = (tem % 32 + kem) % 26 + 'A';\n            j++;\n        }\n        else\n        {\n            res[i] = msg[i];\n        }\n    }\n}"}
{"anchor": "void my_rol_crypt(void *data, size_t data_len, const void *key, size_t key_len)\n{\n    unsigned char *tem = data;\n    const unsigned char *te = key;\n    for (size_t i = 0; i < data_len; i++)\n    {\n        tem[i] = (tem[i] + te[i % key_len]) % 256;\n    }\n    data = tem;\n}", "positive": "c\nvoid my_rol_crypt(unsigned char **data, size_t data_len, const unsigned char **key, size_t key_len)\n{\n    unsigned char *tem = *data;\n    const unsigned char *te = *key;\n    for (size_t i = 0; i < data_len; i++)\n    {\n        tem[i] = (tem[i] + te[i % key_len]) % 256;\n    }\n    *data = tem;\n}", "function_type": 79, "negative": "int my_memcmp(const void *s1, const void *s2, size_t num)\n{\n    const char *r1 = s1;\n    const char *r2 = s2;\n    size_t i = 0;\n    while (i < num && r1[i] == r2[i])\n    {\n        i++;\n    }\n    if (i == num)\n    {\n        return 0;\n    }\n    if (r1[i] < r2[i])\n    {\n        return -1;\n    }\n    else\n    {\n        return 1;\n    }\n}"}
{"anchor": "void my_rol_crypt(void *data, size_t data_len, const void *key, size_t key_len)\n{\n    unsigned char *tem = data;\n    const unsigned char *te = key;\n    for (size_t i = 0; i < data_len; i++)\n    {\n        tem[i] = (tem[i] + te[i % key_len]) % 256;\n    }\n    data = tem;\n}", "positive": "c\nvoid my_rol_crypt(unsigned char **data, size_t data_len, const unsigned char **key, size_t key_len)\n{\n    unsigned char *tempDataPtr = *data;\n    const unsigned char *tempKeyPtr = *key;\n    \n    for (size_t i = 0; i < data_len; i++)\n    {\n        tempDataPtr[i] = (tempDataPtr[i] + tempKeyPtr[i % key_len]) % 256;\n    }\n  \n    *data = tempDataPtr; // reassign to original pointer\n}", "function_type": 79, "negative": "void apply_lut(unsigned char mat[4][4], const unsigned char lut[256])\n{\n    for (int i = 0; i < 4; i++)\n    {\n        for (int j = 0; j < 4; j++)\n        {\n            mat[i][j] = lut[mat[i][j]];\n        }\n    }\n}"}
{"anchor": "void my_rol_crypt(void *data, size_t data_len, const void *key, size_t key_len)\n{\n    unsigned char *tem = data;\n    const unsigned char *te = key;\n    for (size_t i = 0; i < data_len; i++)\n    {\n        tem[i] = (tem[i] + te[i % key_len]) % 256;\n    }\n    data = tem;\n}", "positive": "c\nvoid my_rol_crypt(unsigned char* data, size_t data_len, const unsigned char* key, size_t key_len)\n{\n    unsigned char tempArray[data_len]; // create a temporary array to hold the encrypted values\n    \n    memcpy(tempArray, data, data_len);   // copy original data into new array\n        \n    for (size_t i = 0; i < data_len; i++)\n    {\n        tempArray[i] = (tempArray[i] + key[i % key_len]) % 256;\n    }\n\n    memcpy(data, tempArray, data_len);  // copy back into original array\n}", "function_type": 79, "negative": "void my_strlowcase(char *str)\n{\n    for (size_t i = 0; *(str + i); i++)\n    {\n        if (*(str + i) < 91 && *(str + i) > 64)\n        {\n            *(str + i) = *(str + i) + 32;\n        }\n    }\n}"}
{"anchor": "void array_max_min(int tab[], size_t len, int *max, int *min)\n{\n    if (tab != NULL && len != 0)\n    {\n        *max = tab[0];\n        *min = tab[0];\n        for (size_t i = 0; i < len; i++)\n        {\n            if (tab[i] > *max)\n            {\n                *max = tab[i];\n            }\n            else if (tab[i] < *min)\n            {\n                *min = tab[i];\n            }\n        }\n    }\n}", "positive": "c\nvoid array_max_min(int *tab, size_t len, int *max, int *min)\n{\n    if (tab != NULL && len > 0) // changed \"!\" to \">\" and removed \"== 0\" because it's already checked in condition of loop\n    {\n        *max = tab[0];\n        *min = tab[0];\n        \n        for (size_t i = 1; i < len; ++i) // start from index 1 instead of 0\n        {\n            if (tab[i] > *max)\n            {\n                *max = tab[i];\n            }\n            \n            if (tab[i] < *min) // moved else-if to a separate branch so that we don't have an unnecessary comparison with itself at each step\n            {\n                *min = tab[i];\n            }\n        }", "function_type": 79, "negative": "void map(int *array, size_t len, void (*func)(int *))\n{\n    for (size_t i = 0; i < len; i++)\n    {\n        func(&array[i]);\n    }\n}"}
{"anchor": "void array_max_min(int tab[], size_t len, int *max, int *min)\n{\n    if (tab != NULL && len != 0)\n    {\n        *max = tab[0];\n        *min = tab[0];\n        for (size_t i = 0; i < len; i++)\n        {\n            if (tab[i] > *max)\n            {\n                *max = tab[i];\n            }\n            else if (tab[i] < *min)\n            {\n                *min = tab[i];\n            }\n        }\n    }\n}", "positive": "c\nvoid array_max_min(const int* const tab, size_t len, int * restrict max, int * restrict min) \n{\n    if (tab != NULL && len != 0 && max != NULL && min != NULL)\n    {\n        *max = tab[0];\n        *min = tab[0];\n        \n        while(--len > 0)   // Replace 'for' with 'while' and decrement length manually at each iteration\n        {\n            tab++;     // Point to next element in array\n            \n            if (*tab > *max)\n            {\n                *max = *tab;\n            }\n            else if(*tab < *min)\n            {\n                *min = *tab;\n            }\n        }\n    }\n}", "function_type": 80, "negative": "void insertion_sort(void **array, f_cmp comp)\n{\n    if (array != NULL && *array != NULL)\n    {\n        for (int i = 1; array[i] != NULL; i++)\n        {\n            int j = i;\n            while (j > 0 && comp(array[j - 1], array[j]) > 0)\n            {\n                void *temp = array[j];\n                array[j] = array[j - 1];\n                array[j - 1] = temp;\n                j--;\n            }\n        }\n    }\n}"}
{"anchor": "void array_max_min(int tab[], size_t len, int *max, int *min)\n{\n    if (tab != NULL && len != 0)\n    {\n        *max = tab[0];\n        *min = tab[0];\n        for (size_t i = 0; i < len; i++)\n        {\n            if (tab[i] > *max)\n            {\n                *max = tab[i];\n            }\n            else if (tab[i] < *min)\n            {\n                *min = tab[i];\n            }\n        }\n    }\n}", "positive": "c\nvoid array_max_min(const int* tab, size_t len, int *max, int *min){\n    // check if pointers are not null and length is greater than 0\n    if (!tab || len == 0 || !max || !min ) return;\n    \n    // set first value as initial maximum and minimum values\n    *max = tab[0];\n    *min = tab[0];\n\n    while (len-- > 0)   // change 'for' to 'while', decrease length after each iteration\n    {\n       if (*max < tab[len])\n           *max = tab[len];\n        \n       if(*min > tab[len])\n           *min = tab[len];\n    }\n}", "function_type": 80, "negative": "unsigned array_min(const int arr[], unsigned start, unsigned size)\n{\n    unsigned res = start;\n    for (size_t i = start; i < size; i++)\n    {\n        if (arr[i] < arr[res])\n        {\n            res = i;\n        }\n    }\n    return res;\n}"}
{"anchor": "void array_max_min(int tab[], size_t len, int *max, int *min)\n{\n    if (tab != NULL && len != 0)\n    {\n        *max = tab[0];\n        *min = tab[0];\n        for (size_t i = 0; i < len; i++)\n        {\n            if (tab[i] > *max)\n            {\n                *max = tab[i];\n            }\n            else if (tab[i] < *min)\n            {\n                *min = tab[i];\n            }\n        }\n    }\n}", "positive": "c\nvoid arrayMaxMin(int arr[], size_t length, int *highestValue, int *lowestValue)\n{\n    if (arr != NULL && length != 0)\n    {\n        *highestValue = arr[0];\n        *lowestValue = arr[0];\n        for (size_t index = 0; index < length; index++)\n        {\n            if (arr[index] > *highestValue)\n            {\n                *highestValue = arr[index];\n            }\n            else if (arr[index] < *lowestValue)\n            {\n                *lowestValue = arr[index];\n            }\n        }\n    }\n}", "function_type": 80, "negative": "int binary_search(const int vec[], int size, int elt)\n{\n    if (size == 0)\n    {\n        return -1;\n    }\n    int max = size;\n    int min = 0;\n\n    while (max > min)\n    {\n        int mid = (min + max) / 2;\n        if (vec[mid] == elt)\n        {\n            return mid;\n        }\n        if (vec[mid] < elt)\n        {\n            min = mid + 1;\n        }\n        else\n        {\n            max = mid;\n        }\n    }\n    return -1;\n}"}
{"anchor": "void array_max_min(int tab[], size_t len, int *max, int *min)\n{\n    if (tab != NULL && len != 0)\n    {\n        *max = tab[0];\n        *min = tab[0];\n        for (size_t i = 0; i < len; i++)\n        {\n            if (tab[i] > *max)\n            {\n                *max = tab[i];\n            }\n            else if (tab[i] < *min)\n            {\n                *min = tab[i];\n            }\n        }\n    }\n}", "positive": "static bool isFirstIteration(const size_t iterationCount) \n{\n    return iterationCount == 0; // This can be changed based on your preference.\n}", "function_type": 80, "negative": "int foldl(int *array, size_t len, int (*func)(int, int))\n{\n    int res = 0;\n    for (size_t i = 0; i < len; i++)\n    {\n        res = func(res, array[i]);\n    }\n    return res;\n}"}
